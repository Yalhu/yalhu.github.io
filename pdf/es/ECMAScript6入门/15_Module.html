<p>title: ECMAScript 6入门-15_Module<br>date: 2018.1.26<br>tags: </p>
<ul>
<li>es<br>toc_fold: unfold</li>
</ul>
<hr>
<h2 id="五-Module"><a href="#五-Module" class="headerlink" title=".五 Module"></a>.五 Module</h2><p style="text-align:right">2018.1.26 星期五 22:43</p><br>p226-P233<br><br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。<br><br><strong>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</strong><br>0. CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 <code>var { stat, exists, readFile } = require(&#39;fs&#39;);</code><br>1. ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br><code>import { stat, exists, readFile } from &#39;fs&#39;;</code><br><br><strong>所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。</strong><br><br>### 5.1 export命令<br>0. 模块功能主要由两个命令构成：export和import。<br>1. export命令用于用户自定义模块，规定对外接口；<br>import命令用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突。<br>2. ES6允许将独立的JS文件作为模块，也就是说，允许一个JavaScript脚本文件调用另一个脚本文件。该文件<br>内部的所有变量，外部无法获取，必须使用export关键字输出变量。<br><br>.<br><br>    // profile.js<br>    export var firstName = ‘Michael’;<br>    export var lastName = ‘Jackson’;<br>    export var year = 1958;<br>    // better<br>    export {firstName, lastName, year};<br>### 5.2 import命令<br>1. import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。<br><br>        // main.js<br>        import {firstName, lastName, year} from ‘./profile’;<br>        function sfirsetHeader(element) {<br>            element.textContent = firstName + ‘ ‘ + lastName;<br>        }<br>2. 如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名。<br><br>        import { lastName as surname } from ‘./profile’;<br>3. ES6支持多重加载，即所加载的模块中又加载其他模块。<br><br>        import { Vehicle } from ‘./Vehicle’;<br>        class Car extends Vehicle {<br>            move () {<br>                console.log(this.name + ‘ is spinning wheels…’)<br>            }<br>        }<br>        export { Car }<br>4. 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。<br><br>        export { es6 as default } from ‘./someModule’;<br>        // 等同于<br>        import { es6 } from ‘./someModule’;<br>        export default es6;<br>    export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，h应该采用标准写法。<br>### 5.3 模块的整体输入<br>    // circle.js<br>    export function area(radius) {<br>        return Math.PI <em> radius </em> radius;<br>    }<br>    export function circumference(radius) {<br>        return 2 <em> Math.PI </em> radius;<br>    }<br>    // main.js<br>    import { area, circumference } from ‘circle’;<br>    console.log(“圆面积：” + area(4));<br>    console.log(“圆周长：” + circumference(14));<br>上面写法是逐一指定要输入的方法。另一种写法是整体输入。<br><br>        import <em> as circle from ‘circle’;<br>        console.log(“圆面积：” + circle.area(4));<br>        console.log(“圆周长：” + circle.circumference(14));<br>### 5.4 module命令<br>    // main.js<br>    module circle from ‘circle’;<br>    console.log(“圆面积：” + circle.area(4));<br>    console.log(“圆周长：” + circle.circumference(14));<br>module命令可以取代import语句，达到整体输入模块的作用。  
</em>module命令后面跟一个变量，表示输入的模块定义在该变量上。<em><br>### 5.5 export default命令<br>1. 代码是一个模块文件 export-default.js ，它的默认输出是一个函数。<br><strong>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</strong><br><br>        // export-default.js<br>        export default function () {<br>            console.log(‘foo’);<br>        }<br>        // import-default.js<br>        import customName from ‘./export-default’;<br>        customName(); // ‘foo’<br>2. 用在非匿名函数前，也是可以的。<br><strong>foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</strong><br><br>        // export-default.js<br>        export default function foo() {<br>            console.log(‘foo’);<br>        }<br>        // 或者写成<br>        function foo() {<br>            console.log(‘foo’);<br>        }<br>        export default foo;<br>3. 比较一下默认输出和正常输出。<br><strong>第一组是使用 export default 时，对应的import语句不需要使用大括号；第二组是不使用 export default 时，对应的import语句需要使用大括号。</strong><br>        import crc32 from ‘crc32’;<br>        // 对应的输出<br>        export default function crc32(){}<br><br>        import { crc32 } from ‘crc32’;<br>        // 对应的输出<br>        export function crc32(){};<br><strong>显然，一个模块只能有一个默认输出，因此export deault 命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</strong><br>本质上， export default 就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所<br>以，下面的写法是有效的。<br><br>    // modules.js<br>    export default function (x, y) {<br>        return x </em> y;<br>    };<br>    // app.js<br>    import { default } from ‘modules’;<br>1. 有了 export default 命令，输入模块时就非常直观了，以输入jQuery模块为例。<br><br>        import $ from ‘jquery’;<br>2. 如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。<br><br>    import customName, { otherMethod } from ‘./export-default’;<br>3. 如果要输出默认的值，只需将值跟在 export default 之后即可。<br><br>        export default 42;<br>4. export default 也可以用来输出类。<br><br>        // MyClass.js<br>        export default class { … }<br>        // main.js<br>        import MyClass from ‘MyClass’<br>        let o = new MyClass();<br>### 5.6 模块的继承<br>1. 代码中的“export <em>”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。<br><br>        // circleplus.js<br>        export </em> from ‘circle’;<br>        export var e = 2.71828182846;<br>        export default function(x) {<br>            return Math.exp(x);<br>        }<br>2. 这时，也可以将circle的属性或方法，改名后再输出。<br>只输出circle模块的area方法，且将其改名为circleArea。<br><br>        // circleplus.js<br>        export { area as circleArea } from ‘circle’;<br>3. 加载上面模块的写法如下。<br><br>        // main.js<br>        module math from “circleplus”;<br>        import exp from “circleplus”;<br>        console.log(exp(math.pi));<br>### 5.7 ES6模块的转码<br>#### 1 ES6 module transpiler<br>#### 2 SystemJS<br><strong>$_EXCLUDE:</strong> 这两可能是过时的；因为用babel<br><br><p style="text-align:right">2018.1.26 23：59</p>

<p>读后总结： </p>
<ol>
<li>使用上想简单了，语法还是有限制的</li>
<li>Module的加入，改变了JS引入的方式，传统js文件的书写方式，要有一个大的改变；</li>
<li>包括类的定义和使用，比如定义一个Tab；不是构造函数了</li>
<li>结合今天webpack，传统的js库，需要pollfill引入</li>
</ol>
