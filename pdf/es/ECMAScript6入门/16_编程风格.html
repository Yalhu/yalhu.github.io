<p>title: ECMAScript 6入门-16_编程风格<br>date: 2018.1.27<br>tags: </p>
<ul>
<li>es<br>toc_fold: unfold</li>
</ul>
<hr>
<h2 id="六-编程风格"><a href="#六-编程风格" class="headerlink" title="六 编程风格"></a>六 编程风格</h2><p style="text-align:right">2018.1.27 星期六 00:16</p><br>P235-P244<br>多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的avaScript风格规范。<br><br>### 6.1 块级作用域<br>#### 1 let取代var<br>1. 上面代码如果用var替代let，<strong>实际上就声明了一个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效</strong>，var命令做不到这一点。<br>2. var命令存在变量提升效用，let命令没有这个问题。<strong>违反了变量先声明后使用的原则。</strong><br><br>#### 2 全局常量和线程安全<br>    // bad<br>    var a = 1, b = 2, c = 3;<br>    // good<br>    const a = 1;<br>    const b = 2;<br>    const c = 3;<br>    // best<br>    const [a, b, c] = [1, 2, 3];<br>1. 在let和const之间，<strong>建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算</strong>。<br>2. const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br><br>所有的函数都应该设置为常量。<br>let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。<br><br>#### 3 严格模式<br>V8引擎只在严格模式之下，支持let和const。结合前两点，这实际上意味着，将来所有的编程都是针对严<br>格模式的。<br><br>### 6.2 字符串<br>    // bad<br>    const a = “foobar”;<br>    const b = ‘foo’ + a + ‘bar’;<br>    // acceptable<br>    const c = <code>foobar</code>;<br>    // good<br>    const a  = ‘foobar’;<br>    const b = <code>foo${a}bar</code>;<br>    const c = ‘foobar’;<br>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。<br>### 6.3 解构赋值<br>1. 使用数组成员对变量赋值，优先使用解构赋值。<br><br>        const arr = [1, 2, 3, 4];<br>        // bad<br>        const first = arr[0];<br>        const second = arr[1];<br>        // good<br>        const [first, second] = arr;<br>2. 函数的参数如果是对象的成员，优先使用解构赋值。<br><br>        // bad<br>        function getFullName(user) {<br>            const firstName = user.firstName;<br>            const lastName = user.lastName;<br>        }<br>        // good<br>        function getFullName(obj) {<br>            const { firstName, lastName } = obj;<br>        }<br>        // best<br>        function getFullName({ firstName, lastName }) {<br>        }<br>        $_PROBLEM:不明白，需要参考函数部分<br>3. 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。<br><br>        // bad<br>        function processInput(input) {<br>            return [left, right, top, bottom];<br>        }<br>        // good<br>        function processInput(input) {<br>            return { left, right, top, bottom };<br>        }<br>        const { left, right } = processInput(input);<br>### 6.4 对象<br>1. 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。<br>2. 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。<br><br>        // bad<br>        const a = {};<br>        a.x = 3;<br>        // if reshape unavoidable<br>        const a = {};<br>        Object.assign(a, { x: 3 });<br>        // good<br>        const a = { x: null };<br>        a.x = 3;<br>3. 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。<br><br>        // bad<br>        const obj = {<br>            id: 5,<br>            name: ‘San Francisco’,<br>        };<br>        obj[getKey(‘enabled’)] = true;<br>        // good<br>        const obj = {<br>             id: 5,<br>             name: ‘San Francisco’,<br>            [getKey(‘enabled’)]: true,<br>        };<br>4. 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。<br><br>        var ref = ‘some value’;<br>        // bad<br>        const atom = {<br>            ref: ref,<br>            value: 1,<br>            addValue: function (value) {<br>                return atom.value + value;<br>            },<br>        };<br>        // good<br>        const atom = {<br>            ref,<br>            value: 1,<br>            addValue(value) {<br>                return atom.value + value;<br>            },<br>        };<br>### 6.5 数组<br>1. 使用扩展运算符（…）拷贝数组。<br><br>        // bad<br>        const len = items.length;<br>        const itemsCopy = [];<br>        let i;<br>            for (i = 0; i &lt; len; i++) {<br>            itemsCopy[i] = items[i];<br>        }<br>        // good<br>        const itemsCopy = […items];<br>2. 使用Array.from方法，将类似数组的对象转为数组。<br><br>        const foo = document.querySelectorAll(‘.foo’);<br>        const nodes = Array.from(foo);<br>### 6.6 函数<br>1. 立即执行函数可以写成箭头函数的形式。<br><br>        (() =&gt; {<br>            console.log(‘Welcome to the Internet.’);<br>        })();<br>2. 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。<br><br>        // bad<br>        [1, 2, 3].map(function (x) {<br>            return x <em> x;<br>        });<br>        // good<br>        [1, 2, 3].map((x) =&gt; {<br>            return x </em> x;<br>        });<br>3. 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。<br><br>        // bad<br>        const self = this;<br>        const boundMethod = function(…params) {<br>            return method.apply(self, params);<br>        }<br>        // acceptable<br>        const boundMethod = method.bind(this);<br>        // best<br>        const boundMethod = (…params) =&gt; method.apply(this, params);<br>4. 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。<br><br>        // bad<br>        function divide(a, b, option = false ) {<br>        }<br>        // good<br>        function divide(a, b, { option = false } = {}) {<br>        }<br>4. 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。<br><br>        // bad<br>        function concatenateAll() {<br>            const args = Array.prototype.slice.call(arguments);<br>            return args.join(‘’);<br>        }<br>        // good<br>        function concatenateAll(…args) {<br>            return args.join(‘’);<br>        }<br>5. 使用默认值语法设置函数参数的默认值。<br><br>        // bad<br>        function handleThings(opts) {<br>            opts = opts || {};<br>        }<br>        // good<br>        function handleThings(opts = {}) {<br>            // …<br>        }<br>### 6.7 Map结构<br>    let map = new Map(arr);<br>    for (let key of map.keys()) {<br>        console.log(key);<br>    }<br>    for (let value of map.values()) {<br>        console.log(value);<br>    }<br>    for (let item of map.entries()) {<br>        console.log(item[0], item[1]);<br>    }<br>注意区分Object和Map，只有模拟实体对象时，才使用Object。<strong>如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制</strong>。<br><br>### 6.8 Class<br>1. 总是用class，取代需要prototype操作。因为class的写法更简洁，更易于理解。<br><br>        // bad<br>        function Queue(contents = []) {<br>            this._queue = […contents];<br>        }<br>        Queue.prototype.pop = function() {<br>            const value = this._queue[0];<br>            this._queue.splice(0, 1);<br>            return value;<br>        }<br>        // good<br>        class Queue {<br>            constructor(contents = []) {<br>                this._queue = […contents];<br>            }<br>            pop() {<br>                const value = this._queue[0];<br>                this._queue.splice(0, 1);<br>                return value;<br>            }<br>        }<br>2. 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。<br><br>        // bad<br>        const inherits = require(‘inherits’);<br>        function PeekableQueue(contents) {<br>            Queue.apply(this, contents);<br>        }<br>        inherits(PeekableQueue, Queue);<br>            PeekableQueue.prototype.peek = function() {<br>            return this._queue[0];<br>        }<br>        // good<br>        class PeekableQueue extends Queue {<br>            peek() {<br>                return this._queue[0];<br>            }<br>        }<br>### 6.9 模块<br>1. 首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。<br><br>        // bad<br>        const moduleA = require(‘moduleA’);<br>        const func1 = moduleA.func1;<br>        const func2 = moduleA.func2;<br>        // good<br>        import { func1, func2 } from ‘moduleA’;<br>2. 使用export取代module.exports。<br><br>        // commonJS的写法<br>        var React = require(‘react’);<br>        var Breadcrumbs = React.createClass({<br>            render() {<br>                return <nav />;<br>            }<br>        });<br>        module.exports = Breadcrumbs;<br>        // ES6的写法<br>        import React from ‘react’;<br>        const Breadcrumbs = React.createClass({<br>            render() {<br>                return <nav />;<br>            }<br>        });<br>        export default Breadcrumbs<br>4. 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。<br>$_PROBLEM:有一个默认输出是什么意义，如果不想有一个默认输出呢；<br>$_ANSWER:模块化，应该都是细化的，和之前common.js的引入方式不同了<br><br>        // bad<br>        import * as myObject ‘./importModule’;<br>        // good<br>        import myObject from ‘./importModule’;<br>5. 如果模块默认输出一个函数，函数名的首字母应该小写。<br><br>        function makeStyleGuide() {<br>        }<br>        export default makeStyleGuide;<br>6. 如果模块默认输出一个对象，对象名的首字母应该大写。<br><br>        const StyleGuide = {<br>            es6: {<br>            }<br>        };<br>        export default StyleGuide;<br><p style="text-align:right">2018.</p>

<p>读后总结： </p>
<ol>
<li>都是平时书写中就应该实现的细节</li>
</ol>
