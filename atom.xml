<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yalhu</title>
  
  <subtitle>yalhu&#39;s blob</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-23T13:29:21.043Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yalhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node脚本</title>
    <link href="http://yoursite.com/sum/ser/node%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/sum/ser/node脚本/</id>
    <published>2021-01-23T00:00:00.000Z</published>
    <updated>2021-01-23T13:29:21.043Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2021.1.23 星期六 21：28 </p><h2 id="向npm脚本发送命令行参数"><a href="#向npm脚本发送命令行参数" class="headerlink" title="向npm脚本发送命令行参数"></a>向npm脚本发送命令行参数</h2><!-- [如何向npm脚本发送命令行参数？](https://cloud.tencent.com/developer/ask/50047) --><p>package.json的scripts部分：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "node ./script.js server"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从npm2.0.0开始，可以将参数传递给npm run<br><!-- [npm run 执行package.json中的scripts配置时如何参数传递？](https://www.zhihu.com/question/54471504) --><br>1) npm scripts参数传递的命令行分割符是’–’。<br>比如npm run build – –name hello，即可将后续参数添加到process.env.argv数组中。</p><p>2) 在 vue-cli 创建的项目中，如果执行命令 npm run build –report ，那么参数 –report 将转化成 process.env.npm_config_report = true<br><del>3) 用shell函数，将尾巴的作为参数传进去<code>{&quot;build&quot;: &quot;build(){r.js -o build.js &amp;&amp; node version.js -v $1 &amp;&amp; zip -r ./build/dist.zip ./build;} build&quot;}</code></del><br>4) 只需在尾部提供一个$<em>到你的脚本值条目。 `”start”: “node echoargs.js $</em>“`<br>5) 如果你想将参数传递到npm脚本的中间，而不只是将它们追加到末尾，那么内联环境变量能起到一个很好的作用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "BABEL_ARGS=-w npm run build &amp;&amp; cd lib/server &amp;&amp; nodemon index.js",</span><br><span class="line">  "start": "npm run build &amp;&amp; node lib/server/index.js",</span><br><span class="line">  "build": "mkdir -p lib &amp;&amp; babel $BABEL_ARGS -s inline --stage 0 src -d lib",</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>在这里，npm run dev将-w watch标志传递给babel，但npm run start只运行一次常规构建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2021.1.23 星期六 21：28 &lt;/p&gt;

&lt;h2 id=&quot;向npm脚本发送命令行参数&quot;&gt;&lt;a href=&quot;#向npm脚本发送命令行参数&quot; class=&quot;headerlink&quot; title=&quot;向npm脚本发送命令行参
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="ser" scheme="http://yoursite.com/categories/sum/ser/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>微前端和Qiankun</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%92%8Cqiankun/"/>
    <id>http://yoursite.com/sum/jsplus/微前端和qiankun/</id>
    <published>2021-01-12T00:00:00.000Z</published>
    <updated>2021-01-12T06:25:03.010Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.12 星期二  ： </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>qiankun: <a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">https://qiankun.umijs.org/zh/guide</a><br>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p><h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><blockquote><p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends<br>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。</p></blockquote><a id="more"></a><p>微前端架构具备以下几个核心价值：<br>技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权</p><p>独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p><p>增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p><p>独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</p><h2 id="为什么不是-iframe"><a href="#为什么不是-iframe" class="headerlink" title="为什么不是 iframe"></a>为什么不是 iframe</h2><h1 id="微前端的核心价值"><a href="#微前端的核心价值" class="headerlink" title="微前端的核心价值"></a>微前端的核心价值</h1><p><a href="https://zhuanlan.zhihu.com/p/95085796" target="_blank" rel="noopener">微前端的核心价值</a></p><p>我认为微前端的核心价值在于 “技术栈无关”，这才是它诞生的理由，或者说这才是能说服我采用微前端方案的理由。</p><h2 id="为什么”技术栈无关”这么重要？"><a href="#为什么”技术栈无关”这么重要？" class="headerlink" title="为什么”技术栈无关”这么重要？"></a>为什么”技术栈无关”这么重要？</h2><h2 id="为什么我认为”技术栈无关”才是微前端的初衷？"><a href="#为什么我认为”技术栈无关”才是微前端的初衷？" class="headerlink" title="为什么我认为”技术栈无关”才是微前端的初衷？"></a>为什么我认为”技术栈无关”才是微前端的初衷？</h2><blockquote><p>微前端的初衷应该还是来解决工程问题的，带来的产品价值在不同的领域可大可小。 比如在阿里云这种典型的云产品控制台的场景下，它带来的产品价值就会很可观。</p></blockquote><h2 id="微前端方案正确的架构姿势"><a href="#微前端方案正确的架构姿势" class="headerlink" title="微前端方案正确的架构姿势"></a>微前端方案正确的架构姿势</h2><p>「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。</p><h1 id="可能是你见过最完善的微前端解决方案"><a href="#可能是你见过最完善的微前端解决方案" class="headerlink" title="可能是你见过最完善的微前端解决方案"></a>可能是你见过最完善的微前端解决方案</h1><p><a href="https://zhuanlan.zhihu.com/p/78362028" target="_blank" rel="noopener">可能是你见过最完善的微前端解决方案</a></p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;text-align:right&quot;&gt; 2020.12 星期二  ： &lt;/p&gt;

&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;qiankun: &lt;a href=&quot;https://qiankun.umijs.org/zh/guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://qiankun.umijs.org/zh/guide&lt;/a&gt;&lt;br&gt;qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是微前端&quot;&gt;&lt;a href=&quot;#什么是微前端&quot; class=&quot;headerlink&quot; title=&quot;什么是微前端&quot;&gt;&lt;/a&gt;什么是微前端&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends&lt;br&gt;微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Rollup第一次使用</title>
    <link href="http://yoursite.com/sum/jsplus/rollup%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/sum/jsplus/rollup第一次使用/</id>
    <published>2020-12-29T00:00:00.000Z</published>
    <updated>2021-01-23T06:05:46.651Z</updated>
    
    <content type="html"><![CDATA[<p>以失败告终。（于<!-- （是） -->webapck一次成功）<br>nodejs<!-- 前端脚手架 -->cjs 包，打包执行成功了。<br>但是输出的文件执行报错（解决掉electron，又报其他错误）。</p><p style="text-align:right"> 2020.12.29 星期二  11：41 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    throw new ERR_INVALID_ARG_TYPE(<span class="string">'superCtor'</span>, <span class="string">'Function'</span>, superCtor);</span><br><span class="line">    ^</span><br><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The <span class="string">"superCtor"</span> argument must be of <span class="built_in">type</span> <span class="keyword">function</span>. Received undefined</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/rollup/rollup/issues/3805" target="_blank" rel="noopener">https://github.com/rollup/rollup/issues/3805</a></p></blockquote><p>打包中提示有循环引用<br><!-- [由rollup打包引发的对JS模块循环引用的思考](https://juejin.cn/post/6862635764981235719) --><br><!-- 感觉可能是rollup配置的问题，于是去谷歌了一下， -->发现这其实是rollup的一个bug。<br><!-- 在翻了github上几个issue之后，终于弄清了报错的原因。为了讲清楚问题，首先介绍一下问题发生的背景： --><br>导致rollup打包问题的原因为：打包的过程中rollup将cjs模块转换成esm，由于esm会跳过之前已加载过的模块，实际引入的变量变成了undefined，导致在最终生成的代码中存在undefined的变量。</p><p>这个问题至今尚未有效解决，涉及到大量commonjs模块时，建议使用webpack打包。</p><!-- [rollup打包js的注意点](https://www.haorooms.com/post/rollup_tips)rollup比较适合打包js的sdk或者封装的框架等，例如，vue源码就是rollup打包的。webpack比较适合打包一些应用，例如SPA或者同构项目等等。最近我们对rollup小试牛刀了一下。简单分享一些注意事项吧。 --><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以失败告终。（于&lt;!-- （是） --&gt;webapck一次成功）&lt;br&gt;nodejs&lt;!-- 前端脚手架 --&gt;cjs 包，打包执行成功了。&lt;br&gt;但是输出的文件执行报错（解决掉electron，又报其他错误）。&lt;/p&gt;
&lt;p style=&quot;text-align:right
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="rollup" scheme="http://yoursite.com/tags/rollup/"/>
    
  </entry>
  
  <entry>
    <title>Stencil 了解</title>
    <link href="http://yoursite.com/sum/jsplus/Stencil%20%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/sum/jsplus/Stencil 了解/</id>
    <published>2020-12-14T00:00:00.000Z</published>
    <updated>2021-01-23T13:35:24.900Z</updated>
    
    <content type="html"><![CDATA[<p>Stencil: A Compiler for Web Components and High Performance Web Apps<br><a href="https://stenciljs.com/docs/introduction" target="_blank" rel="noopener">Stencil 文档</a><br>github: <a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">https://github.com/ionic-team/stencil</a></p><p style="text-align:right"> 2020.12.14 星期一 </p><p>一个轻量化，渐进式编译器，注意，不是框架。<br>使用 TypeScript 进行所有操作，这是一个门槛，有一定技术门槛要求。</p><a id="more"></a><p>官方描述特征是：<br>. Virtual DOM<br>. Async rendering (inspired by React Fiber)<br>. Reactive data-binding<br>. TypeScript<br>. JSX</p><!-- \# [胶水（框架） Stencil.js](https://zhuanlan.zhihu.com/p/84465089) --><p>而 Stencil.js 已经在今年（2019 ）的 6 月份，推出了 1.0 正式版<br><!-- $_PS: 17年底，18年初的时候已经有了 --></p><h2 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line"> tag: <span class="string">'my-component'</span>,</span><br><span class="line"> styleUrl: <span class="string">'my-component.css'</span>,</span><br><span class="line"> shadow: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"> @Prop() first: string;</span><br><span class="line"></span><br><span class="line"> private getText(): string &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="keyword">return</span> &lt;div&gt;Hello, World! I'm &#123;this.getText()&#125;&lt;/div&gt;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用 Stencil 开发的组件只是 Web Components，所以这些组件可以运行在所有的主流框架（AVR）中，也可以独立地运行。这一特质使它可以成为新的前端容器框架——毕竟 Web Components 是一个新的前端容器。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>用途一：开发前端应用<br>用途二：连接混合应用<br>用途三：连接其它前端框架<br>用途四：构建跨框架的 UI 库 / 设计系统<br>用途五：微前端应用</p><p>结论：胶水框架<br>Web Components 大法虽好，但是你还是需要一个快速开发 Web Components 的框架/工具。</p><h3 id="5-条评论"><a href="#5-条评论" class="headerlink" title="5 条评论"></a>5 条评论</h3><!-- 王锐2019-09-28是否适用与大型项目（代码量有一定层级，重构简单。开发团队大，适合协同工作）有待商榷。如果只是一些骚操作，看看就好ewind2019-09-28看名字还以为是管 WebGL stencil buffer 的呢…填坑侠2019-09-29和我16年在美团干的事一模一样，实际上响应者稀莫夭2019-09-29曾经尝试用过，个人感觉最大的问题是组件名要全局唯一，而且在组件A中使用组件B，没有import的过程，完全不知道B是在哪定义的。只有等web components引入类似namespace之类的东西才能解决这个问题了不得不全栈2019-10-03以前用过，还是觉得麻烦…… --><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><!-- \# [Stencil 基础](https://www.cnblogs.com/ZweiZhao/p/9817591.html) --><p>生命周期<br>componentWillLoad<br>componentDidLoad<br>componentWillUpdate<br>componentDidUpdate<br>componentDidUnload</p><p>装饰器<br>Component<br>Prop<br>Watch<br>State<br>Method<br>Element</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stencil: A Compiler for Web Components and High Performance Web Apps&lt;br&gt;&lt;a href=&quot;https://stenciljs.com/docs/introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stencil 文档&lt;/a&gt;&lt;br&gt;github: &lt;a href=&quot;https://github.com/ionic-team/stencil&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ionic-team/stencil&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.14 星期一 &lt;/p&gt;

&lt;p&gt;一个轻量化，渐进式编译器，注意，不是框架。&lt;br&gt;使用 TypeScript 进行所有操作，这是一个门槛，有一定技术门槛要求。&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Ohmyshell</title>
    <link href="http://yoursite.com/sum/os/ohmyshell/"/>
    <id>http://yoursite.com/sum/os/ohmyshell/</id>
    <published>2020-12-14T00:00:00.000Z</published>
    <updated>2021-01-23T10:24:14.010Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input type="text" style=" border-radius: 5px; border-style: groove; height: 30px; width: 50%; cursor: auto; font-size: 102%; color: currentColor; outline: none; text-overflow: initial; padding-left: 5px;">   <input type="submit" value="decrypt" onclick="decrypt()" style=" width: 58px; height: 34px; border-radius: 5px; background-color: white; border-style: solid; color: currentColor; ">  <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script>  var onError = function(error) {  $("#enc_error")[0].innerHTML = "password error!";  };  function decrypt() {  var passwd = $("#enc_passwd input")[0].value;  console.log(passwd);  doDecrypt(passwd, onError);  }  </script></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=/js/crypto-js.js&gt;&lt;/script&gt;
&lt;script&gt;
function doDecrypt (pwd, onError) {
	console.log(&#39;in doDecrypt&#39;);
	const txt = document.getE
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="os" scheme="http://yoursite.com/categories/sum/os/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6 - Reflect</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/15-Reflect/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/15-Reflect/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.369Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>静态方法<br>实例：使用 Proxy 实现观察者模式</p><p style="text-align:right"> 2020.12.13 星期日  21：44 </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p><p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。<br>（2） 修改某些Object方法的返回结果，让其变得更合理。<br>（3） 让Object操作都变成函数行为。<br>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。<br>这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>Reflect对象一共有 13 个静态方法。<br>Reflect.apply(target, thisArg, args)<br>Reflect.construct(target, args)<br>Reflect.get(target, name, receiver)<br>Reflect.set(target, name, value, receiver)<br>Reflect.defineProperty(target, name, desc)<br>Reflect.deleteProperty(target, name)<br>Reflect.has(target, name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)<br>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。</p><h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p>Reflect.set方法设置target对象的name属性等于value。</p><p>注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。</p><h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p><h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p>Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。</p><p>Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。</p><h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p>Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。</p><h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。</span></span><br><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;<span class="keyword">set</span>&#125;);</span><br><span class="line"></span><br><span class="line">function <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-align:right">21:51 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;静态方法&lt;br&gt;实例：使用 Proxy 实现观察者模式&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  21：44 &lt;/p&gt;



&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - Proxy</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/14-Proxy/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/14-Proxy/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.205Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>Proxy 实例的方法<br>Proxy.revocable()<br>this 问题<br>实例：Web 服务的客户端</p><p style="text-align:right"> 2020.12.13 星期日  17:33 </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>如果handler没有设置任何拦截，那就等同于直接通向原对象。<br>一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。<code>var object = { proxy: new Proxy(target, handler) };</code><br>Proxy 实例也可以作为其他对象的原型对象。<code>let obj = Object.create(proxy);</code></p><p>同一个拦截器函数，可以设置拦截多个操作。<br>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。<br>下面是 Proxy 支持的拦截操作一览，一共 13 种。<br>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。<br>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p><h2 id="2-Proxy-实例的方法"><a href="#2-Proxy-实例的方法" class="headerlink" title="2 Proxy 实例的方法"></a>2 Proxy 实例的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p>get方法可以继承。<br>上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。</p><p>下面的例子使用get拦截，实现数组读取负数的索引。<br>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。<br>下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。<br>利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。<br>结合get和set方法，就可以做到防止这些内部属性被外部读写。<br>上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。</p><p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br>注意，严格模式下，set代理如果没有返回true，就会报错。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply方法拦截函数的调用、call和apply操作。<br>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line"><span class="comment">// "I am the proxy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，直接调用Reflect.apply方法，也会被拦截。</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。<br>has()方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用has()方法隐藏某些属性，不被in运算符发现。</p><p>另外，虽然for…in循环也用到了in运算符，但是has()拦截对for…in循环不生效。</p><h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p>construct()方法用于拦截new命令，下面是拦截对象的写法。</p><p>另外，由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p>defineProperty()方法拦截了Object.defineProperty()操作。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p>getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p><h3 id="getPrototypeOf-§-⇧"><a href="#getPrototypeOf-§-⇧" class="headerlink" title="getPrototypeOf() § ⇧"></a>getPrototypeOf() § ⇧</h3><p>getPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><p>Object.prototype.<strong>proto</strong><br>Object.prototype.isPrototypeOf()<br>Object.getPrototypeOf()<br>Reflect.getPrototypeOf()<br>instanceof</p><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p>isExtensible()方法拦截Object.isExtensible()操作。</p><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p>ownKeys()方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p><p>for…in循环也受到ownKeys()方法的拦截。</p><p>注意，使用Object.keys()方法时，有三类属性会被ownKeys()方法自动过滤，不会返回。<br>目标对象上不存在的属性<br>属性名为 Symbol 值<br>不可遍历（enumerable）的属性</p><p>另外，如果目标对象是不可扩展的（non-extensible），这时ownKeys()方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p>preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p>setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf()方法不得改变目标对象的原型。</p><h2 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3 Proxy.revocable()"></a>3 Proxy.revocable()</h2><p>Proxy.revocable()方法返回一个可取消的 Proxy 实例。</p><p>Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="4-this-问题"><a href="#4-this-问题" class="headerlink" title="4 this 问题"></a>4 this 问题</h2><!-- 主要原因就是 -->在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br><br>下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。<br>此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，getDate()方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。</span></span><br><span class="line"><span class="comment">// 这时，this绑定原始对象，就可以解决这个问题。</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，Proxy 拦截函数内部的this，指向的是handler对象。</p><h2 id="5-实例：Web-服务的客户端"><a href="#5-实例：Web-服务的客户端" class="headerlink" title="5 实例：Web 服务的客户端"></a>5 实例：Web 服务的客户端</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebService(<span class="string">'http://example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">service.employees().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWebService</span>(<span class="params">baseUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> httpGet(baseUrl + <span class="string">'/'</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p><p># Object.create()<br><!-- [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) --><br>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 （请打开浏览器控制台以查看运行结果。）<br><code>Object.create(proto，[propertiesObject])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p style="text-align:right"> 18:02 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;Proxy 实例的方法&lt;br&gt;Proxy.revocable()&lt;br&gt;this 问题&lt;br&gt;实例：Web 服务的客户端&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  17:33 &lt;/p&gt;


&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 最新提案</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/29-%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/29-最新提案/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.446Z</updated>
    
    <content type="html"><![CDATA[<p>do 表达式<br>throw 表达式<br>函数的部分执行<br>管道运算符<br>数值分隔符<br>Math.signbit()<br>双冒号运算符<br>Realm API</p><p>#!命令<br>import.meta</p><p style="text-align:right"> 2020.12.13 星期日  11：25 </p><p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p><h2 id="1-do-表达式"><a href="#1-do-表达式" class="headerlink" title="1 do 表达式"></a>1 do 表达式</h2><p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。<br>do表达式的逻辑非常简单：封装的是什么，就会返回什么。<br>do表达式的好处是可以封装多个语句，让程序更加模块化<!-- ，就像乐高积木那样一块块拼装起来。 --><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值得一提的是，do表达式在 JSX 语法中非常好用。</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;Home /&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggedIn) &#123;</span><br><span class="line">          &lt;LogoutButton /&gt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          &lt;LoginButton /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p><h2 id="2-throw-表达式"><a href="#2-throw-表达式" class="headerlink" title="2 throw 表达式"></a>2 throw 表达式</h2><p>JavaScript 语法规定throw是一个命令，用来抛出错误，不能用于表达式之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>());</span><br></pre></td></tr></table></figure></p><p>上面代码中，console.log的参数必须是一个表达式，如果是一个throw语句就会报错。</p><p>现在有一个提案，允许throw用于表达式。</p><p>语法上，throw表达式里面的throw不再是一个命令，而是一个运算符。<br>为了避免与throw命令混淆，规定throw出现在行首，一律解释为throw语句，而不是throw表达式。</p><h2 id="3-函数的部分执行"><a href="#3-函数的部分执行" class="headerlink" title="3 函数的部分执行"></a>3 函数的部分执行</h2><p>多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add7</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">7</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 方法</span></span><br><span class="line"><span class="keyword">const</span> add7 = add.bind(<span class="literal">null</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add7 = <span class="function"><span class="params">x</span> =&gt;</span> add(x, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></p><p>上面两种写法都有些冗余。其中，bind方法的局限更加明显，它必须提供this，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。<br>现在有一个提案，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> addOne = add(<span class="number">1</span>, ?);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxGreaterThanZero = <span class="built_in">Math</span>.max(<span class="number">0</span>, ...);</span><br></pre></td></tr></table></figure><p>根据新提案，?是单个参数的占位符，…是多个参数的占位符。以下的形式都属于函数的部分执行。</p><p>?和…只能出现在函数的调用之中，并且会返回一个新函数。<br>函数的部分执行，也可以用于对象的方法。</p><p>注意点</p><h2 id="4-管道运算符"><a href="#4-管道运算符" class="headerlink" title="4 管道运算符"></a>4 管道运算符</h2><p>JavaScript 的管道是一个运算符，写作|&gt;。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。<br>管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的写法</span></span><br><span class="line">exclaim(capitalize(doubleSay(<span class="string">'hello'</span>)))</span><br><span class="line"><span class="comment">// "Hello, hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道的写法</span></span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line">  |&gt; doubleSay</span><br><span class="line">  |&gt; capitalize</span><br><span class="line">  |&gt; exclaim</span><br><span class="line"><span class="comment">// "Hello, hello!"</span></span><br></pre></td></tr></table></figure><p>管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。<br>如果是多参数函数，就必须进行柯里化，改成单参数的版本。</p><p>管道运算符对于await函数也适用。</p><h2 id="5-数值分隔符"><a href="#5-数值分隔符" class="headerlink" title="5 数值分隔符"></a>5 数值分隔符</h2><p>现在有一个提案，允许 JavaScript 的数值使用下划线（_）作为分隔符。<br>JavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p><p>数值分隔符有几个使用注意点。</p><p>除了十进制，其他进制的数值也可以使用分隔符。<br>注意，分隔符不能紧跟着进制的前缀0b、0B、0o、0O、0x、0X。</p><p>下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p><h2 id="6-Math-signbit"><a href="#6-Math-signbit" class="headerlink" title="6 Math.signbit()"></a>6 Math.signbit()</h2><p>Math.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。<br>JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。<br>实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。</p><p>该方法的算法如下。<br>如果参数是NaN，返回false<br>如果参数是-0，返回true<br>如果参数是负值，返回true<br>其他情况返回false</p><h2 id="7-双冒号运算符"><a href="#7-双冒号运算符" class="headerlink" title="7 双冒号运算符"></a>7 双冒号运算符</h2><p>但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p><h2 id="8-Realm-API"><a href="#8-Realm-API" class="headerlink" title="8 Realm API"></a>8 Realm API</h2><p>Realm API 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。<br><!-- 以前，经常使用`<iframe>`作为沙箱。 --></p><p>Realm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。<br>如果要解决这个问题，可以使用下面的代码。<br><code>globalTwo.console = globalOne.console;</code></p><p>Realm()构造函数可以接受一个参数对象，该参数对象的intrinsics属性可以指定 Realm 沙箱继承原始顶层对象的方法。</p><p>正常情况下，沙箱的JSON方法不同于原始的JSON对象。但是，Realm()构造函数接受{ intrinsics: ‘inherit’ }作为参数以后，就会继承原始顶层对象的方法。</p><h2 id="9-命令"><a href="#9-命令" class="headerlink" title="9  #!命令"></a>9  #!命令</h2><!-- Unix 的命令行脚本都支持#!命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。 --><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写在脚本文件第一行</span><br><span class="line">// 写在模块文件第一行</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前执行脚本的方式</span></span><br><span class="line">$ node hello.js</span><br><span class="line"><span class="comment"># hashbang 的方式</span></span><br><span class="line">$ ./hello.js</span><br></pre></td></tr></table></figure><p>有了这一行以后，Unix 命令行就可以直接执行脚本。<br>对于 JavaScript 引擎来说，会把#!理解成注释，忽略掉这一行。</p><h2 id="10-import-meta"><a href="#10-import-meta" class="headerlink" title="10 import.meta"></a>10 import.meta</h2><p>为 import 命令添加了一个元属性import.meta，返回当前模块的元信息。</p><p>import.meta只能在模块内部使用，如果在模块外部使用会报错。</p><p>这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta至少会有下面两个属性。</p><p>（1）import.meta.url</p><p>注意，Node.js 环境中，import.meta.url返回的总是本地路径，即是file:URL协议的字符串，比如file:///home/user/foo.js。</p><p>（2）import.meta.scriptElement<br>import.meta.scriptElement是浏览器特有的元属性，返回加载模块的那个<code>&lt;script&gt;</code>元素，相当于document.currentScript属性。</p><p style="text-align:right"> 11:52 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;do 表达式&lt;br&gt;throw 表达式&lt;br&gt;函数的部分执行&lt;br&gt;管道运算符&lt;br&gt;数值分隔符&lt;br&gt;Math.signbit()&lt;br&gt;双冒号运算符&lt;br&gt;Realm API&lt;/p&gt;
&lt;p&gt;#!命令&lt;br&gt;import.meta&lt;/p&gt;
&lt;p style=&quot;text-a
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 读懂 ECMAScript 规格</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/26-%E8%AF%BB%E6%87%82%20ECMAScript%20%E8%A7%84%E6%A0%BC/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/26-读懂 ECMAScript 规格/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.406Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>术语<br>抽象操作的标准流程<br>相等运算符<br>数组的空位<br>数组的 map 方法</p><p style="text-align:right"> 2020.12.13 星期日  16： </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p><p>一般来说，没有必要阅读规格，除非你要写编译器。<!-- 因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。 --><br>但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p><p>ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">www.ecma-international.org/ecma-262/6.0/</a>）免费下载和在线阅读。<br><!-- 这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。 --><br>ECMAScript 6 规格的 26 章之中，<br>第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。<br>第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。<br>第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，<br>第 6 章介绍数据类型，<br>第 7 章介绍语言内部用到的抽象操作，<br>第 8 章介绍代码如何运行。<br>第 9 章到第 26 章介绍具体的语法。</p><p>对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。</p><h2 id="2-术语"><a href="#2-术语" class="headerlink" title="2 术语"></a>2 术语</h2><p>抽象操作<br>所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。</p><p>Record 和 field<br>ES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。</p><p>[[Notation]]<br>ES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。</p><p>Completion Record<br>每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。<br>[[Type]]属性有五种可能的值。<br>normal<br>return<br>throw<br>break<br>continue</p><h2 id="3-抽象操作的标准流程"><a href="#3-抽象操作的标准流程" class="headerlink" title="3 抽象操作的标准流程"></a>3 抽象操作的标准流程</h2><p>抽象操作的运行流程，一般是下面这样。</p><ol><li>Let result be AbstractOp().</li><li>If result is an abrupt completion, return result.</li><li>Set result to result.[[Value]].</li><li>return result.</li></ol><h2 id="4-相等运算符"><a href="#4-相等运算符" class="headerlink" title="4 相等运算符"></a>4 相等运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。<br>“The comparison x == y, where x and y are values, produces true or false.”<br>下面是算法细节。</p><p>由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。<br>因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。</p><h2 id="5-数组的空位"><a href="#5-数组的空位" class="headerlink" title="5 数组的空位"></a>5 数组的空位</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [, , ,];</span><br><span class="line"></span><br><span class="line">a1.length <span class="comment">// 3</span></span><br><span class="line">a2.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a1[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line">a2[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a1[<span class="number">0</span>] === a2[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，它们实际上存在重大差异。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1 <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a1.hasOwnProperty(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">a2.hasOwnProperty(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a1) <span class="comment">// ["0", "1", "2"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(a2) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a1.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [1, 1, 1]</span></span><br><span class="line">a2.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></p><p>“数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。”</p><h2 id="6-数组的-map-方法"><a href="#6-数组的-map-方法" class="headerlink" title="6 数组的 map 方法"></a>6 数组的 map 方法</h2><p>仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，kPresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [, , ,];</span><br><span class="line">arr.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;术语&lt;br&gt;抽象操作的标准流程&lt;br&gt;相等运算符&lt;br&gt;数组的空位&lt;br&gt;数组的 map 方法&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  16： &lt;/p&gt;


&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 装饰器Decorator</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/30-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/30-装饰器/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.205Z</updated>
    
    <content type="html"><![CDATA[<p>类的装饰<br>方法的装饰<br>为什么装饰器不能用于函数？<br>core-decorators.js<br>使用装饰器实现自动发布事件<br>Mixin<br>Trait</p><p style="text-align:right"> 2020.12.13 星期日  10：40 </p><blockquote><p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。</p></blockquote><p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。</p><p>装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@frozen <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>$_PS: 装饰者模式。babel插件：@babel/plugin-proposal-decorators</p><h2 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h2><p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时<!-- 。这意味着，装饰器能在编译阶段运行代码。也就是说， -->装饰器本质就是编译时执行的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 1.1 装饰器函数的第一个参数，就是所要装饰的目标类。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 1.2 如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</span></span><br><span class="line"><span class="comment">// 装饰器testable可以接受参数，这就等于可以修改装饰器的行为。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>) <span class="comment">// @testable(false)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的例子是为类添加一个静态属性，</span></span><br><span class="line"><span class="comment">// ## 2 如果想添加实例属性，可以通过目标类的prototype对象操作。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 2.1 </span></span><br><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码通过装饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。</span></span><br><span class="line"><span class="comment">// ### 2.2 可以用Object.assign()模拟这个功能。</span></span><br><span class="line"><span class="comment">// ### 2.3 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了装饰器，就可以改写上面的代码。</span></span><br><span class="line">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-方法的装饰"><a href="#2-方法的装饰" class="headerlink" title="2 方法的装饰"></a>2 方法的装饰</h2><p>装饰器不仅可以装饰类，还可以装饰类的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ## 1 装饰器函数readonly一共可以接受三个参数。</span></span><br><span class="line"><span class="comment">// 装饰器第一个参数是类的原型对象，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 1.2 修改属性描述对象的enumerable属性</span></span><br><span class="line"><span class="comment">// ## 1.3 下面的@log装饰器，可以起到输出日志的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 装饰器有注释的作用。</span></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 下面是使用 Decorator 写法的组件，看上去一目了然。</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">'my-component'</span>,</span><br><span class="line">  styleUrl: <span class="string">'my-component.scss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ## 3 除了注释，装饰器还能用来类型检查。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</span></span><br></pre></td></tr></table></figure></p><h2 id="3-为什么装饰器不能用于函数？"><a href="#3-为什么装饰器不能用于函数？" class="headerlink" title="3 为什么装饰器不能用于函数？"></a>3 为什么装饰器不能用于函数？</h2><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。<br>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finished'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure></p><h2 id="4-core-decorators-js"><a href="#4-core-decorators-js" class="headerlink" title="4 core-decorators.js"></a>4 core-decorators.js</h2><p>core-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。<br>（1）@autobind<br>（2）@readonly<br>（3）@override<br>（4）@deprecate (别名@deprecated)<br>（5）@suppressWarnings</p><h2 id="5-使用装饰器实现自动发布事件"><a href="#5-使用装饰器实现自动发布事件" class="headerlink" title="5 使用装饰器实现自动发布事件"></a>5 使用装饰器实现自动发布事件</h2><p>它使用的事件“发布/订阅”库是Postal.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">"postal/lib/postal.lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> channelName = channel || <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">  msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'频道: '</span>, channelName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件: '</span>, topic);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据: '</span>, v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      msgChannel.publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Mixin"><a href="#6-Mixin" class="headerlink" title="6 Mixin"></a>6 Mixin</h2><p>在装饰器的基础上，可以实现Mixin模式。<br><!-- 所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function">(<span class="params">superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo from MyMixin'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo(); <span class="comment">// "foo from MyMixin"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 如果需要“混入”多个方法，就生成多个混入类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><h2 id="7-Trait"><a href="#7-Trait" class="headerlink" title="7 Trait"></a>7 Trait</h2><p>Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。<br>下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><p>上面代码中，TFoo和TBar都有foo方法，结果traits装饰器报错。<br>一种解决方法是排除TBar的foo方法。<br>另一种方法是为TBar的foo方法起一个别名。<br>alias和excludes方法，可以结合起来使用。<br>as方法则为上面的代码提供了另一种写法。</p><p style="text-align:right"> 11.25 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的装饰&lt;br&gt;方法的装饰&lt;br&gt;为什么装饰器不能用于函数？&lt;br&gt;core-decorators.js&lt;br&gt;使用装饰器实现自动发布事件&lt;br&gt;Mixin&lt;br&gt;Trait&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>React状态管理库对比</title>
    <link href="http://yoursite.com/sum/jsplus/react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/sum/jsplus/react状态管理库对比/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:42.909Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.12.13 星期日  21：35 </p><h1 id="实际状态管理项目"><a href="#实际状态管理项目" class="headerlink" title="实际状态管理项目"></a>实际状态管理项目</h1><p>实际使用了redux，也是得益于其“啰嗦”的设计，把所有reducer 定义于一处，包括定义action。清晰，方便查找/追踪state<br>没有使用immutable。但是确实做了一些性能优化的处理，包括state及某个属性如何更新等。</p><!-- 当时 -->没使用dva，因为是一个框架，内置了router等，并不需要，仅是一个简单的状态管理。<br>redux 简单强大，刚好满足。不需要再去学习新框架dva<br><br>mobx 使用简单，灵活，同样的和redux，dva 需要学习新的状态管理概念/文档。用generator语法糖，增加配置成本。<br>每一个需要监听的state/属性/action，需要用@observable，@action 去处理。也可以不去监听，混合在一起。<br>虽然装饰器使得语法明了。但是redux 数据流，有明确的规定，必须先定义action（type，payload），然后去操作reducer。<br><br>若在业务项目中使用，无聊mobx或dva 都是非常不错了。奈何更需要的是一个状态（集中）管理的简单库。<br>如果偏业务，redux确实有一些啰嗦。<br><br><br><!-- 虽然是不用的应用场景。github battle --><h2 id="github-对比"><a href="#github-对比" class="headerlink" title="github 对比"></a>github 对比</h2><p>统计于 20201214</p><table><thead><tr><th>–</th><th>star</th><th>issues</th><th>fork</th></tr></thead><tbody><tr><td>redux</td><td>54.9k</td><td>33/1802</td><td>14.5k </td></tr><tr><td>mobx</td><td>22.9k</td><td>12/1633</td><td>1.9k </td></tr><tr><td>dva</td><td>15.3k</td><td>22/2072</td><td>3k </td></tr></tbody></table><h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>github: <a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">https://github.com/reduxjs/redux</a><br><a href="https://redux.js.org/introduction/installation" target="_blank" rel="noopener">redux文档</a></p><h1 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h1><p>github: <a href="https://github.com/dvajs/dva/blob/master/README_zh-CN.md" target="_blank" rel="noopener">https://github.com/dvajs/dva/blob/master/README_zh-CN.md</a><br><a href="https://dvajs.com/guide/" target="_blank" rel="noopener">dva 文档</a></p><p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</p><h1 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h1><p>github: <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">https://github.com/mobxjs/mobx</a></p><p><a href="https://mobx.js.org/about-this-documentation.html" target="_blank" rel="noopener">MobX</a><br><a href="https://cn.mobx.js.org" target="_blank" rel="noopener">MobX</a><br><!-- [MobX 中文文档](https://suprise.github.io/mobx-cn/index.html) --></p><!-- $_PS: 通过第二篇文档，基本用法已了解。高阶/详细 需要使用的时候再次确认。有时间，学习官方文档 --><p>MobX 以前叫做 Mobservable</p><h2 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义一个可观测的store</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppStore</span> </span>&#123;</span><br><span class="line">  @observable number = <span class="number">0</span>;</span><br><span class="line">  changeNumber()&#123;</span><br><span class="line">      <span class="keyword">this</span>.number++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再定义观测store的组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react'</span>;</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span>&#123;store&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;store.changeNumber.bind(store)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;store.number&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终我们把store注入进去，然后把组件渲染出来</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> AppStore();</span><br><span class="line">render(</span><br><span class="line">  &lt;App store=&#123;store&#125; /&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="mobx-react"><a href="#mobx-react" class="headerlink" title="mobx-react"></a>mobx-react</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><!-- [mobx-react 原理解析(一)](https://zhuanlan.zhihu.com/p/27448262) --><!-- [mobx-react 原理解析(二)](https://zhuanlan.zhihu.com/p/27551105) --><h3 id="REDUX的好处"><a href="#REDUX的好处" class="headerlink" title="REDUX的好处"></a>REDUX的好处</h3><p>通过action,reducer来完成应用的数据流管理，逻辑简单清晰<br>reducer函数式的设计，让我们代码变得可观测，可回溯<br>action的设计，特别适用于多数据联动的场景<br>REDUX的弊端</p><p>啰嗦代码太多<br>reducer无复用性<br>性能优化太繁琐(当然可以引入immutable来解决，但是是不是又增加了学习成本,应用的复杂度和代码量呢)<br>app state和store state的划分<br>在实际开发中，一方面我们受益于redux的好处，但另一方面我们也受制于redux的弊端，其实某种程度制约了我们的开发效率，因此近端时间学习了下mobx，从它这里找到了能提升开发效率的方法，不是说mobx比redux好，而是mobx更适合我们实际的工作内容，而redux更实用与大型项目的开发</p><h3 id="MobX-1"><a href="#MobX-1" class="headerlink" title="MobX"></a>MobX</h3><p>从这张图我们可以看到mobx其实就是mvvm的概念，数据双向绑定，并且能做到字段级的控制，所以用mobx开发react的项目，我们不需要做太多的性能优化，同时它的store是可以复用的，这对我们快速开发项目特别有帮助</p><p>至此，mobx-react的工作原理基本梳理清楚了，大致用一下几句话来概括<br>1.observe组件第一次渲染的时候，会创建Reaction，组件的render处于当前这个Reaction的上下文中，并通过track建立render中用到的observable建立关系<br>2.当observable属性修改的时候，会触发onInvalidate方法，实际上就是组件的forceupdate,然后触发组件渲染，又回到了第一步<br>这篇就先到这里告一段落，后面会对action,compute,atom做进一步的分享</p><h4 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h4><p>运行到代码1处，通过第一节的分析，autorun的Reaction跟fullName建立观测的关系，而通过上面的分析，compute的<code>帅帅的</code>+this.name表达式跟computeValue的Reaction建立了观测关系</p><p>当我们运行p.changeName的时候，根据前面的知识，会触发observer的onBecomeStale，不过computeValue的onBecomeStale跟Reaction的onBecomeStale不一样</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>从源码可以看出，核心就是通过startBatch和endBatch完成一个批量的操作，也就是说我们在executeAction无论改变多少次observable的值，最终只会触发一次Reaction的onInvalidate</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><!-- [[React框架 dva 和 mobx 的使用感受]](https://www.cnblogs.com/owenma/p/8409696.html) --><h2 id="dva-1"><a href="#dva-1" class="headerlink" title="dva"></a>dva</h2><p>经朋友推荐开始接触 dva ，从  2.x 版本开始使用，我也基于这个工具开发了一套项目模版，它简化了 redux 的使用，并且在封装了 redux-saga 和 react-router，同时还可以包含 dva-loading 插件获取 loading 状态等。</p><p>在 redux 时代，当我需要新增一种跨页面全局数据的时候，我需要去项目的 reducers 目录定义一下这种数据命名和初始值，然后在 constans 目录中为更改这项数据的操作定义一种唯一的操作类型（type），再去 actions 目录定义一些方法，这些方法最后会得到更改后的数据和操作类型（type），最后再回到 reducers 中根据这个操作类型（type）把数据整合到 reducer 中…可以看到，我在编写 redux 这部分代码的时候需要频繁在 actions 、 constants 、 reducers 这几个目录间切换。</p><p>而使用 dva 就可以免除这些困扰了，我只需要一个 model 中就可以完成所有操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app全局性状态管理</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> appApis <span class="keyword">from</span> <span class="string">'../services/app'</span>; <span class="comment">// 异步请求接口</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'app'</span>,</span><br><span class="line"> </span><br><span class="line">  state: &#123;</span><br><span class="line">    channels: [],</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  reducers: &#123;</span><br><span class="line">    getChannelsAndGamesSuccess(state, &#123; channels, games &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, channels, games &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeShow(state, &#123; show &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, show &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  effects: &#123; <span class="comment">// 异步</span></span><br><span class="line">    * getChannelsAndGames(_, &#123; call, put &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">yield</span> call(appApis.getChannelsAndGames);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'getChannelsAndGamesSuccess'</span>,</span><br><span class="line">        channels: res.channels</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">     </span><br><span class="line">  subscriptions: &#123; <span class="comment">// 订阅</span></span><br><span class="line">    setup(&#123;dispatch, history&#125;) &#123;</span><br><span class="line">      history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (location.pathname == <span class="string">'/'</span>) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: <span class="string">'getChannelsAndGames'</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><p>既然 dva 这么好用，为什么还要使用 mobx 呢？还不是为了折腾😅，用了才能知道两者的优劣，同样的基于 mobx 我也创建了一个项目模版。</p><p>在使用 dva 的时候，但凡遇到异步请求的时候都需要先定义一个 effects ，请求完成后再触发一个 action 去修改数据，于是，强迫症作怪，这两者的命名总是让我感觉难受和啰嗦，你可以看到我都是定义为 getXxx 和 getXxxSuccess。</p><p>action 是修改 state 的唯一途径，是的，所有的状态管理库都是这样的，但是 mobx 通过一些工具函数解决了这一问题：</p><p>以上是我最喜欢的两种写法，分别借助了 runInAction 和 asyncAction 这两个工具函数，当然，还有其他方法可以参考。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  21：35 &lt;/p&gt;

&lt;h1 id=&quot;实际状态管理项目&quot;&gt;&lt;a href=&quot;#实际状态管理项目&quot; class=&quot;headerlink&quot; title=&quot;实际状态管理项目&quot;&gt;&lt;/a&gt;实际状态管
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack原理</title>
    <link href="http://yoursite.com/sum/jsplus/webpack%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/sum/jsplus/webpack原理/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:05.567Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.11 星期  ： </p><h1 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h1><p><a href="https://www.jianshu.com/p/c71393db6287" target="_blank" rel="noopener">Tapable中文文档</a><br>Tapable是一个用于事件发布订阅执行的插件架构<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公开的方法</span></span><br><span class="line"><span class="built_in">void</span> apply(plugins: Plugin...)</span><br><span class="line"><span class="built_in">void</span> plugin(names: <span class="built_in">string</span>|<span class="built_in">string</span>[], handler: <span class="built_in">Function</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 受保护的方法</span></span><br><span class="line"><span class="built_in">void</span> applyPlugins(name: <span class="built_in">string</span>, args: <span class="built_in">any</span>...)</span><br><span class="line"><span class="built_in">any</span> applyPluginsWaterfall(name: <span class="built_in">string</span>, init: <span class="built_in">any</span>, args: <span class="built_in">any</span>...)</span><br><span class="line">  <span class="built_in">void</span> applyPluginsAsync(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err?: <span class="built_in">Error</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">any</span> applyPluginsBailResult(name: <span class="built_in">string</span>, args: <span class="built_in">any</span>...)</span><br><span class="line">applyPluginsAsyncWaterfall(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    init: <span class="built_in">any</span>,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsAsyncSeries(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsParallel(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err?: <span class="built_in">Error</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsParallelBailResult(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/273e1c9904d2" target="_blank" rel="noopener">Webpack 核心模块 tapable 解析（转）</a><br>Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 tapable 如下</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    SyncHook,</span><br><span class="line">    SyncBailHook,</span><br><span class="line">    SyncWaterfallHook,</span><br><span class="line">    SyncLoopHook,</span><br><span class="line">    AsyncParallelHook,</span><br><span class="line">    AsyncParallelBailHook,</span><br><span class="line">    AsyncSeriesHook,</span><br><span class="line">    AsyncSeriesBailHook,</span><br><span class="line">    AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020.11 星期  ： &lt;/p&gt;

&lt;h1 id=&quot;Tapable&quot;&gt;&lt;a href=&quot;#Tapable&quot; class=&quot;headerlink&quot; title=&quot;Tapable&quot;&gt;&lt;/a&gt;Tapable&lt;/h1&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack5新特性</title>
    <link href="http://yoursite.com/sum/jsplus/webpack5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/sum/jsplus/webpack5新特性/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2020-11-23T02:56:21.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/" target="_blank" rel="noopener">Webpack 5 发布 (2020-10-10)</a><br><a href="https://webpack.docschina.org/migrate/5/" target="_blank" rel="noopener">从 v4 升级到 v5</a><br>文档：<a href="https://webpack.docschina.org/concepts/under-the-hood/" target="_blank" rel="noopener">https://webpack.docschina.org/concepts/under-the-hood/</a><br><!-- [揭示内部原理] --></p><p style="text-align:right"> 2020.11.22 星期日  23：13 </p><p>2020 年 10 月 10 日，Webpack 正式发布了 5.0 版本。</p><h1 id="从-v4-升级到-v5"><a href="#从-v4-升级到-v5" class="headerlink" title="从 v4 升级到 v5"></a>从 v4 升级到 v5</h1><!-- [从 v4 升级到 v5](https://webpack.docschina.org/migrate/5/) --><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>webpack 5 要求至少 Node.js 10.13.0 (LTS)。</p><blockquote><p>使用较新的 Node.js 版本能够改善构建性能。</p></blockquote><h3 id="升级-webpack-以及它的依赖"><a href="#升级-webpack-以及它的依赖" class="headerlink" title="升级 webpack 以及它的依赖"></a>升级 webpack 以及它的依赖</h3><p>将 webpack 4 升级到最新的可用版本<br>将 webpack-cli 升级到最新的可用版本 (当有使用的时候)<br>将所有使用的 plugin 和 loader 升级到最新的可用版本<br>确保你的构建没有错误与警告<br>确保你使用的是 stats 中的入口信息<br>请确保设置了 mode</p><p>升级废弃的配置项<br>测试 webpack 5 兼容性<br>升级 webpack 版本<br>清理配置<br>清理代码<br>清理构建代码</p><p>运行单个构建并遵循以下建议<br>如有需要，在 runtime 代码中禁用 ES2015 语法</p><h2 id="内核的改变"><a href="#内核的改变" class="headerlink" title="内核的改变"></a>内核的改变</h2><p>loader 的 getOptions 方法</p><h1 id="新特性（简要）"><a href="#新特性（简要）" class="headerlink" title="新特性（简要）"></a>新特性（简要）</h1><!-- [Webpack 5 发布，主要做架构改进](https://www.oschina.net/news/119151/webpack-5-release) --><!-- $_PS: 2020年10月13日 --><h2 id="整体方向"><a href="#整体方向" class="headerlink" title="整体方向"></a>整体方向</h2><p>这个版本的重点在于以下几点。</p><p>尝试用持久性缓存来提高构建性能。<br>尝试用更好的算法和默认值来改进长期缓存。<br>尝试用更好的 Tree Shaking 和代码生成来改善包大小。<br>尝试改善与网络平台的兼容性。<br>尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4功能时处于奇怪状态的内部结构。<br>试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5版本上。</p><h2 id="重大变更"><a href="#重大变更" class="headerlink" title="重大变更"></a>重大变更</h2><p>功能清除：清理弃用的能力，废弃代码，语法废弃等<br>长期缓存：确定的 Chunk、模块 ID 和导出名称，真正的内容哈希等<br>开发支持：命名代码块 ID，模块联邦等<br>支持新的 Web 平台特性：JSON 模块，资源模块，异步模块等<br>支持全新的 Node.js 生态特性<br>开发体验：进度，Stars，自动添加唯一命名等<br>构建优化：模块合并，副作用分析，嵌套的 tree-shaking，内部模块 tree-shaking 等<br>性能优化：持久缓存，编译器闲置和关闭，文件生成<br>长期未解决问题：单一文件目标的代码分割，更新解析器等<br>9）未来计划<br>0）内部架构变更</p><h1 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h1><p><a href="https://segmentfault.com/a/1190000037460742" target="_blank" rel="noopener">Webpack 5 正式发布</a><br><!-- $_PS: 上述详细说明.发布于 10月13日 --><br>&lt;!– </p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>英译中<br><a href="https://www.jianshu.com/p/7148d29cee46" target="_blank" rel="noopener">Webpack 5 中的新特性</a><br><a href="https://zhuanlan.zhihu.com/p/56796027" target="_blank" rel="noopener">Webpack 5 中的新特性</a><br> –&gt;<br><!-- $_PS: 英翻译中。2019.06.12 17:27:42 --></p><h1 id="Module-federation"><a href="#Module-federation" class="headerlink" title="Module federation"></a>Module federation</h1><!-- [精读《Webpack5 新特性 - 模块联邦》](https://zhuanlan.zhihu.com/p/115403616)[探索 webpack5 新特性 Module federation 在腾讯文档的应用](http://www.alloyteam.com/2020/04/14338/) --><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Webpack 5 发布 (2020-10-10)&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack实践</title>
    <link href="http://yoursite.com/sum/jsplus/webpack%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/sum/jsplus/webpack实践/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:23.247Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020. 星期  ： </p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>官方：performance，stats<br><!-- [[你值得拥有的几款实用webpack4性能分析插件【测评与推荐】]](https://juejin.cn/post/6844904040128577549) --></p><p>ProgressBarPlugin<br>npm i progress-bar-webpack-plugin</p><p>SpeedMeasurePlugin<br>npm i speed-measure-webpack-plugin<br><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noopener">https://github.com/stephencookdev/speed-measure-webpack-plugin</a></p><p>BundleAnalyzerPlugin<br>npm i webpack-bundle-analyzer</p><p>DashboardPlugin<br>npm i webpack-dashboard</p><p>DuplicatePackageCheckerPlugin<br>npm i duplicate-package-checker-webpack-plugin</p><!-- [浅谈 webpack 性能优化（内附 webpack 学习笔记）](https://zhuanlan.zhihu.com/p/139498741) [webpack 学习整理文档](https://github.com/darrell0904/webpack-doc)--><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020. 星期  ： &lt;/p&gt;




&lt;h1 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h1&gt;&lt;h2 id=&quot;性能分析&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Git文档10 - Git 内部原理</title>
    <link href="http://yoursite.com/w3/git/git%E6%96%87%E6%A1%A3/git%E6%96%87%E6%A1%A3%2010%20-%20Git%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/w3/git/git文档/git文档 10 - Git 内部原理/</id>
    <published>2020-11-15T00:00:00.000Z</published>
    <updated>2021-01-23T13:37:48.075Z</updated>
    
    <content type="html"><![CDATA[<p>10.1 底层命令与上层命令<br>10.2 Git 对象<br>10.3 Git 引用<br>10.4 包文件<br>10.5 引用规范<br>10.6 传输协议<br>10.7 维护与数据恢复<br>10.8 环境变量<br>10.9 总结</p><p style="text-align:right"> 2020. 星期  ： </p><!-- 其他[图解git原理的几个关键概念](https://tonybai.com/2020/04/07/illustrated-tale-of-git-internal-key-concepts/) --><h1 id="底层命令与上层命令"><a href="#底层命令与上层命令" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h1><p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。</p><h3 id="底层命令与上层命令-1"><a href="#底层命令与上层命令-1" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h3><p>本书主要涵盖了 checkout、branch、remote 等约 30 个 Git 的子命令。 <!-- 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统， 所以它还包含了一部分用于完成底层工作的子命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 --> 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p><p>新初始化的 .git 目录的典型结构如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ls -F1</span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">  |- fa/38gezifu(40-2)</span><br><span class="line">  |- infos/</span><br><span class="line">    |- packs/</span><br><span class="line">  |- pack/</span><br><span class="line">  |- ORIG_HEAD</span><br><span class="line">  |- packed-refs</span><br><span class="line">refs/</span><br><span class="line">  |- heads/</span><br><span class="line">    |- 本地的分支| dev-feature-some-20201030-updateSth</span><br><span class="line">  |- remotes/</span><br><span class="line">    |- origin/  </span><br><span class="line">  |-tags/</span><br><span class="line">  |- stash</span><br></pre></td></tr></table></figure></p><p>随着 Git 版本的不同，该目录下可能还会包含其他内容。 不过对于一个全新的 git init 版本库，这将是你看到的默认结构。<br>description 文件仅供 GitWeb 程序使用，我们无需关心。<br>config 文件包含项目特有的配置选项。<br>info 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。<br>hooks 目录包含客户端或服务端的钩子脚本（hook scripts）， 在 Git 钩子 中这部分话题已被详细探讨过。</p><p>剩下的四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 它们都是 Git 的核心组成部分。<br>objects 目录存储所有数据内容；<br>refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；<br>HEAD 文件指向目前被检出的分支；<br>index 文件保存暂存区信息。</p><h1 id="10-2-Git-对象"><a href="#10-2-Git-对象" class="headerlink" title="10.2 Git 对象"></a>10.2 Git 对象</h1><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 是一个内容寻址文件系统</p><h3 id="树对象（tree-object）"><a href="#树对象（tree-object）" class="headerlink" title="树对象（tree object）"></a>树对象（tree object）</h3><p>它能<strong>解决文件名保存的问题</strong>，也允许我们将多个文件组织到一起。<br><!-- Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。  --><br>一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></pre></td></tr></table></figure></p><p>master^{tree} 语法表示 master 分支上最新的提交所指向的树对象。</p><p>Figure 149. 简化版的 Git 数据模型。<br><!-- 你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。  --><br>因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 git update-index 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。</p><p>我们指定的文件模式为 100644，表明这是一个普通文件。 其他选择包括：100755，表示一个可执行文件；120000，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p><p>这就是每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 </p><p>Figure 151. 你的 Git 目录下所有可达的对象。</p><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>Git 首先会以识别出的对象的类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会在头部的第一部分添加一个空格，随后是数据内容的字节数，最后是一个空字节（null byte）</p><p>就是这样——你已创建了一个有效的 Git 数据对象。</p><p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。<br>另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p><h1 id="10-3-Git-内部原理-Git-引用"><a href="#10-3-Git-内部原理-Git-引用" class="headerlink" title="10.3 Git 内部原理 - Git 引用"></a>10.3 Git 内部原理 - Git 引用</h1><h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>不过你需要记得 1a410e 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。</p><p>在 Git 中，这种简单的名字被称为“引用（references，或简写为 refs）”。</p><p>Figure 152. 包含分支引用的 Git 目录对象。<br>当运行类似于 git branch <code>&lt;branch&gt;</code> 这样的命令时，Git 实际上会运行 update-ref 命令， <strong>取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</strong></p><h2 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h2><p>现在的问题是，当你执行 git branch <branch> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。<br>HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。</branch></p><p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p><h4 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h4><!-- 前面我们刚讨论过 Git 的三种主要的对象类型（数据对象、树对象 和 提交对象 ），然而实际上还有第四种。 --><p>标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。<br><!-- 主要的区别在于， -->标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span class="string">'test tag'</span></span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在对该 SHA-1 值运行 git cat-file -p 命令：</span></span><br><span class="line">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line">object 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> tag</span><br></pre></td></tr></table></figure><blockquote><p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。</p></blockquote><h4 id="远程引用-（remote-reference）"><a href="#远程引用-（remote-reference）" class="headerlink" title="远程引用 （remote reference）"></a>远程引用 （remote reference）</h4><p>,并保存在 refs/remotes 目录下。</p><h1 id="10-4-Git-内部原理-包文件"><a href="#10-4-Git-内部原理-包文件" class="headerlink" title="10.4 Git 内部原理 - 包文件"></a>10.4 Git 内部原理 - 包文件</h1><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p><!-- 你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象（每个都被压缩到大约 7K）。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？ --><p>Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，</p><p>剩下的文件是新创建的<strong>包文件和一个索引</strong>。<br>包文件包含了刚才从文件系统中移除的所有对象的内容。<br>索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。<br><!-- 有意思的是运行 gc 命令前磁盘上的对象大小约为 15K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了一半的磁盘占用空间。 --></p><p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 git verify-pack 这个底层命令可以让你查看已打包的内容：</p><p>同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p><p>最妙之处是你可以随时重新打包。 Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 git gc 命令来这么做。</p><h1 id="10-5-引用规范（refspec）"><a href="#10-5-引用规范（refspec）" class="headerlink" title="10.5 引用规范（refspec）"></a>10.5 引用规范（refspec）</h1><p><code>$ git remote add origin https://github.com/schacon/simplegit-progit</code><br>运行上述命令会在你仓库中的 .git/config 文件中添加一个小节， 并在其中指定远程版本库的名称（origin）、URL 和一个用于获取操作的 引用规范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">  ## 让 Git 每次只拉取远程的 master 分支，而不是所有分支</span><br><span class="line">  # fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line"></span><br><span class="line">  ## 你也可以在配置文件中指定多个用于获取操作的引用规范。</span><br><span class="line">    ## 远程仓库获取时都包括 master 和 experiment 分支</span><br><span class="line">  fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br><span class="line">  ## 命名空间（或目录）</span><br><span class="line">  fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # 引用规范推送 `git push origin master:refs/heads/qa/master`</span><br><span class="line">  ## Git 每次运行 `git push origin` 时都像上面这样推送</span><br><span class="line">  push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure></p><p>引用规范的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，<br>其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<br><code>&lt;dst&gt;</code> 是本地跟踪的远程引用的位置。<br><code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><p>1) <!-- 默认情况下，引用规范由 git remote add origin 命令自动生成， Git 获取服务器中 refs/heads/ 下面的所有引用，并将它写入到本地的 refs/remotes/origin/ 中。 所以， -->如果服务器上有一个 master 分支，你可以在本地通过下面任意一种方式来访问该分支上的提交记录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> origin/master</span><br><span class="line">$ git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">$ git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure></p><p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 refs/remotes/origin/master。</p><p>1) 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规范。<br><!-- 远程的 master 分支拉到本地的 origin/mymaster 分支 --><br><code>git fetch origin master:refs/remotes/origin/mymaster</code></p><p>1) 你也可以指定多个引用规范。 在命令行中，你可以按照如下的方式拉取多个分支：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \ </span><br><span class="line">  topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure></p><p>我们不能在模式中使用部分通配符<br>1) 但我们可以使用命名空间（或目录）来达到类似目的</p><p>### 引用规范推送<br><code>$ git push origin master:refs/heads/qa/master</code></p><p>### 删除引用<br><code>$ git push origin :topic</code><br>因为引用规范（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 topic 分支定义为空值，也就是删除它。<br><code>$ git push origin --delete topic</code><br><!-- 或者你可以使用更新的语法（自 Git v1.7.0 以后可用）： --></p><h1 id="10-6-传输协议"><a href="#10-6-传输协议" class="headerlink" title="10.6 传输协议"></a>10.6 传输协议</h1><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。 </p><p>哑协议: 一个基于 HTTP 协议的只读版本库<br><!-- 这个协议之所以被称为“哑”协议，是因为 -->在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 GET 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><p>智能协议<br>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。<br>智能协议是更常用的传送数据的方法，但它<strong>需要在服务端运行一个进程</strong>，而这也是 Git 的智能之处——<strong>它可以读取本地数据</strong>，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><h3 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h3><p>为了上传数据至远端，Git 使用 send-pack 和 receive-pack 进程。 运行在客户端上的 send-pack 进程连接到远端运行的 receive-pack 进程。</p><p>举例来说，在项目中使用命令 git push origin master 时, origin 是由基于 SSH 协议的 URL 所定义的。 Git 会运行 send-pack 进程，它会通过 SSH 连接你的服务器。 它会尝试通过 SSH 在服务端执行命令，就像这样：</p><h3 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h3><p>当你在下载数据时， fetch-pack 和 upload-pack 进程就起作用了。 客户端启动 fetch-pack 进程，连接至远端的 upload-pack 进程，以协商后续传输的数据。</p><h1 id="10-7-维护与数据恢复"><a href="#10-7-维护与数据恢复" class="headerlink" title="10.7 维护与数据恢复"></a>10.7 维护与数据恢复</h1><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 <!-- 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。  --><br>“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中， 将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。<br><code>$ git gc --auto</code><br>这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。<br>你可以通过修改 gc.auto 与 gc.autopacklimit 的设置来改动这些数值。</p><p>gc 将会做的另一件事是打包你的引用到一个单独的文件。<br><!-- 如果你执行了 git gc 命令，refs 目录中将不会再有这些文件。 --> 为了保证效率 Git 会将它们移动到名为 .git/packed-refs 的文件中，<br>Git 会首先在 refs 目录中查找指定的引用，然后再到 packed-refs 文件中查找。 </p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>最方便，也是最常用的方法，是使用一个名叫 git reflog 的工具。<br>当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 <!-- 引用日志（reflog）也可以通过 git update-ref 命令更新， --></p><p>你可以通过创建一个新的分支指向这个提交来恢复它<br><code>git branch recover-branch ab1afef</code><br><code>git log --pretty=oneline recover-branch</code></p><p>由于引用日志数据存放在 .git/logs/ 目录中，现在你已经没有引用日志了。<br><!-- 这时该如何恢复那次提交？ --> 一种方式是使用 git fsck 实用工具，将会检查数据库的完整性。<br>如果使用一个 –full 选项运行它，它会向你显示出所有没有被其他对象指向的对象：<br>$_PS: stash 的丢失，也可以通过这个指令找出/恢复。<code>----lost-found</code> : write dangling objects in .git/lost-found</p><h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 错误添加</span></span><br><span class="line">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz</span><br><span class="line">$ git add git.tgz</span><br><span class="line">$ git commit -m <span class="string">'add git tarball'</span></span><br><span class="line"><span class="comment">## 其实这个项目并不需要这个巨大的压缩文件。 现在我们将它移除</span></span><br><span class="line">git rm git.tgz</span><br><span class="line"><span class="comment">## 执行 gc 来查看数据库占用了多少空间</span></span><br><span class="line">$ git gc</span><br><span class="line"><span class="comment">### 你也可以执行 count-objects 命令来快速的查看占用空间大小</span></span><br><span class="line">git count-objects -v</span><br></pre></td></tr></table></figure><p>size-pack 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。<br>在最后一次提交前，使用了不到 2KB ——显然，从之前的提交中移除文件并不能从历史中移除它。</p><p>首先你必须找到它。 <!-- 在本例中，你已经知道是哪个文件了。 --><br>但是假设你不知道；<!-- 该如何找出哪个文件或哪些文件占用了如此多的空间？ 如果你执行 git gc 命令，所有的对象将被放入一个包文件中， -->你可以通过运行 git verify-pack 命令， 然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。<br>你也可以将这个命令的执行结果通过管道传送给 tail 命令，因为你只需要找到列在最后的几个大对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --index-filter \</span><br><span class="line">  <span class="string">'git rm --ignore-unmatch --cached git.tgz'</span> -- 7b30847^..</span><br><span class="line"></span><br><span class="line"><span class="comment">## 你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 .git/refs/original 通过</span></span><br><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs/</span><br><span class="line">$ git gc</span><br><span class="line"><span class="comment">## 让我们看看你省了多少空间。</span></span><br><span class="line">$ git count-objects -v</span><br><span class="line"><span class="comment">## 这个大文件还在你的松散对象中，并没有消失；</span></span><br><span class="line"><span class="comment">## 如果真的想要删除它，可以通过有 --expire 选项的 git prune 命令来完全地移除那个对象</span></span><br><span class="line">$ git prune --expire now</span><br><span class="line">$ git count-objects -v</span><br></pre></td></tr></table></figure></p><h1 id="10-8-环境变量"><a href="#10-8-环境变量" class="headerlink" title="10.8 环境变量"></a>10.8 环境变量</h1><p>Git 总是在一个 bash shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。</p><p>全局行为<br>GIT_EXEC_PATH<br>GIT_EDITOR</p><p>版本库位置<br>GIT_DIR<br>GIT_WORK_TREE<br>GIT_OBJECT_DIRECTORY</p><p>路径规则<br>GIT_GLOB_PATHSPECS 和 GIT_NOGLOB_PATHSPECS 控制通配符在路径规则中的默认行为。<br>GIT_LITERAL_PATHSPECS<br>GIT_ICASE_PATHSPECS</p><p>提交<br>GIT_AUTHOR_NAME, _EMAIL, _DATE<br>GIT_COMMITTER_NAME, .. , ..</p><p>网络<br>Git 使用 curl 库通过 HTTP 来完成网络操作， 所以 GIT_CURL_VERBOSE 告诉 Git 显示所有由那个库产生的消息。<br>GIT_SSL_NO_VERIFY<br>GIT_HTTP_LOW_SPEED_TIME<br>GIT_HTTP_USER_AGENT</p><p>比较和合并<br>GIT_DIFF_OPTS<br>GIT_EXTERNAL_DIFF<br>GIT_MERGE_VERBOSITY</p><p>调试<br>GIT_TRACE</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;10.1 底层命令与上层命令&lt;br&gt;10.2 Git 对象&lt;br&gt;10.3 Git 引用&lt;br&gt;10.4 包文件&lt;br&gt;10.5 引用规范&lt;br&gt;10.6 传输协议&lt;br&gt;10.7 维护与数据恢复&lt;br&gt;10.8 环境变量&lt;br&gt;10.9 总结&lt;/p&gt;
&lt;p style=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/w3/git/"/>
    
      <category term="git文档" scheme="http://yoursite.com/categories/w3/git/git%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git文档8 - 自定义 Git</title>
    <link href="http://yoursite.com/w3/git/git%E6%96%87%E6%A1%A3/git%E6%96%87%E6%A1%A3%208%20-%20%E8%87%AA%E5%AE%9A%E4%B9%89%20Git/"/>
    <id>http://yoursite.com/w3/git/git文档/git文档 8 - 自定义 Git/</id>
    <published>2020-11-15T00:00:00.000Z</published>
    <updated>2021-01-23T10:58:52.458Z</updated>
    
    <content type="html"><![CDATA[<ol start="8"><li>自定义 Git</li></ol><p>8.1 配置 Git<br>8.2 Git 属性<br>8.3 Git 钩子<br>8.4 使用强制策略的一个例子<br>8.5 总结</p><p style="text-align:right"> 2020.11.15 星期日  23：36 </p><h2 id="8-1-配置-Git"><a href="#8-1-配置-Git" class="headerlink" title="8.1 配置 Git"></a>8.1 配置 Git</h2><p><code>git config --global user.name &quot;John Doe&quot;</code><br><code>git config --global user.email johndoe@example.com</code><br><!-- Git 使用一系列配置文件来保存你自定义的行为。  -->它首先会查找系统级的 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 git config，它就会读写该文件。<br>接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。<br>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该仓库有效，它对应于向 git config 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。</p><h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">man git-config</span><br><span class="line"></span><br><span class="line">git config --global core.editor emacs</span><br><span class="line">git config --global commit.template ~/.gitmessage.txt</span><br><span class="line"></span><br><span class="line">git config --global core.pager <span class="string">''</span></span><br><span class="line">git config --global user.signingkey &lt;gpg-key-id&gt;</span><br><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line"><span class="comment"># help.autocorrect 接受一个代表十分之一秒的整数。 所以如果你把它设置为 50, Git 将在自动执行命令前给你 5 秒的时间改变主意。</span></span><br></pre></td></tr></table></figure><h3 id="Git-中的着色"><a href="#Git-中的着色" class="headerlink" title="Git 中的着色"></a>Git 中的着色</h3><p>color.ui<br>color.*</p><p><code>git config --global color.ui false</code><br><code>git config --global color.diff.meta &quot;blue black bold&quot;</code></p><h3 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h3><p>这里我们以一个不错且免费的工具 —— Perforce 图形化合并工具（P4Merge）</p><p><code>git mergetool</code>，Git 会调用 P4Merge 让你通过图形界面来解决冲突。<br>Git 预设了许多其他的合并和解决冲突的工具，无需特别的设置你就能用上它们。 要想看到它支持的工具列表，<br><code>git mergetool --tool-help</code><br><code>git config --global merge.tool kdiff3</code></p><p>$_PS: 略。编辑器亦可。</p><h3 id="格式化与多余的空白字符"><a href="#格式化与多余的空白字符" class="headerlink" title="格式化与多余的空白字符"></a>格式化与多余的空白字符</h3><p>core.autocrlf<br>core.whitespace</p><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>receive.fsckObjects<br><!-- Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。 --><br>receive.denyNonFastForwards<br><!-- 要禁用这样（变基）的强制更新推送（force-pushes）， --><br>receive.denyDeletes<br><!-- 这样会禁止通过推送删除分支和标签 — 没有用户可以这么做。 --></p><!-- $_PS: 略。过于高级 --><h2 id="8-2-Git-属性"><a href="#8-2-Git-属性" class="headerlink" title="8.2 Git 属性"></a>8.2 Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。 这些基于路径的设置项被称为 Git 属性，<br>可以在你的目录下的 .gitattributes 文件内进行设置（通常是你的项目的根目录）。<br>如果不想让这些属性文件与其它文件一同提交，你也可以在 .git/info/attributes 文件中进行设置。</p><p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3> <!-- 它本应被机器处理。因此，你想把它当成二进制文件。 --><p>识别二进制文件<br><code>*.pbxproj binary</code><br><!-- 现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 git show 或 git diff 时，Git 也不会比较或打印该文件的变化。 --></p><p>比较二进制文件<br><!-- 秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。 --><br><code>*.docx diff=word</code><br>所有匹配 .docx 模式的文件都应该使用“word”过滤器。<br>借助 docx2txt 程序将 Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。<br><code>git config diff.word.textconv docx2txt</code></p><p>还能用这个方法比较图像文件。<br>运用一个过滤器，提炼出 EXIF 信息.   …  下载并安装了 exiftool 程序，<br><code>*.png diff=exif</code><br><code>git config diff.exif.textconv exiftool</code></p><h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p><code>*.txt ident</code></p><p>不过，我们可以在检出某个文件后对其注入文本，并在再次提交前删除这些文本。 Git 属性提供了两种方法来达到这一目的。<br>一种方法是，你可以把文件所对应数据对象的 SHA-1 校验和自动注入到文件中的 <code>$Id$</code> 字段。<br>另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。 一个过滤器由“clean”和“smudge”两个子过滤器组成。<br><code>*.c filter=indent</code><br><code>git config --global filter.indent.clean indent</code><br><code>git config --global filter.indent.smudge cat</code></p><p>$_PS: 功能是强大。不用</p><h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>export-ignore<br><code>test/ export-ignore</code><br>当你运行 <code>git archive</code> 来创建项目的压缩包时，那个目录不会被包括在归档中。</p><p>export-subst<br>在导出文件进行部署的时候，你可以将 git log 的格式化和关键字展开处理应用到标记了 export-subst 属性的部分文件。<br><code>LAST_COMMIT export-subst</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'Last commit date: $Format:%cd by %aN$'</span> &gt; LAST_COMMIT</span><br><span class="line">git add LAST_COMMIT .gitattributes</span><br><span class="line">git commit -am <span class="string">'adding LAST_COMMIT file for archives'</span></span><br><span class="line"><span class="comment">## 运行 git archive 之后，归档文件的内容会被替换成这样：</span></span><br><span class="line">git archive HEAD | tar xCf ../deployment-testing -</span><br><span class="line">cat ../deployment-testing/LAST_COMMIT</span><br><span class="line">Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</span><br></pre></td></tr></table></figure></p><p>你也可以用诸如提交信息或者任意的 git notes 进行替换，并且 git log 还能做简单的字词折行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$'</span> &gt; LAST_COMMIT</span><br><span class="line">git commit -am <span class="string">'export-subst uses git log'</span>\<span class="string">''</span>s custom formatter</span><br></pre></td></tr></table></figure></p><p>由此得到的归档适用于（当前的）部署工作。然而和其他的导出归档一样，它并不适用于后继的部署工作。</p><p>$_PS: 最后一个看了个寂寞。<!-- 不是很懂 --></p><h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>database.xml merge=ours<br><code>git config --global merge.ours.driver true</code></p><p>$_PS: gitattribute先后顺序很重要！！<br><!-- [git merge合并忽略某些文件](https://blog.csdn.net/qq_39176597/article/details/89210686) --><br>&lt;!– 原来gitattribute方法生效是有条件的，跟文件的修改顺序有关系，只有先修改的往后来修改的合并的时候才会生效。<br>这里的先后是指文件的最后修改时间，不是创建的时间，如果最近修改过，那它就是最新的，<br>比如刚才的例子，我们修改了publish分支的info.plist，而没有对另外两个分支下的info.plist进行修改，那么publish分支下的info.plist就比另外两个分支新，<br>这时候合并的时候，gitattribute就会失去作用，那么该如做呢，我们在修改完publish分支后，需要再次修改另外两个分支下的plist配置文件，即使没啥可以改的，也要改(可以先改错，再改回去)这样我们publish分支下的，就会仍然保持最旧。</p><p>举例：<br>release和debug都有个配置项文件：config<br>如果合并时你要忽略config，那你要先改debug分支的config，然后再改release分支的config，<br>这样你在release分支下进行：git merge debug时就会忽略config文件。<br> –&gt;</p><h2 id="8-3-Git-钩子"><a href="#8-3-Git-钩子" class="headerlink" title="8.3 Git 钩子"></a>8.3 Git 钩子</h2><p>有两组这样的钩子：客户端的和服务器端的。 </p><h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>客户端钩子分为很多种。 下面把它们分为：提交工作流钩子、电子邮件工作流钩子和其它钩子。</p><h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p>pre-commit<br>prepare-commit-msg<br>commit-msg<br>post-commit</p><h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>你可以给电子邮件工作流设置三个客户端钩子。<br>它们都是由 git am 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。<br>如果你需要通过电子邮件接收由 git format-patch 产生的补丁，这些钩子也许用得上。</p><p>applypatch-msg<br>pre-applypatch<br>post-applypatch </p><h4 id="其它客户端钩子"><a href="#其它客户端钩子" class="headerlink" title="其它客户端钩子"></a>其它客户端钩子</h4><p>pre-rebase<br>post-rewrite<br>post-checkout<br>post-merge<br>pre-push<br>pre-auto-gc</p><h3 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h3><p>pre-receive<br>update<br>post-receive</p><p>$_PS: husky常用到的，提交前lint代码，检测提交规范；<br>$_PS: CI/CD 用到，push/tag后触发构建；PR后介绍邮件</p><h2 id="8-4-使用强制策略的一个例子"><a href="#8-4-使用强制策略的一个例子" class="headerlink" title="8.4 使用强制策略的一个例子"></a>8.4 使用强制策略的一个例子</h2><p><!-- 在本节中，你将应用前面学到的知识 -->建立这样一个 Git 工作流程：检查提交信息的格式，并且指定只能由特定用户修改项目中特定的子目录。<br>你将编写一个客户端脚本来提示开发人员他们的推送是否会被拒绝，以及一个服务器端脚本来实际执行这些策略。</p><p>$_PS: 略。没有看明白</p><p>服务器端钩子<br>  指定特殊的提交信息格式<br>  指定基于用户的访问权限控制列表（ACL）系统<br>  测试一下<br>客户端钩子</p><p>### </p><p>### </p><p>### </p><p>### </p><h2 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h2><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;自定义 Git&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;8.1 配置 Git&lt;br&gt;8.2 Git 属性&lt;br&gt;8.3 Git 钩子&lt;br&gt;8.4 使用强制策略的一个例子&lt;br&gt;8.5 总结&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/w3/git/"/>
    
      <category term="git文档" scheme="http://yoursite.com/categories/w3/git/git%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git文档7 - Git 工具</title>
    <link href="http://yoursite.com/w3/git/git%E6%96%87%E6%A1%A3/git%E6%96%87%E6%A1%A3%207%20-%20Git%20%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/w3/git/git文档/git文档 7 - Git 工具/</id>
    <published>2020-11-14T00:00:00.000Z</published>
    <updated>2021-01-23T10:58:50.124Z</updated>
    
    <content type="html"><![CDATA[<p>7.1 选择修订版本<br>7.2 交互式暂存<br>7.3 贮藏与清理<br>7.4 签署工作<br>7.5 搜索<br>7.6 重写历史<br>7.7 重置揭密<br>7.8 高级合并<br>7.9 Rerere<br>7.10 使用 Git 调试<br>7.11 子模块<br>7.12 打包<br>7.13 替换<br>7.14 凭证存储<br>7.15 总结</p><p style="text-align:right"> 2020.11，14 星期六  18：12 </p><h2 id="7-1-选择修订版本"><a href="#7-1-选择修订版本" class="headerlink" title="7.1 选择修订版本"></a>7.1 选择修订版本</h2><p>Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。</p><h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过</p><h4 id="简短的-SHA-1"><a href="#简短的-SHA-1" class="headerlink" title="简短的 SHA-1"></a>简短的 SHA-1</h4><p><code>git log; git show xx23</code></p><p>如果你在 git log 后加上 <code>--abbrev-commit</code> 参数，输出结果里就会显示简短且唯一的值；<br><!-- 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数： --><br><code>git log --abbrev-commit --pretty=oneline</code><br><!-- 通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 --></p><h4 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h4><p>引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。 </p><!-- 如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 --><p><code>git rev-parse topic1</code></p><h4 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用日志</h4><!-- 当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。 --><p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。<br>这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。<br><!-- > 如果你有 UNIX 或者 Linux 的背景，不妨将引用日志想作 Git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。 --><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;</span><br><span class="line">git log -g master # 来查看类似于 git log 输出格式的引用日志信息</span><br></pre></td></tr></table></figure></p><h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h4><!-- 祖先引用是另一种指明一个提交的方式。  -->如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。<br>你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交<br>这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）<br><br>另一种指明祖先提交的方法是 ~（波浪号）。<!--  同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。  --><p>而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。</p><h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><!-- 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题 --><h4 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h4><!-- 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。  --><p>查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。(在 experiment 分支中而不在 master 分支中的提交)<br><code>git log master..experiment</code><br><!-- 这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。  -->另一个常用的场景是查看你即将推送到远端的内容：<br><code>git log origin/master..HEAD</code></p><h4 id="多点"><a href="#多点" class="headerlink" title="多点"></a>多点</h4><!-- 双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如 -->查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 –not 来指明你不希望提交被包含其中的分支。<br>查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> refA refB ^refC</span><br><span class="line">$ git <span class="built_in">log</span> refA refB --not refC</span><br></pre></td></tr></table></figure><h4 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h4><p>这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。<br><!-- 再看看之前双点例子中的提交历史。 --> 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交<br><code>git log master...experiment</code><br><code>git log --left-right master...experiment</code><br><!-- 这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。  --></p><h2 id="7-2-交互式暂存"><a href="#7-2-交互式暂存" class="headerlink" title="7.2 交互式暂存"></a>7.2 交互式暂存</h2><!-- 帮助你 -->将文件的特定部分组合成提交。<br>运行 git add 时使用 -i 或者 –interactive 选项<!-- ，Git 将会进入一个交互式终端模式， --><!-- 可以看到这个命令以和平时非常不同的视图显示了暂存区— -->—基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。<br>在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。<br><br>$_PS: 削微操作繁琐，实际没有过<br>### 暂存与取消暂存文件<br>### 暂存补丁<br>Git 也可以暂存文件的特定部分。<br><br>可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code> 来启动同样的脚本。<br><br>更进一步地，可以使用 <code>git reset --patch</code> 命令的补丁模式来部分重置文件，<br>通过 <code>git checkout --patch</code> 命令来部分检出文件<br>与 <code>git stash save --patch</code> 命令来部分暂存文件。<br><br><br>$_PS: 补丁不接触<br><br>## 7.3 贮藏与清理<br>贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上， 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。<br>&gt; 迁移到 git stash push.  弃用了 git stash save 命令<br>### 贮藏工作<br><!-- 如果不指定一个贮藏，Git 认为指定的是最近的贮藏： --><!-- <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">git stash </span><br><span class="line">git stash push</span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line">git stash apply</span><br><span class="line">git stash apply stash@&#123;2&#125;</span><br><span class="line"></span><br><span class="line">git stash drop</span><br><span class="line">git stash drop stash@&#123;0&#125;</span><br><span class="line">``` --&gt;</span><br><span class="line">`git stash apply --index`</span><br><span class="line">文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 --index 选项来运行 git stash apply 命令，来尝试重新应用暂存的修改。 &lt;!-- 如果已经那样做了，那么你将回到原来的位置： --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 贮藏的创意性使用</span></span><br><span class="line">第一个非常流行的选项是 git stash 命令的 --keep-index 选项。 它告诉 Git 不仅要贮藏所有已暂存的内容，同时还要将它们保留在索引中。</span><br><span class="line"></span><br><span class="line">另一个经常使用贮藏来做的事情是像贮藏跟踪文件一样贮藏未跟踪文件。 </span><br><span class="line">&lt;!-- 默认情况下，git stash 只会贮藏已修改和暂存的 已跟踪 文件。 --&gt; 如果指定 --include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。 </span><br><span class="line">在贮藏中包含未跟踪的文件仍然不会包含明确 忽略 的文件。 要额外包含忽略的文件，请使用 --all 或 -a 选项。</span><br><span class="line"></span><br><span class="line">最终，如果指定了 --patch 标记，Git 不会贮藏所有修改过的任何东西， 但是会交互式地提示哪些改动想要贮藏、哪些改动需要保存在工作目录中。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从贮藏创建一个分支</span></span><br><span class="line">`git stash branch &lt;new branchname&gt; `</span><br><span class="line"><span class="comment">### 清理工作目录</span></span><br><span class="line">清理工作目录有一些常见的原因，比如说为了移除由合并或外部工具生成的东西， 或是为了运行一个干净的构建而移除之前构建的残留。</span><br><span class="line">你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 </span><br><span class="line"></span><br><span class="line">你可以使用 git clean 命令去除冗余文件或者清理工作目录。 使用 git clean -f -d 命令来移除工作目录中所有未追踪的文件以及空的子目录。</span><br><span class="line">如果只是想要看看它会做什么，可以使用 --dry-run 或 -n 选项来运行命令， 这意味着“做一次演习然后告诉你 将要 移除什么”。</span><br><span class="line"></span><br><span class="line">默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitignore 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件， 可以给 clean 命令增加一个 -x 选项。</span><br><span class="line"></span><br><span class="line">如果不知道 git clean 命令将会做什么，在将 -n 改为 -f 来真正做之前总是先用 -n 来运行它做双重检查。 </span><br><span class="line">另一个小心处理过程的方式是使用 -i 或 “interactive” 标记来运行它。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 7.4 签署工作</span></span><br><span class="line">GPG 介绍</span><br><span class="line"></span><br><span class="line">签署标签`git tag -s v1.5 -m <span class="string">'my signed 1.5 tag'</span>`</span><br><span class="line">验证标签`git tag -v &lt;tag-name&gt;`</span><br><span class="line"></span><br><span class="line">签署提交`git commit -a -S -m <span class="string">'signed commit'</span>`</span><br><span class="line">也可以给 git merge 命令附加 -S 选项来签署自己生成的合并提交。</span><br><span class="line"></span><br><span class="line">每个人必须签署</span><br><span class="line">签署标签与提交很棒，但是如果决定在正常的工作流程中使用它，你必须确保团队中的每一个人都理解如何这样做。 如果没有，你将会花费大量时间帮助其他人找出并用签名的版本重写提交。 在采用签署成为标准工作流程的一部分前，确保你完全理解 GPG 及签署带来的好处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 7.5 搜索</span></span><br><span class="line"><span class="comment">### Git Grep</span></span><br><span class="line">&lt;!-- Git 提供了一个 grep 命令，你可以很方便地从提交历史、工作目录、甚至索引中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。 --&gt;</span><br><span class="line">默认情况下 git grep 会查找你工作目录的文件。 第一种变体是，你可以传递 -n 或 --line-number 选项数来输出 Git 找到的匹配行的行号。</span><br><span class="line"></span><br><span class="line">若不想打印所有匹配的项，你可以使用 -c 或 --count 选项来让 git grep 输出概述的信息， 其中仅包括那些包含匹配字符串的文件，以及每个文件中包含了多少个匹配。</span><br><span class="line">&lt;!-- <span class="variable">$_PS</span>: 带有count，上面的信息就没有了。什么都不加，和-n 暑促信息一样 --&gt;</span><br><span class="line">如果你还关心搜索字符串的 上下文，那么可以传入 -p 或 --show-function 选项来显示每一个匹配的字符串所在的方法或函数：</span><br><span class="line"></span><br><span class="line">&lt;!-- 相比于一些常用的搜索命令比如 grep 和 ack，git grep 命令有一些的优点。 --&gt;</span><br><span class="line"><span class="comment">### Git 日志搜索</span></span><br><span class="line">&lt;!-- 或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。 --&gt;</span><br><span class="line">&lt;!-- 例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的， --&gt;我们可以使用 -S 选项 （在 Git 中俗称“鹤嘴锄（pickaxe）”选项）来显示新增和删除该字符串的提交。</span><br><span class="line">如果你希望得到更精确的结果，你可以使用 -G 选项来使用正则表达式搜索。</span><br><span class="line">`git <span class="built_in">log</span> -S ZLIB_BUF_MAX --oneline`</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 行日志搜索</span></span><br><span class="line">在 git <span class="built_in">log</span> 后加上 -L 选项即可调用，它可以展示代码中一行或者一个函数的历史。</span><br><span class="line">`git <span class="built_in">log</span> -L :git_deflate_bound:zlib.c`</span><br><span class="line">`git <span class="built_in">log</span> -L <span class="string">'/unsigned long git_deflate_bound/'</span>,/^&#125;/:zlib.c`</span><br><span class="line"></span><br><span class="line"><span class="comment">## 7.6 重写历史</span></span><br><span class="line">&gt; 在满意之前不要推送你的工作</span><br><span class="line"><span class="comment">### 修改最后一次提交</span></span><br><span class="line">`git commit --amend`</span><br><span class="line">`git commit --amend --no-edit`</span><br><span class="line">&lt;!-- 使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 修改多个提交信息</span></span><br><span class="line">通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 </span><br><span class="line">可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</span><br><span class="line">`git rebase -i HEAD~3`</span><br><span class="line">再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 **所有后裔** 都会被重写。 </span><br><span class="line">不要涉及任何已经推送到中央服务器的提交&lt;!-- ——这样做会产生一次变更的两个版本，因而使他人困惑。 --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：</span><br><span class="line">```sh</span><br><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with 'git rebase --continue')</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit's</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 </p><p>你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。<br>当保存并退出编辑器时，<code>git commit --amend</code>; <code>git rebase --continue</code></p><p>$_PS: 以下都是通过 -i 的交互操作命令来编辑。</p><h3 id="重新排序提交"><a href="#重新排序提交" class="headerlink" title="重新排序提交"></a>重新排序提交</h3><h3 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h3><p>如果，指定 “squash” 而不是 “pick” 或 “edit”</p><h3 id="拆分提交"><a href="#拆分提交" class="headerlink" title="拆分提交"></a>拆分提交</h3><h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>全局修改你的邮箱地址或从每一个提交中移除一个文件。<br>除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 </p><blockquote><p>git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 git-filter-repo<br>从每一个提交中移除一个文件<code>git filter-branch --tree-filter &#39;rm -f passwords.txt&#39; HEAD</code><br>使一个子目录做为新的根目录</p></blockquote><p>全局修改邮箱地址</p><p>$_PS: 既核武器，就慎用吧。</p><h2 id="7-7-重置揭密"><a href="#7-7-重置揭密" class="headerlink" title="7.7 重置揭密"></a>7.7 重置揭密</h2><p>2.4 Git 基础 - 撤消操作<br><!-- $_PS: [2.4 Git 基础 - 撤消操作]() --><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MCONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p></p><blockquote><p>git reset 确实是个危险的命令，如果加上了 –hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。<br>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p></blockquote><h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。<br>Index 索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。<br>Working Directory  工作目录（通常也叫 工作区）.沙盒</p><h3 id="重置的作用"><a href="#重置的作用" class="headerlink" title="重置的作用"></a>重置的作用</h3><p>让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。<br>第 1 步：移动 HEAD<br><!-- reset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的） --><br>无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset –soft，它将仅仅停在那儿。<br>现在你可以更新索引并再次运行 git commit 来完成 git commit –amend 所要做的事情了（见 修改最后一次提交）。</p><p>第 2 步：更新索引（–mixed）<br>如果指定 –mixed 选项，reset 将会在这时停止。<br>它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。</p><p>第 3 步：更新工作目录（–hard）<br>reset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 –hard 选项，它将会继续这一步。</p><p>回顾<br>reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p><p>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</p><p>使索引看起来像 HEAD （若未指定 –hard，则到此停止）</p><p>使工作目录看起来像索引</p><h4 id="通过路径来重置"><a href="#通过路径来重置" class="headerlink" title="通过路径来重置"></a>通过路径来重置</h4><p>若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。<br>这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。</p><p>现在，假如我们运行 <code>git reset file.txt</code> （这其实是 <code>git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 –soft 或 –hard），它会：<br>移动 HEAD 分支的指向 （已跳过）<br>让索引看起来像 HEAD （到此处停止）<br>所以它本质上只是将 file.txt 从 HEAD 复制到索引中。</p><p>它还有 取消暂存文件 的实际效果。<br><code>git reset eb43bf file.txt</code><br>还有一点同 git add 一样，就是 reset 命令也可以接受一个 –patch 选项来一块一块地取消暂存的内容。 </p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><!-- 压缩提交 展示了另一种方式($_PS: git rebase -i )，不过在本例中用 reset 更简单。） --><p>可以运行 <code>git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）<br>然后只需再次运行 git commit：</p><h3 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h3><p>和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p><h4 id="不带路径"><a href="#不带路径" class="headerlink" title="不带路径"></a>不带路径</h4><p>运行 <code>git checkout [branch]</code> 与运行<code>git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code>[branch]</code>，<br>首先不同于 reset –hard，checkout 对工作目录是安全的，<br>其实它还更聪明一些。<br>第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD <strong>分支的指向</strong>，而 checkout 只会移动 <strong>HEAD 自身</strong>来指向另一个分支。</p><h4 id="带路径"><a href="#带路径" class="headerlink" title="带路径"></a>带路径</h4><p>运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。<br>特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。</p><p>Commit Level<br>– | HEAD |     Index    | Workdir    | WD Safe?<br>– | – | – | – | –<br><code>reset --soft [commit]</code> | REF | NO | NO | YES<br><code>reset [commit]</code> | REF | YES | NO | YES<br><code>reset --hard [commit]</code> | REF | YES | YES | NO<br><code>checkout &lt;commit&gt;</code> | HEAD| YES| YES| YES</p><p>File Level<br>– | HEAD |     Index    | Workdir    | WD Safe?<br>– | – | – | – | –<br><code>reset [commit] &lt;paths&gt;</code> | NO | YES | NO | YES</p><p><code>checkout [commit] &lt;paths&gt;</code>| NO| YES| YES| NO</p><h2 id="7-8-高级合并"><a href="#7-8-高级合并" class="headerlink" title="7.8 高级合并"></a>7.8 高级合并</h2><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>现在我们尝试合并入我们的 whitespace 分支，因为修改了空白字符，所以合并会出现冲突。</p><h4 id="中断一次合并"><a href="#中断一次合并" class="headerlink" title="中断一次合并"></a>中断一次合并</h4><p><code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态。<br>但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p><p>如果出于某些原因你想要重来一次，也可以运行 git reset –hard HEAD 回到上一次提交的状态。 <!-- 请牢记此时任何未提交的工作都会丢失，所以请确认你不需要保留任何改动。 --></p><h4 id="忽略空白"><a href="#忽略空白" class="headerlink" title="忽略空白"></a>忽略空白</h4><!-- 默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。 如果你看到在一次合并中有大量关于空白的问题，你可以直接中止它并重做一次， 这次使用 --> <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。 第一个选项在比较行时 完全忽略 空白修改，<br>第二个选项将一个空白符与多个连续的空白字符视作等价的。<br><code>git merge -Xignore-space-change whitespace</code><br><br>#### 手动文件再合并<br><!-- 首先，我们进入到了合并冲突状态。  --><p>然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。<br>然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。</p><p>我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 git show 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。</span></span><br><span class="line">$ git show :1:hello.rb &gt; hello.common.rb</span><br><span class="line">$ git show :2:hello.rb &gt; hello.ours.rb</span><br><span class="line">$ git show :3:hello.rb &gt; hello.theirs.rb</span><br><span class="line"><span class="comment"># 如果你想要更专业一点，也可以使用 `ls-files -u` 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。</span></span><br><span class="line"><span class="comment"># :1:hello.rb 只是查找那个 blob 对象 SHA-1 值的简写。</span></span><br><span class="line"></span><br><span class="line">$ git merge-file -p \</span><br><span class="line">    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb</span><br></pre></td></tr></table></figure></p><p>实际上，这比使用 ignore-space-change 选项要更好，因为。。。</p><p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改， 你可以使用 git diff 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。 让我们看看它们。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看看合并引入了什么，可以运行 git diff --ours</span></span><br><span class="line">$ git diff --ours</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们想要查看合并的结果与他们那边有什么不同，可以运行 git diff --theirs。 </span></span><br><span class="line"><span class="comment"># 在本例及后续的例子中，我们会使用 -b 来去除空白</span></span><br><span class="line">$ git diff --theirs -b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终，你可以通过 git diff --base 来查看文件在两边是如何改动的。</span></span><br><span class="line">$ git diff --base -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这时我们可以使用 git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。</span></span><br><span class="line">$ git clean -f</span><br></pre></td></tr></table></figure></p><p>$_PS: 有编辑器插件。手动文件和检出冲突，用少/无。</p><h4 id="检出冲突"><a href="#检出冲突" class="headerlink" title="检出冲突"></a>检出冲突</h4><p>一个很有用的工具是带 –conflict 选项的 git checkout。<br>这会重新检出文件并替换合并冲突标记。 如果想要重置标记并尝试再次解决它们的话这会很有用。</p><p>可以传递给 –conflict 参数 diff3 或 merge（默认选项）。<br>如果传给它 diff3，Git 会使用一个略微不同版本的冲突标记： 不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。<br><code>$ git checkout --conflict=diff3 hello.rb</code><br><code>$ git config --global merge.conflictstyle diff3</code><br>git checkout 命令也可以使用 <code>--ours</code> 和 <code>--theirs</code> 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。</p><h4 id="合并日志"><a href="#合并日志" class="headerlink" title="合并日志"></a>合并日志</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --left-right HEAD...MERGE_HEAD</span><br><span class="line"><span class="comment"># 它会只显示任何一边接触了合并冲突文件的提交。</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --left-right --merge</span><br><span class="line"><span class="comment"># 如果你运行命令时用 -p 选项代替，你会得到所有冲突文件的区别。</span></span><br></pre></td></tr></table></figure><h4 id="组合式差异格式"><a href="#组合式差异格式" class="headerlink" title="组合式差异格式"></a>组合式差异格式</h4><p>这种叫作“组合式差异”的格式会在每一行给你两列数据。</p><p>如果我们解决冲突再次运行 git diff，我们将会看到同样的事情，但是它有一点帮助。</p><p>也可以在合并后通过 git log 来获取相同信息，查看冲突是如何解决的。<br>如果你对一个合并提交运行 git show 命令 Git 将会输出这种格式，<br>或者你也可以在 git log -p（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 –cc 选项。<br><code>$ git log --cc -p -1</code></p><h3 id="撤消合并"><a href="#撤消合并" class="headerlink" title="撤消合并"></a>撤消合并</h3><h4 id="修复引用"><a href="#修复引用" class="headerlink" title="修复引用"></a>修复引用</h4><p>最简单且最好的解决方案是移动分支到你想要它指向的地方。<!--  大多数情况下，如果你在错误的 git merge 后运行 --> <code>git reset --hard HEAD~</code>，这会重置分支指向所以它们看起来像这样：<br>这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。 查阅 <strong>变基的风险</strong>来了…</p><h4 id="还原提交"><a href="#还原提交" class="headerlink" title="还原提交"></a>还原提交</h4><h3 id="其他类型的合并"><a href="#其他类型的合并" class="headerlink" title="其他类型的合并"></a>其他类型的合并</h3><p>到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。</p><h4 id="我们的或他们的偏好"><a href="#我们的或他们的偏好" class="headerlink" title="我们的或他们的偏好"></a>我们的或他们的偏好</h4><p>如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动解决冲突，你可以传递给 merge 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。<br><code>git merge -Xours mundo</code><br>这个选项也可以传递给我们之前看到的 git merge-file 命令， 通过运行类似 git merge-file –ours 的命令来合并单个文件。</p><p>如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改， 有一个更严格的选项，它是 “ours” 合并 策略。 <!-- 这与 “ours” recursive 合并 选项 不同。 --><br><code>$ git merge -s ours mundo</code><br><!-- $_PS: 设置attribute 方式 更适合一些。但是下面例子的情况，更好一些 --></p><p>例如，假设你有一个分叉的 release 分支并且在上面做了一些你想要在未来某个时候合并回 master 的工作。<br>与此同时 master 分支上的某些 bugfix 需要向后移植回 release 分支。<br>你可以合并 bugfix 分支进入 release 分支同时也 merge -s ours 合并进入你的 master 分支 （即使那个修复已经在那儿了）这样当你之后再次合并 release 分支时，就不会有来自 bugfix 的冲突。<br><!-- $_PS: 1） 是否可解决release和master不一致，master新拉的分支merge release的时候冲突。    2）master 或者release 落后多个提交。提交到github 有冲突。  用上面到方法 -s ours，不解决merege 冲突 确定是否会有影响。（但是合进来的commit 都还是在啊。并没有用） --></p><h4 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h4><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，<br>$_PS: 是否类似github fork 工作方式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add rack_remote https://github.com/rack/rack</span><br><span class="line">$ git fetch rack_remote --no-tags</span><br><span class="line">$ git checkout -b rack_branch rack_remote/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># read-tree读取一个分支的根目录树到当前的暂存区和工作目录里。</span></span><br><span class="line"><span class="comment"># 先切回你的 master 分支，将 rack_back 分支拉取到我们项目的 master 分支中的 rack 子目录。</span></span><br><span class="line">$ git <span class="built_in">read</span>-tree --prefix=rack/ -u rack_branch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git checkout rack_branch</span><br><span class="line">$ git pull</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --squash -s recursive -Xsubtree=rack rack_branch</span><br></pre></td></tr></table></figure><p>这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块.<br>另外一个有点奇怪的地方是，当你想查看 rack 子目录和 rack_branch 分支的差异——<!--  来确定你是否需要合并它们——你不能使用普通的 diff 命令。 取而代之的是， -->你必须使用 git diff-tree 来和你的目标分支做比较：<br><code>git diff-tree -p rack_branch</code><br><code>git diff-tree -p rack_remote/master</code></p><p>$_PS: 略。没用到</p><h2 id="7-9-Rerere"><a href="#7-9-Rerere" class="headerlink" title="7.9 Rerere"></a>7.9 Rerere</h2><p>正如它的名字“重用记录的解决方案（reuse recorded resolution）”所示，它允许你让 Git 记住解决一个块冲突的方法， 这样在下一次看到相同冲突时，Git 可以为你自动地解决它。</p><p><code>git config --global rerere.enabled true</code><br>有几种情形下这个功能会非常有用。</p><p>$_PS: 略。没有那么高级的需求，还是每次merge安全些（也没有很不方便）</p><p>所以，如果做了很多次重新合并，或者想要一个主题分支始终与你的 master 分支保持最新但却不想要一大堆合并， 或者经常变基，打开 rerere 功能可以帮助你的生活变得更美好。</p><h2 id="7-10-使用-Git-调试"><a href="#7-10-使用-Git-调试" class="headerlink" title="7.10 使用 Git 调试"></a>7.10 使用 Git 调试</h2><h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p>它能显示任何文件中每行最后一次修改的提交记录。<br><code>git blame -L 69,82 Makefile</code><br><!-- 另一件比较酷的事情是 Git 不会显式地记录文件的重命名。 它会记录快照，然后在事后尝试计算出重命名的动作。 --> 这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。<br><code>git blame -C -L 141,153 GITPackUpload.m</code></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good v1.0</span><br><span class="line"></span><br><span class="line">git bisect good</span><br><span class="line">git bisect bad</span><br><span class="line"></span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>事实上，如果你有一个脚本在项目是正常的情况下返回 0，在不正常的情况下返回非 0，你可以使 git bisect 自动化这些操作。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git bisect start HEAD v1.0</span><br><span class="line">git bisect run <span class="built_in">test</span>-error.sh</span><br></pre></td></tr></table></figure></p><h2 id="7-11-子模块"><a href="#7-11-子模块" class="headerlink" title="7.11 子模块"></a>7.11 子模块</h2><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;DbConnector&quot;]</span><br><span class="line">path = DbConnector</span><br><span class="line">url = https://github.com/chaconinc/DbConnector</span><br></pre></td></tr></table></figure></p><p>$_PS: 看起来是会有一些使用难度。看情况使用（不是每个人都了）</p><h3 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line">git diff --cached DbConnector</span><br></pre></td></tr></table></figure><h3 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h3><p>当你在克隆这样的项目时，默认会包含该子模块目录，但其中还没有任何文件<br><code>git submodule init</code> 用来初始化本地配置文件，<br>而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p><p>如果给 git clone 命令传递 <code>--recurse-submodules</code> 选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。<br>如果你已经克隆了项目但忘记了 –recurse-submodules，<code>git submodule update --init --recursive。</code></p><h3 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h3><h4 id="从子模块的远端拉取上游修改"><a href="#从子模块的远端拉取上游修改" class="headerlink" title="从子模块的远端拉取上游修改"></a>从子模块的远端拉取上游修改</h4><!-- 如果想要在子模块中查看新工作， -->可以进入到目录中运行 git fetch 与 git merge，合并上游分支来更新本地代码。<br>如果你现在返回到主项目并运行 <code>git diff --submodule</code>，就会看到子模块被更新的同时获得了一个包含新添加提交的列表。<br><!-- 如果你不想每次运行 git diff 时都输入 --submodle，那么可以将 diff.submodule 设置为 “log” 来将其作为默认行为。 --><p><code>git config --global diff.submodule log</code></p><!-- 如果你不想在子目录中手动抓取与合并，那么还有种更容易的方式。 运行 git submodule update --remote，Git 将会进入子模块然后抓取并更新。 --><p><code>git submodule update --remote DbConnector</code><br>此命令默认会假定你想要更新并检出子模块仓库的 master 分支。 不过你也可以设置为想要的其他分支。<br>既可以在 .gitmodules 文件中设置 （这样其他人也可以跟踪它），也可以只在本地的 .git/config 文件中设置<br><code>git config -f .gitmodules submodule.DbConnector.branch stable</code></p><p>如果你设置了配置选项 status.submodulesummary，Git 也会显示你的子模块的更改摘要：<br><code>git config status.submodulesummary 1</code></p><h4 id="从项目远端拉取上游更改"><a href="#从项目远端拉取上游更改" class="headerlink" title="从项目远端拉取上游更改"></a>从项目远端拉取上游更改</h4><p>默认情况下，git pull 命令会递归地抓取子模块的更改，如上面第一个命令的输出所示。 然而，它<strong>不会 更新</strong> 子模块。<br><code>git submodule update --init --recursive</code></p><h4 id="在子模块上工作"><a href="#在子模块上工作" class="headerlink" title="在子模块上工作"></a>在子模块上工作</h4><h4 id="发布子模块改动"><a href="#发布子模块改动" class="headerlink" title="发布子模块改动"></a>发布子模块改动</h4><p>git push 命令接受可以设置为 “check” 或 “on-demand” 的 –recurse-submodules 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 push 操作失败。<br><code>git push --recurse-submodules=check</code><br><code>git push --recurse-submodules=on-demand</code></p><h4 id="合并子模块改动"><a href="#合并子模块改动" class="headerlink" title="合并子模块改动"></a>合并子模块改动</h4><h4 id="子模的块技巧"><a href="#子模的块技巧" class="headerlink" title="子模的块技巧"></a>子模的块技巧</h4><p>子模块遍历<br>有用的别名</p><h4 id="子模块的问题"><a href="#子模块的问题" class="headerlink" title="子模块的问题"></a>子模块的问题</h4><p>切换分支<br>从子目录切换到子模块</p><h2 id="7-12-打包"><a href="#7-12-打包" class="headerlink" title="7.12 打包"></a>7.12 打包</h2><p>bundle 命令会将 git push 命令所传输的所有内容打包成一个二进制文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。 </span></span><br><span class="line">git bundle create repo.bundle HEAD master</span><br><span class="line">git <span class="built_in">clone</span> repo.bundle repo</span><br><span class="line"><span class="comment">## 如果你在打包时没有包含 HEAD 引用，你还需要在命令后指定一个 -b master 或者其他被引入的分支， 否则 Git 不知道应该检出哪一个分支。</span></span><br><span class="line"></span><br><span class="line">git bundle create commits.bundle master ^9a466c5</span><br><span class="line"></span><br><span class="line"><span class="comment"># bundle verify 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</span></span><br><span class="line">git bundle verify ../commits.bundle</span><br><span class="line"><span class="comment"># 查看这边包里可以导入哪些分支，同样有一个命令可以列出这些顶端：</span></span><br><span class="line">git bundle list-heads ../commits.bundle</span><br><span class="line"><span class="comment"># 使用 fetch 或者 pull 命令从包中导入提交。 这里我们要从包中取出 master 分支到我们仓库中的 other-master 分支：</span></span><br><span class="line">git fetch ../commits.bundle master:other-master</span><br></pre></td></tr></table></figure></p><!-- 如果打包工具仅仅把最后两个提交打包，而不是三个，原始的仓库是无法导入这个包的， 因为这个包缺失了必要的提交记录。 --><h2 id="7-13-替换"><a href="#7-13-替换" class="headerlink" title="7.13 替换"></a>7.13 替换</h2><!-- Git 对象数据库中的对象是不可改变的， 然而 Git 提供了一种有趣的方式来用其他对象 假装 替换数据库中的 Git 对象。 --><p>replace 命令可以让你在 Git 中指定 某个对象 并告诉 Git：“每次遇到这个 Git 对象时，假装它是 其它对象”。 </p><p>我们可以将新历史推送到新项目中，当其他人克隆这个仓库时，他们仅能看到最近两次提交以及一个包含上述说明的基础提交。<br>现在我们将以想获得整个历史的人的身份来初次克隆这个项目。</p><p>$_PS: 略。不懂意义何在/多大</p><h2 id="7-14-凭证存储"><a href="#7-14-凭证存储" class="headerlink" title="7.14 凭证存储"></a>7.14 凭证存储</h2><p>Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：</p><p><code>git config --global credential.helper cache</code><br><!-- 部分辅助工具有一些选项。  --><br>“store” 模式可以接受一个 –file <code>&lt;path&gt;</code> 参数，可以自定义存放密码的文件路径（默认是 ~/.git-credentials ）。<br>“cache” 模式有 –timeout <code>&lt;seconds&gt;</code> 参数，可以设置后台进程的存活时间（默认是 “900”，也就是 15 分钟）。 </p><p><code>git config --global credential.helper &#39;store --file ~/.my-credentials&#39;</code></p><p>Git 甚至允许你配置多个辅助工具。<br><!-- 如果你在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，.gitconfig 配置文件如下： --><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store --file /mnt/thumbdrive/.git-credentials</span><br><span class="line">    helper = cache --timeout 30000</span><br></pre></td></tr></table></figure></p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><!-- $_PS: 略 --><h3 id="自定义凭证缓存"><a href="#自定义凭证缓存" class="headerlink" title="自定义凭证缓存"></a>自定义凭证缓存</h3><p>$_PS: 略。只需知道，上面的凭证存储的3+2种模式就好</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7.1 选择修订版本&lt;br&gt;7.2 交互式暂存&lt;br&gt;7.3 贮藏与清理&lt;br&gt;7.4 签署工作&lt;br&gt;7.5 搜索&lt;br&gt;7.6 重写历史&lt;br&gt;7.7 重置揭密&lt;br&gt;7.8 高级合并&lt;br&gt;7.9 Rerere&lt;br&gt;7.10 使用 Git 调试&lt;br&gt;7.11 子模
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/w3/git/"/>
    
      <category term="git文档" scheme="http://yoursite.com/categories/w3/git/git%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>小程序转化</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96/"/>
    <id>http://yoursite.com/sum/jsplus/小程序转化/</id>
    <published>2020-11-11T00:00:00.000Z</published>
    <updated>2020-12-05T11:06:06.911Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020. 星期  ： </p><p><a href="https://blog.csdn.net/weixin_43484014/article/details/100667338" target="_blank" rel="noopener">微信小程序转换 Html</a><br>wxParse: <a href="https://github.com/icindy/wxParse" target="_blank" rel="noopener">https://github.com/icindy/wxParse</a><br>  作用: 将Html/Markdown转换为微信小程序的可视化方案</p><p><a href="https://nervjs.github.io/taro/docs/taroize/" target="_blank" rel="noopener">微信小程序转 Taro</a></p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020. 星期  ： &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43484014/article/details/100667338&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Firefox实践</title>
    <link href="http://yoursite.com/sum/others/firefox%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/sum/others/firefox实践/</id>
    <published>2020-11-11T00:00:00.000Z</published>
    <updated>2020-12-05T10:27:35.962Z</updated>
    
    <content type="html"><![CDATA[<p>吃内存，mac pro 就2g<br>可重新打开. (仍然内存比chrome)<br>果断又重新开启了chrome<br>（是否和firefox版本有关系，也没有对比）</p><p>看了下除了firefox 800M；mongod的服务占用了2.71G</p><p><a href="https://support.mozilla.org/zh-CN/kb/内存消耗严重#w_reduce-the-content-process-limit" target="_blank" rel="noopener">内存消耗严重</a></p><p style="text-align:right"> 2020.11.11 星期  ： </p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><a href="https://www.oschina.net/news/115044/firefox-is-now-the-memory-hog" target="_blank" rel="noopener">用户抱怨 Firefox 占用内存比 Chrome 高</a><br><!-- $_PS: 2020.4.21 --><br>回帖中很多用户都表示遇到了同样的情况，有人表示自己用 Firefox 打开 2、3 个标签页就会出现卡顿，而 Chrome 处理同样数量的标签页却十分轻松。还有人提到以为自己的浏览器感染了恶意软件，所以才导致狂吃内存。</p><p>还有用户指出，Firefox 确实比 Chrome 更耗内存，但如果两者打开的标签页越多，内存占用的差距就越小。具体来说就是，当打开 4、5 个标签页时，Chrome 占用的内存大多数时候要比 Firefox 低；不过当打开 20~30 个标签页时，Chrome 占用的内存会比 Firefox 更多。听起来 Firefox 像是擅长“马拉松”的浏览器，Chrome 则是“短跑运动员”。</p><p>帖子评论出现了 Firefox 开发团队成员的回复，他表示确实会偶尔出现某个版本的 Firefox 比 Chrome 更耗内存的情况。原因是每隔几个月 Mozilla 开发者就会审核 Firefox 的内存使用情况并设法对其进行优化。然后添加新特性，导致内存使用量增加（通常是由于需要大量内存的新安全功能，或者由于尚未优化的原型功能），如此循环前进。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><a href="https://support.mozilla.org/zh-CN/kb/内存消耗严重#w_reduce-the-content-process-limit" target="_blank" rel="noopener">内存消耗严重</a></p><h2 id="网文"><a href="#网文" class="headerlink" title="网文"></a>网文</h2><p><a href="https://jingyan.baidu.com/article/c910274b3752da8d361d2d8a.html" target="_blank" rel="noopener">如何优化Firefox的内存占用</a></p><h2 id="关闭插件"><a href="#关闭插件" class="headerlink" title="关闭插件"></a>关闭插件</h2><p>Firefox的扩展功能可能会导致该浏览器的内存占用过高。可以根据禁用的方法来降低内存的占用。方法采用全部禁用<br>然后逐步开启的方法找出扩展占用内存较高的扩展。</p><h2 id="较大问题"><a href="#较大问题" class="headerlink" title="较大问题"></a>较大问题</h2><p>出现较大的问题或配置出现问题的时候，可以进入Firefox的安全模式来进行相关的调试。开启的方法，点击“开始”-“运行”，输入Firefox -safe-mode，进入Firefox的安全模式。</p><h2 id="about-config"><a href="#about-config" class="headerlink" title="about:config"></a>about:config</h2><p>运行Firefox浏览器，在地址栏中输入about:config，搜索查找中输入browser.cache.memory.enable，并找到该项的设置。双击这个项目更改它的值为true。<br>可能有时Firefox只会使用系统内存而不会使用快速缓存，这就需要我们手动来设置以下Firefox浏览器开启快速缓存的使用。</p><p>about:config设置：config.trim_on_minimize = true，最小化火狐时释放内存。<br>如果Firefox中没有该项，可以使用鼠标右键点击空白部分，在“新建”中选“布尔”，输入首项名称“config.trim_on_minimize”，选定其值设定为true。</p><p>about:config设置：network.dns.disableIPv6 = true，禁用IPv6.<br>当前使用IPV6的地址访问网页还是比较少的。当前IPv4还是主流，因而IPv6火狐很少会去解析，建议关闭该项。</p><p>about:config设置：dom.popup_maximum = 5，设置最大弹出窗口数。</p><p><a href="https://blog.csdn.net/xiang__liu/article/details/80615483" target="_blank" rel="noopener">Firefox内存占用过高解决方法</a><br><a href="https://blog.csdn.net/zhuyunier/article/details/79045064" target="_blank" rel="noopener">解决firefox火狐浏览器占用内存大、启动慢问题的方法</a><br>browser.cache.memory.enable，双击这个项目更改它的值为true。</p><p>2.在浏览器中右键点击后选择新建&gt;整数，输入browser.cache.memory.capacity后点击确定。</p><p>3.下一步需在此输入一个值，而这个值的大小则取决于你计算机物理内存的大小。如果你的内存大小为256MB，则输入4096，如果你的内存大小为512MB的话，则输入8192。如果你的内存是128MB甚至更低，建议升级内存。</p><p>(如果要恢复默认设置，将browser.cache.memory.capacity”的值改为-1)</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吃内存，mac pro 就2g&lt;br&gt;可重新打开. (仍然内存比chrome)&lt;br&gt;果断又重新开启了chrome&lt;br&gt;（是否和firefox版本有关系，也没有对比）&lt;/p&gt;
&lt;p&gt;看了下除了firefox 800M；mongod的服务占用了2.71G&lt;/p&gt;
&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
  </entry>
  
  <entry>
    <title>Koajs学习</title>
    <link href="http://yoursite.com/sum/ser/koa%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/sum/ser/koa学习/</id>
    <published>2020-10-26T00:00:00.000Z</published>
    <updated>2020-12-05T11:05:13.526Z</updated>
    
    <content type="html"><![CDATA[<p>koajs/koa : <a href="https://github.com/koajs/koa/wiki" target="_blank" rel="noopener">https://github.com/koajs/koa/wiki</a><br><!-- 文档： https://koajs.com/#introduction --><br>中文文档： <a href="https://www.koajs.com.cn/#introduction" target="_blank" rel="noopener">https://www.koajs.com.cn/#introduction</a></p><p style="text-align:right"> 2020.10.26 星期一  15：31 </p><h1 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h1><p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。<br>使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。<br>koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 </p><p>简介<br>应用（Application）<br>上下文（Context）<br>请求（Request）<br>响应（Response）<br>链接（Links）<br>服务器（Ecs）</p><p><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="noopener">Middleware</a></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>“kcors”: “^2.2.1”,<br>“koa”: “^2.7.0”,<br>“koa-body”: “2.3.0”,<br>“koa-helmet”: “^4.1.0”,<br>“koa-router”: “^7.2.1”,<br>“koa-session”: “^5.10.1”,<br>“koa-static”: “^4.0.1”,<br>“koa2-request”: “^1.0.1”,</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;koajs/koa : &lt;a href=&quot;https://github.com/koajs/koa/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/koajs/koa/wiki&lt;/a&gt;&lt;br&gt;&lt;!-- 文档： 
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="ser" scheme="http://yoursite.com/categories/sum/ser/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
</feed>
