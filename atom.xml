<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yalhu</title>
  
  <subtitle>yalhu&#39;s blob</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-08-20T15:19:47.276Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yalhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Css伪类和伪元素</title>
    <link href="http://yoursite.com/sum/css/css%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/sum/css/css伪类和伪元素/</id>
    <published>2023-08-17T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.276Z</updated>
    
    <content type="html"><![CDATA[<p>伪元素: <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements</a></p><p style="text-align:right"> 2023.8.17 星期四 </p><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>[前端每日知识点8：有趣的css伪元素]</p><p>1、::selection 伪元素<br>2、::first-letter伪元素<br>3、 ::first-line 伪元素</p><h3 id="marker"><a href="#marker" class="headerlink" title="::marker"></a>::marker</h3><p>[前端每日知识9：CSS伪元素之::marker]<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1、利用::marker对序号前面的小圆点进行改造： */</span></span><br><span class="line"><span class="comment">/* ### 2 可以动态变化的::marker */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">2s</span> all;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff6000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'😟'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'😊'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用 emoji 表情  */</span></span><br><span class="line"><span class="comment">/* ### 题前面的一些装饰 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'▍'</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff5722</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;伪元素: &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="css" scheme="http://yoursite.com/categories/sum/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Uri编解码</title>
    <link href="http://yoursite.com/sum/js/uri%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/sum/js/uri编解码/</id>
    <published>2023-08-17T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.311Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2023.8.17 星期四 </p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h1 id="decodeURIComponent解码数据丢失"><a href="#decodeURIComponent解码数据丢失" class="headerlink" title="decodeURIComponent解码数据丢失"></a>decodeURIComponent解码数据丢失</h1><!-- \# [decodeURIComponent解码数据丢失](http://sd.compjd.com/article/18753?shareId=47379&isHideShareButton=1) --><p>含有特殊符%25等特殊字符时decode会丢失字符。</p><p>URL中的保留和不安全字符<br>所谓保留字符就是那些在URL中具有特定意义的字符。不安全字符是指那些在URL中没有特殊含义，但在URL所在的上下文中可能具有特殊意义的字符。例如双引号(“”)</p><p>部分保留字符和不安全字符及其URL编码<br>字符 | 描述 | 用法 | 编码<br> – | -| - | -<br>; | 分号 | 保留 | %3B<br>/ | 斜线 | 保留 | %2F<br>? | 问号 | 保留 | %3F<br>: | 冒号 | 保留 | %3A<br>@ | “at”符号 | 保留 | %4O<br>= | 等号 | 保留 | %3D<br>&amp; | “和”符号 | 保留 | %26<br>&lt; | 小于号 | 不安全 | %3C<br>> | 大于号 | 不安全 | %3E<br>“ | 双引号 | 不安全 | %22<br># | 井号 | 不安全 | %23<br>% | 百分号 | 不安全 | %25<br>{ | 左大括号 | 不安全 | %7B<br>} | 右大括号 | 不安全 | %7D<br>| | 竖线 | 不安全 | %7C<br>\ | 反斜线 | 不安全 | %5C<br>^ | 加字号 | 不安全 | %5E<br>~ | 波浪 | 不安全 | %7E<br>[ | 左中括号 | 不安全 | %5B<br>] | 右中括号 | 不安全 | %5D<br>` | 反单引号 | 不安全 | %60<br>  | 空格 | 不安全 | %20</p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>例如：<br><a href="http://abaaba.com/example/file-upload/file/shendeng%25-%25bal20bablabla.pdf" target="_blank" rel="noopener">http://abaaba.com/example/file-upload/file/shendeng%25-%25bal20bablabla.pdf</a><br>这种带特殊符（%25）的链接经过解码后，数据会丢失（25消失不见了）<br>解决方案:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对查询关键字中的特殊字符进行编码</span></span><br><span class="line">dealURISafely(key) &#123;</span><br><span class="line">    <span class="keyword">const</span> unsafeStr = [&#123;</span><br><span class="line">          code: <span class="string">'%'</span>,</span><br><span class="line">          encode: <span class="string">'%25'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          code: <span class="string">'&#123;'</span>,</span><br><span class="line">          encode: <span class="string">'%7B'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          code: <span class="string">'&#125;'</span>,</span><br><span class="line">          encode: <span class="string">'%7D'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          code: <span class="string">'#'</span>,</span><br><span class="line">          encode: <span class="string">'%23'</span></span><br><span class="line">        &#125;<span class="comment">// 简单举例</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> key.replace(<span class="regexp">/[%?#&amp;=]/g</span>, ($, index, str) =&gt; &#123;  <span class="comment">// 匹配替换</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> unsafeStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.code === $) &#123;</span><br><span class="line">          <span class="keyword">return</span> item.encode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><!-- 这样就可以解决啦~ --><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>有时，浏览器也会帮我们编译字符，如：</p><p><a href="https://baidu.com/%E7%A5%9E%E7%81%AF%E4%B8%AA%E4%BA%BA%E6%A6%9C%E5%89%8D10%" target="_blank" rel="noopener">https://baidu.com/%E7%A5%9E%E7%81%AF%E4%B8%AA%E4%BA%BA%E6%A6%9C%E5%89%8D10%</a><br>用decodeURIComponent解码会报错。</p><p>﻿﻿﻿<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决方案一</span></span><br><span class="line"><span class="comment">// 简单粗暴的用tryCatch去检测，异常直接跳出！</span></span><br><span class="line">dealURISafely(uri) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(uri)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Uncaught URIerror'</span> + uri)</span><br><span class="line">        <span class="keyword">return</span> uri</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样的方法过于粗暴，没有解决问题~ 那我们可以尝试下面的更细致一些的方法~</span></span><br><span class="line"><span class="comment">// 解决方案二</span></span><br><span class="line">dealURISafely(uri, mod = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> decodeStr = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> dealUri = uri.split(<span class="regexp">/(%(?:d0|d1)%.&#123;2&#125;)/</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dealUri.length; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> decoded = <span class="built_in">decodeURIComponent</span>(dealUri[i]);</span><br><span class="line">      decodeStr += decoded;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mod) &#123;</span><br><span class="line">        <span class="keyword">const</span> replaced = dealUri[i].replace(<span class="regexp">/%(?!\d+)/g</span>, <span class="string">'%25'</span>);</span><br><span class="line">        decodeStr += replaced;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeStr += dealUri[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> decodeStr;</span><br><span class="line">&#125; <span class="comment">//  "https://baidu.com/神灯个人榜前10% "</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2023.8.17 星期四 &lt;/p&gt;

&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h1 id=&quot;decodeURIComponen
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/sum/js/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>React 状态管理工具如何选</title>
    <link href="http://yoursite.com/sum/jsplus/react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%A6%82%E4%BD%95%E9%80%89/"/>
    <id>http://yoursite.com/sum/jsplus/react状态管理工具如何选/</id>
    <published>2023-08-14T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.357Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2023.8.14 星期一 </p><!-- [React 状态管理工具如何选](http://xingyun.compjd.com/shendeng/article/detail/10000?forumId=29&jdme_router=jdme%3A%2F%2Fweb%2F202206081297%3Furl%3Dhttp%3A%2F%2Fsd.jd.com%2Farticle%2F10000) @dengwen 2023-01-11--><h2 id="什么是状态管理"><a href="#什么是状态管理" class="headerlink" title="什么是状态管理?"></a>什么是状态管理?</h2><p>“状态”是描述应用程序当前行为的任何数据。这可能包括诸如“从服务器获取的对象列表”、“当前选择的项目”、“当前登录用户的名称”和“此模式是否打开？”等值。</p><p>众所周知，我们在研发一个复杂应用的过程中，一套好的状态管理方案是必不可少的，既能提升研发效率，又能降低研发维护成本，那么状态管理方案那么多，它们有什么不同，我们又该如何选择适合当前应用的方案呢？</p><p>本期将主要就 react 的常用状态管理方案进行对比分析，希望对各位看客有帮助。</p><h2 id="React-状态管理方案"><a href="#React-状态管理方案" class="headerlink" title="React 状态管理方案"></a>React 状态管理方案</h2><p>### 方案介绍<br>hooks context<br>react-redux<br>mobx<br>zustand<br>jotai<br>recoil<br>valtio</p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table><thead><tr><th>框架</th><th>原理</th><th>优点</th><th>缺点  </th></tr></thead><tbody><tr><td>hooks context</td><td>基于 react hook，开发者可实现内/外部存储</td><td><li>1. 使用简单 </li><li>2. 不需要引用第三方库，体积最小 </li><li>3. 支持存储全局状态，但在复杂应用中不推荐 </li><li>4. 不依赖 react 上下文，可在组件外调用（外部存储的条件下）</li></td><td><li>1. context value发生变化时，所有用到这个context的组件都会被重新渲染，基于 content 维护的模块越多，影响范围越大。 </li><li>2.依赖 Context Provider 包裹你的应用程序，修改 store 无法在应用最顶层(App.tsx 层级)触发渲染 </li><li>3. 受ui框架约束(react) </li><li>4. 依赖hooks调用 </li></td></tr><tr><td>react-redux</td><td>Flux思想，发布订阅模式，遵从函数式编程，外部存储</td><td><li>1. 不依赖 react 上下文，可在组件外调用 </li><li>2. 支持存储全局状态 </li><li>3.不受ui框架约束</li></td><td><li>1. 心智模型需要一些时间来理解，特别是当你不熟悉函数式编程的时候 </li><li>2. 依赖 Context Provider 包裹你的应用程序，修改 store 无法在应用最顶层(App.tsx 层级)触发渲染</li></td></tr><tr><td>mobx</td><td>观察者模式 + 数据截止，外部存储</td><td><li>1. 使用简单 </li><li>2. 不依赖 react 上下文，可在组件外调用 </li><li>3. 支持存储全局状态 </li><li>4.不受ui框架约束</li></td><td><li>1.可变状态模型，某些情况下可能影响调试 </li><li>2. 除了体积相对较大之外，笔者目前未感觉到较为明显的缺点，3.99M</li></td></tr><tr><td>zustand</td><td>Flux思想，观察者模式，外部存储</td><td><li>1. 轻量，使用简单 </li><li>2. 不依赖 react 上下文，可在组件外调用 </li><li>3. 支持存储全局状态</li></td><td><li>1.框架本身不支持 computed 属性，但可基于 middleware 机制通过少量代码间接实现 computed ，或基于第三方库 zustand-computed 实现 </li><li>2.受ui框架约束(react / vue)</li></td></tr><tr><td>jotai</td><td>基于 react hook，内部存储</td><td><li>1. 使用简单 </li><li>2. 组件颗粒度较细的情况下，jotai性能更好 </li><li>3.支持存储全局状态，但在复杂应用中不推荐</li></td><td><li>1. 依赖 react 上下文， 无法组件外调用，相对而言, zustand 在 react 环境外及全局可以更好地工作 </li><li>2. 受ui框架约束(react)</li></td></tr><tr><td>recoil</td><td>进阶版 jotai,基于 react hook + provider context，内部存储</td><td>相对于 jotai而言，会更重一些，但思想基本不变，拥有一些 jotai 未支持的特性及 api，如： <li>1.监听 store 变化 </li><li>2. 针对 atom 的操作拥有更多的 api，编程上拥有更多的可能性，更加有趣</li></td><td>拥有 jotai 所有的缺点，且相对于 jotai 而言: <li>1.使用 recoil 需要 &lt; RecoilRoot &gt; 包裹应用程序 </li><li>2. 编写 selector 会复杂一些</li></td></tr><tr><td>valtio</td><td>基于数据劫持，外部存储</td><td><li>1. 使用简单，类mobx（类vue）的编程体验 </li><li>2.支持存储全局状态 </li><li>3.不依赖 react 上下文，可在组件外调用 </li><li>4. 不受ui框架约束</li></td><td><li>1.可变状态模型，某些情况下可能影响调试 </li><li>2.目前笔者没发现其它特别大的缺点，个人猜测之所以star相对zustand较少，是因为 valtio 的数据双向绑定思想与 react 存在冲突。</li></td></tr></tbody></table><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><h4 id="hooks-context"><a href="#hooks-context" class="headerlink" title="hooks context"></a>hooks context</h4><p><a href="https://github.com/AwesomeDevin/blog/issues/79" target="_blank" rel="noopener">1.使用 react hooks + context 进行方便快捷的状态管理</a><br><a href="https://github.com/AwesomeDevin/blog/issues/45" target="_blank" rel="noopener">2.使用 react hooks + context 构建 redux 进行状态管理</a></p><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a><a href="https://codesandbox.io/s/github/reduxjs/redux-essentials-counter-example/tree/master/?from-embed=&amp;file=/src/features/counter/counterSlice.js" target="_blank" rel="noopener">react-redux</a></h4><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span></span><br><span class="line"><span class="keyword">import</span> &#123; makeAutoObservable &#125; <span class="keyword">from</span> <span class="string">"mobx"</span></span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态及相关事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    secondsPassed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        makeAutoObservable(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    increase() &#123;</span><br><span class="line">        <span class="keyword">this</span>.secondsPassed += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reset() &#123;</span><br><span class="line">        <span class="keyword">this</span>.secondsPassed = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myTimer = <span class="keyword">new</span> Timer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建可观擦组件</span></span><br><span class="line"><span class="keyword">const</span> TimerView = observer(<span class="function">(<span class="params">&#123; timer &#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; timer.reset()&#125;&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;TimerView timer=&#123;myTimer&#125; /</span>&gt;, <span class="built_in">document</span>.body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新事件</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    myTimer.increase()</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="zustand"><a href="#zustand" class="headerlink" title="zustand"></a>zustand</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">'zustand'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态及相关事件</span></span><br><span class="line"><span class="keyword">const</span> useBearStore = create(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;</span><br><span class="line">  bears: <span class="number">0</span>,</span><br><span class="line">  increasePopulation: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">set</span>((state) =&gt; (&#123; bears: state.bears + <span class="number">1</span> &#125;)),</span><br><span class="line">  removeAllBears: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">set</span>(&#123; bears: <span class="number">0</span> &#125;),</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染视图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BearCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bears = useBearStore(<span class="function">(<span class="params">state</span>) =&gt;</span> state.bears)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;bears&#125; around here ...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controls</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> increasePopulation = useBearStore(<span class="function">(<span class="params">state</span>) =&gt;</span> state.increasePopulation)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increasePopulation&#125;</span>&gt;</span>one up<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jotai"><a href="#jotai" class="headerlink" title="jotai"></a>jotai</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; atom &#125; <span class="keyword">from</span> <span class="string">'jotai'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countAtom = atom(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 状态及相关事件</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useAtom(countAtom)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125;&gt;one up&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>h1&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="recoil"><a href="#recoil" class="headerlink" title="recoil"></a>recoil</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeState = atom(&#123;  </span><br><span class="line">  key: <span class="string">'fontSizeState'</span>,  </span><br><span class="line">  <span class="keyword">default</span>: <span class="number">14</span>,  </span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FontButton</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">    &lt;button onClick=&#123;() =&gt; setFontSize(<span class="function">(<span class="params">size</span>) =&gt;</span> size + <span class="number">1</span>)&#125; style=&#123;&#123;fontSize&#125;&#125;&gt;  </span><br><span class="line">      Click to Enlarge  </span><br><span class="line">    &lt;<span class="regexp">/button&gt;  </span></span><br><span class="line"><span class="regexp">  );  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="valtio"><a href="#valtio" class="headerlink" title="valtio"></a>valtio</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; proxy, useSnapshot &#125; <span class="keyword">from</span> <span class="string">'valtio'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = proxy(&#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'hello'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> snap = useSnapshot(state)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;snap.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; ++state.count&#125;&gt;+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="相关建议"><a href="#相关建议" class="headerlink" title="相关建议"></a>相关建议</h2><ol><li>如果你需要useState+useContext的替代品，那么jotai非常适合，即原子化的组件状态管理或少量组件间状态共享。</li><li>如果你习惯了redux或喜欢react的自然不可变更新，那么zustand将非常适合。</li><li>如果你习惯了vue/ slute /mobx，或者是JS/React的新手，valtio的可变模型将很适合。</li><li>如果你在使用 zustand(redux/等不可变数据模型) + immer，建议改用valtio(mobx)</li><li>mobx有actions概念，而valtio概念更为简单（自由），如果你希望工程更为规范，可以使用mobx，如果是希望工程更为自由便捷，可以使用valtio</li><li>recoil与jotai的编程思想类似，但提供了更多的 api 与 特性，针对原子状态拥有更多的可操作性，同时包体积也更大，但由于recoil功能庞大，其使用相对于jotai会繁琐一些,如果你希望工程轻巧便捷可以选用jotai，如果你想试试原子状态更多的可能性，那么试试recoil吧。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2023.8.14 星期一 &lt;/p&gt;


&lt;!-- 
[React 状态管理工具如何选](http://xingyun.compjd.com/shendeng/article/detai
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="react.js" scheme="http://yoursite.com/tags/react-js/"/>
    
  </entry>
  
  <entry>
    <title>浏览器插件获利</title>
    <link href="http://yoursite.com/sum/others/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E8%8E%B7%E5%88%A9/"/>
    <id>http://yoursite.com/sum/others/浏览器插件获利/</id>
    <published>2023-06-16T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.406Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2023.6.16 星期五 </p><h2 id="付费插件免除"><a href="#付费插件免除" class="headerlink" title="付费插件免除"></a>付费插件免除</h2><p><a href="https://www.xinhuatone.com/shouji/202009/28375.html" target="_blank" rel="noopener">Google Chrome浏览器的付费扩展程序已被删除</a></p><blockquote><p>Chrome Web Store付款系统现已弃用，并将在未来几个月内关闭。还有很多其他方式可以通过扩展获利，如果您当前正在使用Chrome Web Store付款，则需要切换到另一种方式。</p></blockquote><p># X-1 <a href="https://w2solo.com/topics/88" target="_blank" rel="noopener">怎么利用 Chrome 插件赚钱 (How to monetize your Chrome extension，谷歌开发者大会分享)</a></p><h2 id="Chrome插件盈利机制和类型调研"><a href="#Chrome插件盈利机制和类型调研" class="headerlink" title="Chrome插件盈利机制和类型调研"></a>Chrome插件盈利机制和类型调研</h2><ol><li>免费个⼈插件—这种类型的 Chrome 插件应该占⼤多数；</li><li>免费企业插件—这类插件为某些公司的产品为 Chrome ⽤户特意开发的插件版本， 插件本身并不是其盈利⽬标，更⼤的意义给其⽤户带来便利或者通过 Chrome 这个 平台吸引更多的⽤户，这类插件⽐如 Wunderlist，Dropbox 等等；</li><li>Freemium 插件—基本功能免费，⾼级功能收费，这类插件和第⼆类有⼀定的重 合，其插件数量也不少。典型的列⼦就是 Grammarly，Pocket ；</li><li>Premium 插件—免费试⽤，过期之后需要订阅。⽐如 Anyshortcut；</li><li>收费插件—这类插件下载安装的时候就需要收费（⾮常少），⽐如 lingua.ly</li><li>售卖⼴告、⽤户数据盈利插件—不举例；</li><li>接受开源捐助—⽐如 眼不⻅⼼不烦，Web Maker；</li><li>被收购插件—⽐如 Github 树形⽬录扩展 InSight.io；</li></ol><h2 id="Monetize-with-SaaS-Overview"><a href="#Monetize-with-SaaS-Overview" class="headerlink" title="Monetize with SaaS - Overview"></a>Monetize with SaaS - Overview</h2><p>解决某个⽤户痛点—从⼩众市场⼊⼿，找到⽤户痛点，也许⼀个就够了；<br>良好的⽤户体验—产品体验、视觉设计、社交形象等；<br>集成⽀付⽅案—在国内⽀付是⼀个⽼⼤难的问题，想办法搞定它！//paybase.cn<br>持续为⽤户提供价值—⽤户能够接受 SaaS 制的核⼼价值所在;<br>持续 marketing—持续寻找更多你的⽬标⽤户！最难！</p><h3 id="Monetize-with-SaaS-Strategy-（策略）"><a href="#Monetize-with-SaaS-Strategy-（策略）" class="headerlink" title="Monetize with SaaS - Strategy （策略）"></a>Monetize with SaaS - Strategy （策略）</h3><ol><li>⽤⼼做好产品</li><li>⼀个好的官⽹和 pricing ⻚</li><li>良好的新⼿引导</li><li>流畅的⽀付体验</li><li>恰到好处的邮件运营</li><li>必要的社区运营<!-- END#X-1 --></li></ol><h2 id="付费-chrome-插件案例"><a href="#付费-chrome-插件案例" class="headerlink" title="付费 chrome 插件案例"></a>付费 chrome 插件案例</h2><p># X-2 <a href="https://www.v2ex.com/t/747058" target="_blank" rel="noopener">一个付费 chrome 插件的一生</a><br>在这个插件的鼓舞下，我后来又做了很多开源项目，不过遗憾的是到目前为止那些花费我大量时间的其他 side project 没有一个的收入超过这个“周末产品”😅</p><p>两点感想</p><ul><li>用户是愿意付费的，如果产品真正帮助他们解决了问题</li><li>产品的成败与你付出的工作量没有关系</li></ul><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p># X-11 <a href="https://liujinkai.com/2020/02/13/how-to-monetise-a-chrome-extension/" target="_blank" rel="noopener">Chrome浏览器扩展插件的8种获利方式</a><br>1、帮助用户屏蔽广告 - AdblockPlus<br>2、第三方 — Yieldkit<br>3、CPU占用—CoinHive<br>4、免费和付费<br>5、广告<br>6、出售用户数据<br>7、将你的用户作为僵尸网络出售<br>8、捐赠</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2023.6.16 星期五 &lt;/p&gt;

&lt;h2 id=&quot;付费插件免除&quot;&gt;&lt;a href=&quot;#付费插件免除&quot; class=&quot;headerlink&quot; title=&quot;付费插件免除&quot;&gt;&lt;/a&gt;付费插件免除&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
      <category term="chrome" scheme="http://yoursite.com/tags/chrome/"/>
    
      <category term="browser" scheme="http://yoursite.com/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>React源码学习</title>
    <link href="http://yoursite.com/sum/jsplus/react%E5%8E%9F%E7%90%86/react%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/sum/jsplus/react原理/react源码学习/</id>
    <published>2023-05-04T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.355Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2023.5.4 星期一 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2023.5.4 星期一 &lt;/p&gt;


      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
      <category term="react原理" scheme="http://yoursite.com/categories/sum/jsplus/react%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Pnpm使用记录</title>
    <link href="http://yoursite.com/sum/jsplus/pnpm%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/sum/jsplus/pnpm使用记录/</id>
    <published>2023-04-12T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.342Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2023.4.12 星期三</p><h1 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h1><p><code>ERROR: This version of pnpm requires at least Node.js v16.14</code><br>解决：npm install pnpm@7<br>原因：node14不支持最新的pnpm@8<br>pnpm安装#compatibility: <a href="https://pnpm.io/installation#compatibility" target="_blank" rel="noopener">https://pnpm.io/installation#compatibility</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2023.4.12 星期三&lt;/p&gt;


&lt;h1 id=&quot;issues&quot;&gt;&lt;a href=&quot;#issues&quot; class=&quot;headerlink&quot; title=&quot;issues&quot;&gt;&lt;/a&gt;issues&lt;/h1&gt;&lt;p&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="react.js" scheme="http://yoursite.com/tags/react-js/"/>
    
  </entry>
  
  <entry>
    <title>React代码复用-组件</title>
    <link href="http://yoursite.com/sum/jsplus/react%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8-%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/sum/jsplus/react代码复用-组件/</id>
    <published>2023-03-08T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.343Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个功能：统一处理页面接口数据加载；并且渲染不同状态的ui。<br>    或者是子组件；也可以自定义loading/skeleton，error。<br>最后：高阶组件-render props<br><!-- 实现上参考：先1 -》 4 -》5。 最后发现是2的实践-页面复用 --></p><!-- 1: 组件封装方法 - 2: 介绍高阶组件3： 介绍hooks4: 封装请求 - DataBoundary5: render-props - display name： 文档有介绍 --><p>react文档-高阶组件： <a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/higher-order-components.html</a></p><p style="text-align:right">2023.3.8 星期三</p><h1 id="1-React中封装组件的一些方法"><a href="#1-React中封装组件的一些方法" class="headerlink" title="1 React中封装组件的一些方法"></a>1 React中封装组件的一些方法</h1><p># 1 SS <a href="https://www.shymean.com/article/React中封装组件的一些方法" target="_blank" rel="noopener">React中封装组件的一些方法</a></p><h2 id="1-extends-正向继承"><a href="#1-extends-正向继承" class="headerlink" title="1. extends 正向继承"></a>1. extends 正向继承</h2><p>对于类组件而言，可以通过extends继承某个父类，从而获得一些公共的能力<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogPage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    trackLog() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"trackLog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page1</span> <span class="keyword">extends</span> <span class="title">LogPage</span> </span>&#123;</span><br><span class="line">    onBtnClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">        <span class="keyword">this</span>.trackLog();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onBtnClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借助OOP的思想，可以通过封装、继承和多态来实现数据的隔离和功能的复用。</p><h2 id="2-HOC"><a href="#2-HOC" class="headerlink" title="2. HOC"></a>2. HOC</h2><h3 id="2-1-劫持props"><a href="#2-1-劫持props" class="headerlink" title="2.1. 劫持props"></a>2.1. 劫持props</h3><p>高阶组件会返回一个新的组件，这个组件会拦截传递过来的props，这样就可以做一些特殊的处理，或者仅仅是添加一些通用的props<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> commonProps = &#123; <span class="attr">x</span>: <span class="number">1</span>, commonMethod1, commonMethod2  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...commonProps</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- 看起来像组件注入一些通用的props就更轻松了。 --><h3 id="2-2-反向继承"><a href="#2-2-反向继承" class="headerlink" title="2.2. 反向继承"></a>2.2. 反向继承</h3><p>高阶组件的核心思想是返回一个新的组件，如果是类组件，甚至可以通过继承的方式劫持组件原本的生命周期函数，扩展新的功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">Comp</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">SubComp</span> <span class="keyword">extends</span> <span class="title">Comp</span> </span>&#123;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="comment">// 处理新的生命周期方法，可以按需要决定是否调用supder.componentDidMount</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// 使用原始的render</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-3-控制渲染"><a href="#2-3-控制渲染" class="headerlink" title="2.3. 控制渲染"></a>2.3. 控制渲染</h3><p>比如我们需要判断某个页面是否需要登录，一种做法是直接在页面组件逻辑中编写判断，如果存在多个这种的页面，就变得重复了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (Comp) =&gt; <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = checkLogin()</span><br><span class="line">  <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> '<span class="attr">login</span>' &#125;&#125;/&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.4. HOC的缺点<br>劫持Props是HOC最常用的功能之一，但这也是它的缺点：层级的嵌套和状态的透传。</p><p>对于HOC本身而言，传递给他的props是不需要关心的，他只是负责将props透传下去。这就要求对于一些特殊的prop如ref等，需要额外使用forwardRef才能够满足需求。</p><p>此外，我认为这也导致组件的props来源变得不清晰。最后组件经过多个HOC的装饰之后，我们就很难区分某个props注入的数据到底是哪里来的了</p><h2 id="3-Render-Props"><a href="#3-Render-Props" class="headerlink" title="3. Render Props"></a>3. Render Props</h2><p>3.1. prop传递ReactElement<br>React组件默认的prop: children可以实现default slot的功能<br>3.2. prop传递函数<br>但这种直接传递ReactElement也存在一些问题，那就是这些节点都是在父元素定义的。</p><p>如果能够根据组件内部的一些数据来动态渲染要展示的元素，这样就会更加灵活了。换言之，我们需要实现在组件内部动态构建渲染元素。</p><p>最简单的解决办法就是传递一个函数，由组件内部通过传参的形式通过函数动态生成需要渲染的元素<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Baz = <span class="function">(<span class="params">&#123; renderHead &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;renderHead(count)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;Baz </span><br><span class="line">  renderHead=&#123;(count) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>count is &#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">&gt;&lt;<span class="regexp">/Baz&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过函数的方式，可以在不改动组件内部实现的前提下，利用组件的数据实现UI分发和逻辑复用，类似于Vue的插槽作用域，也跟JavaScript中常见的回调函数作用一致。</p><p>React官方把这种技术称作Render Props:</p><blockquote><p>Render Props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p></blockquote><p>Render Props有下面几个特点</p><ul><li>也是一个prop，用于父子组件之间传递数据</li><li>他的值是一个函数，其参数由子组件在合适的时候传入</li><li>通常用来render(渲染)某个元素或组件</li></ul><p>再举一个更常用的例子，渲染列表组件，</p><p>3.3. prop传递组件<br>上面提到Render props是值为函数的prop，这个函数返回的是ReactElement。那不就是一个函数组件吗？既然如此，是不是也可以直接传递组件呢？答案是肯定的。</p><p>3.4. Render Props存在的问题<br>Render Props可以有效地以松散耦合的方式设计组件，但由于其本质是一个函数，也会存在回调嵌套过深的问题：当返回的节点也需要传入render props时，就会发生多层嵌套。</p><p>一种解决办法是使用<a href="https://github.com/pedronauck/react-adopt" target="_blank" rel="noopener">react-adopt</a>，它提供了组合多个render props返回结果的功能。</p><h2 id="4-Hooks"><a href="#4-Hooks" class="headerlink" title="4. Hooks"></a>4. Hooks</h2><h3 id="4-1-Hooks解决的问题"><a href="#4-1-Hooks解决的问题" class="headerlink" title="4.1. Hooks解决的问题"></a>4.1. Hooks解决的问题</h3><p>React中组件分为了函数组件和Class组件，函数组件是无状态的，在Hooks之前，只能通过props控制函数组件的数据，如果希望实现一个带状态的组件，则需要通过Class组件的instace来维护。</p><p>Class组件主要有几个问题</p><ul><li>逻辑分散，相互关连的逻辑分散在各个生命周期函数；每个生命周期函数又塞满了各不相同的逻辑</li><li>逻辑复用需要通过高阶组件HOC或者Render Props来处理，<br>不论是HOC还是Render Props，都需要重新组织组件结构，很容易形成组件嵌套，代码阅读性和可维护性都会变差。</li></ul><p>因此需要一种扁平化的逻辑复用的方式，因此Hooks出现了。其优点有</p><ul><li>扁平化的逻辑复用，在无需修改组件结构的情况下复用状态逻辑</li><li>将相互关联的部分放在一起，互不相关的地方相互隔离</li><li>函数式编程</li></ul><p>## 5. 小结<br>本文主要总结了几种封装React组件的方式，包括正向继承、HOC、Render Props、 Hooks等方式，每种方式都有各自的优缺点。恰好最近参与了新的React项目，可以多尝试一下这些方法。<br><!-- END#1 --></p><h1 id="2-高阶组件-HOC-的入门及实践"><a href="#2-高阶组件-HOC-的入门及实践" class="headerlink" title="2 高阶组件(HOC)的入门及实践"></a>2 高阶组件(HOC)的入门及实践</h1><p># 2 <a href="https://juejin.cn/post/6844904050236850184#heading-11" target="_blank" rel="noopener">React高阶组件(HOC)的入门及实践</a><br>## 使用高阶组件的原因（为什么❓）<br>关于高阶组件能解决的问题可以简单概括成以下三个方面：<br>1) 抽取重复代码，实现组件复用，常见场景：页面复用。<br>1) 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。<br>1) 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。</p><h2 id="高阶组件的实现（怎么做❓）"><a href="#高阶组件的实现（怎么做❓）" class="headerlink" title="高阶组件的实现（怎么做❓）"></a>高阶组件的实现（怎么做❓）</h2><p>通常情况下，实现高阶组件的方式有以下两种:</p><ul><li>属性代理(Props Proxy)<ul><li>返回一个无状态（stateless）的函数组件</li><li>返回一个 class 组件</li></ul></li><li>反向继承(Inheritance Inversion)</li></ul><p>高阶组件实现方式的差异性决定了它们各自的应用场景：一个 React 组件包含了 props、state、ref、生命周期方法、static方法和React 元素树几个重要部分，所以我将从以下几个方面对比两</p><h3 id="属性代理-Props-Proxy"><a href="#属性代理-Props-Proxy" class="headerlink" title="属性代理(Props Proxy)"></a>属性代理(Props Proxy)</h3><ul><li>属性代理是最常见的实现方式，它本质上是使用组合的方式，通过将组件包装在容器组件中实现功能。</li><li>属性代理方式实现的高阶组件和原组件的生命周期关系完全是React父子组件的生命周期关系，所以该方式实现的高阶组件会影响原组件某些生命周期等方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个无状态的函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newProps = &#123; <span class="attr">type</span>: <span class="string">'HOC'</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个有状态的 class 组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123; <span class="attr">type</span>: <span class="string">'HOC'</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125;/&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>#### 操作 props<br>#### 抽象 state<br>#### 获取 refs 引用<br>#### 获取原组件的 static 方法<br>#### 通过 props 实现条件渲染<br>#### 用其他元素包裹传入的组件<br>我们可以通过类似下面的方式将原组件包裹起来，从而实现布局或者是样式的目的：</p><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>反向继承指的是使用一个函数接受一个组件作为参数传入，并返回一个继承了该传入组件的类组件，且在返回组件的 render() 方法中返回 super.render() 方法，最简单的实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#### 劫持原组件生命周期方法<br>#### 读取/操作原组件的 state<br>#### 渲染劫持</p><h3 id="属性代理和反向继承的对比"><a href="#属性代理和反向继承的对比" class="headerlink" title="属性代理和反向继承的对比"></a>属性代理和反向继承的对比</h3><p>## 具体实践<br>### 页面复用<br>### 权限控制<br>### 组件渲染性能追踪<br>## 扩展阅读（Q &amp; A）<br>### Hook 会替代高阶组件吗？<br><!-- END#2 --></p><h1 id="3-使用React-hooks"><a href="#3-使用React-hooks" class="headerlink" title="3 使用React hooks"></a>3 使用React hooks</h1><p># 3 SS <a href="https://developer.aliyun.com/article/900776#slide-52" target="_blank" rel="noopener">使用React hooks，些许又多了不少摸鱼时间</a><br>一、📻概述<br>1、关于React Hooks<br>• React Hooks 是一个可选功能，通常用 class 组件 来和它做比较；<br>• 100% 向后兼容，没有破坏性改动；<br>• 不会取代 class 组件，尚无计划要移除 class 组件。</p><p>2、认识React Hooks<br>（1）回顾React函数式组件<br>（2）函数组件的特点</p><ul><li>没有组件实例；</li><li>没有生命周期；</li><li>没有 state 和 setState ，只能接收 props 。<br>（3）class组件的问题<br>上面我们说到了函数组件是一个纯函数，只能接收 props ，没有任何其他功能。而 class 组件拥有以上功能，但是呢，class 组件会存在以下问题：</li><li>大型组件很难拆分和重构，很难测试（即 class 不易拆分）；</li><li>相同业务逻辑，分散到各个方法中，逻辑混乱；</li><li>复用逻辑变得复杂，如 Mixins 、 HOC 、 Render Props 。</li></ul><p>因此，有了以上问题的出现，也就有了 React Hooks 。<br>（4）React 组件<br>• React 组件更易于用函数来表达：<br>• React 提倡函数式编程，即 view=fn(props) ；<br>• 函数更灵活，更易拆分，更易测试；<br>• 但函数组件太简单，需要增强能力 ——因此，有了 React Hooks 。<br>二、🪕几种 Hooks</p><h2 id="三、⌨️React-Hooks组件逻辑复用"><a href="#三、⌨️React-Hooks组件逻辑复用" class="headerlink" title="三、⌨️React-Hooks组件逻辑复用"></a>三、⌨️React-Hooks组件逻辑复用</h2><p>1、class组件的逻辑复用<br>class 组件有三种逻辑复用形式。分别是：</p><ul><li>Mixin</li><li>高阶组件 HOC</li><li>Render Prop</li></ul><p>下面说下它们三者各自的缺点。<br>（1）Mixin</p><ul><li>变量作用域来源不清</li><li>属性重名</li><li>mixins 引入过多会导致顺序冲突<br>（2）高阶组件 HOC</li><li>组件层级嵌套过多，不易渲染，不易调试</li><li>HOC 会劫持 props ，必须严格规范，容易出现疏漏<br>（3）Render Prop</li><li>学习成本高，不易理解</li><li>只能传递纯函数，而默认情况下纯函数功能有限</li></ul><p>了解了三种 class 组件的缺点之后，现在，我们来看下如何使用 Hooks 做组件逻辑复用。</p><h3 id="2、使用-Hooks-做组件逻辑复用"><a href="#2、使用-Hooks-做组件逻辑复用" class="headerlink" title="2、使用 Hooks 做组件逻辑复用"></a>2、使用 Hooks 做组件逻辑复用</h3><p>使用 hooks 来使得组件可以进行逻辑复用的本质是：自定义 hooks 。下面我们用一个例子来展示。<br>useMousePosition</p><!-- END#3 --><h1 id="4-React-Hooks：发请求这件小事"><a href="#4-React-Hooks：发请求这件小事" class="headerlink" title="4 React Hooks：发请求这件小事"></a>4 React Hooks：发请求这件小事</h1><p># 4 <a href="https://zhuanlan.zhihu.com/p/72596932" target="_blank" rel="noopener">React Hooks 第二期：发请求这件小事</a><br>## useData ?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useData</span>(<span class="params">dataLoader</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currentDataLoader = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    currentDataGetter.current = dataGetter;</span><br><span class="line"></span><br><span class="line">    dataLoader().then(<span class="function">(<span class="params">responseData</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有更新的请求，放弃之前的</span></span><br><span class="line">      <span class="keyword">if</span> (currentDataGetter.current !== dataGetter) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setData(responseData);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [dataLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>## 处理异步状态<br>以上的 useData 只能解决关于数据获取的那一部分问题，为了处理我们得到的几个状态，不免需要写出这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loading &amp;&amp; data == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Spin</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Exception</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;Spin loading=&#123;loading&#125;&gt;</span><br><span class="line">    &#123;renderMovieList(movieListData)&#125;</span><br><span class="line">    &lt;<span class="regexp">/Spin&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><h2 id="renderProps"><a href="#renderProps" class="headerlink" title="renderProps"></a>renderProps</h2><p>久而久之我们会发现在所有使用这个 useData 的组件中，我们都避免不了手写这两个 if。但是 hooks 只能解决生命周期的问题，没法封装一些 render 的逻辑。其实这里<strong>最有效的解决方法就是 Suspense</strong>，但是因为还没有发布，所以我们想到了 <strong>renderProps</strong>:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataBoundary</span>(<span class="params">&#123; data, loading, error, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Spin</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span>&gt;</span>&#123;children(data)&#125;<span class="tag">&lt;/<span class="name">Spin</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MovieList</span>(<span class="params">&#123; page, size &#125;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queryMovieList = useCallback(<span class="function">(<span class="params">page, size</span>) =&gt;</span> api.queryMovieList(&#123; page, size &#125;), [page, size]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> movieListResult = useData(queryMovieList);</span><br><span class="line">  <span class="comment">// const &#123; data: movieListData, loading, error &#125; = useData(queryMovieList);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;DataBoundary &#123;...movieListResult&#125;&gt;</span><br><span class="line">    &#123;<span class="comment">/* &lt;DataBoundary data=&#123;movieListData&#125; loading=&#123;loading&#125; error=&#123;error&#125;&gt; */</span>&#125;</span><br><span class="line">      &#123;(data) =&gt; renderMovieList(data)&#125;</span><br><span class="line">    &lt;<span class="regexp">/DataBoundary&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  function renderMovieList(movieList) &#123;</span></span><br><span class="line"><span class="regexp">    return movieList.map(item =&gt; &lt;MovieItem key=&#123;item.id&#125; data=&#123;item&#125; /</span>&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 DataBoundary 里，我们封装了关于异步状态处理的渲染流程，还可以提供出类似 fallback 的钩子，满足需要定制化的组件场景。用它做到了类似于 Suspense 的事情。</p><p>## All in Hooks？<br>但是如果我们真的想在 hooks 里完成所有的事情呢？这里再抛出一个彩蛋：</p><p>如果我们可以在 hooks 中返回一个 “renderProp”，我们就可以完整的将 render 相关的逻辑也封装在 hooks 里了，但是同时这样也会使得一个 hook 里的代码变得复杂，这里只是提供一种思路。那么这两种写法你更喜欢那个呢？</p><!-- END#4 --><h1 id="44-Suspense"><a href="#44-Suspense" class="headerlink" title="44 Suspense"></a>44 Suspense</h1><p># 44 <a href="https://juejin.cn/post/7155268983246028807#heading-1" target="_blank" rel="noopener">React组件如何优雅地处理异步数据</a><br>PS: Suspense 文档只处理动态加载组件；并没有拦截渲染的说明。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">"./ErrorBoundary"</span></span><br><span class="line"><span class="keyword">import</span> RandomWord <span class="keyword">from</span> <span class="string">"./RandomWord"</span></span><br><span class="line"><span class="keyword">import</span> &#123;Suspense&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;ErrorBoundary&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;RandomWord /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>ErrorBoundary&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure></p><!-- END#44 --><h1 id="5-React的render-props模式"><a href="#5-React的render-props模式" class="headerlink" title="5 React的render-props模式"></a>5 React的render-props模式</h1><p># 5 <a href="https://www.jianshu.com/p/8d69a74fc5b3" target="_blank" rel="noopener">React的render-props模式、高阶组件</a><br>props.render()模式<br>使用children代替render</p><h2 id="使用displayName"><a href="#使用displayName" class="headerlink" title="使用displayName"></a>使用displayName</h2><p>使用了高阶组件之后会存在一个问题: 开发者工具会显示两个组件名称一样的组件</p><p>因为默认情况下, React会使用组件名称作为组件名称,所有在两个组件都使用了高阶组件的情况下,两个组件的外壳都是其高阶组件的名称</p><p>解决方案: 手动设置displayName<br>使用步骤<br>在高阶组件的函数内部定义一个函数getDisplayName(){}把传入组件作为参数传入这个函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数,在函数内部创建一个类式组件</span></span><br><span class="line"><span class="keyword">const</span> withMouse = <span class="function"><span class="params">WarppedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复用的逻辑代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置开发者工具显示名称,如果不设置开发者工具显示的外壳组件都是一样的</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WarppedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WarppedComponent.displayName || WarppedComponent.name || <span class="string">'Component'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给组件添加displayName属性</span></span><br><span class="line">  Mouse.displayName = <span class="string">`WithMouse<span class="subst">$&#123;getDisplayName(WarppedComponent)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> Mouse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withMouse</span><br></pre></td></tr></table></figure><!-- END#5--><h1 id="111-高阶组件和axios的拦截器"><a href="#111-高阶组件和axios的拦截器" class="headerlink" title="111 高阶组件和axios的拦截器"></a>111 高阶组件和axios的拦截器</h1><p># 111 <a href="https://zhuanlan.zhihu.com/p/34192569" target="_blank" rel="noopener">React中使用高阶组件和axios的拦截器，统一处理请求失败提示</a><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (WrappedComponent) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        error: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      axios.interceptors.response.use(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;,  (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          error: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> errorElem = <span class="keyword">this</span>.state.error ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>请求出错了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123; errorElem &#125;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><!-- END#111 --><p># 第三方库</p><h1 id="react-adopt"><a href="#react-adopt" class="headerlink" title="react-adopt"></a>react-adopt</h1><p>react-adopt: <a href="https://github.com/pedronauck/react-adopt" target="_blank" rel="noopener">https://github.com/pedronauck/react-adopt</a></p><p>React Adopt - Compose render props components like a pro</p><h1 id="SWR"><a href="#SWR" class="headerlink" title="SWR"></a>SWR</h1><p>SWR: <a href="https://swr.vercel.app/zh-CN" target="_blank" rel="noopener">https://swr.vercel.app/zh-CN</a><br>vercel/swr: <a href="https://github.com/vercel/swr" target="_blank" rel="noopener">https://github.com/vercel/swr</a><br>“SWR” 这个名字来自于 stale-while-revalidate：一种由 HTTP RFC 5861(opens in a new tab) 推广的 HTTP 缓存失效策略。这种策略首先从缓存中返回数据（过期的），同时发送 fetch 请求（重新验证），最后得到最新数据。</p><blockquote><p>使用 SWR，组件将会不断地、自动获得最新数据流。<br>UI 也会一直保持快速响应。</p></blockquote><h1 id="useRequest"><a href="#useRequest" class="headerlink" title="useRequest"></a>useRequest</h1><p><a href="https://github.com/alibaba/hooks" target="_blank" rel="noopener">https://github.com/alibaba/hooks</a><br><code>import { useRequest } from &#39;ahooks&#39;;</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRequest &#125; <span class="keyword">from</span> <span class="string">'@umijs/hooks'</span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'jack'</span>);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, error, loading &#125; = useRequest(getUsername)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>failed to load<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Username: &#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://zhuanlan.zhihu.com/p/106796295" target="_blank" rel="noopener">useRequest- 蚂蚁中台标准请求 Hooks</a><br>但日常工作中，只用一个 useAsync 还是不够的，Umi Hooks 中和网络请求相关的 Hooks 就有非常多。比如和分页请求相关的 usePagination，请求自带防抖的 useSearch，内置 umi-request 的 useAPI，加载更多场景的 useLoadMore，等等等等。</p><p>同时随着 zeit/swr 的诞生，给了我们很多灵感，原来网络请求还可以这么玩！swr 有非常多好用，并且我们想不到的能力。比如：</p><ul><li>屏幕聚焦重新发起请求。</li><li>swr 能力。</li></ul><p>能力介绍</p><ul><li>基础网络请求</li><li>手动请求</li><li>轮询</li><li>并行请求</li><li>防抖 &amp; 节流</li><li>缓存 &amp; SWR &amp; 预加载</li><li>屏幕聚焦重新请求</li><li>集成请求库</li><li>分页</li><li>加载更多</li></ul><!-- > 看起来像是一个堆砌了很多业务功能的复刻 swr，没有什么值得兴奋的地方。不过项目收藏了，可以提醒一下自己不要写出缺乏技术审美的东西。 --><h1 id="42-fetching-box"><a href="#42-fetching-box" class="headerlink" title="42 fetching-box"></a>42 fetching-box</h1><p>fetching-box: <a href="https://github.com/GitHubJiKe/fetching-box" target="_blank" rel="noopener">https://github.com/GitHubJiKe/fetching-box</a></p><blockquote><p>React 开发中，更简洁、优雅的处理 loading、error 以及统一 Container 样式的问题的思路<br><!-- PS: 利用render props 高阶组件。 --><br><!-- END#42 fetching-box--></p></blockquote><!-- \# 其他下面两篇和想要实现的功能不匹配了[loading 动画 放在请求拦截里做统一处理，还是放在每个页面里？](https://www.zhihu.com/question/361499790)[React项目优化(2)-使用Axios+CommonModel统一处理Loading](https://juejin.cn/post/7105994337913143333) --><h1 id="React组件设计实践总结04-组件的思维"><a href="#React组件设计实践总结04-组件的思维" class="headerlink" title="React组件设计实践总结04 - 组件的思维"></a>React组件设计实践总结04 - 组件的思维</h1><!-- \# [React组件设计实践总结04 - 组件的思维](https://juejin.cn/post/6844903844711759880) --><ol><li>高阶组件</li><li>Render Props</li><li>使用组件的方式来抽象业务逻辑</li><li>hooks 取代高阶组件</li><li>hooks 实现响应式编程</li><li>类继承也有用处</li><li>模态框管理</li><li>使用 Context 进行依赖注入</li><li>不可变的状态</li><li>React-router: URL 即状态</li><li>组件规范<br>扩展</li></ol><h2 id="4-hooks-取代高阶组件"><a href="#4-hooks-取代高阶组件" class="headerlink" title="4. hooks 取代高阶组件"></a>4. hooks 取代高阶组件</h2><p>自定义 hook 和函数组件的代码结构基本一致, 所以有时候hooks 写着写着原来越像组件, 组件写着写着越像 hooks. 我觉得可以认为组件就是一种特殊的 hook, 只不过它输出 Virtual DOM.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现一个功能：统一处理页面接口数据加载；并且渲染不同状态的ui。&lt;br&gt;    或者是子组件；也可以自定义loading/skeleton，error。&lt;br&gt;最后：高阶组件-render props&lt;br&gt;&lt;!-- 实现上参考：先1 -》 4 -》5。 最后发现是2的实践
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="react.js" scheme="http://yoursite.com/tags/react-js/"/>
    
  </entry>
  
  <entry>
    <title>骨架屏方案</title>
    <link href="http://yoursite.com/sum/jsplus/%E9%AA%A8%E6%9E%B6%E5%B1%8F%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/sum/jsplus/骨架屏方案/</id>
    <published>2023-03-03T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.382Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2023.3.3 星期五 </p><h1 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h1><p>通过chrome插件<!-- 浏览器插件：page-web-skeleton -->，生成了骨架屏代码，放到<code>&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;</code> 内。<br>也可以在接口请求结束后移除骨架屏。</p><h1 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h1><!-- \#1-SSS [Vue项目骨架屏注入实践](https://www.f2ecoder.net/814.html) --><p>生成骨架屏的方式主要有：</p><ol><li>手写HTML、CSS的方式为目标页定制骨架屏<br>做法可以参考【Vue页面骨架屏注入实践】，主要思路就是使用 vue-server-renderer 这个本来用于服务端渲染的插件，用来把我们写的.vue文件处理为HTML，插入到页面模板的挂载点中，完成骨架屏的注入。这种方式不甚文明，如果页面样式改变了，还得改一遍骨架屏，增加了维护成本。 骨架屏的样式实现参考 CodePen</li><li>使用图片作为骨架屏；<br>简单暴力，让UI同学花点功夫吧哈哈；小米商城的移动端页面采用的就是这个方法，它是使用了一个Base64的图片来作为骨架屏。</li><li>自动生成并自动插入静态骨架屏 <!-- 这种方法跟第一种方法类似，不过是自动生成骨架屏，可以关注下饿了么开源的插件 page-skeleton-webpack-plugin ，它根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中，不过要注意的是这个插件目前只支持history方式的路由，不支持hash方式，且目前只支持首页的骨架屏，并没有组件级的局部骨架屏实现，作者说以后会有计划实现(issue9)。 --></li><li>vue-skeleton-webpack-plugin<!-- 另外还有个插件 vue-skeleton-webpack-plugin，它将插入骨架屏的方式由手动改为自动，原理在构建时使用 Vue 预渲染功能，将骨架屏组件的渲染结果 HTML 片段插入 HTML 页面模版的挂载点中，将样式内联到 head 标签中。这个插件可以给单页面的不同路由设置不同的骨架屏，也可以给多页面设置，同时为了开发时调试方便，会将骨架屏作为路由写入router中，可谓是相当体贴了。 vue-skeleton-webpack-plugin的具体使用参考 vue-style-codebase，主要关注build目录的几个文件，线上Demo 在Chrome的DevTools中把network的网速调为Gast 3G / Slow 3G就能看到效果了~ --></li></ol><!-- END#1 --><h1 id="awesome-skeleton"><a href="#awesome-skeleton" class="headerlink" title="awesome-skeleton"></a>awesome-skeleton</h1><p><a href="https://github.com/kaola-fed/awesome-skeleton" target="_blank" rel="noopener">https://github.com/kaola-fed/awesome-skeleton</a></p><ul><li>骨架图生成组件，仅限node端使用。该组件提供骨架图生成和骨架图模板注入两个能力。</li><li>骨架图生成逻辑：通过传入页面地址，使用 Puppeteer 无头浏览器打开页面地址，对页面首屏图片和文本等节点进行灰色背景处理，然后对页面首屏进行截图，生成压缩后的 base64 png 图片。</li></ul><p>#11 <a href="https://zhuanlan.zhihu.com/p/114362353" target="_blank" rel="noopener">考拉前端骨架屏生成技术揭秘</a></p><ol><li>通过设计师给出的骨架屏图片。</li><li>通过 HTML+CSS 编写骨架屏代码。</li><li>非侵入式自动生成骨架屏代码。</li></ol><p>本文主要针对自动生成骨架屏技术进行了深入的探讨，并开发了 awesome-skeleton，支持多种配置，以及骨架屏定制功能，并提供骨架图生成和骨架图模板注入能力。</p><p>使用 awesome-skeleton</p><p>通过上述讨论的技术方案，我们实现了 awesome-skeleton 骨架屏生成工具。支持命令行生成骨架屏代码，同时也可以非常方便的在第三方平台接入。<br><!-- END#11 --></p><h1 id="page-skeleton-webpack-plugin"><a href="#page-skeleton-webpack-plugin" class="headerlink" title="page-skeleton-webpack-plugin"></a>page-skeleton-webpack-plugin</h1><!-- 浏览器插件：page-web-skeleton --><p><a href="https://github.com/ElemeFE/page-skeleton-webpack-plugin" target="_blank" rel="noopener">https://github.com/ElemeFE/page-skeleton-webpack-plugin</a></p><p>Page Skeleton 是一款 webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。</p><ul><li>支持多种加载动画</li><li>针对移动端 web 页面</li><li>支持多路由</li><li>可定制化，可以通过配置项对骨架块形状颜色进行配置，同时也可以在预览页面直接修改骨架页面源码</li><li>几乎可以零配置使用</li></ul><p>#21 <a href="https://www.jianshu.com/p/ec55680fa48c" target="_blank" rel="noopener">一种自动化生成骨架屏的方案</a><br>今天的分享主要分为三个部分：<br>首屏加载状态演进<br>如何构建骨架屏<br>将骨架屏打包的项目中</p><p>下面我将通过 page-skeleton-webpack-plugin 工具中的代码，来展示骨架屏的具体生成过程。<br><!-- END#21 --><br># 22 <a href="https://cloud.tencent.com/developer/article/2109640" target="_blank" rel="noopener">前端骨架屏方案小结</a><br>作为首屏渲染(自动化方案)</p><p>该方案是饿了么在骨架屏的实践中总结出的一套方案:</p><p>骨架屏的dom结构和css通过离线生成后构建的时候注入模板中的节点下面.<br>原理相关eleme骨架屏插件实现原理<br>方案的项目地址:page-skeleton-webpack-plugin<br><!-- END#22 --></p><h1 id="smart-skeleton-screen"><a href="#smart-skeleton-screen" class="headerlink" title="smart-skeleton-screen"></a>smart-skeleton-screen</h1><p># 31 <a href="https://segmentfault.com/a/1190000040463903" target="_blank" rel="noopener">什么？都1202年了，你还在手写骨架屏</a><br># 31 <a href="https://juejin.cn/post/6993003923866910733" target="_blank" rel="noopener">骨架屏自动化？看这篇就够了</a><br>百度 - vue-skeleton-webpack-plugin<br>&lt;!–<br>实现原理<br>通过 vueSSR (vue 服务端渲染)结合 webpack 在构建时渲染写好的 vue 骨架屏组件，将预渲染生成的 DOM 节点和相关样式插入到最终输出的 html 中</p><p>不足<br>预渲染的骨架屏组件需要开发者编写（对于想偷懒的小伟来说明显不是最优解🙄️）<br>方案只适用于vue项目(小伟的H5项目既有react也有vue) –&gt;<br>京东 - dps<br>&lt;!–<br>实现原理<br>通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架页面的页面，在等待页面加载渲染完成之后, 执行遍历dom树的脚本代码，通过单纯的 DOM 操作，挑选目标节点，生成骨架屏html和css代码</p><p>不足</p><p>无法选择生成骨架屏的时机。当页面存在着重定向(H5需要鉴权)的时候，生成的骨架屏和预期相差比较大<br>内部实现并不完善，某些元素比如伪元素等无法生成骨架屏<br>某些依赖浏览器jsbridge接口的页面，工具无法使用 –&gt;<br>饿了么 - page-skeleton-webpack-plugin<br>&lt;!–<br>实现原理</p><p>通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架页面的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片、文字和图片的展现，通过样式覆盖，使得其展示为灰色块。并且将修改后的 HTML 和 CSS 样式提取出来，通过 webpack 插件的形式注入最后生成的html中，并且还可以启动 UI 界面专门调整骨架屏代码。</p><p>不足</p><p>由于生成的骨架屏节点是基于页面本身的结构和样式，在某些嵌套比较深的页面，骨架屏代码体积不会很小，并且对于多路由的页面，生成的代码就更加庞大了<br>无法选择生成骨架屏的时机。当页面存在着重定向(H5需要鉴权)的时候，生成的骨架屏和预期相差比较大<br>某些依赖浏览器jsbridge接口的页面，工具无法使用<br>只支持history路由 –&gt;</p><p>## 骨架屏代码如何生成<br>## 如何将生成的骨架屏代码插件集成到项目中<br>当我们把骨架屏代码保存到用户项目之后，我们一样可以借用构建工具插件的功能，遍历骨架屏文件夹，获取所有骨架屏代码，再插入到项目的html中，其实就是一个简版的HtmlWebpackPlugin。</p><p>## 骨架屏编辑器<br>### 无痛接入smart-skeleton-screen<br>安装插件包 (根据项目构建工具选择相关的插件包，以webpack为例)<br><code>tnpm install @tencent/smart-skeleton-screen</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">%</span> <span class="attr">smart-skeleton</span> %&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><!-- END#31 --><h1 id="draw-page-structure"><a href="#draw-page-structure" class="headerlink" title="draw-page-structure"></a>draw-page-structure</h1><p><a href="https://github.com/famanoder/dps#readme" target="_blank" rel="noopener">https://github.com/famanoder/dps#readme</a></p><ul><li>automatic: easy to use CLI to make skeleton screen</li><li>flexible: just use javascript even in browser</li><li>simple: some usefull config items do it well</li></ul><blockquote><p>可在控制台输出当前页面骨架屏节点，复制添加到应用页面；该做法目前来说最大的作用在于应对需要登录的页面，可在相应页面直接调用evalDOM函数生成该页面的骨架屏节点；</p></blockquote><p># 71 <a href="https://blog.csdn.net/weixin_39843414/article/details/116177807" target="_blank" rel="noopener">前端骨架屏自动生成方案</a><br># 71 <a href="https://codeantenna.com/a/YbpZlonQLo" target="_blank" rel="noopener">一种对开发更友好的前端骨架屏自动生成方案</a></p><p>page-skeleton-webpack-plguin 生成骨架屏的方案可以根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。<br>它的不足之处在于：<br>实际使用过程中无法监听接口返回导致生成骨架屏的时机是否准确<br>生成的页面与业务人员写的结构质量有直接关系，经常出现需要手工二次调整的情况</p><p>在方案调研过程中，draw-page-structure 为我们的设计提供了灵感。 –&gt;<br>draw-page-structure</p><!-- END#71 --><h1 id="create-skeleton-quickly"><a href="#create-skeleton-quickly" class="headerlink" title="create-skeleton-quickly"></a>create-skeleton-quickly</h1><p># 81 <a href="https://juejin.cn/post/6917519801170526222" target="_blank" rel="noopener">前端可视化工具（自动生成骨架屏代码）</a><br><code>npm i create-skeleton-quickly -g</code></p><p>PS: 和项目无关。启动独立服务，传入页面路径。<br><!-- END#81 --></p><h1 id="skeleton"><a href="#skeleton" class="headerlink" title="skeleton"></a>skeleton</h1><p># 113 <a href="https://korbinzhao.github.io/前端开发/骨架屏/2018/06/23/skeleton-auto-generator/" target="_blank" rel="noopener">一个前端非侵入式骨架屏自动生成方案</a></p><!-- END#113 --><h1 id="基于-React-Native"><a href="#基于-React-Native" class="headerlink" title="基于 React Native"></a>基于 React Native</h1><p># 443 <a href="https://cloud.tencent.com/developer/article/1876082" target="_blank" rel="noopener">干货 | 前端智能化探索，骨架屏低代码自动生成方案实践</a><br>目前业界对于自动化骨架屏的实现方式有以下两种主流方案。<br>1.2.1 puppeteer 自动生成骨架<br>1.2.2 现有的 RN 实现方案</p><p>我们实现的骨架屏方案主要基于 React Native，但从 DSL 层面来说，这样的方案可以移植到任何前端框架方案中进行实现。<br>最终实现的方案不仅达到了预期，还具有以下特点：</p><ul><li>可针对多种前端方案，输出对应的骨架屏代码；</li><li>结合视觉稿标注平台，由视觉设计师的 UI 设计稿可直出可用的代码内容；</li><li>解放开发同学的双手，复制粘贴即可使用，不需要做节点标示、筛除；</li><li>封装骨架屏 loading 动画，开箱即用；</li><li>从视觉稿标注平台，可直接预览生成后的代码效果，方便快捷。</li></ul><!-- END#443 --><h1 id="基于-BeeMa-架构和vscode插件"><a href="#基于-BeeMa-架构和vscode插件" class="headerlink" title="基于 BeeMa 架构和vscode插件"></a>基于 BeeMa 架构和vscode插件</h1><p># 444 <a href="https://mdnice.com/writing/bb3aaf5c613d4e0a9cc86ee2244754df" target="_blank" rel="noopener">自动化生成骨架屏的技术方案设计与落地</a><br>&lt;!–<br>方案调研<br>骨架屏技术方案上从实现上来说大致可以三类：</p><ol><li>手动维护骨架屏的代码（HTML、css or vue 、React）</li><li>使用图片作为骨架屏</li><li>自动生成骨架屏<br>对于前两种方案有一定的维护成本比较费人力，这里主要介绍下自动生成骨架屏的方案。<br>技术方案<br>目前市面上主要使用的是饿了么开源的 webpack 插件：page-skeleton-webpack-plugin。它根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。这种方式将骨架屏代码与业务代码隔离，通过 webpack 注入的方式骨架屏代码（图片）注入到项目中。优势非常明显但是缺点也显而易见：webpack配置成本（还依赖html-webpack-plugin）。 –&gt;<br>综合如上的技术调研，我们还是决定采用最低侵入业务代码且降低配置成本的骨架屏自动生成的方案。参考饿了么的设计思路，基于 BeeMa 架构和vscode插件来实现一个新的骨架屏生成方案。<blockquote><p>目前仅支持 beema 架构源码开发</p><!-- END#444 --></blockquote></li></ol><p># <a href></a><br># <a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2023.3.3 星期五 &lt;/p&gt;

&lt;h1 id=&quot;实际&quot;&gt;&lt;a href=&quot;#实际&quot; class=&quot;headerlink&quot; title=&quot;实际&quot;&gt;&lt;/a&gt;实际&lt;/h1&gt;&lt;p&gt;通过chrome插件&lt;!-- 浏览器插件：p
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Chrome Devtools使用</title>
    <link href="http://yoursite.com/sum/js/chrome%20devtools%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/sum/js/chrome devtools使用/</id>
    <published>2023-02-24T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><!-- \# SS [Network Throttling in Chrome DevTools](https://www.debugbear.com/blog/chrome-devtools-network-throttling) --><!-- 33 How to test a page speed with a slower connection## What do Slow 3G and Fast 3G mean in DevTools?### What is latency? --><h3 id="transferred-over-network和resources-loaded-by-the-page"><a href="#transferred-over-network和resources-loaded-by-the-page" class="headerlink" title="transferred over network和resources loaded by the page"></a>transferred over network和resources loaded by the page</h3><p># S <a href="https://www.webperf.tips/tip/resource-size-vs-transfer-size/" target="_blank" rel="noopener">Transfer Size vs. Resource Size</a></p><blockquote><p>“Transferred” is the compressed size of all resources. You can think of it as the amount of upload and download data that a mobile user will use in order to load this page. “Resources” is the uncompressed size of all resources.</p></blockquote><!-- 其他参考：[Chrome开发者工具network标签页里的transferred over network和resources loaded by the page的区别](https://www.jianshu.com/p/c12c61ab5162)[Chrome开发者工具network标签页里的transferred over network和resources loaded by the page的区别](https://blog.csdn.net/i042416/article/details/109447173)[What is the difference between "transferred" and "resources" in Chrome DevTools Network tab?](https://stackoverflow.com/questions/56043151/what-is-the-difference-between-transferred-and-resources-in-chrome-devtools)transferred over network是通过网络加载的资源尺寸，而resources loaded by the page不仅包含前者，也包含直接从浏览器缓存里加载的资源尺寸。这种说法不完全准确，更精确的说法是，resources loaded by the page统计的是前端页面加载的所有资源经过解压之后的原始大小。 --><h2 id="performence"><a href="#performence" class="headerlink" title="performence"></a>performence</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;network&quot;&gt;&lt;a href=&quot;#network&quot; class=&quot;headerlink&quot; title=&quot;network&quot;&gt;&lt;/a&gt;network&lt;/h2&gt;&lt;!-- \# SS [Network Throttling in Chrome DevTools](ht
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/sum/js/"/>
    
    
  </entry>
  
  <entry>
    <title>网速基础知识</title>
    <link href="http://yoursite.com/sum/others/%E7%BD%91%E9%80%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/sum/others/网速基础知识/</id>
    <published>2023-02-24T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.407Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2023.2.24 星期五</p><h1 id="Mbps、Mb-s、MB-s"><a href="#Mbps、Mb-s、MB-s" class="headerlink" title="Mbps、Mb/s、MB/s"></a>Mbps、Mb/s、MB/s</h1><!-- \# [一文看懂Mbps、Mb/s、MB/s 有什么区别](https://www.ithome.com/0/437/491.htm) --><p>那么这个Mbps跟我们平常说的MB/s到底是不是一个意思呢？直接公布答案吧，不是，因为其中涉及到换算的问题，你不能想当然的认为美国的一元跟中国的一元其价值是一样。</p><p>Mbps、Mb/s、MB/s傻傻分不清？</p><h2 id="Mbps、Mb-s、MB-s傻傻分不清？"><a href="#Mbps、Mb-s、MB-s傻傻分不清？" class="headerlink" title="Mbps、Mb/s、MB/s傻傻分不清？"></a>Mbps、Mb/s、MB/s傻傻分不清？</h2><p>我们先来看一下换算关系：</p><p>B=Byte<br>b=bit<br>1 Kb = 1024 bit<br>1 KB = 1024 Byte<br>1 Mb = 1024 Kb<br>1 MB = 1024 KB<br>1 Byte = 8 bit<br>1 MB = 8Mb<br>1 Mb = 0.125 MB</p><p>其中，bit（比特，1比特代表1个位）是信息的最小单位，是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量。一般来说，n比特的信息量可以表现出2的n次方种选择。</p><p>而Byte（字节）是计算机信息技术用于计量存储容量的一种计量单位，作为一个单位来处理的一个二进制数字串，是构成信息的一个小单位。最常用的字节是八位的字节，即它包含八位的二进制数。一个位就代表一个0或1（即二进制），每8个位组成一个字节（Byte，简写为B）。</p><p>那么答案就出来了，1 Byte = 8 bit，每秒传输多少bit、每秒传输多少Byte，我们可以用Byte/s、bit/s来表示，换算一下就可以得出8Mbps=8Mb/s=1MB/s。</p><h2 id="为什么网速用Mbps而不是MB-s呢"><a href="#为什么网速用Mbps而不是MB-s呢" class="headerlink" title="为什么网速用Mbps而不是MB/s呢"></a>为什么网速用Mbps而不是MB/s呢</h2><p>我们知道，计算机是以Bit和Byte作为计算单位，其中bit（比特）是电脑辨识讯息的最小单位，再上一个更大的单位为Byte（字节）。</p><p>一般来说，数据传输大多是以“位”（bit，又名“比特”）为单位的，这也就是为什么网速的单位都是Mbps而不是MB/s了，而数据存储是则以“字节”（Byte）为单位，比如硬盘的读写速度一般就用的是MB/S。</p><p>通常，运营商说的1M宽带的M是指Mb/s，也就是Mbps，换算一下的话，1M宽带下载速度也就是125KB/s，再去掉损耗的话就是120KB/s左右。以此类推，10M宽带的最快下载速度是1.25MB/s，100M的宽带最快下载速度是12.5MB/s。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>无论是以Byte还是bit作为网速单位其实都是正确的，但是我们在在书写单位时一定要注意B字母的大小写，此时B字母的大小写真的可以称之为“失之毫厘，谬以千里”。其实运营商等在宣传的时候，Mbps作为网络速率单位是最正确的，因为数据的传输以及运营商在流量收费的时候都是按照比特来计算的；但从消费者的角度来看，MB/s符合我们大众的生活习惯，而且也便于理解。</p><h1 id="三大运营商4G网速"><a href="#三大运营商4G网速" class="headerlink" title="三大运营商4G网速"></a>三大运营商4G网速</h1><!-- [三大运营商4G网速谁家最快？中国4G平均网速揭晓](http://m.ikanchai.com/pcarticle/240464) --><p>根据Speedtest公布的统计数据，目前中国的4G移动网速平均下载速度为29.91Mbps（3.74MB/s），平均上传速度则是12.5Mbps（1.56MB/s）。这个数值算快还是慢呢？</p><p>相对于全球移动宽带平均下载速度22.99Mbps，平均上传速度9.19Mbps来说，还算是不错的。</p><p>最慢的是中国移动。<br>移动的4G信号覆盖虽然广，但其用户数量远远超过联通和电信，平均下来，网速也就自然不如联通和电信了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2023.2.24 星期五&lt;/p&gt;


&lt;h1 id=&quot;Mbps、Mb-s、MB-s&quot;&gt;&lt;a href=&quot;#Mbps、Mb-s、MB-s&quot; class=&quot;headerlink&quot; title=&quot;Mbps、Mb/s、MB/s&quot;&gt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
  </entry>
  
  <entry>
    <title>Ens-2023</title>
    <link href="http://yoursite.com/ins/ens/characters-2023/"/>
    <id>http://yoursite.com/ins/ens/characters-2023/</id>
    <published>2023-02-22T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.286Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2023.22.22 星期三 </p><h2 id="0222"><a href="#0222" class="headerlink" title="0222"></a>0222</h2><ol><li>concurrent： adj-同时；合流的</li><li>suspense： [n] 悬念。<br>React 18 introduces the foundation of concurrent rendering and new features such as suspense, streaming server rendering, and transitions are powered by concurrent rendering.<!-- google翻译：React 18 引入了并发渲染的基础，并且新功能（例如悬念、流式服务器渲染和过渡）由并发渲染提供支持。 --></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2023.22.22 星期三 &lt;/p&gt;


&lt;h2 id=&quot;0222&quot;&gt;&lt;a href=&quot;#0222&quot; class=&quot;headerlink&quot; title=&quot;0222&quot;&gt;&lt;/a&gt;0222&lt;
      
    
    </summary>
    
      <category term="ins" scheme="http://yoursite.com/categories/ins/"/>
    
      <category term="ens" scheme="http://yoursite.com/categories/ins/ens/"/>
    
    
      <category term="ens" scheme="http://yoursite.com/tags/ens/"/>
    
  </entry>
  
  <entry>
    <title>前端埋点实现</title>
    <link href="http://yoursite.com/sum/js/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/sum/js/前端埋点实现/</id>
    <published>2023-02-20T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.342Z</updated>
    
    <content type="html"><![CDATA[<p>Intersection Observer API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></p><a id="more"></a><p style="text-align:right">2023.2.20 星期一 </p><p>小程序，h5，taro等埋点：属性埋点，自动/全/零埋点，区别于手动上报。</p><h1 id="曝光埋点"><a href="#曝光埋点" class="headerlink" title="曝光埋点"></a>曝光埋点</h1><h2 id="IntersectionObserver-方式"><a href="#IntersectionObserver-方式" class="headerlink" title="IntersectionObserver 方式"></a>IntersectionObserver 方式</h2><!-- \# 1-A [Web曝光埋点实现原理](https://www.jianshu.com/p/bb9375b0999d)IntersectionObserver:demo源代码：https://stackblitz.com/edit/js-ozzzjw?file=index.jsdemo效果：https://js-ozzzjw.stackblitz.io/曝光埋点实现demo源代码：https://stackblitz.com/edit/react-hfq33n?file=src%2FApp.jsdemo效果：https://react-hfq33n.stackblitz.io/--><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( entry.intersectionRatio &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            report(entry.target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".item"</span>)</span><br><span class="line">nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    intersectionObserver.observe(node)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主要用到的API<br><code>IntersectionObserver</code> 主要用来检测被监听的目标元素可见部分与root元素的交叉状况，比如获取相交区域的比例值，后面做曝光埋点的判断需要用到。</p><p><code>requestIdleCallback</code> 方法，浏览器会在空闲时执行传入的函数。后面埋点我们使用这个方法，避免埋点影响主业务。</p><!-- END#1 --><h3 id="react-两种方式"><a href="#react-两种方式" class="headerlink" title="react 两种方式"></a>react 两种方式</h3><!-- \# 2-A [基于 IntersectionObserver 实现一个组件的曝光监控](https://www.xiabingbao.com/post/js/dom-expose-intersectionobserver.html) --><p>实现的方式主要有两种：</p><ul><li>函数的方式；</li><li>高阶组件的方式；<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # 调用方式</span></span><br><span class="line"><span class="comment">// ## 函数方式</span></span><br><span class="line"><span class="comment">// 重新设置IntersectionObserver的配置</span></span><br><span class="line">exposeListener(<span class="built_in">document</span>.querySelector(<span class="string">'.dom3'</span>), &#123;</span><br><span class="line">  observerOptions: &#123;</span><br><span class="line">    threshold: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">1</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  onExpose() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dom1 expose'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 类的方式</span></span><br><span class="line"><span class="comment">// ## useEffect()</span></span><br><span class="line">&lt;ComExpose always onExpose=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'expose'</span>)&#125; onHide=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'hide'</span>)&#125;&gt;</span><br><span class="line">  &lt;div className=<span class="string">"dom dom1"</span>&gt;dom1 always&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ComExpose&gt;</span><br></pre></td></tr></table></figure></li></ul><!-- END#2 --><p>PS: 可以用自定义useExpo。<br>&lt;!– PS:<br>app.jsx中使用新的hooks；不用每个组件都调用。可以用高阶组件， 或者函数试：useEffect(() =&gt; {useExpo()}, [])<br>高阶组件，不用通过class获取目标元素。而是<code>const ref = useRef&lt;any&gt;(null);</code></p><p>–&gt;</p><h3 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h3><p>taro或者小程序项目有api：Taro.createIntersectionObserver<br><code>const observer = Taro.createIntersectionObserver(this, { thresholds: [0], observeAll: true })</code></p><blockquote><p>创建并返回一个 IntersectionObserver 对象实例。<br>监听文档/dom的变化以他用<!-- 比如：添加埋点 --></p></blockquote><!-- 微信小程序内createIntersectionObserver 需要添加定时器，而且回调函数不能用requestIdle包装：动态添加视图不会上报。比如接口请求拿到数据后渲染。--><p><a href="https://github.com/NervJS/taro/pull/13972" target="_blank" rel="noopener">refactor(runtime/shared/api): 优化获取节点的逻辑，增加其成功率</a></p><blockquote><ol><li>小程序和 H5 的 createIntersectionObserver 和 createSelectorQuery API 自动在一个 Taro.nextTick 后执行，减少开发者手动使用 Taro.nextTick 或 setTimeout 的需要。</li><li>Taro.nextTick 增加等待执行逻辑，增加其在开发框架完成渲染后再执行的成功率</li></ol></blockquote><h4 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h4><p>兼容h5语法<!-- ，3.4.x 版本h5有些问题：不会触发回调 -->，使用原生js写法。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useExposure。</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> observeCb = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// const dataset = document.getElementById(res.id)?.dataset;</span></span><br><span class="line">              <span class="keyword">let</span> target;</span><br><span class="line">              <span class="keyword">let</span> dataset;</span><br><span class="line">              <span class="comment">// let intersectionRatio:number;</span></span><br><span class="line">              <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">                  target = e.target;</span><br><span class="line">                  dataset = target.dataset;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  dataset = <span class="built_in">document</span>.getElementById(e.id)?.dataset</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!dataset) <span class="keyword">return</span>;</span><br><span class="line">              <span class="comment">// do sth</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">"weapp"</span>) &#123;</span><br><span class="line">            timerRef.current = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                obRef.current = Taro.createIntersectionObserver(<span class="keyword">this</span> <span class="keyword">as</span> unknown <span class="keyword">as</span> TaroGeneral.IAnyObject, &#123;</span><br><span class="line">                    observeAll: <span class="literal">true</span></span><br><span class="line">                &#125;);</span><br><span class="line">                obRef.current</span><br><span class="line">                    .relativeToViewport(&#123; <span class="attr">top</span>: <span class="number">10</span> &#125;)</span><br><span class="line">                    .observe(<span class="string">".expo"</span>, observeCb);</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> options = &#123;</span><br><span class="line">                root: <span class="literal">null</span>,</span><br><span class="line">                <span class="comment">// rootMargin: '0px 0px 0px 0px',</span></span><br><span class="line">                <span class="comment">// threshold: [0, 0.3, 1],</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries<span class="regexp">/* , observer */</span></span>) =&gt;</span> &#123;</span><br><span class="line">                entries.forEach(requestIdle(observeCb));</span><br><span class="line">                <span class="comment">// entries.forEach(entry =&gt; &#123;</span></span><br><span class="line">                <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">                <span class="comment">// target element:</span></span><br><span class="line">                <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">                <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">                <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">                <span class="comment">//   entry.isIntersecting</span></span><br><span class="line">                <span class="comment">//   entry.rootBounds</span></span><br><span class="line">                <span class="comment">//   entry.target</span></span><br><span class="line">                <span class="comment">//   entry.time</span></span><br><span class="line">                <span class="comment">// const target = entry.target;</span></span><br><span class="line">                <span class="comment">// observeCb(entry)</span></span><br><span class="line">                <span class="comment">// &#125;);</span></span><br><span class="line">            &#125;, options);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"[Expo]doms:"</span>, <span class="built_in">document</span>.querySelectorAll(<span class="string">'.expo'</span>))</span><br><span class="line">            <span class="comment">// eslint-disable-next-line semi-style</span></span><br><span class="line">            ;[].slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.expo'</span>)).forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">                observer.observe(el);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// window['myObserver'] = observer;</span></span><br><span class="line">            obRef.current = observer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">            obRef.current?.disconnect()</span><br><span class="line">            timerRef.current &amp;&amp; clearTimeout(timerRef.current);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span></span><br><span class="line">    &#125;, deps);</span><br></pre></td></tr></table></figure></p><!--## 其他[监听DOM曝光事件 IntersectionObserver](https://juejin.cn/post/6844903886013071373)[如何实现元素曝光上报](https://segmentfault.com/a/1190000019980376)[JavaScript 监听元素是否进入/移出可视区域](https://blog.csdn.net/latency_cheng/article/details/84963435)方案一：监听页面或者区域scroll事件，通过getBoundingClientRect接口取元素的位置与可视窗口进行判断。防抖节流优点：兼容性好缺点：需要关注页面或者区域的scroll事件频繁的scroll事件，性能问题IntersectionObserver方案二：通过 IntersectionObserver 监听元素是否处于可视范围实际上，针对兼容性问题，w3c 官方提供了对应 polyfill, 因此intersectionObserver用于生产是可行的。 --><h2 id="滚动监听"><a href="#滚动监听" class="headerlink" title="滚动监听"></a>滚动监听</h2><h1 id="点击埋点"><a href="#点击埋点" class="headerlink" title="点击埋点"></a>点击埋点</h1><h2 id="自动埋点"><a href="#自动埋点" class="headerlink" title="自动埋点"></a>自动埋点</h2><h3 id="web页面"><a href="#web页面" class="headerlink" title="web页面"></a>web页面</h3><p>document.addEventListener</p><h3 id="taro-小程序"><a href="#taro-小程序" class="headerlink" title="taro 小程序"></a>taro 小程序</h3><p>运行时注入事件监听<code>modifyDispatchEvent</code>。<br><!-- 通过`mergeReconciler` <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeReconciler &#125; <span class="keyword">from</span> <span class="string">"@tarojs/shared"</span>;</span><br><span class="line"></span><br><span class="line">mergeReconciler(&#123;</span><br><span class="line">    modifyDispatchEvent: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log("[Plugin-track]modify-Dispatch-Event", e);</span></span><br><span class="line">        <span class="keyword">if</span> (e.type === <span class="string">"tap"</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> dataset = e.currentTarget &amp;&amp; e.currentTarget.dataset;</span><br><span class="line">            <span class="keyword">const</span> eid = dataset.eid;</span><br><span class="line">            <span class="keyword">if</span> (!dataset || !eid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> eparam = dataset.eparam;</span><br><span class="line">            <span class="comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span></span><br><span class="line">            <span class="keyword">const</span> runtime = <span class="built_in">require</span>(<span class="string">"@tarojs/runtime"</span>);</span><br><span class="line">            <span class="keyword">const</span> event = <span class="keyword">new</span> runtime.TaroEvent(<span class="string">"tracks"</span>, &#123;</span><br><span class="line">                bubbles: <span class="literal">true</span>,</span><br><span class="line">                cancelable: <span class="literal">true</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                detail: &#123;</span><br><span class="line">                    eid,</span><br><span class="line">                    eparam</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            runtime.document.dispatchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>–&gt;</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useClick</span></span><br><span class="line">useEfect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleClkTrack = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> target = e.target;</span><br><span class="line">        <span class="comment">// console.log("[UseClick]. e:", e, target.dataset, e.mpEvent);</span></span><br><span class="line">        <span class="keyword">let</span> detail;</span><br><span class="line">        <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'h5'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> trackEle = getTargetEle(target);</span><br><span class="line">            <span class="keyword">if</span> (trackEle) &#123;</span><br><span class="line">                detail = trackEle.dataset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            detail = e.mpEvent?.detail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; eid, eparam &#125; = detail || &#123;&#125;;</span><br><span class="line">        track.clic(eid, eparam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> trackEventName = process.env.TARO_ENV === <span class="string">"h5"</span> ? <span class="string">'click'</span> : <span class="string">'tracks'</span>;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(trackEventName, handleClkTrack);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.removeEventListener(trackEventName, handleClkTrack);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="自动埋点-1"><a href="#自动埋点-1" class="headerlink" title="自动埋点"></a>自动埋点</h1><p>pv，function/click等。</p><p>零埋点：各个埋点/数据分析统计平台，百度等。</p><h2 id="代码方式"><a href="#代码方式" class="headerlink" title="代码方式"></a>代码方式</h2><h3 id="原生小程序"><a href="#原生小程序" class="headerlink" title="原生小程序"></a>原生小程序</h3><p># 21 <a href="https://juejin.cn/post/6844903766328606728">小程序从手动埋点到自动埋点</a></p><h4 id="1、通过事件冒泡监听元素是否被点击"><a href="#1、通过事件冒泡监听元素是否被点击" class="headerlink" title="1、通过事件冒泡监听元素是否被点击"></a>1、通过事件冒泡监听元素是否被点击</h4><p>小程序没有提供Dom的事件监听方法，不过我们可以通过事件冒泡的方式监听，在wxml最外层绑定catchtap事件获取点击元素的坐标，判断点击元素与监听目标的坐标是否相交触发记录。</p><h4 id="2、扩展Page方法"><a href="#2、扩展Page方法" class="headerlink" title="2、扩展Page方法"></a>2、扩展Page方法</h4><h4 id="3、对页面函数埋点"><a href="#3、对页面函数埋点" class="headerlink" title="3、对页面函数埋点"></a>3、对页面函数埋点</h4><p>PS: 生命周期。<br>#### 通过配置表设置埋点</p><p>完整的代码已经封装成SDK了，可以快速集成到项目 <a href="https://github.com/zhengguorong/xbosstrack-wechat">github地址</a><br><!-- END#21 --></p><h3 id="Taro小程序-生命周期"><a href="#Taro小程序-生命周期" class="headerlink" title="Taro小程序-生命周期"></a>Taro小程序-生命周期</h3><!-- \# 31 [taro微信小程序全埋点的思路与解决方案导向](http://www.wxappclub.com/topic/5300) --><!-- POST: 2023 --><p>思路<br>​ 我们要想要实现无侵入或低侵入的监控页面声明周期函数，对于原生的微信小程序，我们可以参考网上的一个现有解决方案：<a href>小程序从手动埋点到自动埋点</a>。<br><!-- PS: 见#21 --></p><p>​ 其实现原理主要是：通过代理微信小程序的Page方法，在用户传递进来的生命周期钩子函数外层包装一层wrapper函数，并在wrapper函数中实现统一数据上报的逻辑，然后再调用用户定义的声明周期钩子函数，这样，使用者便可以在无感知的情况下进行编码，所有的数据收集与上报操作都可以在这个wrapper函数中执行。</p><p>​ 然而，上述方案仅适用于原生微信小程序，在基于Taro开发的微信小程序项目中，由于在Taro中所有单元都是组件Component，而非Page,经过本人的反复试验，Taro在运行的过程中，并没有调用过Page方法,因此，通过代理微信原生Page方法这条路是行不通了。</p><p>​ 那么，既然在Taro中一切皆组件，我们能不能通过代理Component实现类似的逻辑呢？经过试验，这个想法是可行的，不过由于Component的生命周期钩子跟Page的生命周期钩子不一样，所以我们需要对其做一定的转化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写微信原生Page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">newPage</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">overrideWxPage</span>(<span class="params">newPage: any</span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  Page = newPage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要代理的生命周期钩子，包含Page和Component的钩子</span></span><br><span class="line"><span class="keyword">const</span> proxyMethods = [</span><br><span class="line">  <span class="string">"onShow"</span>,</span><br><span class="line">  <span class="string">"onHide"</span>,</span><br><span class="line">  <span class="string">"onReady"</span>,</span><br><span class="line">  <span class="string">"onLoad"</span>,</span><br><span class="line">  <span class="string">"onUnload"</span>,</span><br><span class="line">  <span class="string">"created"</span>,</span><br><span class="line">  <span class="string">"attached"</span>,</span><br><span class="line">  <span class="string">"ready"</span>,</span><br><span class="line">  <span class="string">"moved"</span>,</span><br><span class="line">  <span class="string">"detached"</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>Github: <a href="https://github.com/kiner-tang/taro-track" target="_blank" rel="noopener">taro-track</a></p><p>注：由于taro是第三方框架，版本升级不可控，因此，我们只是对特定个版本，如2.1.5进行兼容，其他版本尚未做兼容处理<br><!-- END#31 --><br>&lt;!–<br><a href="https://www.php.cn/faq/459905.html" target="_blank" rel="noopener">了解微信小程序 Taro 的自动埋点</a><br> POST: 2020-09-10 17:12:43</p><p>而在小程序中因为其和浏览器不同的架构，导致了监听页面变的更加困难，通常我们都会通过重写 Page 方法来达到对小程序原生生命周期的拦截代理，从而进行业务埋点，但是在 Taro 中这一切变得不同了。</p><p>想在小程序中进行自动的埋点，其实要做的就是在小程序指定的生命周期里做一些固定的处理，所以我们自动埋点的问题实际上是如何劫持小程序的生命周期，而要劫持小程序的生命周期，我们需要做的就是去重写options。<br> –&gt;<br>weapp-lifecycle-hook-plugin: npm插件。</p><p>PS: 以上两篇基于taro2.x。</p><h3 id="Taro小程序-事件"><a href="#Taro小程序-事件" class="headerlink" title="Taro小程序-事件"></a>Taro小程序-事件</h3><p># 30-a <a href="https://xie.infoq.cn/article/09b84bfd093476657a8f04cff" target="_blank" rel="noopener">Taro3 无埋点的探索与实践</a><br>这点在 Taro2 时期已经是实现完美适配的，但在 Taro3 之后，由于 Taro 团队对其整体架构的调整，使得之前的方式已经无法实现准确的无埋点，促使了本次探索。<br>&lt;!– </p><p>GrowingIO 小程序 SDK 无埋点功能的实现有两个核心问题：</p><ul><li>如何拦截到用户事件的触发方法</li><li>如何为节点生成一个唯一且稳定的标识符</li></ul><p>如果想处理掉已定义无埋点事件失效问题，那就必须能提供一个稳定的标识符。类比与在 Taro2 上的实现，如果也能在拦截到事件触发的时候获取到用户方法名，那就可以了。也就是说只要能把以下两个问题处理掉，便能实现这个目标了。</p><ul><li>运行时 SDK 能拦截用户方法</li><li>能在生产环境将用户方法名保留下来<br>结语<br>–&gt;<br>在 Taro3 无埋点功能的实现上，GrowingIO 小程序 SDK 从运行期和编译期同时下手，在运行期实现事件拦截，在编译期实现用户方法名的保留，以此实现较稳定的无埋点功能。具体的使用方式可见：<a href="https://github.com/growingio/growing-babel-plugin-setname/wiki/Taro3中集成GrowingIO小程序SDK" target="_blank" rel="noopener">Taro3中集成GrowingIO小程序SDK</a>。通过这次 Taro3 无埋点的支持，GrowingIO 小程序无埋点实现也从仅运行期的操作扩展到了编译期，这也是一种新的方式，未来也可能会在这个方向上继续优化，提供更稳定的无埋点功能。相关 Babel 插件以开源，仓库可见：<br><a href="https://github.com/growingio/growing-babel-plugin-setname" target="_blank" rel="noopener">growing-babel-plugin-setname</a></li></ul><p><code>npm install --dev babel-plugin-setname</code></p><blockquote><p>为匿名函数设置函数名</p></blockquote><!-- END#30s --><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p><a href="https://www.cnblogs.com/o2team/p/13259338.html" target="_blank" rel="noopener">小程序零开发埋点，就是这么简单！</a></p><blockquote><p>Taro 引入了腾讯有数的微信小程序无痕埋点能力，为 Taro 的开发者提供真·零开发的 8 大无痕埋点能力以及自定义埋点能力，包含小程序启动、显示、隐藏、页面浏览、页面离开、分享、下拉刷新、上拉触底等八大自动化埋点能力以及搜索、商品归因等定制化埋点，以及经营分析、直播分析、导购分析等能力，让你的小程序可以基于微信生态，串联全场景多触点，实现全域经营洞察。</p></blockquote><h1 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h1><!-- \#41 [利用好浏览器的空闲时间 --- requestIdleCallback](https://www.cnblogs.com/Wayou/p/requestIdleCallback.html) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intersection Observer API: &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/sum/js/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript-d.ts文件</title>
    <link href="http://yoursite.com/sum/jsplus/typescript-d.ts%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/sum/jsplus/typescript-d.ts文件/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:30:30.104Z</updated>
    
    <content type="html"><![CDATA[<p>typescript 声明文件介绍<!-- 历史 -->及使用</p><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h1 id="d-ts-介绍"><a href="#d-ts-介绍" class="headerlink" title="d.ts 介绍"></a>d.ts 介绍</h1><!-- \#1-S [一文读懂TS的(.d.ts)文件](https://juejin.cn/post/6987735091925483551)\#1-S [一文读懂TS的(.d.ts)文件](https://developer.aliyun.com/article/929847) --><h2 id="二、-什么是“-d-ts”-文件"><a href="#二、-什么是“-d-ts”-文件" class="headerlink" title="二、 什么是“.d.ts” 文件"></a>二、 什么是“.d.ts” 文件</h2><p>基于 Typescript 开发的时候，很麻烦的一个问题就是类型定义。导致在编译的时候，经常会看到一连串的找不到类型的提示。“d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息。<br>简单讲，就是你可以在 ts 中调用的 js 的声明文件。TS的核心在于静态类型，我们在编写 TS 的时候会定义很多的类型，但是主流的库都是 JS编写的，并不支持类型系统。这个时候你不能用TS重写主流的库，<strong>这个时候我们只需要编写仅包含类型注释的 d.ts 文件</strong>，然后从您的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的 TS 优势。</p><p>在此期间，解决的方式经过了许多的变化，从 DefinitelyTyped 到 typings。<strong>最后是 @types</strong>。在 Typescript 2.0 之后，推荐使用 @types 方式。</p><!-- ### 2.1 DefinitelyTyped### 2.2 Typings --><h3 id="2-3-Types"><a href="#2-3-Types" class="headerlink" title="2.3 @Types"></a>2.3 @Types</h3><!-- DefinitelyTyped和# Typings都需要使用另外一套系统来管理类型定义显然不太方便。 在 Typescript 2.0 之后，TypeScript 将会默认的查看 ./node_modules/@types 文件夹，自动从这里来获取模块的类型定义，当然了，你需要独立安装这个类型定义。Microsoft 在 The Future of Declaration Files 介绍了 TypeScript 的这个新特性。 --><p>默认情况下，所有的 @types 包都会在编译时应用，任意层的 node_modules/@types 都会被使用，进一步说，在  ./node_modules/@types/ , ../node_modules/@types/, ../../node_modules/@types/ 都被应用。如果你的类型定义不在这个文件夹中，可以使用 typesRoot 来配置，只有在 typeRoots 中的包才会被包含，配置如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">       <span class="string">"types"</span> : [<span class="string">"node"</span>, <span class="string">"lodash"</span>, <span class="string">"express"</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-d-ts和-types关系"><a href="#2-4-d-ts和-types关系" class="headerlink" title="2.4 *.d.ts和@types关系"></a>2.4 *.d.ts和@types关系</h4><p>@types是npm的一个分支，用来存放<em>.d.ts文件，如果对应的npm包存放在@types中，要使用必须下载！如果是自己本地的</em>.d.ts申明文件，则和@types没有任何关系！<br><!-- \## 三、 编写语法\## 四、案例五、常用工具参考--></p><!-- END#1 --><h1 id="第三方库的声明文件"><a href="#第三方库的声明文件" class="headerlink" title="第三方库的声明文件"></a>第三方库的声明文件</h1><!-- \#2 [Typescript入门教程-声明文件](https://ts.xcatliu.com/basics/declaration-files.html#发布声明文件) --><p>## 什么是声明语句§<br>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。</p><p>## 什么是声明文件§<br>通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件3</p><p>### 第三方声明文件§<br>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。</p><p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：<br><code>npm install @types/jquery --save-dev</code></p><p>## 书写声明文件§<br><!-- 当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。 --></p><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><!-- 库的使用场景主要有以下几种：全局变量：通过 `<script>` 标签引入第三方库，注入全局变量npm 包：通过 import foo from 'foo' 导入，符合 ES6 模块规范UMD 库：既可以通过 <`script>` 标签引入，又可以通过 `import` 导入直接扩展全局变量：通过 `<script>` 标签引入后，改变一个全局变量的结构在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构模块插件：通过 `<script>` 或 `import` 导入后，改变另一个模块的结构\## 发布声明文件\### 将声明文件和源码放在一起1) 如果声明文件是通过 tsc 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。2) 如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：* 给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址* 在项目根目录下，编写一个 index.d.ts 文件* 针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件\### 将声明文件发布到 @types 下 --><h1 id="声明文件文档"><a href="#声明文件文档" class="headerlink" title="声明文件文档"></a>声明文件文档</h1><p><a href="https://www.tslang.cn/docs/handbook/declaration-files/library-structures.html" target="_blank" rel="noopener">typescript文档-声明文件</a></p><h2 id="识别库的类型"><a href="#识别库的类型" class="headerlink" title="识别库的类型"></a>识别库的类型</h2><h3 id="全局库"><a href="#全局库" class="headerlink" title="全局库"></a>全局库</h3><h3 id="模块化库"><a href="#模块化库" class="headerlink" title="模块化库"></a>模块化库</h3><h3 id="使用依赖"><a href="#使用依赖" class="headerlink" title="使用依赖"></a>使用依赖</h3><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>防止命名冲突</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;typescript 声明文件介绍&lt;!-- 历史 --&gt;及使用&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:23:16.227Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript</a><br><a href="https://www.typescriptlang.org/zh/docs/" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/</a></p><!-- typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.htmltypescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.htmlPS: 简介，基础，进阶，工程，感谢。 --><p>TypeScript: 静态类型检查器</p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h1 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h1><p>Quick introductions based on your background or preference.</p><p>TS for the New Programmer<br>TypeScript for JS Programmers<br>TS for Java/C# Programmers<br>TS for Functional Programmers<br>TypeScript Tooling in 5 minutes</p><h1 id="Handbook"><a href="#Handbook" class="headerlink" title="Handbook"></a>Handbook</h1><p>A great first read for your daily TS work.</p><h2 id="The-TypeScript-Handbook"><a href="#The-TypeScript-Handbook" class="headerlink" title="The TypeScript Handbook"></a>The TypeScript Handbook</h2><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><h2 id="More-on-Functions"><a href="#More-on-Functions" class="headerlink" title="More on Functions"></a>More on Functions</h2><h2 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h2><h2 id="Type-Manipulation"><a href="#Type-Manipulation" class="headerlink" title="Type Manipulation"></a>Type Manipulation</h2><p>Creating Types from Types<br>Generics<br>Keyof Type Operator<br>Typeof Type Operator<br>Indexed Access Types<br>Conditional Types<br>Mapped Types<br>Template Literal Types</p><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><p>Using TypeScript in several environments.</p><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><h2 id="DOM-Manipulation"><a href="#DOM-Manipulation" class="headerlink" title="DOM Manipulation"></a>DOM Manipulation</h2><h2 id="Migrating-from-JavaScript"><a href="#Migrating-from-JavaScript" class="headerlink" title="Migrating from JavaScript"></a>Migrating from JavaScript</h2><h2 id="Using-Babel-with-TypeScript"><a href="#Using-Babel-with-TypeScript" class="headerlink" title="Using Babel with TypeScript"></a>Using Babel with TypeScript</h2><h1 id="Declaration-Files"><a href="#Declaration-Files" class="headerlink" title="Declaration Files"></a>Declaration Files</h1><p>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Declaration-Reference"><a href="#Declaration-Reference" class="headerlink" title="Declaration Reference"></a>Declaration Reference</h2><h2 id="Library-Structures"><a href="#Library-Structures" class="headerlink" title="Library Structures"></a>Library Structures</h2><h2 id="d-ts-Templates"><a href="#d-ts-Templates" class="headerlink" title=".d.ts Templates"></a>.d.ts Templates</h2><p>Modules .d.ts<br>Module: Plugin<br>Module: Class<br>Module: Function<br>Global .d.ts<br>Global: Modifying Module</p><h2 id="Do’s-and-Don’ts"><a href="#Do’s-and-Don’ts" class="headerlink" title="Do’s and Don’ts"></a>Do’s and Don’ts</h2><h2 id="Deep-Dive"><a href="#Deep-Dive" class="headerlink" title="Deep Dive"></a>Deep Dive</h2><h2 id="Publishing"><a href="#Publishing" class="headerlink" title="Publishing"></a>Publishing</h2><h2 id="Consumption"><a href="#Consumption" class="headerlink" title="Consumption"></a>Consumption</h2><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>How to use TypeScript-powered JavaScript tooling.</p><h2 id="JS-Projects-Utilizing-TypeScript"><a href="#JS-Projects-Utilizing-TypeScript" class="headerlink" title="JS Projects Utilizing TypeScript"></a>JS Projects Utilizing TypeScript</h2><h2 id="Type-Checking-JavaScript-Files"><a href="#Type-Checking-JavaScript-Files" class="headerlink" title="Type Checking JavaScript Files"></a>Type Checking JavaScript Files</h2><h2 id="JSDoc-Reference"><a href="#JSDoc-Reference" class="headerlink" title="JSDoc Reference"></a>JSDoc Reference</h2><h2 id="Creating-d-ts-Files-from-js-files"><a href="#Creating-d-ts-Files-from-js-files" class="headerlink" title="Creating .d.ts Files from .js files"></a>Creating .d.ts Files from .js files</h2><h1 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h1><p>Compiler configuration reference.</p><h2 id="What-is-a-tsconfig-json"><a href="#What-is-a-tsconfig-json" class="headerlink" title="What is a tsconfig.json"></a>What is a tsconfig.json</h2><h2 id="Compiler-Options-in-MSBuild"><a href="#Compiler-Options-in-MSBuild" class="headerlink" title="Compiler Options in MSBuild"></a>Compiler Options in MSBuild</h2><h2 id="TSConfig-Reference"><a href="#TSConfig-Reference" class="headerlink" title="TSConfig Reference"></a>TSConfig Reference</h2><h2 id="tsc-CLI-Options"><a href="#tsc-CLI-Options" class="headerlink" title="tsc CLI Options"></a>tsc CLI Options</h2><h2 id="Project-References"><a href="#Project-References" class="headerlink" title="Project References"></a>Project References</h2><h2 id="Integrating-with-Build-Tools"><a href="#Integrating-with-Build-Tools" class="headerlink" title="Integrating with Build Tools"></a>Integrating with Build Tools</h2><h2 id="Configuring-Watch"><a href="#Configuring-Watch" class="headerlink" title="Configuring Watch"></a>Configuring Watch</h2><h2 id="Nightly-Builds"><a href="#Nightly-Builds" class="headerlink" title="Nightly Builds"></a>Nightly Builds</h2><h1 id="Cheat-Sheets"><a href="#Cheat-Sheets" class="headerlink" title="Cheat Sheets"></a>Cheat Sheets</h1><p><strong>Downloadable</strong> syntax reference pages for different parts of everyday TypeScript code.</p><h2 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h2><h2 id="Classes-1"><a href="#Classes-1" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h2 id="Download-PDFs-and-PNGs"><a href="#Download-PDFs-and-PNGs" class="headerlink" title="Download PDFs and PNGs"></a>Download PDFs and PNGs</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Microsoft/TypeScript&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/&lt;/a&gt;&lt;/p&gt;
&lt;!-- 
typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.html

typescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.html
PS: 简介，基础，进阶，工程，感谢。
 --&gt;
&lt;p&gt;TypeScript: 静态类型检查器&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档1-Get Started</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A31-Get%20Started/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档1-Get Started/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:25:27.993Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="TypeScript-for-the-New-Programmer"><a href="#TypeScript-for-the-New-Programmer" class="headerlink" title="TypeScript for the New Programmer"></a>TypeScript for the New Programmer</h2><p>JavaScript 的类型化超集</p><p>不过，TypeScript 与 JavaScript 是什么关系呢？</p><p>语法<br>TypeScript 是 JavaScript 的 超集 ：因此 JS 语法是合法的 TS。&lt;!– 语法是指我们编写文本以组成程序的方式。例如，这段代码有一个 语法 错误，因为它缺少一个 )：</p><p>类型<br>但是，TypeScript 是一个 类型化 的超集，意味着它添加了针对如何使用不同类型的值的规则。<!-- 之前关于 obj.heigth 的错误不是 语法 错误，而是以不正确的方式使用了某种值（ 类型 ）。 --></p><p>运行时行为<br>TypeScript 保留了 JavaScript 的 运行时行为 。<!-- 例如，在JavaScript 中被零除的结果是 Infinity，而不是抛出运行时异常。 -->原则上，TypeScript 绝不 改变 JavaScript 代码的运行时行为。</p><!-- 这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以 保证 以相同的方式运行。 --><p>擦除类型<br>粗略地说，一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码<!-- 。这意味着一旦您的代码被编译，生成的普通 JS 代码便没有类型信息。 --><br><!-- 这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为 。最重要的是，尽管您可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 --></p><h2 id="TypeScript-for-JavaScript-Programmers"><a href="#TypeScript-for-JavaScript-Programmers" class="headerlink" title="TypeScript for JavaScript Programmers"></a>TypeScript for JavaScript Programmers</h2><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><!-- 通过感知 JavaScript 的工作原理，TypeScript 可以构建一个接受 JavaScript 代码但具有类型的类型系统。这个类型系统使得我们不需要添加额外的字符来显式地指定类型。在上面的例子中，TypeScript就是这样知道 helloWorld 是 string 类型的。你可能已经在 Visual Studio Code 中编写了 JavaScript，并已使用了编辑器的自动补全功能。Visual Studio Code 使用了 TypeScript 的引擎，以便更容易地处理 JavaScript。 --><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><p>JavaScript 中已经有一些基本类型可用：boolean、 bigint、 null、number、 string、 symbol 和 undefined，它们都可以在接口中使用。TypeScript 将此列表扩展为更多的内容，例如 any （允许任何类型）、unknown （确保使用此类型的人声明类型是什么）、 never （这种类型不可能发生）和 void （返回 undefined 或没有返回值的函数）。</p><p>构建类型有两种语法： 接口和类型。 你应该更喜欢 interface。当需要特定功能时使用 type 。</p><h3 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h3><!-- 使用 TypeScript，可以通过组合简单类型来创建复杂类型。 -->有两种流行的方法可以做到这一点：联合和泛型。<br>#### 联合<br>使用联合，可以声明类型可以是许多类型中的一种。<br>#### 泛型<br>泛型为类型提供变量。一个常见的例子是数组。没有泛型的数组可以包含任何内容。带有泛型的数组可以描述数组包含的值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringArray = <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> NumberArray = <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> ObjectWithNameArray = <span class="built_in">Array</span>&lt;&#123; name: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 声明自己使用泛型的类型</span></span><br><span class="line"><span class="keyword">interface</span> Backpack&lt;Type&gt; &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">obj: Type</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> Type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这一行是一个简写，可以告诉 TypeScript 有一个常量，叫做`backpack`，并且不用担心它是从哪</span></span><br><span class="line"><span class="comment">// 里来的。</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> backpack: Backpack&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// 对象是一个字符串，因为我们在上面声明了它作为 Backpack 的变量部分。</span></span><br><span class="line"><span class="keyword">const</span> object = backpack.get();</span><br><span class="line"><span class="comment">// 因为 backpack 变量是一个字符串，不能将数字传递给 add 函数。</span></span><br><span class="line">backpack.add(<span class="number">23</span>);</span><br><span class="line"><span class="comment">// Argument of type 'number' is not assignable to parameter of type 'string'.</span></span><br></pre></td></tr></table></figure><h3 id="结构化的类型系统（structural-type-system）"><a href="#结构化的类型系统（structural-type-system）" class="headerlink" title="结构化的类型系统（structural type system）"></a>结构化的类型系统（structural type system）</h3><p>TypeScript 的一个核心原则是类型检查基于对象的属性和行为（type checking focuses on the shape that values have）。<!-- 这有时被叫做“鸭子类型”或“结构类型”（structural typing）。 --></p><p>在结构化的类型系统当中，如果两个对象具有相同的结构，则认为它们是相同类型的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档2-Handbook</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A32-Handbook/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档2-Handbook/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T16:42:30.247Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/intro.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/intro.html</a><br><a href="https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="The-TypeScript-Handbook"><a href="#The-TypeScript-Handbook" class="headerlink" title="The TypeScript Handbook"></a>The TypeScript Handbook</h2><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h3 id="Static-type-checking"><a href="#Static-type-checking" class="headerlink" title="Static type-checking"></a>Static type-checking</h3><h3 id="Non-exception-Failures"><a href="#Non-exception-Failures" class="headerlink" title="Non-exception Failures"></a>Non-exception Failures</h3><h3 id="Types-for-Tooling"><a href="#Types-for-Tooling" class="headerlink" title="Types for Tooling"></a>Types for Tooling</h3><h3 id="tsc-the-TypeScript-compiler"><a href="#tsc-the-TypeScript-compiler" class="headerlink" title="tsc, the TypeScript compiler"></a>tsc, the TypeScript compiler</h3><h3 id="Emitting-with-Errors"><a href="#Emitting-with-Errors" class="headerlink" title="Emitting with Errors"></a>Emitting with Errors</h3><h3 id="Explicit-Types"><a href="#Explicit-Types" class="headerlink" title="Explicit Types"></a>Explicit Types</h3><h3 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h3><h3 id="Downleveling"><a href="#Downleveling" class="headerlink" title="Downleveling"></a>Downleveling</h3><h3 id="Strictness"><a href="#Strictness" class="headerlink" title="Strictness"></a>Strictness</h3><h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><h3 id="The-primitives-string-number-and-boolean"><a href="#The-primitives-string-number-and-boolean" class="headerlink" title="The primitives: string, number, and boolean"></a>The primitives: string, number, and boolean</h3><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><h4 id="noImplicitAny-1"><a href="#noImplicitAny-1" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h4><h3 id="Type-Annotations-on-Variables"><a href="#Type-Annotations-on-Variables" class="headerlink" title="Type Annotations on Variables"></a>Type Annotations on Variables</h3><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="Parameter-Type-Annotations"><a href="#Parameter-Type-Annotations" class="headerlink" title="Parameter Type Annotations"></a>Parameter Type Annotations</h4><h4 id="Return-Type-Annotations"><a href="#Return-Type-Annotations" class="headerlink" title="Return Type Annotations"></a>Return Type Annotations</h4><h4 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h4><h3 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h3><h4 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h4><h3 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h3><h4 id="Defining-a-Union-Type"><a href="#Defining-a-Union-Type" class="headerlink" title="Defining a Union Type"></a>Defining a Union Type</h4><h4 id="Working-with-Union-Types"><a href="#Working-with-Union-Types" class="headerlink" title="Working with Union Types"></a>Working with Union Types</h4><h3 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h3><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><h3 id="Differences-Between-Type-Aliases-and-Interfaces"><a href="#Differences-Between-Type-Aliases-and-Interfaces" class="headerlink" title="Differences Between Type Aliases and Interfaces"></a>Differences Between Type Aliases and Interfaces</h3><h3 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h3><h3 id="Literal-Types"><a href="#Literal-Types" class="headerlink" title="Literal Types"></a>Literal Types</h3><h3 id="Literal-Inference"><a href="#Literal-Inference" class="headerlink" title="Literal Inference"></a>Literal Inference</h3><h3 id="null-and-undefined"><a href="#null-and-undefined" class="headerlink" title="null and undefined"></a>null and undefined</h3><h4 id="strictNullChecks-off"><a href="#strictNullChecks-off" class="headerlink" title="strictNullChecks off"></a>strictNullChecks off</h4><h4 id="strictNullChecks-on"><a href="#strictNullChecks-on" class="headerlink" title="strictNullChecks on"></a>strictNullChecks on</h4><h4 id="Non-null-Assertion-Operator-Postfix"><a href="#Non-null-Assertion-Operator-Postfix" class="headerlink" title="Non-null Assertion Operator (Postfix !)"></a>Non-null Assertion Operator (Postfix !)</h4><h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><h3 id="Less-Common-Primitives"><a href="#Less-Common-Primitives" class="headerlink" title="Less Common Primitives"></a>Less Common Primitives</h3><h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><h2 id="More-on-Functions"><a href="#More-on-Functions" class="headerlink" title="More on Functions"></a>More on Functions</h2><h2 id="Object-Types-1"><a href="#Object-Types-1" class="headerlink" title="Object Types"></a>Object Types</h2><h2 id="Type-Manipulation"><a href="#Type-Manipulation" class="headerlink" title="Type Manipulation"></a>Type Manipulation</h2><p>Creating Types from Types<br>Generics<br>Keyof Type Operator<br>Typeof Type Operator<br>Indexed Access Types<br>Conditional Types<br>Mapped Types<br>Template Literal Types</p><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/intro.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档6-Declaration Files</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A36-Declaration%20Files/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档6-Declaration Files/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T16:42:35.202Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><p><a href="https://juejin.cn/post/6987735091925483551" target="_blank" rel="noopener">一文读懂TS的(.d.ts)文件</a></p><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Declaration-Reference"><a href="#Declaration-Reference" class="headerlink" title="Declaration Reference"></a>Declaration Reference</h2><h2 id="Library-Structures"><a href="#Library-Structures" class="headerlink" title="Library Structures"></a>Library Structures</h2><h2 id="d-ts-Templates"><a href="#d-ts-Templates" class="headerlink" title=".d.ts Templates"></a>.d.ts Templates</h2><p>Modules .d.ts<br>Module: Plugin<br>Module: Class<br>Module: Function<br>Global .d.ts<br>Global: Modifying Module</p><h2 id="Do’s-and-Don’ts"><a href="#Do’s-and-Don’ts" class="headerlink" title="Do’s and Don’ts"></a>Do’s and Don’ts</h2><h2 id="Deep-Dive"><a href="#Deep-Dive" class="headerlink" title="Deep Dive"></a>Deep Dive</h2><h2 id="Publishing"><a href="#Publishing" class="headerlink" title="Publishing"></a>Publishing</h2><h2 id="Consumption"><a href="#Consumption" class="headerlink" title="Consumption"></a>Consumption</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6987735091925483551&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一文读懂TS的(.d.ts)文件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档7-JavaScript</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A37-JavaScript/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档7-JavaScript/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:29:41.670Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><!-- # JavaScript --><p>How to use TypeScript-powered JavaScript tooling.</p><h2 id="JS-Projects-Utilizing-TypeScript"><a href="#JS-Projects-Utilizing-TypeScript" class="headerlink" title="JS Projects Utilizing TypeScript"></a>JS Projects Utilizing TypeScript</h2><p>The type system in TypeScript has different levels of strictness when working with a codebase:</p><p>A type-system based only on inference with JavaScript code</p><ul><li>Incremental typing in JavaScript via JSDoc</li><li>Using // @ts-check in a JavaScript file</li><li>TypeScript code</li><li>TypeScript with strict enabled<br>Each step represents a move towards a safer type-system, but not every project needs that level of verification.<h3 id="TypeScript-with-JavaScript"><a href="#TypeScript-with-JavaScript" class="headerlink" title="TypeScript with JavaScript"></a>TypeScript with JavaScript</h3><h3 id="Providing-Type-Hints-in-JS-via-JSDoc"><a href="#Providing-Type-Hints-in-JS-via-JSDoc" class="headerlink" title="Providing Type Hints in JS via JSDoc"></a>Providing Type Hints in JS via JSDoc</h3>In a .js file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.</li></ul><p>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// OK?!</span></span><br></pre></td></tr></table></figure><h3 id="ts-check"><a href="#ts-check" class="headerlink" title="@ts-check"></a>@ts-check</h3><!-- The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project.  -->To enable errors in your JavaScript files add: <code>// @ts-check</code> to the first line in your .js files to have TypeScript raise it as an error.<br><br>If you have a lot of JavaScript files you want to add errors to then you can switch to using a <a href>jsconfig.json</a>. You can skip checking some files by adding a <code>// @ts-nocheck</code> comment to files.<br><br>TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding <code>// @ts-ignore</code> or<code>// @ts-expect-error</code>on the preceding line.<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// Not OK</span></span><br><span class="line"><span class="comment">// Type 'boolean' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// Not OK</span></span><br></pre></td></tr></table></figure><h2 id="Type-Checking-JavaScript-Files"><a href="#Type-Checking-JavaScript-Files" class="headerlink" title="Type Checking JavaScript Files"></a>Type Checking JavaScript Files</h2><h2 id="JSDoc-Reference"><a href="#JSDoc-Reference" class="headerlink" title="JSDoc Reference"></a>JSDoc Reference</h2><p>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</p><!-- Note any tags which are not explicitly listed below (such as @async) are not yet supported. --><h2 id="Creating-d-ts-Files-from-js-files"><a href="#Creating-d-ts-Files-from-js-files" class="headerlink" title="Creating .d.ts Files from .js files"></a>Creating .d.ts Files from .js files</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档8-Project Configuration</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A38-Project%20Configuration/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档8-Project Configuration/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T16:42:27.006Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/tsconfig-json.html</a><br><a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a></p><!-- typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.htmltypescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.htmlPS: 简介，基础，进阶，工程，感谢。 --><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><p>Compiler configuration reference.</p><h2 id="What-is-a-tsconfig-json"><a href="#What-is-a-tsconfig-json" class="headerlink" title="What is a tsconfig.json"></a>What is a tsconfig.json</h2><h2 id="Compiler-Options-in-MSBuild"><a href="#Compiler-Options-in-MSBuild" class="headerlink" title="Compiler Options in MSBuild"></a>Compiler Options in MSBuild</h2><h2 id="TSConfig-Reference"><a href="#TSConfig-Reference" class="headerlink" title="TSConfig Reference"></a>TSConfig Reference</h2><h2 id="tsc-CLI-Options"><a href="#tsc-CLI-Options" class="headerlink" title="tsc CLI Options"></a>tsc CLI Options</h2><h2 id="Project-References"><a href="#Project-References" class="headerlink" title="Project References"></a>Project References</h2><h2 id="Integrating-with-Build-Tools"><a href="#Integrating-with-Build-Tools" class="headerlink" title="Integrating with Build Tools"></a>Integrating with Build Tools</h2><h2 id="Configuring-Watch"><a href="#Configuring-Watch" class="headerlink" title="Configuring Watch"></a>Configuring Watch</h2><h2 id="Nightly-Builds"><a href="#Nightly-Builds" class="headerlink" title="Nightly Builds"></a>Nightly Builds</h2><h1 id="typescript文档-项目配置"><a href="#typescript文档-项目配置" class="headerlink" title="typescript文档-项目配置"></a>typescript文档-项目配置</h1><p>typescript文档-项目配置：<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a></p><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><h2 id="错误信息列表"><a href="#错误信息列表" class="headerlink" title="错误信息列表"></a>错误信息列表</h2><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h2 id="项目引用"><a href="#项目引用" class="headerlink" title="项目引用"></a>项目引用</h2><h2 id="MSBuild编译选项"><a href="#MSBuild编译选项" class="headerlink" title="MSBuild编译选项"></a>MSBuild编译选项</h2><h2 id="构建工具集成"><a href="#构建工具集成" class="headerlink" title="构建工具集成"></a>构建工具集成</h2><h2 id="每日构建"><a href="#每日构建" class="headerlink" title="每日构建"></a>每日构建</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.tslang.cn/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tslang.cn/docs/handbook/tsconfig-json.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 
typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.html

typescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.html
PS: 简介，基础，进阶，工程，感谢。
 --&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript使用记录</title>
    <link href="http://yoursite.com/sum/jsplus/typescript%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/sum/jsplus/typescript使用记录/</id>
    <published>2023-02-18T00:00:00.000Z</published>
    <updated>2023-08-20T15:19:47.380Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2023.2.18 星期六 </p><ol><li><p>忽略报错提示</p><blockquote><p>Using a @ts-ignore comment to silence the error </p><!-- `/* tslint:disable:no-unused-variable */`PS: 上面指定报错类型去忽略无效 --></blockquote></li><li><p><code>Property &#39;xxx&#39; does not exist on type YYY</code><br>1、将对象设置成 any <code>item:any</code><br>2、通过字符方式获取对象属性 <code>item[&quot;articleId&quot;]</code><br>3、声明断言，强制执行 <code>(item as any).articleId == val;</code></p><!-- > 是因为Typescript在执行代码检查时在该对象没有定义相应属性，遇到该错误有以下几种解决办法。 --></li></ol><ol start="3"><li>未使用的变量配置。包括定义和函数<!-- [tslint how to disable error "someVariable is declared but its value is never read"](https://stackoverflow.com/questions/50011443/tslint-how-to-disable-error-somevariable-is-declared-but-its-value-is-never-rea) -->eslint.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="comment">// "noUnusedLocals": false,</span></span><br><span class="line">        <span class="comment">// 'no-unused-vars': 'off',</span></span><br><span class="line">        <span class="string">'@typescript-eslint/no-unused-vars'</span>: [<span class="string">'error'</span>, </span><br><span class="line">            &#123; <span class="string">'varsIgnorePattern'</span>: <span class="string">'^_'</span>, <span class="string">"argsIgnorePattern"</span>: <span class="string">"e|error|args|param"</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'@typescript-eslint/naming-convention'</span>: [</span><br><span class="line">            <span class="string">'error'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'variable'</span>,</span><br><span class="line">                format: [<span class="string">'camelCase'</span>, <span class="string">'PascalCase'</span>, <span class="string">'UPPER_CASE'</span>],</span><br><span class="line">                leadingUnderscore: <span class="string">'allow'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'function'</span>,</span><br><span class="line">                format: [<span class="string">'camelCase'</span>, <span class="string">'PascalCase'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'typeLike'</span>,</span><br><span class="line">                format: [<span class="string">'PascalCase'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>PS: 需要把tsconfog.json中的开关也关掉<!-- （如果是ture上面的配置不会生效） -->。<br>tsconfig.json<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"noUnusedLocals"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"noUnusedParameters"</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>setTimeout 定时器类型定义。<!-- [TypeScript - use correct version of setTimeout (node vs window)](https://stackoverflow.com/questions/45802988/typescript-use-correct-version-of-settimeout-node-vs-window) --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ## 1 number 报错:  `TS2322: Type 'Timer' is not assignable to type 'number'.`</span></span><br><span class="line"><span class="keyword">let</span> n: number; </span><br><span class="line"><span class="comment">// ## 2 NodeJS.Timeout 可以运行</span></span><br><span class="line"><span class="keyword">let</span> n: NodeJS.Timeout;</span><br><span class="line"><span class="comment">// ## 3 ReturnType 最佳。</span></span><br><span class="line"><span class="keyword">let</span> timer: ReturnType&lt;<span class="keyword">typeof</span> setTimeout&gt; = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; ... &#125;);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>By using ReturnType<code>&lt;fn&gt;</code> you are getting independence from platform. You won’t be forced to use neither any nor window.setTimeout which will break if you run the code on nodeJS server (eg. server-side rendered page).</p></blockquote><p>#### 原因定位<br><a href="https://www.jianshu.com/p/6421f2a884fe" target="_blank" rel="noopener">Typescript 给setTimeout 的返回值定义为 number出错</a><br><a href="https://blog.csdn.net/weixin_42369598/article/details/125000346" target="_blank" rel="noopener">Typescript 给setTimeout 的返回值定义为 number出错</a></p><p>通过 cmd + 点击定位，发现setTimeout使用的是 Node.js 下的接口定义<code>@types/node index.d.ts</code><br>通过yarn.lock定位依赖，发现来源于<code>@types/react-dom</code></p><p>而在typescript中，window下的setTimeout返回的是number：</p><p>解决：<br>移除对@type/node的依赖(不太可行)<br>使用window.setTimeout</p><p>#### taro内结合useRef 使用</p><ol><li>不用any去定义</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ## 定义</span></span><br><span class="line"><span class="comment">// ### 1 直接定义，</span></span><br><span class="line"><span class="keyword">const</span> timerRef = useRef&lt;ReturnType&lt;<span class="keyword">typeof</span> setTimeout&gt;&gt;(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// ### 2 也可以先定义类型</span></span><br><span class="line">type Timer = ReturnType&lt;<span class="keyword">typeof</span> setTimeout&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 赋值时报错： `Cannot assign to 'current' because it is a read-only property.ts(2540)` 。 解决：需要添加null 类型</span></span><br><span class="line">timerRef.current = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 3 正确的定义</span></span><br><span class="line"><span class="keyword">const</span> timerRef = useRef&lt;ReturnType&lt;<span class="keyword">typeof</span> setTimeout&gt; | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><!-- [TS中的内置条件类型：ReturnType](https://juejin.cn/post/7151669172970192904) --><p>内置条件类型：ReturnType<code>&lt;Type&gt;</code></p><p>其他内置的条件类型还有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ts复制代码Exclude&lt;T, U&gt; -- 从T中剔除可以赋值给U的类型。</span><br><span class="line">Extract&lt;T, U&gt; -- 提取T中可以赋值给U的类型。</span><br><span class="line">NonNullable&lt;T&gt; -- 从T中剔除null和undefined。</span><br><span class="line">InstanceType&lt;T&gt; -- 获取构造函数类型的实例类型。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2023.2.18 星期六 &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;忽略报错提示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a @ts-ignore comment to silence the error &lt;/p&gt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
</feed>
