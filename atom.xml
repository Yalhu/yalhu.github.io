<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yalhu</title>
  
  <subtitle>yalhu&#39;s blob</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-21T15:41:24.222Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yalhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Orm了解</title>
    <link href="http://yoursite.com/sum/others/orm%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/sum/others/orm了解/</id>
    <published>2021-02-21T00:00:00.000Z</published>
    <updated>2021-02-21T15:41:24.222Z</updated>
    
    <content type="html"><![CDATA[<p>Sequelize是一个基于promise的nodejs ORM，目前支持Postgres、mysql、SQLite和Microsoft SQL Server。<br>它具有强大的事务支持，关联关系，读取和复制等功能。</p><p style="text-align:right">2021.2.21 星期日</p><!-- [基于Koa2框架的项目搭建及实战开发](https://www.cnblogs.com/zjknb/p/12149420.html) --><!-- $_PS: 用了Sequelize --><!-- \# [ORM是什么？如何理解ORM](https://www.cnblogs.com/huanhang/p/6054908.html) --><p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。<!-- 那么，到底如何实现持久化呢？一种简单的方案是采用硬编码方式，为每一种可能的数据库访问操作提供单独的方法。  --><br>ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。<br>ORM技术特点：<br>1.提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。<br>2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。 </p><p>三、ORM的优缺点<br>ORM的缺点是会牺牲程序的执行效率和会固定思维模式。<br>从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。<br><!-- 在我们开发系统时，一般都有性能问题。性能问题主要产生在算法不正确和与数据库不正确的使用上。ORM所生成的代码一般不太可能写出很高效的算法，在数据库应用上更有可能会被误用，主要体现在对持久对象的提取和和数据的加工处理上，如果用上了ORM,程序员很有可能将全部的数据提取到内存对象中，然后再进行过滤和加工处理，这样就容易产生性能问题。  --><br>在对对象做持久化时，ORM一般会持久化所有的属性，有时，这是不希望的。<br>但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。但我们不能指望工具能一劳永逸的解决所有问题，有些问题还是需要特殊处理的，但需要特殊处理的部分对绝大多数的系统，应该是很少的。</p><!-- \#[什么是ORM？为什么要用ORM？](https://blog.csdn.net/u010947534/article/details/90669452) --><p>为什么要做持久化和ORM设计(重要)<br>在目前的企业应用系统设计中，MVC，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。MVC 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如 JDBC的连接、SQL生成和Statement创建、还有ResultSet结果集的读取等）等。将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。MVC 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 ORM 作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。</p><p><a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html" target="_blank" rel="noopener">ORM 实例教程-ryf</a><br><!-- 面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能使用面向对象编程，来操作关系型数据库。 --><br><!-- 简单说， -->ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是”对象-关系映射”（Object/Relational Mapping） 的缩写。</p><p>一比较就可以发现，ORM 使用对象，封装了数据库操作，因此可以不碰 SQL 语言。开发者只使用面向对象编程，与数据对象直接交互，不用关心底层数据库。<br>&lt;!– 总结起来，ORM 有下面这些优点。<br>数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。<br>ORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。<br>它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。<br>基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。<br>你不必编写性能不佳的 SQL。</p><p>但是，ORM 也有很突出的缺点。<br>ORM 库不是轻量级工具，需要花很多精力学习和设置。<br>对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。<br>ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。<br> –&gt;</p><!-- Comment --><p>实用，现在 Node.js 使用最广泛的 ORM 库应该是 sequelize<br>sequelize 太重了，openrecord 就很轻量级。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sequelize是一个基于promise的nodejs ORM，目前支持Postgres、mysql、SQLite和Microsoft SQL Server。&lt;br&gt;它具有强大的事务支持，关联关系，读取和复制等功能。&lt;/p&gt;
&lt;p style=&quot;text-align:ri
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
  </entry>
  
  <entry>
    <title>Sonarqube了解</title>
    <link href="http://yoursite.com/sum/others/sonarqube%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/sum/others/sonarqube了解/</id>
    <published>2021-02-09T00:00:00.000Z</published>
    <updated>2021-02-21T15:24:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>SonarQube Documentation: <a href="https://docs.sonarqube.org/latest/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/</a></p><p style="text-align:right"> 2021.2.9 星期  ： </p><h2 id="Architecture-and-Integration"><a href="#Architecture-and-Integration" class="headerlink" title="Architecture and Integration"></a>Architecture and Integration</h2><p><a href="https://docs.sonarqube.org/latest/architecture/architecture-integration/" target="_blank" rel="noopener">Architecture and Integration</a><br><!-- [sonarqube代码质量检查简单使用说明](https://www.cnblogs.com/echo-valley/p/11868115.html) --></p><h3 id="架构画介绍"><a href="#架构画介绍" class="headerlink" title="架构画介绍"></a>架构画介绍</h3><p>一台SonarQube Server启动3个主要过程：</p><p>Web服务器，供开发人员，管理人员浏览高质量的快照并配置SonarQube实例<br>基于Elasticsearch的Search Server从UI进行后退搜索<br>Compute Engine服务器，负责处理代码分析报告并将其保存在SonarQube数据库中<br>一个SonarQube数据库要存储：</p><p>SonarQube实例的配置（安全性，插件设置等）<br>项目，视图等的质量快照。<br>服务器上安装了多个SonarQube插件，可能包括语言，SCM，集成，身份验证和管理插件<br>在构建/持续集成服务器上运行一个或多个SonarScanner，以分析项目</p><h3 id="2-0二，使用流程"><a href="#2-0二，使用流程" class="headerlink" title="2|0二，使用流程"></a>2|0二，使用流程</h3><p>使用流程</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SonarQube Documentation: &lt;a href=&quot;https://docs.sonarqube.org/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.sonarqube.org/latest/&lt;/
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
  </entry>
  
  <entry>
    <title>可视化监测</title>
    <link href="http://yoursite.com/sum/others/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%B5%8B/"/>
    <id>http://yoursite.com/sum/others/可视化监测/</id>
    <published>2021-02-09T00:00:00.000Z</published>
    <updated>2021-02-09T10:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>elastic: <a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">https://www.elastic.co/cn/</a><br>grafana: <a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><!-- $_PS: 还有一个bdp 是啥啊。海致BDP-大数据时代的商业智能 --><p style="text-align:right"> 2021.2.9 星期二  16：54 </p><h2 id="Kibana-和-Grafana-对比区别"><a href="#Kibana-和-Grafana-对比区别" class="headerlink" title="Kibana 和 Grafana 对比区别"></a>Kibana 和 Grafana 对比区别</h2><p><a href="https://www.zhihu.com/question/54388690" target="_blank" rel="noopener">Grafana 与 Kibana 有什么区别，Kibana 能做的事情 Grafana 是否也都能做？</a><br>Grafana 最早其实应该是 Kibana 3 的分支，<!-- 不相信的可以去翻 Github 的提交记录，所以但凡用过 Kibana 3的人就知道， Grafana 的界面风格其实和 Kibana3 的风格是一致的。 --><br>这还是2013年。<br><!-- 我们来回顾一下历史， Kibana 1.0 的作者是 Rashid Khan 于 2011 年编写的，用的 PHP，开发起来发现不爽，然后第二年又用 Ruby 重写了 Kibana 2.0，发现还是不爽，于是一年后，用 Html+JS 再重写，用的 AngularJS，也是个爱折腾的主，这还是2013年。--></p><!-- [对比了解 Grafana 与 Kibana 的关键差异](https://www.infoq.cn/article/grafana-vs-kibana-the-key-differences-to-know)[Grafana与Kibana之间的比较](https://www.jianshu.com/p/3ebbde9601be) --><p>Kibana的核心功能是数据查询和分析。</p><p>Kibana和Grafana都是强大的可视化工具。但是，它们的核心是用于不同的数据类型和用例。<br>Grafana与时间序列数据库（如Graphite或InfluxDB）是用于度量分析的组合，<br>而Kibana是流行的ELK Stack的一部分，用于探索日志数据。</p><p><a href="https://www.cnblogs.com/tgzhu/p/6865770.html" target="_blank" rel="noopener">kibana 与 grafana</a><br>Kibana 和 Grafana 是两个开源工具，能可视化和推断大量日志数据内的趋势。<br>Kibana 是一个分析和可视化平台，它可以让你浏览、可视化存储在Elasticsearch集群上排名靠前的日志数据，并构建仪表盘。<!-- 你可以执行深入的数据分析并以多种图表、表格和地图方式可视化这些数据。 --><br>Grafana 是一个开源仪表盘工具，支持如：Graphite、InfluxDB与 OpenTSDB、Elasticsearch、druid等数据源，</p><p>对比分析<br>日志与度量：Grafana专注于根据CPU和IO利用率之类的特定指标提供时间序列图表。Kibana则专注于另一方面，它运行于Elasticsearch的上层，能创建一个复杂的日志分析仪表盘。举个例子，Grafana无法进行数据的检索和浏览<br>角色权限：默认情况下，Kibana的仪表盘是公开的，没有进行基于角色的访问控制。如果你需要针对多个用户设置不同的权限级别，就得增加额外的配置预算采购 Shield 了。Grafana内置的RBA允许你维护用户和团队访问仪表盘的权限。<br>仪表盘灵活性：虽然Kibana有大量内置的图表类型，但它们之上的控制仍是最初的限制，Grafana包括更多的选择，可以更灵活地浏览和使用图表，如果要选择一个指定的时间序列，可以使用Y-Bar之类的工具。然而，随着 Kibana 4中展示的增强特性，比如可以保存元素并拖曳到新的仪表盘中，我们可以预期Kibana能快速地弥补这一差距<br>支持数据源：Grafana支持许多不同的存储后端。Grafana针对每个数据源都有一个特定的查询编辑器，它是针对数据源所具备的特性和能力特别定制的。然而，正如上文所说，Kibana原生集成进了ELK栈，这使安装极为简单，对用户非常友好</p><p>共同协作<br>Kibana和Grafana都是强大的可视化工具。然而，Grafana和InfluxDB组合是用于度量数据的，反之，Kibana是流行的ELK栈的一部分，它可以更为灵活地浏览日志数据。这两个平台都是好的选择，甚至有时还可以互补。首先，用Kibana去分析你的日志。然后，把数据导入到Grafana作为可视化层。这些的前提是需要同一个Elasticsearch库</p><p>解决方案</p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><!-- [Grafana和Kibana是写给程序员最美的情诗！ ](https://www.sohu.com/a/216585475_632967) --><p>当然，在设备监控和运维方面<!-- ，除了Grafana外，还有很多其他类似工具，如名叫Kibana的工具， --><br>它是一个分析和可视化平台，支持浏览、可视化存储的日志数据，如ELK栈(Elasticsearch、Logstash和Kibana) 。同样也支持Dashboard，支持深入的数据分析并以多种图表、表格和可视化方式展示数据。</p><p>在日志与度量方面，Grafana专注于根据CPU和IO利用率之类的特定指标提供时间序列图表。<br>Kibana运行于Elasticsearch的上层(可以实现数据的检索和浏览)，专注于创建一个复杂的日志分析仪表盘。</p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p><a href="http://docs.flycloud.me/docs/ELKStack/elasticsearch/other/grafana.html" target="_blank" rel="noopener">Grafana教程</a><br><!-- [Grafana使用教程](https://blog.csdn.net/bbwangj/article/details/81109615) --><br>Grafana是一个开源的度量分析与可视化套件。经常被用作基础设施的时间序列数据和应用程序分析的可视化，<!-- 它在其他领域也被广泛的使用包括工业传感器、家庭自动化、天气和过程控制等。 --></p><p>Grafana支持许多不同的数据源。每个数据源都有一个特定的查询编辑器,该编辑器定制的特性和功能是公开的特定数据来源。<br>官方支持以下数据源:Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB。</p><p>大多数公司都是使用Zabbix收集数据，通过Grafana展示出来。</p><p>每个数据源的查询语言和能力都是不同的。你可以把来自多个数据源的数据组合到一个仪表板，但每一个面板被绑定到一个特定的数据源,它就属于一个特定的组织。</p><p>Grafana非常强大的一个功能叫做Grafana Dashboard Templating，可以说是使用Grafana必用的技能。Dashboard 通过定义变量在不同界面被引用，如当你定义了变量在某一个Dashboard页面就会出现下拉选择框，从而也就具有可交互性了。<br>6、仪表盘模板功能<br>单纯的手动去添加一个个监控图,只能显示一个主机的所有监控图形，若要查看不同主机的所有监控图形，就要通过变量的方式去实现。我<!-- 们要设置的变量包括group，host，application和iteam。 --></p><p>模板:仪表盘模板可以让你创建一个交互式和动态性的仪表板，它是Grafana里面最强大的、最常用的功能之一。创建的仪表盘模板参数，可以在任何一个仪表盘中使用。</p><p>变量及使用<br>3.1变量之interval<br>3.2变量之query</p><p>preview<br>query<br>Transform<br>Alert</p><p>panel</p><p>访问控制和身份验证</p><h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><!-- [InfluxDB从原理到实战 - 什么是InfluxDB](https://zhuanlan.zhihu.com/p/80062750) --><p>InfluxDB是一个由InfluxData开发的开源时序型数据库，专注于海量时序数据的高性能读、高性能写、高效存储与实时分析等，在DB-Engines Ranking时序型数据库排行榜上排名第一，广泛应用于DevOps监控、IoT监控、实时分析等场景。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;elastic: &lt;a href=&quot;https://www.elastic.co/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/cn/&lt;/a&gt;&lt;br&gt;grafana: &lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="others" scheme="http://yoursite.com/categories/sum/others/"/>
    
    
  </entry>
  
  <entry>
    <title>OSS实践</title>
    <link href="http://yoursite.com/sum/ser/OSS%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/sum/ser/OSS实践/</id>
    <published>2021-02-09T00:00:00.000Z</published>
    <updated>2021-02-21T15:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>对象存储 OSS: <a href="https://help.aliyun.com/product/31815.html" target="_blank" rel="noopener">https://help.aliyun.com/product/31815.html</a></p><p style="text-align:right"> 2021.2.9 星期  ： </p><p>阿里云 OSS<br>图片处理服务<br>阿里云 OSS 图片处理服务 (Image Processing，简称 IMG), 将原始图片上传保存在OSS上，通过简单的 RESTful 接口，在任何时间、任何地点、任何互联网设备上对图片进行处理。</p><p>图片服务基础功能<br>获取图片信息<br>图片格式转换<br>图片缩放、裁剪、旋转(image/resize,w_200/rotate,90/crop,x_100,y_50/blur,r_3,s_2/)<br>图片添加图片、文字、图文混合水印<br>自定义图片处理样式<br>通过管道顺序调用多种图片处理功能<br>类似的图片处理效果还有模糊(blur)，对比度(contrast)，亮度(bright)，锐化(sharpen),使用的就是图片的样式功能。</p><p><a href="https://help.aliyun.com/document_detail/44703.html?spm=a2c4g.11186623.6.1095.31447117Qsqm2t" target="_blank" rel="noopener">对象存储 OSS-图片处理参数</a></p><p>直接在后端返回的URL后面拼接字符串：<code>?x-oss-process=image/resize,m_fill,w_782,h_540</code></p><p>//设置图片清晰度最后就是清晰度0-100，数字越大，清晰度越高<br><code>?x-oss-process=image/quality,q_60</code></p><p>裁剪<br><a href="http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/circle,r_100" target="_blank" rel="noopener">http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/circle,r_100</a></p><p>先压缩再裁剪<br><a href="http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/quality,q_80/circle,r_100" target="_blank" rel="noopener">http://demo.oss-cn-xxxxx.aliyuncs.com/test.jpg?x-oss-process=image/quality,q_80/circle,r_100</a></p><p>快速获取视频的封面方法介绍<br>?x-oss-process=video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast<br>t_ 后面配置截取多少毫秒的视频对应的画面</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象存储 OSS: &lt;a href=&quot;https://help.aliyun.com/product/31815.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://help.aliyun.com/product/31815.html&lt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="ser" scheme="http://yoursite.com/categories/sum/ser/"/>
    
    
  </entry>
  
  <entry>
    <title>Node脚本</title>
    <link href="http://yoursite.com/sum/ser/node%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/sum/ser/node脚本/</id>
    <published>2021-01-23T00:00:00.000Z</published>
    <updated>2021-01-23T13:29:21.043Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2021.1.23 星期六 21：28 </p><h2 id="向npm脚本发送命令行参数"><a href="#向npm脚本发送命令行参数" class="headerlink" title="向npm脚本发送命令行参数"></a>向npm脚本发送命令行参数</h2><!-- [如何向npm脚本发送命令行参数？](https://cloud.tencent.com/developer/ask/50047) --><p>package.json的scripts部分：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "node ./script.js server"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从npm2.0.0开始，可以将参数传递给npm run<br><!-- [npm run 执行package.json中的scripts配置时如何参数传递？](https://www.zhihu.com/question/54471504) --><br>1) npm scripts参数传递的命令行分割符是’–’。<br>比如npm run build – –name hello，即可将后续参数添加到process.env.argv数组中。</p><p>2) 在 vue-cli 创建的项目中，如果执行命令 npm run build –report ，那么参数 –report 将转化成 process.env.npm_config_report = true<br><del>3) 用shell函数，将尾巴的作为参数传进去<code>{&quot;build&quot;: &quot;build(){r.js -o build.js &amp;&amp; node version.js -v $1 &amp;&amp; zip -r ./build/dist.zip ./build;} build&quot;}</code></del><br>4) 只需在尾部提供一个$<em>到你的脚本值条目。 `”start”: “node echoargs.js $</em>“`<br>5) 如果你想将参数传递到npm脚本的中间，而不只是将它们追加到末尾，那么内联环境变量能起到一个很好的作用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "BABEL_ARGS=-w npm run build &amp;&amp; cd lib/server &amp;&amp; nodemon index.js",</span><br><span class="line">  "start": "npm run build &amp;&amp; node lib/server/index.js",</span><br><span class="line">  "build": "mkdir -p lib &amp;&amp; babel $BABEL_ARGS -s inline --stage 0 src -d lib",</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>在这里，npm run dev将-w watch标志传递给babel，但npm run start只运行一次常规构建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2021.1.23 星期六 21：28 &lt;/p&gt;

&lt;h2 id=&quot;向npm脚本发送命令行参数&quot;&gt;&lt;a href=&quot;#向npm脚本发送命令行参数&quot; class=&quot;headerlink&quot; title=&quot;向npm脚本发送命令行参
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="ser" scheme="http://yoursite.com/categories/sum/ser/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>微前端和Qiankun</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%92%8Cqiankun/"/>
    <id>http://yoursite.com/sum/jsplus/微前端和qiankun/</id>
    <published>2021-01-12T00:00:00.000Z</published>
    <updated>2021-01-12T06:25:03.010Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.12 星期二  ： </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>qiankun: <a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">https://qiankun.umijs.org/zh/guide</a><br>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p><h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><blockquote><p>Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends<br>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。</p></blockquote><a id="more"></a><p>微前端架构具备以下几个核心价值：<br>技术栈无关<br>主框架不限制接入应用的技术栈，微应用具备完全自主权</p><p>独立开发、独立部署<br>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p><p>增量升级<br>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p><p>独立运行时<br>每个微应用之间状态隔离，运行时状态不共享</p><h2 id="为什么不是-iframe"><a href="#为什么不是-iframe" class="headerlink" title="为什么不是 iframe"></a>为什么不是 iframe</h2><h1 id="微前端的核心价值"><a href="#微前端的核心价值" class="headerlink" title="微前端的核心价值"></a>微前端的核心价值</h1><p><a href="https://zhuanlan.zhihu.com/p/95085796" target="_blank" rel="noopener">微前端的核心价值</a></p><p>我认为微前端的核心价值在于 “技术栈无关”，这才是它诞生的理由，或者说这才是能说服我采用微前端方案的理由。</p><h2 id="为什么”技术栈无关”这么重要？"><a href="#为什么”技术栈无关”这么重要？" class="headerlink" title="为什么”技术栈无关”这么重要？"></a>为什么”技术栈无关”这么重要？</h2><h2 id="为什么我认为”技术栈无关”才是微前端的初衷？"><a href="#为什么我认为”技术栈无关”才是微前端的初衷？" class="headerlink" title="为什么我认为”技术栈无关”才是微前端的初衷？"></a>为什么我认为”技术栈无关”才是微前端的初衷？</h2><blockquote><p>微前端的初衷应该还是来解决工程问题的，带来的产品价值在不同的领域可大可小。 比如在阿里云这种典型的云产品控制台的场景下，它带来的产品价值就会很可观。</p></blockquote><h2 id="微前端方案正确的架构姿势"><a href="#微前端方案正确的架构姿势" class="headerlink" title="微前端方案正确的架构姿势"></a>微前端方案正确的架构姿势</h2><p>「技术栈无关」是架构上的准绳，具体到实现时，对应的就是：应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。</p><h1 id="可能是你见过最完善的微前端解决方案"><a href="#可能是你见过最完善的微前端解决方案" class="headerlink" title="可能是你见过最完善的微前端解决方案"></a>可能是你见过最完善的微前端解决方案</h1><p><a href="https://zhuanlan.zhihu.com/p/78362028" target="_blank" rel="noopener">可能是你见过最完善的微前端解决方案</a></p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p style=&quot;text-align:right&quot;&gt; 2020.12 星期二  ： &lt;/p&gt;

&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;qiankun: &lt;a href=&quot;https://qiankun.umijs.org/zh/guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://qiankun.umijs.org/zh/guide&lt;/a&gt;&lt;br&gt;qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是微前端&quot;&gt;&lt;a href=&quot;#什么是微前端&quot; class=&quot;headerlink&quot; title=&quot;什么是微前端&quot;&gt;&lt;/a&gt;什么是微前端&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. – Micro Frontends&lt;br&gt;微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Rollup第一次使用</title>
    <link href="http://yoursite.com/sum/jsplus/rollup%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/sum/jsplus/rollup第一次使用/</id>
    <published>2020-12-29T00:00:00.000Z</published>
    <updated>2021-01-23T06:05:46.651Z</updated>
    
    <content type="html"><![CDATA[<p>以失败告终。（于<!-- （是） -->webapck一次成功）<br>nodejs<!-- 前端脚手架 -->cjs 包，打包执行成功了。<br>但是输出的文件执行报错（解决掉electron，又报其他错误）。</p><p style="text-align:right"> 2020.12.29 星期二  11：41 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    throw new ERR_INVALID_ARG_TYPE(<span class="string">'superCtor'</span>, <span class="string">'Function'</span>, superCtor);</span><br><span class="line">    ^</span><br><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The <span class="string">"superCtor"</span> argument must be of <span class="built_in">type</span> <span class="keyword">function</span>. Received undefined</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/rollup/rollup/issues/3805" target="_blank" rel="noopener">https://github.com/rollup/rollup/issues/3805</a></p></blockquote><p>打包中提示有循环引用<br><!-- [由rollup打包引发的对JS模块循环引用的思考](https://juejin.cn/post/6862635764981235719) --><br><!-- 感觉可能是rollup配置的问题，于是去谷歌了一下， -->发现这其实是rollup的一个bug。<br><!-- 在翻了github上几个issue之后，终于弄清了报错的原因。为了讲清楚问题，首先介绍一下问题发生的背景： --><br>导致rollup打包问题的原因为：打包的过程中rollup将cjs模块转换成esm，由于esm会跳过之前已加载过的模块，实际引入的变量变成了undefined，导致在最终生成的代码中存在undefined的变量。</p><p>这个问题至今尚未有效解决，涉及到大量commonjs模块时，建议使用webpack打包。</p><!-- [rollup打包js的注意点](https://www.haorooms.com/post/rollup_tips)rollup比较适合打包js的sdk或者封装的框架等，例如，vue源码就是rollup打包的。webpack比较适合打包一些应用，例如SPA或者同构项目等等。最近我们对rollup小试牛刀了一下。简单分享一些注意事项吧。 --><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以失败告终。（于&lt;!-- （是） --&gt;webapck一次成功）&lt;br&gt;nodejs&lt;!-- 前端脚手架 --&gt;cjs 包，打包执行成功了。&lt;br&gt;但是输出的文件执行报错（解决掉electron，又报其他错误）。&lt;/p&gt;
&lt;p style=&quot;text-align:right
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="rollup" scheme="http://yoursite.com/tags/rollup/"/>
    
  </entry>
  
  <entry>
    <title>Stencil 了解</title>
    <link href="http://yoursite.com/sum/jsplus/Stencil%20%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/sum/jsplus/Stencil 了解/</id>
    <published>2020-12-14T00:00:00.000Z</published>
    <updated>2021-01-23T13:35:24.900Z</updated>
    
    <content type="html"><![CDATA[<p>Stencil: A Compiler for Web Components and High Performance Web Apps<br><a href="https://stenciljs.com/docs/introduction" target="_blank" rel="noopener">Stencil 文档</a><br>github: <a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">https://github.com/ionic-team/stencil</a></p><p style="text-align:right"> 2020.12.14 星期一 </p><p>一个轻量化，渐进式编译器，注意，不是框架。<br>使用 TypeScript 进行所有操作，这是一个门槛，有一定技术门槛要求。</p><a id="more"></a><p>官方描述特征是：<br>. Virtual DOM<br>. Async rendering (inspired by React Fiber)<br>. Reactive data-binding<br>. TypeScript<br>. JSX</p><!-- \# [胶水（框架） Stencil.js](https://zhuanlan.zhihu.com/p/84465089) --><p>而 Stencil.js 已经在今年（2019 ）的 6 月份，推出了 1.0 正式版<br><!-- $_PS: 17年底，18年初的时候已经有了 --></p><h2 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line"> tag: <span class="string">'my-component'</span>,</span><br><span class="line"> styleUrl: <span class="string">'my-component.css'</span>,</span><br><span class="line"> shadow: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line"> @Prop() first: string;</span><br><span class="line"></span><br><span class="line"> private getText(): string &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, World! I'm &#123;this.getText()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用 Stencil 开发的组件只是 Web Components，所以这些组件可以运行在所有的主流框架（AVR）中，也可以独立地运行。这一特质使它可以成为新的前端容器框架——毕竟 Web Components 是一个新的前端容器。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>用途一：开发前端应用<br>用途二：连接混合应用<br>用途三：连接其它前端框架<br>用途四：构建跨框架的 UI 库 / 设计系统<br>用途五：微前端应用</p><p>结论：胶水框架<br>Web Components 大法虽好，但是你还是需要一个快速开发 Web Components 的框架/工具。</p><h3 id="5-条评论"><a href="#5-条评论" class="headerlink" title="5 条评论"></a>5 条评论</h3><!-- 王锐2019-09-28是否适用与大型项目（代码量有一定层级，重构简单。开发团队大，适合协同工作）有待商榷。如果只是一些骚操作，看看就好ewind2019-09-28看名字还以为是管 WebGL stencil buffer 的呢…填坑侠2019-09-29和我16年在美团干的事一模一样，实际上响应者稀莫夭2019-09-29曾经尝试用过，个人感觉最大的问题是组件名要全局唯一，而且在组件A中使用组件B，没有import的过程，完全不知道B是在哪定义的。只有等web components引入类似namespace之类的东西才能解决这个问题了不得不全栈2019-10-03以前用过，还是觉得麻烦…… --><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><!-- \# [Stencil 基础](https://www.cnblogs.com/ZweiZhao/p/9817591.html) --><p>生命周期<br>componentWillLoad<br>componentDidLoad<br>componentWillUpdate<br>componentDidUpdate<br>componentDidUnload</p><p>装饰器<br>Component<br>Prop<br>Watch<br>State<br>Method<br>Element</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stencil: A Compiler for Web Components and High Performance Web Apps&lt;br&gt;&lt;a href=&quot;https://stenciljs.com/docs/introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stencil 文档&lt;/a&gt;&lt;br&gt;github: &lt;a href=&quot;https://github.com/ionic-team/stencil&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ionic-team/stencil&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.14 星期一 &lt;/p&gt;

&lt;p&gt;一个轻量化，渐进式编译器，注意，不是框架。&lt;br&gt;使用 TypeScript 进行所有操作，这是一个门槛，有一定技术门槛要求。&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Ohmyshell</title>
    <link href="http://yoursite.com/sum/os/ohmyshell/"/>
    <id>http://yoursite.com/sum/os/ohmyshell/</id>
    <published>2020-12-14T00:00:00.000Z</published>
    <updated>2021-01-23T10:24:14.010Z</updated>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input type="text" style=" border-radius: 5px; border-style: groove; height: 30px; width: 50%; cursor: auto; font-size: 102%; color: currentColor; outline: none; text-overflow: initial; padding-left: 5px;">   <input type="submit" value="decrypt" onclick="decrypt()" style=" width: 58px; height: 34px; border-radius: 5px; background-color: white; border-style: solid; color: currentColor; ">  <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script>  var onError = function(error) {  $("#enc_error")[0].innerHTML = "password error!";  };  function decrypt() {  var passwd = $("#enc_passwd input")[0].value;  console.log(passwd);  doDecrypt(passwd, onError);  }  </script></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=/js/crypto-js.js&gt;&lt;/script&gt;
&lt;script&gt;
function doDecrypt (pwd, onError) {
	console.log(&#39;in doDecrypt&#39;);
	const txt = document.getE
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="os" scheme="http://yoursite.com/categories/sum/os/"/>
    
    
  </entry>
  
  <entry>
    <title>React状态管理库对比</title>
    <link href="http://yoursite.com/sum/jsplus/react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/sum/jsplus/react状态管理库对比/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:42.909Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.12.13 星期日  21：35 </p><h1 id="实际状态管理项目"><a href="#实际状态管理项目" class="headerlink" title="实际状态管理项目"></a>实际状态管理项目</h1><p>实际使用了redux，也是得益于其“啰嗦”的设计，把所有reducer 定义于一处，包括定义action。清晰，方便查找/追踪state<br>没有使用immutable。但是确实做了一些性能优化的处理，包括state及某个属性如何更新等。</p><!-- 当时 -->没使用dva，因为是一个框架，内置了router等，并不需要，仅是一个简单的状态管理。<br>redux 简单强大，刚好满足。不需要再去学习新框架dva<br><br>mobx 使用简单，灵活，同样的和redux，dva 需要学习新的状态管理概念/文档。用generator语法糖，增加配置成本。<br>每一个需要监听的state/属性/action，需要用@observable，@action 去处理。也可以不去监听，混合在一起。<br>虽然装饰器使得语法明了。但是redux 数据流，有明确的规定，必须先定义action（type，payload），然后去操作reducer。<br><br>若在业务项目中使用，无聊mobx或dva 都是非常不错了。奈何更需要的是一个状态（集中）管理的简单库。<br>如果偏业务，redux确实有一些啰嗦。<br><br><br><!-- 虽然是不用的应用场景。github battle --><h2 id="github-对比"><a href="#github-对比" class="headerlink" title="github 对比"></a>github 对比</h2><p>统计于 20201214</p><table><thead><tr><th>–</th><th>star</th><th>issues</th><th>fork</th></tr></thead><tbody><tr><td>redux</td><td>54.9k</td><td>33/1802</td><td>14.5k </td></tr><tr><td>mobx</td><td>22.9k</td><td>12/1633</td><td>1.9k </td></tr><tr><td>dva</td><td>15.3k</td><td>22/2072</td><td>3k </td></tr></tbody></table><h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>github: <a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">https://github.com/reduxjs/redux</a><br><a href="https://redux.js.org/introduction/installation" target="_blank" rel="noopener">redux文档</a></p><h1 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h1><p>github: <a href="https://github.com/dvajs/dva/blob/master/README_zh-CN.md" target="_blank" rel="noopener">https://github.com/dvajs/dva/blob/master/README_zh-CN.md</a><br><a href="https://dvajs.com/guide/" target="_blank" rel="noopener">dva 文档</a></p><p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</p><h1 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h1><p>github: <a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">https://github.com/mobxjs/mobx</a></p><p><a href="https://mobx.js.org/about-this-documentation.html" target="_blank" rel="noopener">MobX</a><br><a href="https://cn.mobx.js.org" target="_blank" rel="noopener">MobX</a><br><!-- [MobX 中文文档](https://suprise.github.io/mobx-cn/index.html) --></p><!-- $_PS: 通过第二篇文档，基本用法已了解。高阶/详细 需要使用的时候再次确认。有时间，学习官方文档 --><p>MobX 以前叫做 Mobservable</p><h2 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义一个可观测的store</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppStore</span> </span>&#123;</span><br><span class="line">  @observable number = <span class="number">0</span>;</span><br><span class="line">  changeNumber()&#123;</span><br><span class="line">      <span class="keyword">this</span>.number++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AppStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再定义观测store的组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">'mobx-react'</span>;</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span>&#123;store&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;store.changeNumber.bind(store)&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;store.number&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终我们把store注入进去，然后把组件渲染出来</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> AppStore();</span><br><span class="line">render(</span><br><span class="line">  &lt;App store=&#123;store&#125; /&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="mobx-react"><a href="#mobx-react" class="headerlink" title="mobx-react"></a>mobx-react</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><!-- [mobx-react 原理解析(一)](https://zhuanlan.zhihu.com/p/27448262) --><!-- [mobx-react 原理解析(二)](https://zhuanlan.zhihu.com/p/27551105) --><h3 id="REDUX的好处"><a href="#REDUX的好处" class="headerlink" title="REDUX的好处"></a>REDUX的好处</h3><p>通过action,reducer来完成应用的数据流管理，逻辑简单清晰<br>reducer函数式的设计，让我们代码变得可观测，可回溯<br>action的设计，特别适用于多数据联动的场景<br>REDUX的弊端</p><p>啰嗦代码太多<br>reducer无复用性<br>性能优化太繁琐(当然可以引入immutable来解决，但是是不是又增加了学习成本,应用的复杂度和代码量呢)<br>app state和store state的划分<br>在实际开发中，一方面我们受益于redux的好处，但另一方面我们也受制于redux的弊端，其实某种程度制约了我们的开发效率，因此近端时间学习了下mobx，从它这里找到了能提升开发效率的方法，不是说mobx比redux好，而是mobx更适合我们实际的工作内容，而redux更实用与大型项目的开发</p><h3 id="MobX-1"><a href="#MobX-1" class="headerlink" title="MobX"></a>MobX</h3><p>从这张图我们可以看到mobx其实就是mvvm的概念，数据双向绑定，并且能做到字段级的控制，所以用mobx开发react的项目，我们不需要做太多的性能优化，同时它的store是可以复用的，这对我们快速开发项目特别有帮助</p><p>至此，mobx-react的工作原理基本梳理清楚了，大致用一下几句话来概括<br>1.observe组件第一次渲染的时候，会创建Reaction，组件的render处于当前这个Reaction的上下文中，并通过track建立render中用到的observable建立关系<br>2.当observable属性修改的时候，会触发onInvalidate方法，实际上就是组件的forceupdate,然后触发组件渲染，又回到了第一步<br>这篇就先到这里告一段落，后面会对action,compute,atom做进一步的分享</p><h4 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h4><p>运行到代码1处，通过第一节的分析，autorun的Reaction跟fullName建立观测的关系，而通过上面的分析，compute的<code>帅帅的</code>+this.name表达式跟computeValue的Reaction建立了观测关系</p><p>当我们运行p.changeName的时候，根据前面的知识，会触发observer的onBecomeStale，不过computeValue的onBecomeStale跟Reaction的onBecomeStale不一样</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>从源码可以看出，核心就是通过startBatch和endBatch完成一个批量的操作，也就是说我们在executeAction无论改变多少次observable的值，最终只会触发一次Reaction的onInvalidate</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><!-- [[React框架 dva 和 mobx 的使用感受]](https://www.cnblogs.com/owenma/p/8409696.html) --><h2 id="dva-1"><a href="#dva-1" class="headerlink" title="dva"></a>dva</h2><p>经朋友推荐开始接触 dva ，从  2.x 版本开始使用，我也基于这个工具开发了一套项目模版，它简化了 redux 的使用，并且在封装了 redux-saga 和 react-router，同时还可以包含 dva-loading 插件获取 loading 状态等。</p><p>在 redux 时代，当我需要新增一种跨页面全局数据的时候，我需要去项目的 reducers 目录定义一下这种数据命名和初始值，然后在 constans 目录中为更改这项数据的操作定义一种唯一的操作类型（type），再去 actions 目录定义一些方法，这些方法最后会得到更改后的数据和操作类型（type），最后再回到 reducers 中根据这个操作类型（type）把数据整合到 reducer 中…可以看到，我在编写 redux 这部分代码的时候需要频繁在 actions 、 constants 、 reducers 这几个目录间切换。</p><p>而使用 dva 就可以免除这些困扰了，我只需要一个 model 中就可以完成所有操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app全局性状态管理</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> appApis <span class="keyword">from</span> <span class="string">'../services/app'</span>; <span class="comment">// 异步请求接口</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: <span class="string">'app'</span>,</span><br><span class="line"> </span><br><span class="line">  state: &#123;</span><br><span class="line">    channels: [],</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  reducers: &#123;</span><br><span class="line">    getChannelsAndGamesSuccess(state, &#123; channels, games &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, channels, games &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeShow(state, &#123; show &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, show &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  effects: &#123; <span class="comment">// 异步</span></span><br><span class="line">    * getChannelsAndGames(_, &#123; call, put &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">yield</span> call(appApis.getChannelsAndGames);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">'getChannelsAndGamesSuccess'</span>,</span><br><span class="line">        channels: res.channels</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">     </span><br><span class="line">  subscriptions: &#123; <span class="comment">// 订阅</span></span><br><span class="line">    setup(&#123;dispatch, history&#125;) &#123;</span><br><span class="line">      history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (location.pathname == <span class="string">'/'</span>) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: <span class="string">'getChannelsAndGames'</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><p>既然 dva 这么好用，为什么还要使用 mobx 呢？还不是为了折腾😅，用了才能知道两者的优劣，同样的基于 mobx 我也创建了一个项目模版。</p><p>在使用 dva 的时候，但凡遇到异步请求的时候都需要先定义一个 effects ，请求完成后再触发一个 action 去修改数据，于是，强迫症作怪，这两者的命名总是让我感觉难受和啰嗦，你可以看到我都是定义为 getXxx 和 getXxxSuccess。</p><p>action 是修改 state 的唯一途径，是的，所有的状态管理库都是这样的，但是 mobx 通过一些工具函数解决了这一问题：</p><p>以上是我最喜欢的两种写法，分别借助了 runInAction 和 asyncAction 这两个工具函数，当然，还有其他方法可以参考。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  21：35 &lt;/p&gt;

&lt;h1 id=&quot;实际状态管理项目&quot;&gt;&lt;a href=&quot;#实际状态管理项目&quot; class=&quot;headerlink&quot; title=&quot;实际状态管理项目&quot;&gt;&lt;/a&gt;实际状态管
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6 - Proxy</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/14-Proxy/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/14-Proxy/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.205Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>Proxy 实例的方法<br>Proxy.revocable()<br>this 问题<br>实例：Web 服务的客户端</p><p style="text-align:right"> 2020.12.13 星期日  17:33 </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。<br>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>如果handler没有设置任何拦截，那就等同于直接通向原对象。<br>一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。<code>var object = { proxy: new Proxy(target, handler) };</code><br>Proxy 实例也可以作为其他对象的原型对象。<code>let obj = Object.create(proxy);</code></p><p>同一个拦截器函数，可以设置拦截多个操作。<br>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。<br>下面是 Proxy 支持的拦截操作一览，一共 13 种。<br>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。<br>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p><h2 id="2-Proxy-实例的方法"><a href="#2-Proxy-实例的方法" class="headerlink" title="2 Proxy 实例的方法"></a>2 Proxy 实例的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p>get方法可以继承。<br>上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。</p><p>下面的例子使用get拦截，实现数组读取负数的索引。<br>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。<br>下面是一个get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。<br>利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。<br>结合get和set方法，就可以做到防止这些内部属性被外部读写。<br>上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。</p><p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。<br>注意，严格模式下，set代理如果没有返回true，就会报错。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply方法拦截函数的调用、call和apply操作。<br>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line"><span class="comment">// "I am the proxy"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，直接调用Reflect.apply方法，也会被拦截。</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p>has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。<br>has()方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用has()方法隐藏某些属性，不被in运算符发现。</p><p>另外，虽然for…in循环也用到了in运算符，但是has()拦截对for…in循环不生效。</p><h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p>construct()方法用于拦截new命令，下面是拦截对象的写法。</p><p>另外，由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p>defineProperty()方法拦截了Object.defineProperty()操作。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p>getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p><h3 id="getPrototypeOf-§-⇧"><a href="#getPrototypeOf-§-⇧" class="headerlink" title="getPrototypeOf() § ⇧"></a>getPrototypeOf() § ⇧</h3><p>getPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><p>Object.prototype.<strong>proto</strong><br>Object.prototype.isPrototypeOf()<br>Object.getPrototypeOf()<br>Reflect.getPrototypeOf()<br>instanceof</p><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p>isExtensible()方法拦截Object.isExtensible()操作。</p><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p>ownKeys()方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p><p>for…in循环也受到ownKeys()方法的拦截。</p><p>注意，使用Object.keys()方法时，有三类属性会被ownKeys()方法自动过滤，不会返回。<br>目标对象上不存在的属性<br>属性名为 Symbol 值<br>不可遍历（enumerable）的属性</p><p>另外，如果目标对象是不可扩展的（non-extensible），这时ownKeys()方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p>preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p>setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf()方法不得改变目标对象的原型。</p><h2 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3 Proxy.revocable()"></a>3 Proxy.revocable()</h2><p>Proxy.revocable()方法返回一个可取消的 Proxy 实例。</p><p>Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="4-this-问题"><a href="#4-this-问题" class="headerlink" title="4 this 问题"></a>4 this 问题</h2><!-- 主要原因就是 -->在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br><br>下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。<br>此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，getDate()方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。</span></span><br><span class="line"><span class="comment">// 这时，this绑定原始对象，就可以解决这个问题。</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，Proxy 拦截函数内部的this，指向的是handler对象。</p><h2 id="5-实例：Web-服务的客户端"><a href="#5-实例：Web-服务的客户端" class="headerlink" title="5 实例：Web 服务的客户端"></a>5 实例：Web 服务的客户端</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebService(<span class="string">'http://example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">service.employees().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWebService</span>(<span class="params">baseUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> httpGet(baseUrl + <span class="string">'/'</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p><p># Object.create()<br><!-- [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) --><br>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 （请打开浏览器控制台以查看运行结果。）<br><code>Object.create(proto，[propertiesObject])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p style="text-align:right"> 18:02 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;Proxy 实例的方法&lt;br&gt;Proxy.revocable()&lt;br&gt;this 问题&lt;br&gt;实例：Web 服务的客户端&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  17:33 &lt;/p&gt;


&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - Reflect</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/15-Reflect/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/15-Reflect/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.369Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>静态方法<br>实例：使用 Proxy 实现观察者模式</p><p style="text-align:right"> 2020.12.13 星期日  21：44 </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p><p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。<br>（2） 修改某些Object方法的返回结果，让其变得更合理。<br>（3） 让Object操作都变成函数行为。<br>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。<br>这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>Reflect对象一共有 13 个静态方法。<br>Reflect.apply(target, thisArg, args)<br>Reflect.construct(target, args)<br>Reflect.get(target, name, receiver)<br>Reflect.set(target, name, value, receiver)<br>Reflect.defineProperty(target, name, desc)<br>Reflect.deleteProperty(target, name)<br>Reflect.has(target, name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)<br>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。</p><h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p>Reflect.set方法设置target对象的name属性等于value。</p><p>注意，如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。</p><h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p>Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p><h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p>Reflect.getPrototypeOf方法用于读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。</p><p>Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。</p><h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p>Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。</p><h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。</span></span><br><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;<span class="keyword">set</span>&#125;);</span><br><span class="line"></span><br><span class="line">function <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-align:right">21:51 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;静态方法&lt;br&gt;实例：使用 Proxy 实现观察者模式&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  21：44 &lt;/p&gt;



&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 读懂 ECMAScript 规格</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/26-%E8%AF%BB%E6%87%82%20ECMAScript%20%E8%A7%84%E6%A0%BC/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/26-读懂 ECMAScript 规格/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.406Z</updated>
    
    <content type="html"><![CDATA[<p>概述<br>术语<br>抽象操作的标准流程<br>相等运算符<br>数组的空位<br>数组的 map 方法</p><p style="text-align:right"> 2020.12.13 星期日  16： </p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p><p>一般来说，没有必要阅读规格，除非你要写编译器。<!-- 因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。 --><br>但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p><p>ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（<a href="http://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">www.ecma-international.org/ecma-262/6.0/</a>）免费下载和在线阅读。<br><!-- 这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。 --><br>ECMAScript 6 规格的 26 章之中，<br>第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。<br>第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。<br>第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，<br>第 6 章介绍数据类型，<br>第 7 章介绍语言内部用到的抽象操作，<br>第 8 章介绍代码如何运行。<br>第 9 章到第 26 章介绍具体的语法。</p><p>对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。</p><h2 id="2-术语"><a href="#2-术语" class="headerlink" title="2 术语"></a>2 术语</h2><p>抽象操作<br>所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。</p><p>Record 和 field<br>ES6 规格将键值对（key-value map）的数据结构称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。</p><p>[[Notation]]<br>ES6 规格大量使用[[Notation]]这种书写法，比如[[Value]]、[[Writable]]、[[Get]]、[[Set]]等等。它用来指代 field 的键名。</p><p>Completion Record<br>每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个[[Type]]属性，表示运行结果的类型。<br>[[Type]]属性有五种可能的值。<br>normal<br>return<br>throw<br>break<br>continue</p><h2 id="3-抽象操作的标准流程"><a href="#3-抽象操作的标准流程" class="headerlink" title="3 抽象操作的标准流程"></a>3 抽象操作的标准流程</h2><p>抽象操作的运行流程，一般是下面这样。</p><ol><li>Let result be AbstractOp().</li><li>If result is an abrupt completion, return result.</li><li>Set result to result.[[Value]].</li><li>return result.</li></ol><h2 id="4-相等运算符"><a href="#4-相等运算符" class="headerlink" title="4 相等运算符"></a>4 相等运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。<br>“The comparison x == y, where x and y are values, produces true or false.”<br>下面是算法细节。</p><p>由于0的类型是数值，null的类型是 Null（这是规格4.3.13 小节的规定，是内部 Type 运算的结果，跟typeof运算符无关）。<br>因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。</p><h2 id="5-数组的空位"><a href="#5-数组的空位" class="headerlink" title="5 数组的空位"></a>5 数组的空位</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [, , ,];</span><br><span class="line"></span><br><span class="line">a1.length <span class="comment">// 3</span></span><br><span class="line">a2.length <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a1[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line">a2[<span class="number">0</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a1[<span class="number">0</span>] === a2[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，它们实际上存在重大差异。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1 <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a1.hasOwnProperty(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">a2.hasOwnProperty(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a1) <span class="comment">// ["0", "1", "2"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(a2) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">a1.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [1, 1, 1]</span></span><br><span class="line">a2.map(<span class="function"><span class="params">n</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></p><p>“数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。”</p><h2 id="6-数组的-map-方法"><a href="#6-数组的-map-方法" class="headerlink" title="6 数组的 map 方法"></a>6 数组的 map 方法</h2><p>仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，kPresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [, , ,];</span><br><span class="line">arr.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述&lt;br&gt;术语&lt;br&gt;抽象操作的标准流程&lt;br&gt;相等运算符&lt;br&gt;数组的空位&lt;br&gt;数组的 map 方法&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  16： &lt;/p&gt;


&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 最新提案</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/29-%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/29-最新提案/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.446Z</updated>
    
    <content type="html"><![CDATA[<p>do 表达式<br>throw 表达式<br>函数的部分执行<br>管道运算符<br>数值分隔符<br>Math.signbit()<br>双冒号运算符<br>Realm API</p><p>#!命令<br>import.meta</p><p style="text-align:right"> 2020.12.13 星期日  11：25 </p><p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p><h2 id="1-do-表达式"><a href="#1-do-表达式" class="headerlink" title="1 do 表达式"></a>1 do 表达式</h2><p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。<br>do表达式的逻辑非常简单：封装的是什么，就会返回什么。<br>do表达式的好处是可以封装多个语句，让程序更加模块化<!-- ，就像乐高积木那样一块块拼装起来。 --><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值得一提的是，do表达式在 JSX 语法中非常好用。</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;Home /&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggedIn) &#123;</span><br><span class="line">          &lt;LogoutButton /&gt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          &lt;LoginButton /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p><h2 id="2-throw-表达式"><a href="#2-throw-表达式" class="headerlink" title="2 throw 表达式"></a>2 throw 表达式</h2><p>JavaScript 语法规定throw是一个命令，用来抛出错误，不能用于表达式之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>());</span><br></pre></td></tr></table></figure></p><p>上面代码中，console.log的参数必须是一个表达式，如果是一个throw语句就会报错。</p><p>现在有一个提案，允许throw用于表达式。</p><p>语法上，throw表达式里面的throw不再是一个命令，而是一个运算符。<br>为了避免与throw命令混淆，规定throw出现在行首，一律解释为throw语句，而不是throw表达式。</p><h2 id="3-函数的部分执行"><a href="#3-函数的部分执行" class="headerlink" title="3 函数的部分执行"></a>3 函数的部分执行</h2><p>多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add7</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">7</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 方法</span></span><br><span class="line"><span class="keyword">const</span> add7 = add.bind(<span class="literal">null</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add7 = <span class="function"><span class="params">x</span> =&gt;</span> add(x, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></p><p>上面两种写法都有些冗余。其中，bind方法的局限更加明显，它必须提供this，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。<br>现在有一个提案，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> addOne = add(<span class="number">1</span>, ?);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxGreaterThanZero = <span class="built_in">Math</span>.max(<span class="number">0</span>, ...);</span><br></pre></td></tr></table></figure><p>根据新提案，?是单个参数的占位符，…是多个参数的占位符。以下的形式都属于函数的部分执行。</p><p>?和…只能出现在函数的调用之中，并且会返回一个新函数。<br>函数的部分执行，也可以用于对象的方法。</p><p>注意点</p><h2 id="4-管道运算符"><a href="#4-管道运算符" class="headerlink" title="4 管道运算符"></a>4 管道运算符</h2><p>JavaScript 的管道是一个运算符，写作|&gt;。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。<br>管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的写法</span></span><br><span class="line">exclaim(capitalize(doubleSay(<span class="string">'hello'</span>)))</span><br><span class="line"><span class="comment">// "Hello, hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道的写法</span></span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line">  |&gt; doubleSay</span><br><span class="line">  |&gt; capitalize</span><br><span class="line">  |&gt; exclaim</span><br><span class="line"><span class="comment">// "Hello, hello!"</span></span><br></pre></td></tr></table></figure><p>管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。<br>如果是多参数函数，就必须进行柯里化，改成单参数的版本。</p><p>管道运算符对于await函数也适用。</p><h2 id="5-数值分隔符"><a href="#5-数值分隔符" class="headerlink" title="5 数值分隔符"></a>5 数值分隔符</h2><p>现在有一个提案，允许 JavaScript 的数值使用下划线（_）作为分隔符。<br>JavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p><p>数值分隔符有几个使用注意点。</p><p>除了十进制，其他进制的数值也可以使用分隔符。<br>注意，分隔符不能紧跟着进制的前缀0b、0B、0o、0O、0x、0X。</p><p>下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p><h2 id="6-Math-signbit"><a href="#6-Math-signbit" class="headerlink" title="6 Math.signbit()"></a>6 Math.signbit()</h2><p>Math.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。<br>JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。<br>实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。</p><p>该方法的算法如下。<br>如果参数是NaN，返回false<br>如果参数是-0，返回true<br>如果参数是负值，返回true<br>其他情况返回false</p><h2 id="7-双冒号运算符"><a href="#7-双冒号运算符" class="headerlink" title="7 双冒号运算符"></a>7 双冒号运算符</h2><p>但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p><h2 id="8-Realm-API"><a href="#8-Realm-API" class="headerlink" title="8 Realm API"></a>8 Realm API</h2><p>Realm API 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。<br><!-- 以前，经常使用`<iframe>`作为沙箱。 --></p><p>Realm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。<br>如果要解决这个问题，可以使用下面的代码。<br><code>globalTwo.console = globalOne.console;</code></p><p>Realm()构造函数可以接受一个参数对象，该参数对象的intrinsics属性可以指定 Realm 沙箱继承原始顶层对象的方法。</p><p>正常情况下，沙箱的JSON方法不同于原始的JSON对象。但是，Realm()构造函数接受{ intrinsics: ‘inherit’ }作为参数以后，就会继承原始顶层对象的方法。</p><h2 id="9-命令"><a href="#9-命令" class="headerlink" title="9  #!命令"></a>9  #!命令</h2><!-- Unix 的命令行脚本都支持#!命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。 --><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写在脚本文件第一行</span><br><span class="line">// 写在模块文件第一行</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前执行脚本的方式</span></span><br><span class="line">$ node hello.js</span><br><span class="line"><span class="comment"># hashbang 的方式</span></span><br><span class="line">$ ./hello.js</span><br></pre></td></tr></table></figure><p>有了这一行以后，Unix 命令行就可以直接执行脚本。<br>对于 JavaScript 引擎来说，会把#!理解成注释，忽略掉这一行。</p><h2 id="10-import-meta"><a href="#10-import-meta" class="headerlink" title="10 import.meta"></a>10 import.meta</h2><p>为 import 命令添加了一个元属性import.meta，返回当前模块的元信息。</p><p>import.meta只能在模块内部使用，如果在模块外部使用会报错。</p><p>这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。一般来说，import.meta至少会有下面两个属性。</p><p>（1）import.meta.url</p><p>注意，Node.js 环境中，import.meta.url返回的总是本地路径，即是file:URL协议的字符串，比如file:///home/user/foo.js。</p><p>（2）import.meta.scriptElement<br>import.meta.scriptElement是浏览器特有的元属性，返回加载模块的那个<code>&lt;script&gt;</code>元素，相当于document.currentScript属性。</p><p style="text-align:right"> 11:52 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;do 表达式&lt;br&gt;throw 表达式&lt;br&gt;函数的部分执行&lt;br&gt;管道运算符&lt;br&gt;数值分隔符&lt;br&gt;Math.signbit()&lt;br&gt;双冒号运算符&lt;br&gt;Realm API&lt;/p&gt;
&lt;p&gt;#!命令&lt;br&gt;import.meta&lt;/p&gt;
&lt;p style=&quot;text-a
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 装饰器Decorator</title>
    <link href="http://yoursite.com/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/30-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/w3/es/ECMAScript6入门/30-装饰器/</id>
    <published>2020-12-13T00:00:00.000Z</published>
    <updated>2021-01-23T06:12:40.205Z</updated>
    
    <content type="html"><![CDATA[<p>类的装饰<br>方法的装饰<br>为什么装饰器不能用于函数？<br>core-decorators.js<br>使用装饰器实现自动发布事件<br>Mixin<br>Trait</p><p style="text-align:right"> 2020.12.13 星期日  10：40 </p><blockquote><p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。</p></blockquote><p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。</p><p>装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@frozen <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>$_PS: 装饰者模式。babel插件：@babel/plugin-proposal-decorators</p><h2 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h2><p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时<!-- 。这意味着，装饰器能在编译阶段运行代码。也就是说， -->装饰器本质就是编译时执行的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 1.1 装饰器函数的第一个参数，就是所要装饰的目标类。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 1.2 如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</span></span><br><span class="line"><span class="comment">// 装饰器testable可以接受参数，这就等于可以修改装饰器的行为。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>) <span class="comment">// @testable(false)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的例子是为类添加一个静态属性，</span></span><br><span class="line"><span class="comment">// ## 2 如果想添加实例属性，可以通过目标类的prototype对象操作。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 2.1 </span></span><br><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码通过装饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。</span></span><br><span class="line"><span class="comment">// ### 2.2 可以用Object.assign()模拟这个功能。</span></span><br><span class="line"><span class="comment">// ### 2.3 实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了装饰器，就可以改写上面的代码。</span></span><br><span class="line">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-方法的装饰"><a href="#2-方法的装饰" class="headerlink" title="2 方法的装饰"></a>2 方法的装饰</h2><p>装饰器不仅可以装饰类，还可以装饰类的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ## 1 装饰器函数readonly一共可以接受三个参数。</span></span><br><span class="line"><span class="comment">// 装饰器第一个参数是类的原型对象，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 1.2 修改属性描述对象的enumerable属性</span></span><br><span class="line"><span class="comment">// ## 1.3 下面的@log装饰器，可以起到输出日志的作用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 装饰器有注释的作用。</span></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 下面是使用 Decorator 写法的组件，看上去一目了然。</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">'my-component'</span>,</span><br><span class="line">  styleUrl: <span class="string">'my-component.scss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ## 3 除了注释，装饰器还能用来类型检查。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</span></span><br></pre></td></tr></table></figure></p><h2 id="3-为什么装饰器不能用于函数？"><a href="#3-为什么装饰器不能用于函数？" class="headerlink" title="3 为什么装饰器不能用于函数？"></a>3 为什么装饰器不能用于函数？</h2><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。<br>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finished'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure></p><h2 id="4-core-decorators-js"><a href="#4-core-decorators-js" class="headerlink" title="4 core-decorators.js"></a>4 core-decorators.js</h2><p>core-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。<br>（1）@autobind<br>（2）@readonly<br>（3）@override<br>（4）@deprecate (别名@deprecated)<br>（5）@suppressWarnings</p><h2 id="5-使用装饰器实现自动发布事件"><a href="#5-使用装饰器实现自动发布事件" class="headerlink" title="5 使用装饰器实现自动发布事件"></a>5 使用装饰器实现自动发布事件</h2><p>它使用的事件“发布/订阅”库是Postal.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">"postal/lib/postal.lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> channelName = channel || <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">  msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'频道: '</span>, channelName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件: '</span>, topic);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据: '</span>, v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      msgChannel.publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Mixin"><a href="#6-Mixin" class="headerlink" title="6 Mixin"></a>6 Mixin</h2><p>在装饰器的基础上，可以实现Mixin模式。<br><!-- 所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function">(<span class="params">superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo from MyMixin'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo(); <span class="comment">// "foo from MyMixin"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 如果需要“混入”多个方法，就生成多个混入类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><h2 id="7-Trait"><a href="#7-Trait" class="headerlink" title="7 Trait"></a>7 Trait</h2><p>Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。<br>下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><p>上面代码中，TFoo和TBar都有foo方法，结果traits装饰器报错。<br>一种解决方法是排除TBar的foo方法。<br>另一种方法是为TBar的foo方法起一个别名。<br>alias和excludes方法，可以结合起来使用。<br>as方法则为上面的代码提供了另一种写法。</p><p style="text-align:right"> 11.25 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;类的装饰&lt;br&gt;方法的装饰&lt;br&gt;为什么装饰器不能用于函数？&lt;br&gt;core-decorators.js&lt;br&gt;使用装饰器实现自动发布事件&lt;br&gt;Mixin&lt;br&gt;Trait&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2020.12.13 星期日  
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="es" scheme="http://yoursite.com/categories/w3/es/"/>
    
      <category term="ECMAScript6入门" scheme="http://yoursite.com/categories/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>Webpack5新特性</title>
    <link href="http://yoursite.com/sum/jsplus/webpack5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/sum/jsplus/webpack5新特性/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2020-11-23T02:56:21.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/" target="_blank" rel="noopener">Webpack 5 发布 (2020-10-10)</a><br><a href="https://webpack.docschina.org/migrate/5/" target="_blank" rel="noopener">从 v4 升级到 v5</a><br>文档：<a href="https://webpack.docschina.org/concepts/under-the-hood/" target="_blank" rel="noopener">https://webpack.docschina.org/concepts/under-the-hood/</a><br><!-- [揭示内部原理] --></p><p style="text-align:right"> 2020.11.22 星期日  23：13 </p><p>2020 年 10 月 10 日，Webpack 正式发布了 5.0 版本。</p><h1 id="从-v4-升级到-v5"><a href="#从-v4-升级到-v5" class="headerlink" title="从 v4 升级到 v5"></a>从 v4 升级到 v5</h1><!-- [从 v4 升级到 v5](https://webpack.docschina.org/migrate/5/) --><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>webpack 5 要求至少 Node.js 10.13.0 (LTS)。</p><blockquote><p>使用较新的 Node.js 版本能够改善构建性能。</p></blockquote><h3 id="升级-webpack-以及它的依赖"><a href="#升级-webpack-以及它的依赖" class="headerlink" title="升级 webpack 以及它的依赖"></a>升级 webpack 以及它的依赖</h3><p>将 webpack 4 升级到最新的可用版本<br>将 webpack-cli 升级到最新的可用版本 (当有使用的时候)<br>将所有使用的 plugin 和 loader 升级到最新的可用版本<br>确保你的构建没有错误与警告<br>确保你使用的是 stats 中的入口信息<br>请确保设置了 mode</p><p>升级废弃的配置项<br>测试 webpack 5 兼容性<br>升级 webpack 版本<br>清理配置<br>清理代码<br>清理构建代码</p><p>运行单个构建并遵循以下建议<br>如有需要，在 runtime 代码中禁用 ES2015 语法</p><h2 id="内核的改变"><a href="#内核的改变" class="headerlink" title="内核的改变"></a>内核的改变</h2><p>loader 的 getOptions 方法</p><h1 id="新特性（简要）"><a href="#新特性（简要）" class="headerlink" title="新特性（简要）"></a>新特性（简要）</h1><!-- [Webpack 5 发布，主要做架构改进](https://www.oschina.net/news/119151/webpack-5-release) --><!-- $_PS: 2020年10月13日 --><h2 id="整体方向"><a href="#整体方向" class="headerlink" title="整体方向"></a>整体方向</h2><p>这个版本的重点在于以下几点。</p><p>尝试用持久性缓存来提高构建性能。<br>尝试用更好的算法和默认值来改进长期缓存。<br>尝试用更好的 Tree Shaking 和代码生成来改善包大小。<br>尝试改善与网络平台的兼容性。<br>尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4功能时处于奇怪状态的内部结构。<br>试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5版本上。</p><h2 id="重大变更"><a href="#重大变更" class="headerlink" title="重大变更"></a>重大变更</h2><p>功能清除：清理弃用的能力，废弃代码，语法废弃等<br>长期缓存：确定的 Chunk、模块 ID 和导出名称，真正的内容哈希等<br>开发支持：命名代码块 ID，模块联邦等<br>支持新的 Web 平台特性：JSON 模块，资源模块，异步模块等<br>支持全新的 Node.js 生态特性<br>开发体验：进度，Stars，自动添加唯一命名等<br>构建优化：模块合并，副作用分析，嵌套的 tree-shaking，内部模块 tree-shaking 等<br>性能优化：持久缓存，编译器闲置和关闭，文件生成<br>长期未解决问题：单一文件目标的代码分割，更新解析器等<br>9）未来计划<br>0）内部架构变更</p><h1 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h1><p><a href="https://segmentfault.com/a/1190000037460742" target="_blank" rel="noopener">Webpack 5 正式发布</a><br><!-- $_PS: 上述详细说明.发布于 10月13日 --><br>&lt;!– </p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>英译中<br><a href="https://www.jianshu.com/p/7148d29cee46" target="_blank" rel="noopener">Webpack 5 中的新特性</a><br><a href="https://zhuanlan.zhihu.com/p/56796027" target="_blank" rel="noopener">Webpack 5 中的新特性</a><br> –&gt;<br><!-- $_PS: 英翻译中。2019.06.12 17:27:42 --></p><h1 id="Module-federation"><a href="#Module-federation" class="headerlink" title="Module federation"></a>Module federation</h1><!-- [精读《Webpack5 新特性 - 模块联邦》](https://zhuanlan.zhihu.com/p/115403616)[探索 webpack5 新特性 Module federation 在腾讯文档的应用](http://www.alloyteam.com/2020/04/14338/) --><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Webpack 5 发布 (2020-10-10)&lt;/a&gt;&lt;b
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack原理</title>
    <link href="http://yoursite.com/sum/jsplus/webpack%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/sum/jsplus/webpack原理/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:05.567Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020.11 星期  ： </p><h1 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h1><p><a href="https://www.jianshu.com/p/c71393db6287" target="_blank" rel="noopener">Tapable中文文档</a><br>Tapable是一个用于事件发布订阅执行的插件架构<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公开的方法</span></span><br><span class="line"><span class="built_in">void</span> apply(plugins: Plugin...)</span><br><span class="line"><span class="built_in">void</span> plugin(names: <span class="built_in">string</span>|<span class="built_in">string</span>[], handler: <span class="built_in">Function</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 受保护的方法</span></span><br><span class="line"><span class="built_in">void</span> applyPlugins(name: <span class="built_in">string</span>, args: <span class="built_in">any</span>...)</span><br><span class="line"><span class="built_in">any</span> applyPluginsWaterfall(name: <span class="built_in">string</span>, init: <span class="built_in">any</span>, args: <span class="built_in">any</span>...)</span><br><span class="line">  <span class="built_in">void</span> applyPluginsAsync(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err?: <span class="built_in">Error</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">any</span> applyPluginsBailResult(name: <span class="built_in">string</span>, args: <span class="built_in">any</span>...)</span><br><span class="line">applyPluginsAsyncWaterfall(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    init: <span class="built_in">any</span>,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsAsyncSeries(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsParallel(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err?: <span class="built_in">Error</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line">applyPluginsParallelBailResult(</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    args: <span class="built_in">any</span>...,</span><br><span class="line">    callback: (err: <span class="built_in">Error</span>, result: <span class="built_in">any</span>) -&gt; <span class="built_in">void</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><a href="https://www.jianshu.com/p/273e1c9904d2" target="_blank" rel="noopener">Webpack 核心模块 tapable 解析（转）</a><br>Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 tapable 如下</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    SyncHook,</span><br><span class="line">    SyncBailHook,</span><br><span class="line">    SyncWaterfallHook,</span><br><span class="line">    SyncLoopHook,</span><br><span class="line">    AsyncParallelHook,</span><br><span class="line">    AsyncParallelBailHook,</span><br><span class="line">    AsyncSeriesHook,</span><br><span class="line">    AsyncSeriesBailHook,</span><br><span class="line">    AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的实现事件流机制的 “钩子” 大方向可以分为两个类别，“同步” 和 “异步”，“异步” 又分为两个类别，“并行” 和 “串行”，而 “同步” 的钩子都是串行的。</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020.11 星期  ： &lt;/p&gt;

&lt;h1 id=&quot;Tapable&quot;&gt;&lt;a href=&quot;#Tapable&quot; class=&quot;headerlink&quot; title=&quot;Tapable&quot;&gt;&lt;/a&gt;Tapable&lt;/h1&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack实践</title>
    <link href="http://yoursite.com/sum/jsplus/webpack%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/sum/jsplus/webpack实践/</id>
    <published>2020-11-22T00:00:00.000Z</published>
    <updated>2021-01-23T10:32:23.247Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2020. 星期  ： </p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>官方：performance，stats<br><!-- [[你值得拥有的几款实用webpack4性能分析插件【测评与推荐】]](https://juejin.cn/post/6844904040128577549) --></p><p>ProgressBarPlugin<br>npm i progress-bar-webpack-plugin</p><p>SpeedMeasurePlugin<br>npm i speed-measure-webpack-plugin<br><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noopener">https://github.com/stephencookdev/speed-measure-webpack-plugin</a></p><p>BundleAnalyzerPlugin<br>npm i webpack-bundle-analyzer</p><p>DashboardPlugin<br>npm i webpack-dashboard</p><p>DuplicatePackageCheckerPlugin<br>npm i duplicate-package-checker-webpack-plugin</p><!-- [浅谈 webpack 性能优化（内附 webpack 学习笔记）](https://zhuanlan.zhihu.com/p/139498741) [webpack 学习整理文档](https://github.com/darrell0904/webpack-doc)--><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2020. 星期  ： &lt;/p&gt;




&lt;h1 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h1&gt;&lt;h2 id=&quot;性能分析&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Git文档10 - Git 内部原理</title>
    <link href="http://yoursite.com/w3/git/git%E6%96%87%E6%A1%A3/git%E6%96%87%E6%A1%A3%2010%20-%20Git%20%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/w3/git/git文档/git文档 10 - Git 内部原理/</id>
    <published>2020-11-15T00:00:00.000Z</published>
    <updated>2021-01-23T13:49:55.785Z</updated>
    
    <content type="html"><![CDATA[<p>10.1 底层命令与上层命令<br>10.2 Git 对象<br>10.3 Git 引用<br>10.4 包文件<br>10.5 引用规范<br>10.6 传输协议<br>10.7 维护与数据恢复<br>10.8 环境变量<br>10.9 总结</p><p style="text-align:right"> 2020. 星期  ： </p><!-- 其他[图解git原理的几个关键概念](https://tonybai.com/2020/04/07/illustrated-tale-of-git-internal-key-concepts/) --><h1 id="底层命令与上层命令"><a href="#底层命令与上层命令" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h1><p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。</p><h3 id="底层命令与上层命令-1"><a href="#底层命令与上层命令-1" class="headerlink" title="底层命令与上层命令"></a>底层命令与上层命令</h3><p>本书主要涵盖了 checkout、branch、remote 等约 30 个 Git 的子命令。 <!-- 然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统， 所以它还包含了一部分用于完成底层工作的子命令。 这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。 --> 这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p><p>新初始化的 .git 目录的典型结构如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ls -F1</span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">  |- fa/38gezifu(40-2)</span><br><span class="line">  |- infos/</span><br><span class="line">    |- packs/</span><br><span class="line">  |- pack/</span><br><span class="line">  |- ORIG_HEAD</span><br><span class="line">  |- packed-refs</span><br><span class="line">refs/</span><br><span class="line">  |- heads/</span><br><span class="line">    |- 本地的分支| dev-feature-some-20201030-updateSth</span><br><span class="line">  |- remotes/</span><br><span class="line">    |- origin/  </span><br><span class="line">  |-tags/</span><br><span class="line">  |- stash</span><br></pre></td></tr></table></figure></p><p>随着 Git 版本的不同，该目录下可能还会包含其他内容。 不过对于一个全新的 git init 版本库，这将是你看到的默认结构。<br>description 文件仅供 GitWeb 程序使用，我们无需关心。<br>config 文件包含项目特有的配置选项。<br>info 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）。<br>hooks 目录包含客户端或服务端的钩子脚本（hook scripts）， 在 Git 钩子 中这部分话题已被详细探讨过。</p><p>剩下的四个条目很重要：HEAD 文件、（尚待创建的）index 文件，和 objects 目录、refs 目录。 它们都是 Git 的核心组成部分。<br>objects 目录存储所有数据内容；<br>refs 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；<br>HEAD 文件指向目前被检出的分支；<br>index 文件保存暂存区信息。</p><h1 id="10-2-Git-对象"><a href="#10-2-Git-对象" class="headerlink" title="10.2 Git 对象"></a>10.2 Git 对象</h1><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git 是一个内容寻址文件系统</p><h3 id="树对象（tree-object）"><a href="#树对象（tree-object）" class="headerlink" title="树对象（tree object）"></a>树对象（tree object）</h3><p>它能<strong>解决文件名保存的问题</strong>，也允许我们将多个文件组织到一起。<br><!-- Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。  --><br>一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></pre></td></tr></table></figure></p><p>master^{tree} 语法表示 master 分支上最新的提交所指向的树对象。</p><p>Figure 149. 简化版的 Git 数据模型。<br><!-- 你可以轻松创建自己的树对象。 通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录（某个时间段内）一系列的树对象。  --><br>因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。 可以通过底层命令 git update-index 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。</p><p>我们指定的文件模式为 100644，表明这是一个普通文件。 其他选择包括：100755，表示一个可执行文件；120000，表示一个符号链接。 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</p><p>这就是每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 </p><p>Figure 151. 你的 Git 目录下所有可达的对象。</p><h4 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h4><p>Git 首先会以识别出的对象的类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。 接着 Git 会在头部的第一部分添加一个空格，随后是数据内容的字节数，最后是一个空字节（null byte）</p><p>就是这样——你已创建了一个有效的 Git 数据对象。</p><p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。<br>另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p><h1 id="10-3-Git-内部原理-Git-引用"><a href="#10-3-Git-内部原理-Git-引用" class="headerlink" title="10.3 Git 内部原理 - Git 引用"></a>10.3 Git 内部原理 - Git 引用</h1><h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>不过你需要记得 1a410e 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。</p><p>在 Git 中，这种简单的名字被称为“引用（references，或简写为 refs）”。</p><p>Figure 152. 包含分支引用的 Git 目录对象。<br>当运行类似于 git branch <code>&lt;branch&gt;</code> 这样的命令时，Git 实际上会运行 update-ref 命令， <strong>取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</strong></p><h2 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h2><p>现在的问题是，当你执行 git branch <branch> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。<br>HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。</branch></p><p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</p><h4 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h4><!-- 前面我们刚讨论过 Git 的三种主要的对象类型（数据对象、树对象 和 提交对象 ），然而实际上还有第四种。 --><p>标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。<br><!-- 主要的区别在于， -->标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m <span class="string">'test tag'</span></span><br><span class="line"></span><br><span class="line">$ cat .git/refs/tags/v1.1</span><br><span class="line">9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在对该 SHA-1 值运行 git cat-file -p 命令：</span></span><br><span class="line">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2</span><br><span class="line">object 1a410efbd13591db07496601ebc7a059dd55cfe9</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> tag</span><br></pre></td></tr></table></figure><blockquote><p>我们注意到，object 条目指向我们打了标签的那个提交对象的 SHA-1 值。 另外要注意的是，标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象打标签。</p></blockquote><h4 id="远程引用-（remote-reference）"><a href="#远程引用-（remote-reference）" class="headerlink" title="远程引用 （remote reference）"></a>远程引用 （remote reference）</h4><p>,并保存在 refs/remotes 目录下。</p><h1 id="10-4-Git-内部原理-包文件"><a href="#10-4-Git-内部原理-包文件" class="headerlink" title="10.4 Git 内部原理 - 包文件"></a>10.4 Git 内部原理 - 包文件</h1><h3 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h3><p>这意味着，虽然你只是在一个 400 行的文件后面加入一行新内容，Git 也会用一个全新的对象来存储新的文件内容：</p><!-- 你的磁盘上现在有两个几乎完全相同、大小均为 22K 的对象（每个都被压缩到大约 7K）。 如果 Git 只完整保存其中一个，再保存另一个对象与之前版本的差异内容，岂不更好？ --><p>Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，</p><p>剩下的文件是新创建的<strong>包文件和一个索引</strong>。<br>包文件包含了刚才从文件系统中移除的所有对象的内容。<br>索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。<br><!-- 有意思的是运行 gc 命令前磁盘上的对象大小约为 15K，而这个新生成的包文件大小仅有 7K。 通过打包对象减少了一半的磁盘占用空间。 --></p><p>Git 是如何做到这点的？ Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。 你可以查看包文件，观察它是如何节省空间的。 git verify-pack 这个底层命令可以让你查看已打包的内容：</p><p>同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p><p>最妙之处是你可以随时重新打包。 Git 时常会自动对仓库进行重新打包以节省空间。当然你也可以随时手动执行 git gc 命令来这么做。</p><h1 id="10-5-引用规范（refspec）"><a href="#10-5-引用规范（refspec）" class="headerlink" title="10.5 引用规范（refspec）"></a>10.5 引用规范（refspec）</h1><p><code>$ git remote add origin https://github.com/schacon/simplegit-progit</code><br>运行上述命令会在你仓库中的 .git/config 文件中添加一个小节， 并在其中指定远程版本库的名称（origin）、URL 和一个用于获取操作的 引用规范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/schacon/simplegit-progit</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">  ## 让 Git 每次只拉取远程的 master 分支，而不是所有分支</span><br><span class="line">  # fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line"></span><br><span class="line">  ## 你也可以在配置文件中指定多个用于获取操作的引用规范。</span><br><span class="line">    ## 远程仓库获取时都包括 master 和 experiment 分支</span><br><span class="line">  fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br><span class="line">  ## 命名空间（或目录）</span><br><span class="line">  fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # 引用规范推送 `git push origin master:refs/heads/qa/master`</span><br><span class="line">  ## Git 每次运行 `git push origin` 时都像上面这样推送</span><br><span class="line">  push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure></p><p>引用规范的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成，<br>其中 <code>&lt;src&gt;</code> 是一个模式（pattern），代表远程版本库中的引用；<br><code>&lt;dst&gt;</code> 是本地跟踪的远程引用的位置。<br><code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</p><p>1) <!-- 默认情况下，引用规范由 git remote add origin 命令自动生成， Git 获取服务器中 refs/heads/ 下面的所有引用，并将它写入到本地的 refs/remotes/origin/ 中。 所以， -->如果服务器上有一个 master 分支，你可以在本地通过下面任意一种方式来访问该分支上的提交记录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> origin/master</span><br><span class="line">$ git <span class="built_in">log</span> remotes/origin/master</span><br><span class="line">$ git <span class="built_in">log</span> refs/remotes/origin/master</span><br></pre></td></tr></table></figure></p><p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 refs/remotes/origin/master。</p><p>1) 如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规范。<br><!-- 远程的 master 分支拉到本地的 origin/mymaster 分支 --><br><code>git fetch origin master:refs/remotes/origin/mymaster</code></p><p>1) 你也可以指定多个引用规范。 在命令行中，你可以按照如下的方式拉取多个分支：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \ </span><br><span class="line">  topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure></p><p>我们不能在模式中使用部分通配符<br>1) 但我们可以使用命名空间（或目录）来达到类似目的</p><p>### 引用规范推送<br><code>$ git push origin master:refs/heads/qa/master</code></p><p>### 删除引用<br><code>$ git push origin :topic</code><br>因为引用规范（的格式）是 <code>&lt;src&gt;:&lt;dst&gt;</code>，所以上述命令把 <code>&lt;src&gt;</code> 留空，意味着把远程版本库的 topic 分支定义为空值，也就是删除它。<br><code>$ git push origin --delete topic</code><br><!-- 或者你可以使用更新的语法（自 Git v1.7.0 以后可用）： --></p><h1 id="10-6-传输协议"><a href="#10-6-传输协议" class="headerlink" title="10.6 传输协议"></a>10.6 传输协议</h1><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。 </p><p>哑协议: 一个基于 HTTP 协议的只读版本库<br><!-- 这个协议之所以被称为“哑”协议，是因为 -->在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 GET 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><p>智能协议<br>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。<br>智能协议是更常用的传送数据的方法，但它<strong>需要在服务端运行一个进程</strong>，而这也是 Git 的智能之处——<strong>它可以读取本地数据</strong>，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><h3 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h3><p>为了上传数据至远端，Git 使用 send-pack 和 receive-pack 进程。 运行在客户端上的 send-pack 进程连接到远端运行的 receive-pack 进程。</p><p>举例来说，在项目中使用命令 git push origin master 时, origin 是由基于 SSH 协议的 URL 所定义的。 Git 会运行 send-pack 进程，它会通过 SSH 连接你的服务器。 它会尝试通过 SSH 在服务端执行命令，就像这样：</p><h3 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h3><p>当你在下载数据时， fetch-pack 和 upload-pack 进程就起作用了。 客户端启动 fetch-pack 进程，连接至远端的 upload-pack 进程，以协商后续传输的数据。</p><h1 id="10-7-维护与数据恢复"><a href="#10-7-维护与数据恢复" class="headerlink" title="10.7 维护与数据恢复"></a>10.7 维护与数据恢复</h1><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。 <!-- 大多数时候，这个命令并不会产生效果。 然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。  --><br>“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中， 将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。<br><code>$ git gc --auto</code><br>这个命令通常并不会产生效果。 大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令。<br>你可以通过修改 gc.auto 与 gc.autopacklimit 的设置来改动这些数值。</p><p>gc 将会做的另一件事是打包你的引用到一个单独的文件。<br><!-- 如果你执行了 git gc 命令，refs 目录中将不会再有这些文件。 --> 为了保证效率 Git 会将它们移动到名为 .git/packed-refs 的文件中，<br>Git 会首先在 refs 目录中查找指定的引用，然后再到 packed-refs 文件中查找。 </p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>最方便，也是最常用的方法，是使用一个名叫 git reflog 的工具。<br>当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新。 <!-- 引用日志（reflog）也可以通过 git update-ref 命令更新， --></p><p>你可以通过创建一个新的分支指向这个提交来恢复它<br><code>git branch recover-branch ab1afef</code><br><code>git log --pretty=oneline recover-branch</code></p><p>由于引用日志数据存放在 .git/logs/ 目录中，现在你已经没有引用日志了。<br><!-- 这时该如何恢复那次提交？ --> 一种方式是使用 git fsck 实用工具，将会检查数据库的完整性。<br>如果使用一个 –full 选项运行它，它会向你显示出所有没有被其他对象指向的对象：<br>$_PS: stash 的丢失，也可以通过这个指令找出/恢复。<code>----lost-found</code> : write dangling objects in .git/lost-found</p><h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>当你迁移 Subversion 或 Perforce 仓库到 Git 的时候，这会是一个严重的问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 错误添加</span></span><br><span class="line">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz</span><br><span class="line">$ git add git.tgz</span><br><span class="line">$ git commit -m <span class="string">'add git tarball'</span></span><br><span class="line"><span class="comment">## 其实这个项目并不需要这个巨大的压缩文件。 现在我们将它移除</span></span><br><span class="line">git rm git.tgz</span><br><span class="line"><span class="comment">## 执行 gc 来查看数据库占用了多少空间</span></span><br><span class="line">$ git gc</span><br><span class="line"><span class="comment">### 你也可以执行 count-objects 命令来快速的查看占用空间大小</span></span><br><span class="line">git count-objects -v</span><br></pre></td></tr></table></figure><p>size-pack 的数值指的是你的包文件以 KB 为单位计算的大小，所以你大约占用了 5MB 的空间。<br>在最后一次提交前，使用了不到 2KB ——显然，从之前的提交中移除文件并不能从历史中移除它。</p><p>首先你必须找到它。 <!-- 在本例中，你已经知道是哪个文件了。 --><br>但是假设你不知道；<!-- 该如何找出哪个文件或哪些文件占用了如此多的空间？ 如果你执行 git gc 命令，所有的对象将被放入一个包文件中， -->你可以通过运行 git verify-pack 命令， 然后对输出内容的第三列（即文件大小）进行排序，从而找出这个大文件。<br>你也可以将这个命令的执行结果通过管道传送给 tail 命令，因为你只需要找到列在最后的几个大对象。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --index-filter \</span><br><span class="line">  <span class="string">'git rm --ignore-unmatch --cached git.tgz'</span> -- 7b30847^..</span><br><span class="line"></span><br><span class="line"><span class="comment">## 你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 .git/refs/original 通过</span></span><br><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs/</span><br><span class="line">$ git gc</span><br><span class="line"><span class="comment">## 让我们看看你省了多少空间。</span></span><br><span class="line">$ git count-objects -v</span><br><span class="line"><span class="comment">## 这个大文件还在你的松散对象中，并没有消失；</span></span><br><span class="line"><span class="comment">## 如果真的想要删除它，可以通过有 --expire 选项的 git prune 命令来完全地移除那个对象</span></span><br><span class="line">$ git prune --expire now</span><br><span class="line">$ git count-objects -v</span><br></pre></td></tr></table></figure></p><h1 id="10-8-环境变量"><a href="#10-8-环境变量" class="headerlink" title="10.8 环境变量"></a>10.8 环境变量</h1><p>Git 总是在一个 bash shell 中运行，并借助一些 shell 环境变量来决定它的运行方式。</p><p>全局行为<br>GIT_EXEC_PATH<br>GIT_EDITOR</p><p>版本库位置<br>GIT_DIR<br>GIT_WORK_TREE<br>GIT_OBJECT_DIRECTORY</p><p>路径规则<br>GIT_GLOB_PATHSPECS 和 GIT_NOGLOB_PATHSPECS 控制通配符在路径规则中的默认行为。<br>GIT_LITERAL_PATHSPECS<br>GIT_ICASE_PATHSPECS</p><p>提交<br>GIT_AUTHOR_NAME, _EMAIL, _DATE<br>GIT_COMMITTER_NAME, .. , ..</p><p>网络<br>Git 使用 curl 库通过 HTTP 来完成网络操作， 所以 GIT_CURL_VERBOSE 告诉 Git 显示所有由那个库产生的消息。<br>GIT_SSL_NO_VERIFY<br>GIT_HTTP_LOW_SPEED_TIME<br>GIT_HTTP_USER_AGENT</p><p>比较和合并<br>GIT_DIFF_OPTS<br>GIT_EXTERNAL_DIFF<br>GIT_MERGE_VERBOSITY</p><p>调试<br>GIT_TRACE</p><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;10.1 底层命令与上层命令&lt;br&gt;10.2 Git 对象&lt;br&gt;10.3 Git 引用&lt;br&gt;10.4 包文件&lt;br&gt;10.5 引用规范&lt;br&gt;10.6 传输协议&lt;br&gt;10.7 维护与数据恢复&lt;br&gt;10.8 环境变量&lt;br&gt;10.9 总结&lt;/p&gt;
&lt;p style=&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/w3/git/"/>
    
      <category term="git文档" scheme="http://yoursite.com/categories/w3/git/git%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git文档8 - 自定义 Git</title>
    <link href="http://yoursite.com/w3/git/git%E6%96%87%E6%A1%A3/git%E6%96%87%E6%A1%A3%208%20-%20%E8%87%AA%E5%AE%9A%E4%B9%89%20Git/"/>
    <id>http://yoursite.com/w3/git/git文档/git文档 8 - 自定义 Git/</id>
    <published>2020-11-15T00:00:00.000Z</published>
    <updated>2021-01-23T13:50:02.565Z</updated>
    
    <content type="html"><![CDATA[<ol start="8"><li>自定义 Git</li></ol><p>8.1 配置 Git<br>8.2 Git 属性<br>8.3 Git 钩子<br>8.4 使用强制策略的一个例子<br>8.5 总结</p><p style="text-align:right"> 2020.11.15 星期日  23：36 </p><h2 id="8-1-配置-Git"><a href="#8-1-配置-Git" class="headerlink" title="8.1 配置 Git"></a>8.1 配置 Git</h2><p><code>git config --global user.name &quot;John Doe&quot;</code><br><code>git config --global user.email johndoe@example.com</code><br><!-- Git 使用一系列配置文件来保存你自定义的行为。  -->它首先会查找系统级的 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 git config，它就会读写该文件。<br>接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。<br>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该仓库有效，它对应于向 git config 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。</p><h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">man git-config</span><br><span class="line"></span><br><span class="line">git config --global core.editor emacs</span><br><span class="line">git config --global commit.template ~/.gitmessage.txt</span><br><span class="line"></span><br><span class="line">git config --global core.pager <span class="string">''</span></span><br><span class="line">git config --global user.signingkey &lt;gpg-key-id&gt;</span><br><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line"><span class="comment"># help.autocorrect 接受一个代表十分之一秒的整数。 所以如果你把它设置为 50, Git 将在自动执行命令前给你 5 秒的时间改变主意。</span></span><br></pre></td></tr></table></figure><h3 id="Git-中的着色"><a href="#Git-中的着色" class="headerlink" title="Git 中的着色"></a>Git 中的着色</h3><p>color.ui<br>color.*</p><p><code>git config --global color.ui false</code><br><code>git config --global color.diff.meta &quot;blue black bold&quot;</code></p><h3 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h3><p>这里我们以一个不错且免费的工具 —— Perforce 图形化合并工具（P4Merge）</p><p><code>git mergetool</code>，Git 会调用 P4Merge 让你通过图形界面来解决冲突。<br>Git 预设了许多其他的合并和解决冲突的工具，无需特别的设置你就能用上它们。 要想看到它支持的工具列表，<br><code>git mergetool --tool-help</code><br><code>git config --global merge.tool kdiff3</code></p><p>$_PS: 略。编辑器亦可。</p><h3 id="格式化与多余的空白字符"><a href="#格式化与多余的空白字符" class="headerlink" title="格式化与多余的空白字符"></a>格式化与多余的空白字符</h3><p>core.autocrlf<br>core.whitespace</p><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>receive.fsckObjects<br><!-- Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。 --><br>receive.denyNonFastForwards<br><!-- 要禁用这样（变基）的强制更新推送（force-pushes）， --><br>receive.denyDeletes<br><!-- 这样会禁止通过推送删除分支和标签 — 没有用户可以这么做。 --></p><!-- $_PS: 略。过于高级 --><h2 id="8-2-Git-属性"><a href="#8-2-Git-属性" class="headerlink" title="8.2 Git 属性"></a>8.2 Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。 这些基于路径的设置项被称为 Git 属性，<br>可以在你的目录下的 .gitattributes 文件内进行设置（通常是你的项目的根目录）。<br>如果不想让这些属性文件与其它文件一同提交，你也可以在 .git/info/attributes 文件中进行设置。</p><p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3> <!-- 它本应被机器处理。因此，你想把它当成二进制文件。 --><p>识别二进制文件<br><code>*.pbxproj binary</code><br><!-- 现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 git show 或 git diff 时，Git 也不会比较或打印该文件的变化。 --></p><p>比较二进制文件<br><!-- 秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。 --><br><code>*.docx diff=word</code><br>所有匹配 .docx 模式的文件都应该使用“word”过滤器。<br>借助 docx2txt 程序将 Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。<br><code>git config diff.word.textconv docx2txt</code></p><p>还能用这个方法比较图像文件。<br>运用一个过滤器，提炼出 EXIF 信息.   …  下载并安装了 exiftool 程序，<br><code>*.png diff=exif</code><br><code>git config diff.exif.textconv exiftool</code></p><h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p><code>*.txt ident</code></p><p>不过，我们可以在检出某个文件后对其注入文本，并在再次提交前删除这些文本。 Git 属性提供了两种方法来达到这一目的。<br>一种方法是，你可以把文件所对应数据对象的 SHA-1 校验和自动注入到文件中的 <code>$Id$</code> 字段。<br>另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。 一个过滤器由“clean”和“smudge”两个子过滤器组成。<br><code>*.c filter=indent</code><br><code>git config --global filter.indent.clean indent</code><br><code>git config --global filter.indent.smudge cat</code></p><p>$_PS: 功能是强大。不用</p><h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>export-ignore<br><code>test/ export-ignore</code><br>当你运行 <code>git archive</code> 来创建项目的压缩包时，那个目录不会被包括在归档中。</p><p>export-subst<br>在导出文件进行部署的时候，你可以将 git log 的格式化和关键字展开处理应用到标记了 export-subst 属性的部分文件。<br><code>LAST_COMMIT export-subst</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'Last commit date: $Format:%cd by %aN$'</span> &gt; LAST_COMMIT</span><br><span class="line">git add LAST_COMMIT .gitattributes</span><br><span class="line">git commit -am <span class="string">'adding LAST_COMMIT file for archives'</span></span><br><span class="line"><span class="comment">## 运行 git archive 之后，归档文件的内容会被替换成这样：</span></span><br><span class="line">git archive HEAD | tar xCf ../deployment-testing -</span><br><span class="line">cat ../deployment-testing/LAST_COMMIT</span><br><span class="line">Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</span><br></pre></td></tr></table></figure></p><p>你也可以用诸如提交信息或者任意的 git notes 进行替换，并且 git log 还能做简单的字词折行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$'</span> &gt; LAST_COMMIT</span><br><span class="line">git commit -am <span class="string">'export-subst uses git log'</span>\<span class="string">''</span>s custom formatter</span><br></pre></td></tr></table></figure></p><p>由此得到的归档适用于（当前的）部署工作。然而和其他的导出归档一样，它并不适用于后继的部署工作。</p><p>$_PS: 最后一个看了个寂寞。<!-- 不是很懂 --></p><h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>database.xml merge=ours<br><code>git config --global merge.ours.driver true</code></p><p>$_PS: gitattribute先后顺序很重要！！<br><!-- [git merge合并忽略某些文件](https://blog.csdn.net/qq_39176597/article/details/89210686) --><br>&lt;!– 原来gitattribute方法生效是有条件的，跟文件的修改顺序有关系，只有先修改的往后来修改的合并的时候才会生效。<br>这里的先后是指文件的最后修改时间，不是创建的时间，如果最近修改过，那它就是最新的，<br>比如刚才的例子，我们修改了publish分支的info.plist，而没有对另外两个分支下的info.plist进行修改，那么publish分支下的info.plist就比另外两个分支新，<br>这时候合并的时候，gitattribute就会失去作用，那么该如做呢，我们在修改完publish分支后，需要再次修改另外两个分支下的plist配置文件，即使没啥可以改的，也要改(可以先改错，再改回去)这样我们publish分支下的，就会仍然保持最旧。</p><p>举例：<br>release和debug都有个配置项文件：config<br>如果合并时你要忽略config，那你要先改debug分支的config，然后再改release分支的config，<br>这样你在release分支下进行：git merge debug时就会忽略config文件。<br> –&gt;</p><h2 id="8-3-Git-钩子"><a href="#8-3-Git-钩子" class="headerlink" title="8.3 Git 钩子"></a>8.3 Git 钩子</h2><p>有两组这样的钩子：客户端的和服务器端的。 </p><h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>客户端钩子分为很多种。 下面把它们分为：提交工作流钩子、电子邮件工作流钩子和其它钩子。</p><h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p>pre-commit<br>prepare-commit-msg<br>commit-msg<br>post-commit</p><h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>你可以给电子邮件工作流设置三个客户端钩子。<br>它们都是由 git am 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。<br>如果你需要通过电子邮件接收由 git format-patch 产生的补丁，这些钩子也许用得上。</p><p>applypatch-msg<br>pre-applypatch<br>post-applypatch </p><h4 id="其它客户端钩子"><a href="#其它客户端钩子" class="headerlink" title="其它客户端钩子"></a>其它客户端钩子</h4><p>pre-rebase<br>post-rewrite<br>post-checkout<br>post-merge<br>pre-push<br>pre-auto-gc</p><h3 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h3><p>pre-receive<br>update<br>post-receive</p><p>$_PS: husky常用到的，提交前lint代码，检测提交规范；<br>$_PS: CI/CD 用到，push/tag后触发构建；PR后介绍邮件</p><h2 id="8-4-使用强制策略的一个例子"><a href="#8-4-使用强制策略的一个例子" class="headerlink" title="8.4 使用强制策略的一个例子"></a>8.4 使用强制策略的一个例子</h2><p><!-- 在本节中，你将应用前面学到的知识 -->建立这样一个 Git 工作流程：检查提交信息的格式，并且指定只能由特定用户修改项目中特定的子目录。<br>你将编写一个客户端脚本来提示开发人员他们的推送是否会被拒绝，以及一个服务器端脚本来实际执行这些策略。</p><p>$_PS: 略。没有看明白</p><p>服务器端钩子<br>  指定特殊的提交信息格式<br>  指定基于用户的访问权限控制列表（ACL）系统<br>  测试一下<br>客户端钩子</p><p>### </p><p>### </p><p>### </p><p>### </p><h2 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h2><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;自定义 Git&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;8.1 配置 Git&lt;br&gt;8.2 Git 属性&lt;br&gt;8.3 Git 钩子&lt;br&gt;8.4 使用强制策略的一个例子&lt;br&gt;8.5 总结&lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/w3/git/"/>
    
      <category term="git文档" scheme="http://yoursite.com/categories/w3/git/git%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
