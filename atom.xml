<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yalhu</title>
  
  <subtitle>yalhu&#39;s blob</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-02-22T14:01:19.286Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yalhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ens-2023</title>
    <link href="http://yoursite.com/ins/ens/characters-2023/"/>
    <id>http://yoursite.com/ins/ens/characters-2023/</id>
    <published>2023-02-22T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.286Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2023.22.22 星期三 </p><h2 id="0222"><a href="#0222" class="headerlink" title="0222"></a>0222</h2><ol><li>concurrent： adj-同时；合流的</li><li>suspense： [n] 悬念。<br>React 18 introduces the foundation of concurrent rendering and new features such as suspense, streaming server rendering, and transitions are powered by concurrent rendering.<!-- google翻译：React 18 引入了并发渲染的基础，并且新功能（例如悬念、流式服务器渲染和过渡）由并发渲染提供支持。 --></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2023.22.22 星期三 &lt;/p&gt;


&lt;h2 id=&quot;0222&quot;&gt;&lt;a href=&quot;#0222&quot; class=&quot;headerlink&quot; title=&quot;0222&quot;&gt;&lt;/a&gt;0222&lt;
      
    
    </summary>
    
      <category term="ins" scheme="http://yoursite.com/categories/ins/"/>
    
      <category term="ens" scheme="http://yoursite.com/categories/ins/ens/"/>
    
    
      <category term="ens" scheme="http://yoursite.com/tags/ens/"/>
    
  </entry>
  
  <entry>
    <title>曝光埋点监听实现</title>
    <link href="http://yoursite.com/sum/js/%E6%9B%9D%E5%85%89%E5%9F%8B%E7%82%B9%E7%9B%91%E5%90%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/sum/js/曝光埋点监听实现/</id>
    <published>2023-02-20T00:00:00.000Z</published>
    <updated>2023-02-22T14:39:54.740Z</updated>
    
    <content type="html"><![CDATA[<p>Intersection Observer API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></p><a id="more"></a><p style="text-align:right">2023.2.20 星期一 </p><h2 id="IntersectionObserver-方式"><a href="#IntersectionObserver-方式" class="headerlink" title="IntersectionObserver 方式"></a>IntersectionObserver 方式</h2><!-- \# 1-A [Web曝光埋点实现原理](https://www.jianshu.com/p/bb9375b0999d)IntersectionObserver:demo源代码：https://stackblitz.com/edit/js-ozzzjw?file=index.jsdemo效果：https://js-ozzzjw.stackblitz.io/曝光埋点实现demo源代码：https://stackblitz.com/edit/react-hfq33n?file=src%2FApp.jsdemo效果：https://react-hfq33n.stackblitz.io/--><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( entry.intersectionRatio &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            report(entry.target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">document</span>.querySelectorAll(<span class="string">".item"</span>)</span><br><span class="line">nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    intersectionObserver.observe(node)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主要用到的API<br><code>IntersectionObserver</code> 主要用来检测被监听的目标元素可见部分与root元素的交叉状况，比如获取相交区域的比例值，后面做曝光埋点的判断需要用到。</p><p><code>requestIdleCallback</code> 方法，浏览器会在空闲时执行传入的函数。后面埋点我们使用这个方法，避免埋点影响主业务。</p><!-- END#1 --><h2 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h2><!-- \# 2-A [基于 IntersectionObserver 实现一个组件的曝光监控](https://www.xiabingbao.com/post/js/dom-expose-intersectionobserver.html) --><p>实现的方式主要有两种：<br>函数的方式；<br>高阶组件的方式；<br>&lt;!– PS:<br>app.jsx中使用新的hooks；不用每个组件都调用。可以用高阶组件， 或者函数试：useEffect(() =&gt; {useExpo()}, [])<br>高阶组件，不用通过class获取目标元素。而是<code>const ref = useRef&lt;any&gt;(null);</code></p><p>taro或者小程序项目有api：Taro.createIntersectionObserver<br>–&gt;</p><!-- END#2 --><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><!-- \#3 [利用好浏览器的空闲时间 --- requestIdleCallback](https://www.cnblogs.com/Wayou/p/requestIdleCallback.html) --><!--[监听DOM曝光事件 IntersectionObserver](https://juejin.cn/post/6844903886013071373)[如何实现元素曝光上报](https://segmentfault.com/a/1190000019980376)[JavaScript 监听元素是否进入/移出可视区域](https://blog.csdn.net/latency_cheng/article/details/84963435)方案一：监听页面或者区域scroll事件，通过getBoundingClientRect接口取元素的位置与可视窗口进行判断。防抖节流优点：兼容性好缺点：需要关注页面或者区域的scroll事件频繁的scroll事件，性能问题IntersectionObserver方案二：通过 IntersectionObserver 监听元素是否处于可视范围实际上，针对兼容性问题，w3c 官方提供了对应 polyfill, 因此intersectionObserver用于生产是可行的。 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intersection Observer API: &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/sum/js/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript-d.ts文件</title>
    <link href="http://yoursite.com/sum/jsplus/typescript-d.ts%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/sum/jsplus/typescript-d.ts文件/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:30:30.104Z</updated>
    
    <content type="html"><![CDATA[<p>typescript 声明文件介绍<!-- 历史 -->及使用</p><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h1 id="d-ts-介绍"><a href="#d-ts-介绍" class="headerlink" title="d.ts 介绍"></a>d.ts 介绍</h1><!-- \#1-S [一文读懂TS的(.d.ts)文件](https://juejin.cn/post/6987735091925483551)\#1-S [一文读懂TS的(.d.ts)文件](https://developer.aliyun.com/article/929847) --><h2 id="二、-什么是“-d-ts”-文件"><a href="#二、-什么是“-d-ts”-文件" class="headerlink" title="二、 什么是“.d.ts” 文件"></a>二、 什么是“.d.ts” 文件</h2><p>基于 Typescript 开发的时候，很麻烦的一个问题就是类型定义。导致在编译的时候，经常会看到一连串的找不到类型的提示。“d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息。<br>简单讲，就是你可以在 ts 中调用的 js 的声明文件。TS的核心在于静态类型，我们在编写 TS 的时候会定义很多的类型，但是主流的库都是 JS编写的，并不支持类型系统。这个时候你不能用TS重写主流的库，<strong>这个时候我们只需要编写仅包含类型注释的 d.ts 文件</strong>，然后从您的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的 TS 优势。</p><p>在此期间，解决的方式经过了许多的变化，从 DefinitelyTyped 到 typings。<strong>最后是 @types</strong>。在 Typescript 2.0 之后，推荐使用 @types 方式。</p><!-- ### 2.1 DefinitelyTyped### 2.2 Typings --><h3 id="2-3-Types"><a href="#2-3-Types" class="headerlink" title="2.3 @Types"></a>2.3 @Types</h3><!-- DefinitelyTyped和# Typings都需要使用另外一套系统来管理类型定义显然不太方便。 在 Typescript 2.0 之后，TypeScript 将会默认的查看 ./node_modules/@types 文件夹，自动从这里来获取模块的类型定义，当然了，你需要独立安装这个类型定义。Microsoft 在 The Future of Declaration Files 介绍了 TypeScript 的这个新特性。 --><p>默认情况下，所有的 @types 包都会在编译时应用，任意层的 node_modules/@types 都会被使用，进一步说，在  ./node_modules/@types/ , ../node_modules/@types/, ../../node_modules/@types/ 都被应用。如果你的类型定义不在这个文件夹中，可以使用 typesRoot 来配置，只有在 typeRoots 中的包才会被包含，配置如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">       <span class="string">"types"</span> : [<span class="string">"node"</span>, <span class="string">"lodash"</span>, <span class="string">"express"</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-d-ts和-types关系"><a href="#2-4-d-ts和-types关系" class="headerlink" title="2.4 *.d.ts和@types关系"></a>2.4 *.d.ts和@types关系</h4><p>@types是npm的一个分支，用来存放<em>.d.ts文件，如果对应的npm包存放在@types中，要使用必须下载！如果是自己本地的</em>.d.ts申明文件，则和@types没有任何关系！<br><!-- \## 三、 编写语法\## 四、案例五、常用工具参考--></p><!-- END#1 --><h1 id="第三方库的声明文件"><a href="#第三方库的声明文件" class="headerlink" title="第三方库的声明文件"></a>第三方库的声明文件</h1><!-- \#2 [Typescript入门教程-声明文件](https://ts.xcatliu.com/basics/declaration-files.html#发布声明文件) --><p>## 什么是声明语句§<br>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。</p><p>## 什么是声明文件§<br>通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件3</p><p>### 第三方声明文件§<br>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。</p><p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：<br><code>npm install @types/jquery --save-dev</code></p><p>## 书写声明文件§<br><!-- 当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。 --></p><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><!-- 库的使用场景主要有以下几种：全局变量：通过 `<script>` 标签引入第三方库，注入全局变量npm 包：通过 import foo from 'foo' 导入，符合 ES6 模块规范UMD 库：既可以通过 <`script>` 标签引入，又可以通过 `import` 导入直接扩展全局变量：通过 `<script>` 标签引入后，改变一个全局变量的结构在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构模块插件：通过 `<script>` 或 `import` 导入后，改变另一个模块的结构\## 发布声明文件\### 将声明文件和源码放在一起1) 如果声明文件是通过 tsc 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。2) 如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：* 给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址* 在项目根目录下，编写一个 index.d.ts 文件* 针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件\### 将声明文件发布到 @types 下 --><h1 id="声明文件文档"><a href="#声明文件文档" class="headerlink" title="声明文件文档"></a>声明文件文档</h1><p><a href="https://www.tslang.cn/docs/handbook/declaration-files/library-structures.html" target="_blank" rel="noopener">typescript文档-声明文件</a></p><h2 id="识别库的类型"><a href="#识别库的类型" class="headerlink" title="识别库的类型"></a>识别库的类型</h2><h3 id="全局库"><a href="#全局库" class="headerlink" title="全局库"></a>全局库</h3><h3 id="模块化库"><a href="#模块化库" class="headerlink" title="模块化库"></a>模块化库</h3><h3 id="使用依赖"><a href="#使用依赖" class="headerlink" title="使用依赖"></a>使用依赖</h3><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>防止命名冲突</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;typescript 声明文件介绍&lt;!-- 历史 --&gt;及使用&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:23:16.227Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript</a><br><a href="https://www.typescriptlang.org/zh/docs/" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/</a></p><!-- typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.htmltypescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.htmlPS: 简介，基础，进阶，工程，感谢。 --><p>TypeScript: 静态类型检查器</p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h1 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h1><p>Quick introductions based on your background or preference.</p><p>TS for the New Programmer<br>TypeScript for JS Programmers<br>TS for Java/C# Programmers<br>TS for Functional Programmers<br>TypeScript Tooling in 5 minutes</p><h1 id="Handbook"><a href="#Handbook" class="headerlink" title="Handbook"></a>Handbook</h1><p>A great first read for your daily TS work.</p><h2 id="The-TypeScript-Handbook"><a href="#The-TypeScript-Handbook" class="headerlink" title="The TypeScript Handbook"></a>The TypeScript Handbook</h2><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><h2 id="More-on-Functions"><a href="#More-on-Functions" class="headerlink" title="More on Functions"></a>More on Functions</h2><h2 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h2><h2 id="Type-Manipulation"><a href="#Type-Manipulation" class="headerlink" title="Type Manipulation"></a>Type Manipulation</h2><p>Creating Types from Types<br>Generics<br>Keyof Type Operator<br>Typeof Type Operator<br>Indexed Access Types<br>Conditional Types<br>Mapped Types<br>Template Literal Types</p><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><p>Using TypeScript in several environments.</p><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><h2 id="DOM-Manipulation"><a href="#DOM-Manipulation" class="headerlink" title="DOM Manipulation"></a>DOM Manipulation</h2><h2 id="Migrating-from-JavaScript"><a href="#Migrating-from-JavaScript" class="headerlink" title="Migrating from JavaScript"></a>Migrating from JavaScript</h2><h2 id="Using-Babel-with-TypeScript"><a href="#Using-Babel-with-TypeScript" class="headerlink" title="Using Babel with TypeScript"></a>Using Babel with TypeScript</h2><h1 id="Declaration-Files"><a href="#Declaration-Files" class="headerlink" title="Declaration Files"></a>Declaration Files</h1><p>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Declaration-Reference"><a href="#Declaration-Reference" class="headerlink" title="Declaration Reference"></a>Declaration Reference</h2><h2 id="Library-Structures"><a href="#Library-Structures" class="headerlink" title="Library Structures"></a>Library Structures</h2><h2 id="d-ts-Templates"><a href="#d-ts-Templates" class="headerlink" title=".d.ts Templates"></a>.d.ts Templates</h2><p>Modules .d.ts<br>Module: Plugin<br>Module: Class<br>Module: Function<br>Global .d.ts<br>Global: Modifying Module</p><h2 id="Do’s-and-Don’ts"><a href="#Do’s-and-Don’ts" class="headerlink" title="Do’s and Don’ts"></a>Do’s and Don’ts</h2><h2 id="Deep-Dive"><a href="#Deep-Dive" class="headerlink" title="Deep Dive"></a>Deep Dive</h2><h2 id="Publishing"><a href="#Publishing" class="headerlink" title="Publishing"></a>Publishing</h2><h2 id="Consumption"><a href="#Consumption" class="headerlink" title="Consumption"></a>Consumption</h2><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>How to use TypeScript-powered JavaScript tooling.</p><h2 id="JS-Projects-Utilizing-TypeScript"><a href="#JS-Projects-Utilizing-TypeScript" class="headerlink" title="JS Projects Utilizing TypeScript"></a>JS Projects Utilizing TypeScript</h2><h2 id="Type-Checking-JavaScript-Files"><a href="#Type-Checking-JavaScript-Files" class="headerlink" title="Type Checking JavaScript Files"></a>Type Checking JavaScript Files</h2><h2 id="JSDoc-Reference"><a href="#JSDoc-Reference" class="headerlink" title="JSDoc Reference"></a>JSDoc Reference</h2><h2 id="Creating-d-ts-Files-from-js-files"><a href="#Creating-d-ts-Files-from-js-files" class="headerlink" title="Creating .d.ts Files from .js files"></a>Creating .d.ts Files from .js files</h2><h1 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h1><p>Compiler configuration reference.</p><h2 id="What-is-a-tsconfig-json"><a href="#What-is-a-tsconfig-json" class="headerlink" title="What is a tsconfig.json"></a>What is a tsconfig.json</h2><h2 id="Compiler-Options-in-MSBuild"><a href="#Compiler-Options-in-MSBuild" class="headerlink" title="Compiler Options in MSBuild"></a>Compiler Options in MSBuild</h2><h2 id="TSConfig-Reference"><a href="#TSConfig-Reference" class="headerlink" title="TSConfig Reference"></a>TSConfig Reference</h2><h2 id="tsc-CLI-Options"><a href="#tsc-CLI-Options" class="headerlink" title="tsc CLI Options"></a>tsc CLI Options</h2><h2 id="Project-References"><a href="#Project-References" class="headerlink" title="Project References"></a>Project References</h2><h2 id="Integrating-with-Build-Tools"><a href="#Integrating-with-Build-Tools" class="headerlink" title="Integrating with Build Tools"></a>Integrating with Build Tools</h2><h2 id="Configuring-Watch"><a href="#Configuring-Watch" class="headerlink" title="Configuring Watch"></a>Configuring Watch</h2><h2 id="Nightly-Builds"><a href="#Nightly-Builds" class="headerlink" title="Nightly Builds"></a>Nightly Builds</h2><h1 id="Cheat-Sheets"><a href="#Cheat-Sheets" class="headerlink" title="Cheat Sheets"></a>Cheat Sheets</h1><p><strong>Downloadable</strong> syntax reference pages for different parts of everyday TypeScript code.</p><h2 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h2><h2 id="Classes-1"><a href="#Classes-1" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h2 id="Download-PDFs-and-PNGs"><a href="#Download-PDFs-and-PNGs" class="headerlink" title="Download PDFs and PNGs"></a>Download PDFs and PNGs</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/TypeScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Microsoft/TypeScript&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/&lt;/a&gt;&lt;/p&gt;
&lt;!-- 
typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.html

typescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.html
PS: 简介，基础，进阶，工程，感谢。
 --&gt;
&lt;p&gt;TypeScript: 静态类型检查器&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档1-Get Started</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A31-Get%20Started/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档1-Get Started/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:25:27.993Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="TypeScript-for-the-New-Programmer"><a href="#TypeScript-for-the-New-Programmer" class="headerlink" title="TypeScript for the New Programmer"></a>TypeScript for the New Programmer</h2><p>JavaScript 的类型化超集</p><p>不过，TypeScript 与 JavaScript 是什么关系呢？</p><p>语法<br>TypeScript 是 JavaScript 的 超集 ：因此 JS 语法是合法的 TS。&lt;!– 语法是指我们编写文本以组成程序的方式。例如，这段代码有一个 语法 错误，因为它缺少一个 )：</p><p>类型<br>但是，TypeScript 是一个 类型化 的超集，意味着它添加了针对如何使用不同类型的值的规则。<!-- 之前关于 obj.heigth 的错误不是 语法 错误，而是以不正确的方式使用了某种值（ 类型 ）。 --></p><p>运行时行为<br>TypeScript 保留了 JavaScript 的 运行时行为 。<!-- 例如，在JavaScript 中被零除的结果是 Infinity，而不是抛出运行时异常。 -->原则上，TypeScript 绝不 改变 JavaScript 代码的运行时行为。</p><!-- 这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以 保证 以相同的方式运行。 --><p>擦除类型<br>粗略地说，一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码<!-- 。这意味着一旦您的代码被编译，生成的普通 JS 代码便没有类型信息。 --><br><!-- 这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为 。最重要的是，尽管您可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 --></p><h2 id="TypeScript-for-JavaScript-Programmers"><a href="#TypeScript-for-JavaScript-Programmers" class="headerlink" title="TypeScript for JavaScript Programmers"></a>TypeScript for JavaScript Programmers</h2><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><!-- 通过感知 JavaScript 的工作原理，TypeScript 可以构建一个接受 JavaScript 代码但具有类型的类型系统。这个类型系统使得我们不需要添加额外的字符来显式地指定类型。在上面的例子中，TypeScript就是这样知道 helloWorld 是 string 类型的。你可能已经在 Visual Studio Code 中编写了 JavaScript，并已使用了编辑器的自动补全功能。Visual Studio Code 使用了 TypeScript 的引擎，以便更容易地处理 JavaScript。 --><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><p>JavaScript 中已经有一些基本类型可用：boolean、 bigint、 null、number、 string、 symbol 和 undefined，它们都可以在接口中使用。TypeScript 将此列表扩展为更多的内容，例如 any （允许任何类型）、unknown （确保使用此类型的人声明类型是什么）、 never （这种类型不可能发生）和 void （返回 undefined 或没有返回值的函数）。</p><p>构建类型有两种语法： 接口和类型。 你应该更喜欢 interface。当需要特定功能时使用 type 。</p><h3 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h3><!-- 使用 TypeScript，可以通过组合简单类型来创建复杂类型。 -->有两种流行的方法可以做到这一点：联合和泛型。<br>#### 联合<br>使用联合，可以声明类型可以是许多类型中的一种。<br>#### 泛型<br>泛型为类型提供变量。一个常见的例子是数组。没有泛型的数组可以包含任何内容。带有泛型的数组可以描述数组包含的值。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringArray = <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> NumberArray = <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> ObjectWithNameArray = <span class="built_in">Array</span>&lt;&#123; name: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 声明自己使用泛型的类型</span></span><br><span class="line"><span class="keyword">interface</span> Backpack&lt;Type&gt; &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">obj: Type</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> Type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这一行是一个简写，可以告诉 TypeScript 有一个常量，叫做`backpack`，并且不用担心它是从哪</span></span><br><span class="line"><span class="comment">// 里来的。</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> backpack: Backpack&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// 对象是一个字符串，因为我们在上面声明了它作为 Backpack 的变量部分。</span></span><br><span class="line"><span class="keyword">const</span> object = backpack.get();</span><br><span class="line"><span class="comment">// 因为 backpack 变量是一个字符串，不能将数字传递给 add 函数。</span></span><br><span class="line">backpack.add(<span class="number">23</span>);</span><br><span class="line"><span class="comment">// Argument of type 'number' is not assignable to parameter of type 'string'.</span></span><br></pre></td></tr></table></figure><h3 id="结构化的类型系统（structural-type-system）"><a href="#结构化的类型系统（structural-type-system）" class="headerlink" title="结构化的类型系统（structural type system）"></a>结构化的类型系统（structural type system）</h3><p>TypeScript 的一个核心原则是类型检查基于对象的属性和行为（type checking focuses on the shape that values have）。<!-- 这有时被叫做“鸭子类型”或“结构类型”（structural typing）。 --></p><p>在结构化的类型系统当中，如果两个对象具有相同的结构，则认为它们是相同类型的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/handbook/typescript-from-scratch.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Rtypescript文档2-Handbook</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A32-Handbook/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档2-Handbook/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:25:13.468Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/intro.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/intro.html</a><br><a href="https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html" target="_blank" rel="noopener">https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="The-TypeScript-Handbook"><a href="#The-TypeScript-Handbook" class="headerlink" title="The TypeScript Handbook"></a>The TypeScript Handbook</h2><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h3 id="Static-type-checking"><a href="#Static-type-checking" class="headerlink" title="Static type-checking"></a>Static type-checking</h3><h3 id="Non-exception-Failures"><a href="#Non-exception-Failures" class="headerlink" title="Non-exception Failures"></a>Non-exception Failures</h3><h3 id="Types-for-Tooling"><a href="#Types-for-Tooling" class="headerlink" title="Types for Tooling"></a>Types for Tooling</h3><h3 id="tsc-the-TypeScript-compiler"><a href="#tsc-the-TypeScript-compiler" class="headerlink" title="tsc, the TypeScript compiler"></a>tsc, the TypeScript compiler</h3><h3 id="Emitting-with-Errors"><a href="#Emitting-with-Errors" class="headerlink" title="Emitting with Errors"></a>Emitting with Errors</h3><h3 id="Explicit-Types"><a href="#Explicit-Types" class="headerlink" title="Explicit Types"></a>Explicit Types</h3><h3 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h3><h3 id="Downleveling"><a href="#Downleveling" class="headerlink" title="Downleveling"></a>Downleveling</h3><h3 id="Strictness"><a href="#Strictness" class="headerlink" title="Strictness"></a>Strictness</h3><h3 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h3><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><h3 id="The-primitives-string-number-and-boolean"><a href="#The-primitives-string-number-and-boolean" class="headerlink" title="The primitives: string, number, and boolean"></a>The primitives: string, number, and boolean</h3><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><h4 id="noImplicitAny-1"><a href="#noImplicitAny-1" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h4><h3 id="Type-Annotations-on-Variables"><a href="#Type-Annotations-on-Variables" class="headerlink" title="Type Annotations on Variables"></a>Type Annotations on Variables</h3><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><h4 id="Parameter-Type-Annotations"><a href="#Parameter-Type-Annotations" class="headerlink" title="Parameter Type Annotations"></a>Parameter Type Annotations</h4><h4 id="Return-Type-Annotations"><a href="#Return-Type-Annotations" class="headerlink" title="Return Type Annotations"></a>Return Type Annotations</h4><h4 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h4><h3 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h3><h4 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h4><h3 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h3><h4 id="Defining-a-Union-Type"><a href="#Defining-a-Union-Type" class="headerlink" title="Defining a Union Type"></a>Defining a Union Type</h4><h4 id="Working-with-Union-Types"><a href="#Working-with-Union-Types" class="headerlink" title="Working with Union Types"></a>Working with Union Types</h4><h3 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h3><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><h3 id="Differences-Between-Type-Aliases-and-Interfaces"><a href="#Differences-Between-Type-Aliases-and-Interfaces" class="headerlink" title="Differences Between Type Aliases and Interfaces"></a>Differences Between Type Aliases and Interfaces</h3><h3 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h3><h3 id="Literal-Types"><a href="#Literal-Types" class="headerlink" title="Literal Types"></a>Literal Types</h3><h3 id="Literal-Inference"><a href="#Literal-Inference" class="headerlink" title="Literal Inference"></a>Literal Inference</h3><h3 id="null-and-undefined"><a href="#null-and-undefined" class="headerlink" title="null and undefined"></a>null and undefined</h3><h4 id="strictNullChecks-off"><a href="#strictNullChecks-off" class="headerlink" title="strictNullChecks off"></a>strictNullChecks off</h4><h4 id="strictNullChecks-on"><a href="#strictNullChecks-on" class="headerlink" title="strictNullChecks on"></a>strictNullChecks on</h4><h4 id="Non-null-Assertion-Operator-Postfix"><a href="#Non-null-Assertion-Operator-Postfix" class="headerlink" title="Non-null Assertion Operator (Postfix !)"></a>Non-null Assertion Operator (Postfix !)</h4><h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><h3 id="Less-Common-Primitives"><a href="#Less-Common-Primitives" class="headerlink" title="Less Common Primitives"></a>Less Common Primitives</h3><h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><h2 id="More-on-Functions"><a href="#More-on-Functions" class="headerlink" title="More on Functions"></a>More on Functions</h2><h2 id="Object-Types-1"><a href="#Object-Types-1" class="headerlink" title="Object Types"></a>Object Types</h2><h2 id="Type-Manipulation"><a href="#Type-Manipulation" class="headerlink" title="Type Manipulation"></a>Type Manipulation</h2><p>Creating Types from Types<br>Generics<br>Keyof Type Operator<br>Typeof Type Operator<br>Indexed Access Types<br>Conditional Types<br>Mapped Types<br>Template Literal Types</p><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/intro.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/zh/docs/handbook/2/basic-types.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Rtypescript文档6-Declaration Files</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A36-Declaration%20Files/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档6-Declaration Files/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:31:27.088Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><p><a href="https://juejin.cn/post/6987735091925483551" target="_blank" rel="noopener">一文读懂TS的(.d.ts)文件</a></p><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Declaration-Reference"><a href="#Declaration-Reference" class="headerlink" title="Declaration Reference"></a>Declaration Reference</h2><h2 id="Library-Structures"><a href="#Library-Structures" class="headerlink" title="Library Structures"></a>Library Structures</h2><h2 id="d-ts-Templates"><a href="#d-ts-Templates" class="headerlink" title=".d.ts Templates"></a>.d.ts Templates</h2><p>Modules .d.ts<br>Module: Plugin<br>Module: Class<br>Module: Function<br>Global .d.ts<br>Global: Modifying Module</p><h2 id="Do’s-and-Don’ts"><a href="#Do’s-and-Don’ts" class="headerlink" title="Do’s and Don’ts"></a>Do’s and Don’ts</h2><h2 id="Deep-Dive"><a href="#Deep-Dive" class="headerlink" title="Deep Dive"></a>Deep Dive</h2><h2 id="Publishing"><a href="#Publishing" class="headerlink" title="Publishing"></a>Publishing</h2><h2 id="Consumption"><a href="#Consumption" class="headerlink" title="Consumption"></a>Consumption</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6987735091925483551&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一文读懂TS的(.d.ts)文件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript文档7-JavaScript</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A37-JavaScript/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档7-JavaScript/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:29:41.670Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html</a></p><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><!-- # JavaScript --><p>How to use TypeScript-powered JavaScript tooling.</p><h2 id="JS-Projects-Utilizing-TypeScript"><a href="#JS-Projects-Utilizing-TypeScript" class="headerlink" title="JS Projects Utilizing TypeScript"></a>JS Projects Utilizing TypeScript</h2><p>The type system in TypeScript has different levels of strictness when working with a codebase:</p><p>A type-system based only on inference with JavaScript code</p><ul><li>Incremental typing in JavaScript via JSDoc</li><li>Using // @ts-check in a JavaScript file</li><li>TypeScript code</li><li>TypeScript with strict enabled<br>Each step represents a move towards a safer type-system, but not every project needs that level of verification.<h3 id="TypeScript-with-JavaScript"><a href="#TypeScript-with-JavaScript" class="headerlink" title="TypeScript with JavaScript"></a>TypeScript with JavaScript</h3><h3 id="Providing-Type-Hints-in-JS-via-JSDoc"><a href="#Providing-Type-Hints-in-JS-via-JSDoc" class="headerlink" title="Providing Type Hints in JS via JSDoc"></a>Providing Type Hints in JS via JSDoc</h3>In a .js file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.</li></ul><p>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// OK?!</span></span><br></pre></td></tr></table></figure><h3 id="ts-check"><a href="#ts-check" class="headerlink" title="@ts-check"></a>@ts-check</h3><!-- The last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project.  -->To enable errors in your JavaScript files add: <code>// @ts-check</code> to the first line in your .js files to have TypeScript raise it as an error.<br><br>If you have a lot of JavaScript files you want to add errors to then you can switch to using a <a href>jsconfig.json</a>. You can skip checking some files by adding a <code>// @ts-nocheck</code> comment to files.<br><br>TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding <code>// @ts-ignore</code> or<code>// @ts-expect-error</code>on the preceding line.<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"> </span><br><span class="line">x = <span class="number">0</span>; <span class="comment">// OK</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// Not OK</span></span><br><span class="line"><span class="comment">// Type 'boolean' is not assignable to type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// Not OK</span></span><br></pre></td></tr></table></figure><h2 id="Type-Checking-JavaScript-Files"><a href="#Type-Checking-JavaScript-Files" class="headerlink" title="Type Checking JavaScript Files"></a>Type Checking JavaScript Files</h2><h2 id="JSDoc-Reference"><a href="#JSDoc-Reference" class="headerlink" title="JSDoc Reference"></a>JSDoc Reference</h2><p>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</p><!-- Note any tags which are not explicitly listed below (such as @async) are not yet supported. --><h2 id="Creating-d-ts-Files-from-js-files"><a href="#Creating-d-ts-Files-from-js-files" class="headerlink" title="Creating .d.ts Files from .js files"></a>Creating .d.ts Files from .js files</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Rtypescript文档8-Project Configuration</title>
    <link href="http://yoursite.com/w3/jslib/typescript%E6%96%87%E6%A1%A3/typescript%E6%96%87%E6%A1%A38-Project%20Configuration/"/>
    <id>http://yoursite.com/w3/jslib/typescript文档/typescript文档8-Project Configuration/</id>
    <published>2023-02-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:26:40.340Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/tsconfig-json.html</a><br><a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a></p><!-- typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.htmltypescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.htmlPS: 简介，基础，进阶，工程，感谢。 --><!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： --><a id="more"></a><p style="text-align:right">2023.2.19 星期日</p><p>Compiler configuration reference.</p><h2 id="What-is-a-tsconfig-json"><a href="#What-is-a-tsconfig-json" class="headerlink" title="What is a tsconfig.json"></a>What is a tsconfig.json</h2><h2 id="Compiler-Options-in-MSBuild"><a href="#Compiler-Options-in-MSBuild" class="headerlink" title="Compiler Options in MSBuild"></a>Compiler Options in MSBuild</h2><h2 id="TSConfig-Reference"><a href="#TSConfig-Reference" class="headerlink" title="TSConfig Reference"></a>TSConfig Reference</h2><h2 id="tsc-CLI-Options"><a href="#tsc-CLI-Options" class="headerlink" title="tsc CLI Options"></a>tsc CLI Options</h2><h2 id="Project-References"><a href="#Project-References" class="headerlink" title="Project References"></a>Project References</h2><h2 id="Integrating-with-Build-Tools"><a href="#Integrating-with-Build-Tools" class="headerlink" title="Integrating with Build Tools"></a>Integrating with Build Tools</h2><h2 id="Configuring-Watch"><a href="#Configuring-Watch" class="headerlink" title="Configuring Watch"></a>Configuring Watch</h2><h2 id="Nightly-Builds"><a href="#Nightly-Builds" class="headerlink" title="Nightly Builds"></a>Nightly Builds</h2><h1 id="typescript文档-项目配置"><a href="#typescript文档-项目配置" class="headerlink" title="typescript文档-项目配置"></a>typescript文档-项目配置</h1><p>typescript文档-项目配置：<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a></p><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><h2 id="错误信息列表"><a href="#错误信息列表" class="headerlink" title="错误信息列表"></a>错误信息列表</h2><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h2 id="项目引用"><a href="#项目引用" class="headerlink" title="项目引用"></a>项目引用</h2><h2 id="MSBuild编译选项"><a href="#MSBuild编译选项" class="headerlink" title="MSBuild编译选项"></a>MSBuild编译选项</h2><h2 id="构建工具集成"><a href="#构建工具集成" class="headerlink" title="构建工具集成"></a>构建工具集成</h2><h2 id="每日构建"><a href="#每日构建" class="headerlink" title="每日构建"></a>每日构建</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.tslang.cn/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tslang.cn/docs/handbook/tsconfig-json.html&lt;/a&gt;&lt;/p&gt;
&lt;!-- 
typescript文档-项目配置：https://www.tslang.cn/docs/handbook/tsconfig-json.html

typescript入门教程-类型断言: https://ts.xcatliu.com/basics/type-assertion.html
PS: 简介，基础，进阶，工程，感谢。
 --&gt;
&lt;!-- 前面我们提到，一些语言根本不允许那些错误的程序运行。在不运行代码的情况下检测其中的错误称为 静态检查 。根据被操作的值的种类来确定是什么错误和什么不是错误，这称为静态 类型 检查。

TypeScript 在执行之前，基于 值的类型 检查程序是否有错误。它是 静态类型检查器。例如，基于 obj 的 类型，TypeScript 在上面的最后一个示例中发现了一个错误： 
--&gt;
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="jslib" scheme="http://yoursite.com/categories/w3/jslib/"/>
    
      <category term="typescript文档" scheme="http://yoursite.com/categories/w3/jslib/typescript%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript使用记录</title>
    <link href="http://yoursite.com/sum/jsplus/typescript%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/sum/jsplus/typescript使用记录/</id>
    <published>2023-02-18T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.416Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right"> 2023.2.18 星期六 </p><ol><li><p>忽略报错提示</p><blockquote><p>Using a @ts-ignore comment to silence the error </p><!-- `/* tslint:disable:no-unused-variable */`PS: 上面指定报错类型去忽略无效 --></blockquote></li><li><p><code>Property &#39;xxx&#39; does not exist on type YYY</code><br>1、将对象设置成 any <code>item:any</code><br>2、通过字符方式获取对象属性 <code>item[&quot;articleId&quot;]</code><br>3、声明断言，强制执行 <code>(item as any).articleId == val;</code></p><!-- > 是因为Typescript在执行代码检查时在该对象没有定义相应属性，遇到该错误有以下几种解决办法。 --></li></ol><ol start="3"><li>未使用的变量配置。包括定义和函数<!-- [tslint how to disable error "someVariable is declared but its value is never read"](https://stackoverflow.com/questions/50011443/tslint-how-to-disable-error-somevariable-is-declared-but-its-value-is-never-rea) -->eslint.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="comment">// "noUnusedLocals": false,</span></span><br><span class="line">        <span class="comment">// 'no-unused-vars': 'off',</span></span><br><span class="line">        <span class="string">'@typescript-eslint/no-unused-vars'</span>: [<span class="string">'error'</span>, </span><br><span class="line">            &#123; <span class="string">'varsIgnorePattern'</span>: <span class="string">'^_'</span>, <span class="string">"argsIgnorePattern"</span>: <span class="string">"e|error|args|param"</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'@typescript-eslint/naming-convention'</span>: [</span><br><span class="line">            <span class="string">'error'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'variable'</span>,</span><br><span class="line">                format: [<span class="string">'camelCase'</span>, <span class="string">'PascalCase'</span>, <span class="string">'UPPER_CASE'</span>],</span><br><span class="line">                leadingUnderscore: <span class="string">'allow'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'function'</span>,</span><br><span class="line">                format: [<span class="string">'camelCase'</span>, <span class="string">'PascalCase'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                selector: <span class="string">'typeLike'</span>,</span><br><span class="line">                format: [<span class="string">'PascalCase'</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>PS: 需要把tsconfog.json中的开关也关掉<!-- （如果是ture上面的配置不会生效） -->。<br>tsconfig.json<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"noUnusedLocals"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"noUnusedParameters"</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt; 2023.2.18 星期六 &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;忽略报错提示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a @ts-ignore comment to silence the error &lt;/p&gt;
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
  </entry>
  
  <entry>
    <title>document.referrer实践</title>
    <link href="http://yoursite.com/sum/js/document.referrer%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/sum/js/document.referrer实践/</id>
    <published>2023-02-06T00:00:00.000Z</published>
    <updated>2023-02-22T14:31:48.981Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://web.dev/i18n/zh/referrer-best-practices/" target="_blank" rel="noopener">引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践</a></p><a id="more"></a><p style="text-align:right">2023.2.6 星期一 </p><p>背景：有些情况无法获得<code>document.referrer</code>， 或者只能获取的origin。</p><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><!-- \#1-sss [引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践](https://web.dev/i18n/zh/referrer-best-practices/) --><p>概述<br>引荐来源和引荐来源政策 101<br>有哪些可用的政策，它们之间有何不同？<br>浏览器中的默认引荐来源政策<br>设置您的引荐来源政策：最佳实践<br>如何查看引荐来源政策？<br>您应该为您的网站设置哪种政策？<br>    为什么要”显式”？<br>    为什么要用strict-origin-when-cross-origin（或更严格的政策）？<br>    如果strict-origin-when-cross-origin（或更严格的政策）不适用于您所有的用例怎么办？<br>    示例：元素级政策<br>    示例：请求级政策<br>    您还应该考虑什么？<br>使用传入请求中的引荐来源：最佳实践<br>    如果您的网站功能使用传入请求的引荐来源 URL 怎么办？<br>    跨站请求伪造 (CSRF) 保护<br>    日志记录<br>    付款<br>结论<br>资源</p><!-- END#1 --><!-- \#2-S [HTTP Referer 教程](https://www.ruanyifeng.com/blog/2019/06/http-referer.html) --><p>一、Referer 的含义<br>二、Referer 的发生场景<br>浏览器向服务器请求资源的时候，Referer字段的逻辑是这样的，用户在地址栏输入网址，或者选中浏览器书签，就不发送Referer字段。</p><p>主要是以下三种场景，会发送Referer字段。<br>（1）用户点击网页上的链接。<br>（2）用户发送表单。<br>（3）网页加载静态资源，比如加载图片、脚本、样式。<br>三、Referer 的作用<br>四、rel属性<br>由于上一节的原因，浏览器提供一系列手段，允许改变默认的Referer行为。</p><h3 id="五、Referrer-Policy-的值"><a href="#五、Referrer-Policy-的值" class="headerlink" title="五、Referrer Policy 的值"></a>五、Referrer Policy 的值</h3><p>Referrer Policy 可以设定8个值。<br>（1）no-referrer<br>不发送Referer字段。</p><p>（2）no-referrer-when-downgrade<br>如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况发送（包括 HTTP 网址链接到 HTTP 网址）。这是浏览器的默认行为。</p><p>（3）same-origin<br>链接到同源网址（协议+域名+端口 都相同）时发送，否则不发送。注意，<a href="https://foo.com链接到http://foo.com也属于跨域。" target="_blank" rel="noopener">https://foo.com链接到http://foo.com也属于跨域。</a></p><p>（4）origin<br>Referer字段一律只发送源信息（协议+域名+端口），不管是否跨域。</p><p>（5）strict-origin<br>如果从 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，其他情况只发送源信息。</p><p>（6）origin-when-cross-origin<br>同源时，发送完整的Referer字段，跨域时发送源信息。</p><p>（7）strict-origin-when-cross-origin<br>同源时，发送完整的Referer字段；跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送Referer字段，否则发送源信息。</p><p>（8）unsafe-url<br>Referer字段包含源信息、路径和查询字符串，不包含锚点、用户名和密码。</p><h3 id="六、Referrer-Policy-的用法"><a href="#六、Referrer-Policy-的用法" class="headerlink" title="六、Referrer Policy 的用法"></a>六、Referrer Policy 的用法</h3><p>（1）HTTP 头信息<br>服务器发送网页的时候，通过 HTTP 头信息的Referrer-Policy告诉浏览器。<br><code>Referrer-Policy: origin</code><br>（2）<code>&lt;meta&gt;</code>标签<br>也可以使用<code>&lt;meta&gt;</code>标签，在网页头部设置。<br><code>&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;&gt;</code><br>（3）referrerpolicy属性<br><code>&lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;</code>和<code>&lt;link&gt;</code>标签，可以设置referrerpolicy 属性。<br><code>&lt;a href=&quot;...&quot; referrerpolicy=&quot;origin&quot; target=&quot;_blank&quot;&gt;xxx&lt;/a&gt;</code><br><!-- END#2 --></p><h3 id="简单结论"><a href="#简单结论" class="headerlink" title="简单结论"></a>简单结论</h3><p>有不同浏览器及政策，包括跳转方式的不同。</p><!-- \#5 [关于 document.referrer](https://oldj.net/article/2012/08/04/document-referrer/)--><p>最后，一个简单的结论是：如果你需要通过 document.referrer 采集页面访问来源，最好不要使用 JS 跳转或打开新窗口，也不要使用 meta 跳转。<br><!-- PS: 有浏览器及跳转方式统计。 --><br><!-- END#5 --></p><h2 id="无法获取场景"><a href="#无法获取场景" class="headerlink" title="无法获取场景"></a>无法获取场景</h2><!-- \#11 [JS获取上一访问页面URL地址document.referrer实践](https://www.zhangxinxu.com/wordpress/2017/02/js-page-url-document-referrer/) --><p>二、哪些场景下无法获得上一页referrer信息<br>1) 直接在浏览器地址栏中输入地址；<br>2) 使用location.reload()刷新（location.href或者location.replace()刷新有信息）；<br>3) 在微信对话框中，点击链接进入微信自身的浏览器；<br>4) 扫码进入QQ或者微信的浏览器；<br>5) 直接新窗口打开一个页面； 2017.8.3更新 新版本Chrome测试，新窗口页面依然有document.referrer<br>6) 从https的网站直接进入一个http协议的网站（Chrome下亲测）；<br>7) a标签设置rel=”noreferrer”（兼容IE7+）；<br>8) meta标签来控制不让浏览器发送referer<br>   <code>&lt;meta content=&quot;never&quot; name=&quot;referrer&quot;&gt;</code></p><!-- END#11 --><!-- \#12 [Document.Referrer丢失的几个原因](https://cloud.tencent.com/developer/article/1363227) --><ul><li>修改Location对象进行页面导航</li><li>window.open方式打开新窗口</li><li>鼠标拖拽打开新窗口</li><li>点击Flash内部链接</li><li>HTTPS跳转到HTTP<!-- END#12 --></li></ul><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><!-- \#11 [document.referrer和window.opener 获取页面来源路径 #57](https://github.com/5Mi/wumi_blog/issues/57) --><p>只有当用户在上一个页面点击链接到达当前页面，document.referrer才会有值当用户输入这一页的网址、通过response.redirect、用了ssl这些情况referrer都会为空。<br>另外，其必须通过http协议使用。否则不能得到返回值，即值为空。<br>项目中引用了外链图片, 在本地页面里用img标签访问页面图片返回403 forbidden。<br>而浏览器可以直接打开. 应该好像是他们的服务器做了处理(防盗链)</p><p>由于可以直接从浏览器打开,就简单设置了个 meta标签<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><!-- END#11 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://web.dev/i18n/zh/referrer-best-practices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引荐来源 (Referer) 和引荐来源政策 (Referrer-Policy) 最佳实践&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="js" scheme="http://yoursite.com/categories/sum/js/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>性能指标-TP50</title>
    <link href="http://yoursite.com/sum/os/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-TP50/"/>
    <id>http://yoursite.com/sum/os/性能指标-TP50/</id>
    <published>2022-12-19T00:00:00.000Z</published>
    <updated>2023-02-22T14:45:05.674Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2022. 星期 : </p><p><a href="https://blog.csdn.net/qq_39809613/article/details/102853986" target="_blank" rel="noopener">性能指标TP50、TP90、TP99、TP999解读和学习</a><br>TP指标说明<br>TP指标: 指在一个时间段内，统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序, 并取出结果为：总次数*指标数=对应TP指标的值，再取出排序好的时间。</p><p>TP=Top Percentile，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。</p><p>TP50、TP90、TP99和TP999等指标常用于系统性能监控场景，指高于50%、90%、99%等百分线的情况</p><p>计算/统计方法<br>TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第50%的那个值作为TP50的值；配置此监控指标对应的报警阀值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阀值，否则系统将会报警。</p><p>TP90，TP99，TP999与TP50值计算方式一致，它们分别代表着对方法的不同性能要求，TP50相对较低，TP90则比较高，TP99，TP999则对方法性能要求很高</p><p>##<br>TPS  TPS峰值 并发量  响应时间解读</p><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p>TPS：每秒处理的消息数（Transaction Per Second），指系统在单位时间内处理请求的数量。</p><p>例如：查询jimdb缓存，预期每分钟10万调用量，则TPS=100000/60=1666.67(笔/秒)。</p><p>相关术语：吞吐量、QPS每秒查询率(Query Per Second) 、TPM每分钟事物处理数(Transaction Per Minute)。</p><h3 id="TPS峰值"><a href="#TPS峰值" class="headerlink" title="TPS峰值"></a>TPS峰值</h3><p>TPS峰值：符合帕累托法则，即80%的调用量发生在20%的时间内。</p><p>例如：查询jimdb缓存，预期每分钟10万调用量，则TPS峰值=100000<em>80%/(60</em>20%)=6666.67(笔/秒)=4TPS(平均)。这是评估手段，实际目前是按照监控得来的</p><h3 id="并发量"><a href="#并发量" class="headerlink" title="并发量"></a>并发量</h3><p>并发量：系统可以同时承载的正常使用系统功能的用户的数量。</p><p>例如：某一个地铁站进站有10个闸机，可以允许10个人同时进站，那么并发量即为10。</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间：系统对请求作出响应的时间。是指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p><p>例如：向服务器A发送请求时间为T1，服务器A处理请求时间(思考时间)为T2，服务器A返回信息的时间为T3，响应时间T=T1+T2+T3。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2022. 星期 : &lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39809613/article/details/102853986&quot; ta
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="os" scheme="http://yoursite.com/categories/sum/os/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js的require Hook 魔术</title>
    <link href="http://yoursite.com/sum/server/Node.js%E7%9A%84require%20hook%20%E9%AD%94%E6%9C%AF/"/>
    <id>http://yoursite.com/sum/server/Node.js的require hook 魔术/</id>
    <published>2022-09-05T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.457Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align:right">2022.9.5 星期一 </p><p># <a href="https://juejin.cn/post/7012243156703903751" target="_blank" rel="noopener">Node.js 的 require hook 的魔术</a></p><h2 id="魔术揭秘"><a href="#魔术揭秘" class="headerlink" title="魔术揭秘"></a>魔术揭秘</h2><p>Node.js 加载模块的流程是这样的：<br>模块加载会调用 load 方法， load 会调用对应后缀名的 _extensions 的方法来处理，其中会调用 _compile 来编译并把结果放入 cache，之后返回。<br>所以呢？我们想改变 js 模块的返回值，只需要改造下 Module._extensions[‘.js’] 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'卡颂'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = func();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js // 在另一个模块 test.js 中引入这个 input.js，然后打印一下：</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">require</span>(<span class="string">'./input.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.js // 在 entry.js 里面引入 test.js:</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./test.js'</span>);</span><br></pre></td></tr></table></figure><!-- 东东：是“卡颂”。东东：是 “卡帅”，哇，好神奇，怎么做到的。 --><p>我们想改变 js 模块的返回值，只需要改造下 Module._extensions[‘.js’] 就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">if</span> (filename.includes(<span class="string">'input'</span>)) &#123;</span><br><span class="line">        content = content.replace(<span class="string">'卡颂'</span>, <span class="string">'卡帅'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">module</span>._compile(content, filename);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><!-- 东东：原来是你藏了一段代码没展示。我：魔术都是这样的啊。而且你别小看了这个 require hook，它能做到很多强大的功能呢。东东：哦？比如说我： --><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>比如说 ts-node，它是怎么做到直接 require ts 模块的？就是通过 require hook 偷偷做了编译，其实你执行的是编译后的 js。<br>比如说 babel-register 它是怎么做到直接执行带有 esnext 新特性的代码的？也是通过 require hook 偷偷做了编译。<br>还有覆盖率测试，其实是通过函数插桩做到的，也就是你每执行一条语句都会计数。怎么插桩呢？跑单测的时候也没手动插桩啊，就是因为工具内部偷偷通过 require hook 做了插桩，才能得到覆盖率数据。<br>&lt;!– 东东： 这个魔术还挺有用的嘛。学会了～ </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Node.js 的 js 模块加载的流程是 load -&gt; _extensions[‘.js’] -&gt; _compile，可以通过修改 _extensions[‘.js’] 来达到 hook 的目的，比如在 _compile 之前做一些代码转换。<br>这种 hook 在 babel-register、ts-node 还有单测的覆盖率测试中都有应用，能够达到透明的修改代码的目的。<br>因为开发者不知道代码什么时候被修改的，所以看起来比较神奇<br>–&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p style=&quot;text-align:right&quot;&gt;2022.9.5 星期一 &lt;/p&gt;

&lt;p&gt;# &lt;a href=&quot;https://juejin.cn/post/7012243156703903751&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="server" scheme="http://yoursite.com/categories/sum/server/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Airbnbabel文档b风格学习</title>
    <link href="http://yoursite.com/w3/frontend/babel%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/w3/frontend/babel文档/</id>
    <published>2022-09-03T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.471Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 中文网: <a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">https://www.babeljs.cn/docs/</a></p><p>Babel 用户手册： <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md</a><br>Babel Plugin Handbook: <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#writing-your-first-babel-plugin" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#writing-your-first-babel-plugin</a></p><p style="text-align:right"> 2022.8.3 星期六 21:45 </p><p># 文档<br>## 指南<br>Babel 是什么？<br>使用指南<br>配置 Babel<br>学习 ES2015<br>升级到 Babel 7<br>## 配置<br>Config Files<br>Config Options<br>预设（Presets）<br>插件<br>Plugins List<br>Compiler assumptions<br>## 预设（Presets）<br>@babel/preset-env<br>@babel/preset-react<br>@babel/preset-typescript<br>@babel/preset-flow<br>## 杂项<br>路线图<br>附加说明<br>Features Timeline<br>FAQ<br>编辑器<br>## 集成<br>@babel/cli<br>@babel/polyfill<br>@babel/plugin-transform-runtime<br>@babel/register<br>@babel/standalone<br>## 工具<br>@babel/parser<br>@babel/core<br>@babel/generator<br>@babel/code-frame<br>@babel/runtime<br>@babel/template<br>@babel/traverse<br>@babel/types<br>## 辅助<br>helper-compilation-targets<br>helper-module-imports</p><p># 用户手册<br>## 介绍<br>## 安装 Babel<br>babel-cli<br>在项目内运行 Babel CLI<br>babel-register<br>babel-node<br>babel-core<br>## 配置 Babel<br>.babelrc<br>babel-preset-es2015<br>babel-preset-react<br>babel-preset-stage-x<br>## 执行 Babel 生成的代码<br>babel-polyfill<br>babel-runtime<br>## 配置 Babel（进阶）<br>手动指定插件<br>插件选项<br>基于环境自定义 Babel<br>制作你自己的预设（preset）<br>## Babel 和其他工具<br>静态分析工具<br>语法检查（Linting）<br>代码风格<br>文档<br>框架<br>React<br>文本编辑器和 IDEs（集成开发环境）<br>## Babel 支持<br>Babel 论坛<br>Babel 聊天<br>Babel 问题<br>创建漂亮的 Babel 错误报告</p><h2 id="安装-Babel"><a href="#安装-Babel" class="headerlink" title="安装 Babel"></a>安装 Babel</h2><p>babel-register: 这种方法只需要引入文件就可以运行 Babel，或许能更好地融入你的项目设置。<br>这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。<br>现在我们可以使用 register.js 来代替 node index.js 来运行了。</p><p>babel-node: 如果你要用 <code>node</code> CLI 来运行代码，那么整合 Babel 最简单的方式就是使用 <code>babel-node</code> CLI，它是 <code>node</code> CLI 的替代品。</p><p>babel-core: 如果你需要以编程的方式来使用 Babel，可以使用 babel-core 这个包。</p><h2 id="配置-Babel"><a href="#配置-Babel" class="headerlink" title="配置 Babel"></a>配置 Babel</h2><p>babel-preset-es2015<br>babel-preset-react<br>babel-preset-stage-x: 这个流程分为 5（0－4）个阶段。</p><blockquote><p>注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。<br>以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。.</p></blockquote><h2 id="执行-Babel-生成的代码"><a href="#执行-Babel-生成的代码" class="headerlink" title="执行 Babel 生成的代码"></a>执行 Babel 生成的代码</h2><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>abel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。<br>为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁） 的技术。 简单地说，polyfill 即是在当前运行环境中用来复制（意指模拟性的复制，而不是拷贝）尚不存在的原生 api 的代码。 能让你提前使用还不可用的 APIs，Array.from 就是一个例子。</p><p>Babel 用了优秀的 core-js 用作 polyfill，并且还有定制化的 regenerator 来让 generators（生成器）和 async functions（异步函数）正常工作。</p><p>然后只需要在文件顶部导入 polyfill 就可以了：<br><code>import &quot;babel-polyfill&quot;;</code></p><h3 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h3><p>为了实现 ECMAScript 规范的细节，Babel 会使用“助手”方法来保持生成代码的整洁。<br>由于这些助手方法可能会特别长并且会被添加到每一个文件的顶部，因此你可以把它们统一移动到一个单一的“运行时（runtime）”中去。</p><p>通过安装 babel-plugin-transform-runtime 和 babel-runtime 来开始。</p><p>这样就不需要把 _classCallCheck 和 _createClass 这两个助手方法放进每一个需要的文件里去了。</p><h2 id="配置-Babel（进阶）"><a href="#配置-Babel（进阶）" class="headerlink" title="配置 Babel（进阶）"></a>配置 Babel（进阶）</h2><p>### 基于环境自定义 Babel<br>当前环境可以使用 process.env.BABEL_ENV 来获得。 如果 BABEL_ENV 不可用，将会替换成 NODE_ENV，并且如果后者也没有设置，那么缺省值是”development”。.</p><h3 id="制作你自己的预设（preset）"><a href="#制作你自己的预设（preset）" class="headerlink" title="制作你自己的预设（preset）"></a>制作你自己的预设（preset）</h3><p>你要做的就是依循命名约定 babel-preset-* 来创建一个新项目<!-- （请务必对这个命名约定保持责任心，也就是说不要滥用这个命名空间）， -->然后创建两个文件。<br>首先，创建一个 package.json，包括针对预设所必要的 dependencies。<br>然后创建 index.js 文件用于导出 .babelrc 的内容，使用对应的 require 调用来替换 plugins／presets 字符串。<br>然后只需要发布到 npm 于是你就可以像其它预设一样来使用你的预设了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"babel-preset-my-awesome-preset"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"James Kyle &lt;me@thejameskyle.com&gt;"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.3.13"</span>,</span><br><span class="line">    <span class="string">"babel-preset-react"</span>: <span class="string">"^6.3.13"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-flow-strip-types"</span>: <span class="string">"^6.3.15"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"babel-preset-es2015"</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"babel-preset-react"</span>)</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"babel-plugin-transform-flow-strip-types"</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预设的结果 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-flow-strip-types"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## Babel 和其他工具<br>静态分析工具<br>语法检查（Linting）<br>ESLint 是最流行的语法检查工具之一，因此我们维护了一个官方的 babel-eslint 整合软件包。</p><p># Babel 插件手册<br>Babel 插件手册: <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-visitors</a><br>## 介绍<br>## 基础<br>抽象语法树（ASTs）<br>Babel 的处理步骤<br>解析<br>#### 词法分析<br>#### 语法分析<br>转换<br>生成<br>遍历<br>Visitors（访问者）<br>Paths（路径）<br>#### Paths in Visitors（存在于访问者中的路径）<br>State（状态）<br>Scopes（作用域）<br>#### Bindings（绑定）<br>## API<br>babylon<br>babel-traverse<br>babel-types<br>Definitions（定义）<br>Builders（构建器）<br>Validators（验证器）<br>Converters（变换器）<br>babel-generator<br>babel-template<br>## 编写你的第一个 Babel 插件<br>## 转换操作<br>访问<br>获取子节点的Path<br>检查节点（Node）类型<br>检查路径（Path）类型<br>检查标识符（Identifier）是否被引用<br>找到特定的父路径<br>获取同级路径<br>停止遍历<br>处理<br>替换一个节点<br>用多节点替换单节点<br>用字符串源码替换节点<br>插入兄弟节点<br>插入到容器（container）中<br>删除节点<br>替换父节点<br>删除父节点<br>Scope（作用域）<br>检查本地变量是否被绑定<br>生成UID<br>提升变量声明至父级作用域<br>重命名绑定及其引用<br>## 插件选项<br>插件的准备和收尾工作<br>在插件中启用其他语法<br>构建节点<br>## 最佳实践<br>尽量避免遍历抽象语法树（AST）<br>及时合并访问者对象<br>可以手动查找就不要遍历<br>优化嵌套的访问者对象<br>留意嵌套结构<br>单元测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Babel 中文网: &lt;a href=&quot;https://www.babeljs.cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.babeljs.cn/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Babel 用户手册： &lt;a h
      
    
    </summary>
    
      <category term="w3" scheme="http://yoursite.com/categories/w3/"/>
    
      <category term="frontend" scheme="http://yoursite.com/categories/w3/frontend/"/>
    
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>Ast和babel学习记录</title>
    <link href="http://yoursite.com/sum/jsplus/ast%E5%92%8Cbabel%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/sum/jsplus/ast和babel学习记录/</id>
    <published>2022-09-01T00:00:00.000Z</published>
    <updated>2023-02-22T14:01:19.399Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 中文网: <a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">https://www.babeljs.cn/docs/</a><br>&lt;!– Babel Handbook： <a href="https://github.com/jamiebuilds/babel-handbook?spm=a2c6h.12873639.article-detail.21.20ae2384l3nF8E" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook?spm=a2c6h.12873639.article-detail.21.20ae2384l3nF8E</a> </p><blockquote><p>A guided handbook on how to use Babel and how to create plugins for Babel.<br>PS: 下面两个具体的手册内容。<br><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/README.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/README.md</a><br>–&gt;<br>Babel 用户手册： <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md</a><br><!-- Babel 插件手册： https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md PS: 下面的内容字 越来越小--><br>Babel 插件手册： <a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#writing-your-first-babel-plugin" target="_blank" rel="noopener">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#writing-your-first-babel-plugin</a></p></blockquote><p>@babel/types: <a href="https://babeljs.io/docs/en/babel-types" target="_blank" rel="noopener">https://babeljs.io/docs/en/babel-types</a></p><p style="text-align:right"> 2022.9.1 星期  ： </p><p># ast 介绍<br>&lt;!– # 1 <a href="https://juejin.cn/post/7078909564120203300" target="_blank" rel="noopener">babel和ast（实现简单的babel插件）</a> </p><p>–&gt;</p><h2 id="AST简介"><a href="#AST简介" class="headerlink" title="AST简介"></a>AST简介</h2><p>抽象语法树（abstract syntax trees），就是将代码转换成的⼀种抽象的树形结构，通常是 JSON描述。<br>AST 并不是哪个编程语⾔特有的概念，在前端领域，⽐较常⽤的 AST ⼯具如<a href="https://esprima.org/index.html" target="_blank" rel="noopener">esprima</a>,babel(babylon<br>) 的解析模块，其他如 Vue ⾃⼰实现的模板解析器。</p><p>AST Explorer: <a href="https://astexplorer.net" target="_blank" rel="noopener">https://astexplorer.net</a><br>&lt;!–<br>推荐⼯具： <a href="https://astexplorer.net" target="_blank" rel="noopener">AST 在线学习</a> 和 <a href="https://resources.jointjs.com/demos/rappid/apps/Ast/index.html" target="_blank" rel="noopener">tokens 在线分析</a><br>PS: tokens 在线分析 打不开。<br>插件集合（注意，前端 AST 并不仅针对 JavaScript，CSS、HTML ⼀样具有相应的解析⼯具，JavaScript 重点关注）</p><p>功能插件常用方法<br>ast 解析esprima @babel/parser recast.parse<br>ast 遍历estraverse @babel/traverserecast.visit<br>⽣成代码escodegen @babel/generatorrecast.print recast.prettyPrint</p><p> –&gt;</p><h2 id="代码的编译流程"><a href="#代码的编译流程" class="headerlink" title="代码的编译流程"></a>代码的编译流程</h2><p><img src="http://you img base url/../assets/images/AST与%20V8%20引擎的编译过程.png?e=1677084656&token=your qiniu access key:BnrVVaovFXuytAjJDnEek6ihDD8=" alt="AST与 V8 引擎的编译过程"><br>上述过程分为三部分：解析（parse），转换（transform），⽣成（generate），其中 scanner 部分叫做词法（syntax）分析，parser 部分叫做语法（grammar）分析。<br>显然，词法分析的结果是 tokens，语法分析得到的就是 AST。</p><ul><li>可⻅词法分析，旨在将源代码按照⼀定的分隔符（空格/tab/换⾏等）、注释进⾏分割，并将各个部分进⾏分类构造出⼀段 token 流。</li><li>⽽语法分析，则基于 tokens 将源码语义化、结构化为⼀段 JOSN 描述（AST）。反之，如果给出⼀段代码的描述信息，我们也是可以还原源码的。<!-- 理论上，描述信息发⽣变化，⽣成的源码的对应信息也会发⽣变化。所以我们可以通过操作 AST 达到修改源码信息的⽬的，辅以⽂件的创建接⼝，这也是 babel 打包⽣成代码的基本原理。了解到这⼀层，便能想象 ES6 => ES5、ts => js、uglifyJS、样式预处理器、eslint、代码提示等⼯具的⼯作⽅式了。 --></li></ul><h2 id="AST-的节点类型"><a href="#AST-的节点类型" class="headerlink" title="AST 的节点类型"></a>AST 的节点类型</h2><p>在操作 AST 过程中，源码部分集中在 Program 对象的 body 属性下，每个节点有着统⼀固定的格式：<br>@babel/core 依赖了 parser、traverse、generator 模块，所以安装 @babel/core 即可。<!-- 下⽂均以 babel 作为⽰例⼯具，其他⼯具类似，不再赘述。 --></p><!-- 由此可⻅，处理 AST 的过程就是对不同节点类型遍历和操作的过程，为简化操作，babel 提供了专⻔的接⼝，我们只需要提供相应类型的处理⽅法（visitor）即可。还是上⾯的需求（好⼀点的是所有的return 语句都会处理，即使是嵌套的函数）： --><p>traverse ⽅法帮我们处理了 ast 的遍历过程，对于不同节点的处理只需要维护⼀份 types 对应的⽅法即可。进⼀步的，构造 CONSOLE_AST 节点也有⼏种⽅式。先使⽤在线⼯具将 <code>console.log(&#39;函数执⾏完成&#39;);</code> 结构化（如果你已经⼗分熟悉这个过程，可以跳过）：</p><ul><li>基础⽅式——使⽤ @babel/types 来构造语句</li><li>终极简化版——模板 API</li></ul><h2 id="AST-与-babel-插件"><a href="#AST-与-babel-插件" class="headerlink" title="AST 与 babel 插件"></a>AST 与 babel 插件</h2><p>官⽅插件<br>随着 ECMAScript 的发展，不断涌出⼀些新的语⾔特性（如管道操作符、可选链操作符、控制合并操作符……），也包括但不限于 JSX 语法等。遇到 babel 本身的解析引擎模块不能识别新特性的问题，可以由插件来处理。</p><p>运⾏上⾯的代码会直接报错，源码（第 5 ⾏）使⽤的管道操作符处于提案中，需要借助插件来解析：</p><ol><li>@babel/parser 模块 + 内联配置（记得安装 @babel/plugin-proposal-pipeline-operator ）解析</li><li>@babel/core模块 + ⽂件 babel.config.json 解析（babel 会⾃动到项⽬⽬录查找最近的）babel配置文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ## 1  */</span></span><br><span class="line"><span class="keyword">const</span> ast = babel.parse(code, &#123;</span><br><span class="line">  sourceType: <span class="string">'module'</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">    [<span class="string">"pipelineOperator"</span>, &#123;</span><br><span class="line">      <span class="string">"proposal"</span>: <span class="string">"hack"</span>,</span><br><span class="line">      <span class="string">"topicToken"</span>: <span class="string">"^^"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">/* ## 2 */</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="string">"plugins"</span>: [</span><br><span class="line">         [<span class="string">"@babel/plugin-proposal-pipeline-operator"</span>, &#123;</span><br><span class="line">             <span class="string">"proposal"</span>: <span class="string">"hack"</span>,</span><br><span class="line">             <span class="string">"topicToken"</span>: <span class="string">"^^"</span></span><br><span class="line">         &#125;]</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x ** <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> list = sum(square(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>当项⽬需要⽀持的语⾔特性越来越多， plugins 需要逐⼀添加，为了解决插件的管理与依赖问题，通过提供常⽤的环境配置。<br><!-- 因此 总能看到这样的配置 (React 项⽬)：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>, <span class="string">"@babel/preset-react"</span>]</span><br><span class="line">     <span class="string">"plugin"</span>: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 先执⾏完所有 plugins，再执⾏ presets。</span></span><br><span class="line"><span class="string">2. 多个 plugins，按照声明次序顺序执⾏。</span></span><br><span class="line"><span class="string">3. 多个 presets，按照声明次序逆序执⾏。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\## 自定义插件</span></span><br><span class="line"><span class="string">以上⾯的源码为例，实现变量标识的重命名，源码及转换逻辑：</span></span><br><span class="line"><span class="string">\## 自定义try-catch插件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- END: #1 --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\## AST 概述</span></span><br><span class="line"><span class="string">&lt;!-- \# 2 [手把手带你走进Babel的编译世界](https://segmentfault.com/a/1190000041599576) </span></span><br><span class="line"><span class="string">[Babel AST代码转换、生成](https://blog.csdn.net/weixin_43294560/article/details/125443800)</span></span><br><span class="line"><span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;!-- TODO: ablob --&gt;</span></span><br><span class="line"><span class="string">&gt; AST 全称是是 Abstract Syntax Tree，中文为抽象语法树，将我们所写的代码转换为机器能识别的一种树形结构。其本身是由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型（Type）来区分，常见的类型有：Identifier(标识符)，Expression(表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## AST 结构</span></span><br><span class="line"><span class="string">随着 JavaScript 的发展，为了统一ECMAScript标准的语法表达。社区中衍生出了ESTree Spec，是目前社区所遵循的一种语法表达标准。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- ESTree 提供了例如Identifier、Literal等常见的节点类型。 --&gt;</span></span><br><span class="line"><span class="string">### 节点类型</span></span><br><span class="line"><span class="string">类型说明</span></span><br><span class="line"><span class="string">File文件 (顶层节点包含 Program)</span></span><br><span class="line"><span class="string">Program整个程序节点 (包含 body 属性代表程序体)</span></span><br><span class="line"><span class="string">Directive指令 (例如 "use strict")</span></span><br><span class="line"><span class="string">Comment代码注释</span></span><br><span class="line"><span class="string">Statement语句 (可独立执行的语句)</span></span><br><span class="line"><span class="string">Literal字面量 (基本数据类型、复杂数据类型等值类型)</span></span><br><span class="line"><span class="string">Identifier标识符 (变量名、属性名、函数名、参数名等)</span></span><br><span class="line"><span class="string">Declaration声明 (变量声明、函数声明、Import、Export 声明等)</span></span><br><span class="line"><span class="string">Specifier关键字 (ImportSpecifier、ImportDefaultSpecifier、ImportNamespaceSpecifier、ExportSpecifier)</span></span><br><span class="line"><span class="string">Expression表达式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 公共属性</span></span><br><span class="line"><span class="string">类型说明</span></span><br><span class="line"><span class="string">typeAST 节点的类型</span></span><br><span class="line"><span class="string">start记录该节点代码字符串起始下标</span></span><br><span class="line"><span class="string">end记录该节点代码字符串结束下标</span></span><br><span class="line"><span class="string">loc内含 line、column 属性，分别记录开始结束的行列号</span></span><br><span class="line"><span class="string">leadingComments开始的注释</span></span><br><span class="line"><span class="string">innerComments中间的注释</span></span><br><span class="line"><span class="string">trailingComments结尾的注释</span></span><br><span class="line"><span class="string">extra额外信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Babel 概述</span></span><br><span class="line"><span class="string">Babel 是一个 JavaScript 编译器，在实际开发过程中通常借助Babel来完成相关 AST 的操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Babel 工作流程</span></span><br><span class="line"><span class="string">Babel AST</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Babel 解析代码后生成的 AST 是以ESTree作为基础，并略作修改。</span></span><br><span class="line"><span class="string">&gt; The Babel parser generates AST according to Babel AST format. It is based on ESTree spec with the following deviations:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Babel 核心包</span></span><br><span class="line"><span class="string">工具包说明</span></span><br><span class="line"><span class="string">@babel/coreBabel 转码的核心包,包括了整个 babel 工作流（已集成@babel/types）</span></span><br><span class="line"><span class="string">@babel/parser解析器，将代码解析为 AST</span></span><br><span class="line"><span class="string">@babel/traverse遍历/修改 AST 的工具</span></span><br><span class="line"><span class="string">@babel/generator生成器，将 AST 还原成代码</span></span><br><span class="line"><span class="string">@babel/types包含手动构建 AST 和检查 AST 节点类型的方法</span></span><br><span class="line"><span class="string">@babel/template可将字符串代码片段转换为 AST 节点</span></span><br><span class="line"><span class="string">`</span>npm i @babel/parser @babel/traverse @babel/types @babel/generator @babel/template -D<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Babel 插件</span></span><br><span class="line"><span class="string">Babel 插件大致分为两种：语法插件和转换插件。</span></span><br><span class="line"><span class="string">- 语法插件作用于 @babel/parser，负责将代码解析为抽象语法树（AST）（官方的语法插件以 babel-plugin-syntax 开头);</span></span><br><span class="line"><span class="string">- 转换插件作用于 @babel/core，负责转换 AST 的形态。绝大多数情况下我们都是在编写转换插件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Babel 插件本质上就是编写各种 visitor 去访问 AST 上的节点，并进行 traverse。当遇到对应类型的节点，visitor 就会做出相应的处理，从而将原本的代码 transform 成最终的代码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- </span></span><br><span class="line"><span class="string">其实编写一个 Babel 插件很简单。我们要做的事情就是回传一个 visitor 对象，定义以Node Type为名称的函数。该函数接收path,state两个参数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其中path（路径）提供了访问/操作AST 节点的方法。path 本身表示两个节点之间连接的对象。例如path.node可以访问当前节点，path.parent可以访问父节点等。path.remove()可以移除当前节点。具体 API 见下图。其他可见</span></span><br><span class="line"><span class="string">handlebook。</span></span><br><span class="line"><span class="string"> --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Babel Types</span></span><br><span class="line"><span class="string">Babel Types 模块是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\### 类型判断</span></span><br><span class="line"><span class="string">Babel Types 提供了节点类型判断的方法，每一种类型的节点都有相应的判断方法。更多见babel-types API。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\### 创建节点</span></span><br><span class="line"><span class="string">Babel Types 同样提供了各种类型节点的创建方法，详见下属示例。</span></span><br><span class="line"><span class="string">注: Babel Types 生成的 AST 节点需使用@babel/generator转换后得到相应代码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// ### 基本数据类型</span></span><br><span class="line">types.stringLiteral(<span class="string">"Hello World"</span>); <span class="comment">// string</span></span><br><span class="line">types.numericLiteral(<span class="number">100</span>); <span class="comment">// number</span></span><br><span class="line">types.booleanLiteral(<span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line">types.nullLiteral(); <span class="comment">// null</span></span><br><span class="line">types.identifier(); <span class="comment">// undefined</span></span><br><span class="line">types.regExpLiteral(<span class="string">"\\.js?$"</span>, <span class="string">"g"</span>); <span class="comment">// 正则</span></span><br><span class="line"><span class="comment">// ### 复杂数据类型</span></span><br><span class="line"><span class="comment">// #### 数组</span></span><br><span class="line">types.arrayExpression([</span><br><span class="line">  types.stringLiteral(<span class="string">"Hello World"</span>),</span><br><span class="line">  types.numericLiteral(<span class="number">100</span>),</span><br><span class="line">  types.booleanLiteral(<span class="literal">true</span>),</span><br><span class="line">  types.regExpLiteral(<span class="string">"\\.js?$"</span>, <span class="string">"g"</span>),</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// #### 对象</span></span><br><span class="line">types.objectExpression([</span><br><span class="line">  types.objectProperty(</span><br><span class="line">    types.identifier(<span class="string">"key"</span>),</span><br><span class="line">    types.stringLiteral(<span class="string">"HelloWorld"</span>)</span><br><span class="line">  ),</span><br><span class="line">  types.objectProperty(</span><br><span class="line">    <span class="comment">// 字符串类型 key</span></span><br><span class="line">    types.stringLiteral(<span class="string">"str"</span>),</span><br><span class="line">    types.arrayExpression([])</span><br><span class="line">  ),</span><br><span class="line">  types.objectProperty(</span><br><span class="line">    types.memberExpression(</span><br><span class="line">      types.identifier(<span class="string">"obj"</span>),</span><br><span class="line">      types.identifier(<span class="string">"propName"</span>)</span><br><span class="line">    ),</span><br><span class="line">    types.booleanLiteral(<span class="literal">false</span>),</span><br><span class="line">    <span class="comment">// 计算值 key</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  ),</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// ### JSX 节点</span></span><br><span class="line"><span class="comment">// ### 声明</span></span><br><span class="line"><span class="comment">// ### React 函数式组件</span></span><br><span class="line"><span class="comment">// ###</span></span><br></pre></td></tr></table></figure></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>AST 本身应用非常广泛，例如:Babel 插件(ES6 转化 ES5)、构建时压缩代码 、css 预处理器编译、 webpack 插件等等，可以说是无处不在。</p><p><img src="http://you img base url/../../assets/images/ast应用场景.png?e=1677084656&token=your qiniu access key:7Vjghre2W8bKyWieNHLlwzwzmtg=" alt="ast应用场景"><br><!-- 如图所示，不难发现，一旦涉及到编译，或者说代码本身的处理，都和 AST 息息相关。下面列举了一些常见应用，让我们看看是如何处理的。 --></p><ul><li>代码转换<!-- <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 =&gt; ES5 let 转 var</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">types</span>: t &#125; = babel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"let-to-var"</span>,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      VariableDeclaration(path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.node.kind === <span class="string">"let"</span>) &#123;</span><br><span class="line">          path.node.kind = <span class="string">"var"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string">- babel-plugin-import</span></span><br><span class="line"><span class="string">&lt;!-- 在 CommonJS 规范下，当我们需要按需引入antd的时候，通常会借助该插件。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">babel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">types</span>: t &#125; = babel;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"import-to-require"</span>,</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      ImportDeclaration(path) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.node.source.value === <span class="string">"antd"</span>) &#123;</span><br><span class="line">          <span class="comment">// var _button = require("antd/lib/button");</span></span><br><span class="line">          <span class="keyword">const</span> _botton = t.variableDeclaration(<span class="string">"var"</span>, [</span><br><span class="line">            t.variableDeclarator(</span><br><span class="line">              t.identifier(<span class="string">"_button"</span>),</span><br><span class="line">              t.callExpression(t.identifier(<span class="string">"require"</span>), [</span><br><span class="line">                t.stringLiteral(<span class="string">"antd/lib/button"</span>),</span><br><span class="line">              ])</span><br><span class="line">            ),</span><br><span class="line">          ]);</span><br><span class="line">          <span class="comment">// 替换当前import语句</span></span><br><span class="line">          path.replaceWith(_botton);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>TIPS: 目前 antd 包中已包含esm规范文件，可以依赖 webpack 原生 TreeShaking 实现按需引入。<br> –&gt;</p><ul><li>LowCode 可视化编码<br>&lt;!– 当下LowCode，依旧是前端一大热门领域。目前主流的做法大致下述两种。<ul><li>Schema 驱动: 目前主流做法，将表单或者表格的配置，描述为一份 Schema，可视化设计器基于 Schema 驱动，结合拖拽能力，快速搭建。</li><li>AST 驱动</li></ul></li></ul><p>通过CloudIDE，CodeSandbox等浏览器端在线编译，编码。外加可视化设计器，最终实现可视化编码。</p><p> –&gt;</p><ul><li>ESLint<!-- 自定义 eslint-rule,本质上也是访问 AST 节点，是不是跟 Babel 插件的写法很相似呢？ --></li><li>Code2Code<br>&lt;!– 以 Vue To React 为例，大致过程跟ES6 =&gt; ES5类似，通过vue-template-compiler编译得到 Vue AST =&gt; 转换为 React AST =&gt; 输出 React 代码。</li></ul><p>有兴趣的同学可以参考<a href="https://github.com/dwqs/vue-to-react" target="_blank" rel="noopener">vue-to-react</a></p><p>其他多端框架：一份代码 =&gt; 多端，大体思路一致。<br>–&gt;<br><!-- END: #2 --></p><h2 id="babel-path操作"><a href="#babel-path操作" class="headerlink" title="babel path操作"></a>babel path操作</h2><!-- [AST介绍和babel插件开发](https://blog.csdn.net/web2022050903/article/details/124877015) --><p>### path<br>其中path指的是两个节点的连接，其中可以访问节点信息，也包含相关增删改查方法，类似于DOM操作，其中path上的操作是操作子节点，想操作父节点可以使用path.parentPath</p><p>增<br>插入相邻节点<br>插入进一个数组类型节点<br>删<br>改<br>查<br>可以通过.node获取<br>也可以.get</p><p>### state</p><p># babel插件实践</p><h2 id="babel插件实例"><a href="#babel插件实例" class="headerlink" title="babel插件实例"></a>babel插件实例</h2><!-- [通过写Babel插件理解抽象语法树（翻译）](https://www.jianshu.com/p/3c495dcbed49) PS: 我们希望设计允许我们把普通的对象和数组字面量通过使用**Mori**转换为不可变的数据结构的插件。原文：https://www.sitepoint.com/understanding-asts-building-babel-plugin/今天，我们将看下如何写Bable插件为JavaScript添加默认的不可变数据。这个教程的代码可以从 [GitHub仓库](https://github.com/sitepoint-editors/moriscript?spm=a2c6h.12873639.article-detail.8.20ae2384C1u3iA)下载。--><!-- [babel 修改抽象语法树——入门与实践](https://www.jianshu.com/p/3c495dcbed49)PS: 实践新增一个route对象。--> <!--[使用 Babel 进行抽象语法树操作](https://juejin.cn/post/6844903894284238856) PS: 把log换成console.log[手撸一个babel自动埋点插件](https://juejin.cn/post/7026994278664503304)[点击这里查看源码](https://github.com/jialongsu/babel-auto-tracker)> 使用注释实现自动埋点的babel插件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * autoTracker</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">id</span></span> - 订单id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">name</span></span> - 用户名</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">needTracker</span>(<span class="params">id, name, text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'needTracker====需要埋点1 '</span>, text);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> –&gt;</p><!-- [通过编译器插件实现代码注入](https://segmentfault.com/a/1190000037521833)PS: 介绍了babel的一些概念。比如：tokenizer， TraversalContext，visitor， path, babel-generator ,Buffer,SourceMap等。babel-generator 主要实现了两个功能：使用缓冲区分步生成目标代码源码映射（sourcemap）PS: 将特定的注释替换成调试语句首先，应从 babel 构造的语法树上找到对应的注释节点。但我们发现，在 babel 构造的语法树中，无论何种注释，都不是一个具体的节点：在它的语法树中，注释节点既属于第一段的"trailingComments"属性，也属于第二段代码的"leadingComments"属性。包括代码和注释同行，结果也是相同的。 --><p># Babylon</p><h2 id="Babylon"><a href="#Babylon" class="headerlink" title="Babylon"></a>Babylon</h2><p>项目主页地址：<a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a><br>项目仓库地址: <a href="https://github.com/babel/babylon" target="_blank" rel="noopener">https://github.com/babel/babylon</a><br><!-- npm地址: https://www.npmjs.com/package/babylon --></p><blockquote><p>Babylon is a JavaScript parser used in Babel.</p></blockquote><p>Heavily based on <a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">acorn</a> and <a href="https://github.com/acornjs/acorn-jsx" target="_blank" rel="noopener">acorn-jsx</a>, thanks to the awesome work of @RReverser and @marijnh.</p><!-- PS: Acorn: A tiny, fast JavaScript parser, written completely in JavaScript. --><!-- [babylon中文文档|babylon js中文教程|解析](http://www.npmdoc.org/babylonzhongwenwendangbabylon-jszhongwenjiaochengjiexi.html)PS: babylon中文翻译。parse options 选项。应用程序接口babylon.parse(code, [options])babylon.parseExpression(code, [options])parse()将提供的内容解析code为整个 ECMAScript 程序，同时parseExpression()尝试在考虑性能的情况下解析单个表达式。如有疑问，请使用.parse(). --><p style="text-align:right"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Babel 中文网: &lt;a href=&quot;https://www.babeljs.cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.babeljs.cn/docs/&lt;/a&gt;&lt;br&gt;&amp;lt;!– Babel Handboo
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>微信H5开发记录</title>
    <link href="http://yoursite.com/sum/miniapp/%E5%BE%AE%E4%BF%A1h5%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/sum/miniapp/微信h5开发记录/</id>
    <published>2022-08-31T00:00:00.000Z</published>
    <updated>2022-09-02T05:51:21.473Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2021.8.31 星期三 </p><h1 id="政策等"><a href="#政策等" class="headerlink" title="政策等"></a>政策等</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><h3 id="链接被禁"><a href="#链接被禁" class="headerlink" title="链接被禁"></a>链接被禁</h3><!--https://weixin110.qq.com/cgi-bin/mmspamsupport-bin/newredirectconfirmcgi?bancode=474826a3567a5cd38b6674ca27a4cb81b70bda0b9db2b01001e91eb9b4253c69e10ad3ff71850415f997aec30f3877f4&click=ebf42e2681123287b7319b819928c384&bankey=7f15f0c4463193140c914e4d9cd9174b&midpagecode=56a2466b749b7f0be6d0e17374747d09aeb32f13292e67a723d52c83e49281daf5f8a28b76753c979550cf5156ac9f52&wx_header=0--><!--[微信域名检测接口的机制原理以及实现方式](https://www.jianshu.com/p/b24af6e75a54)经常遇到一些公司做活动因为一个 h5 页面被分享多次遭到微信拦截，导致所有的分享都白做了。所以就有一个想法，能不能实时监测这个 h5 的 URL 一单发现被拦截 就立马更换 域名或 url 在网上看到好多借口，但是都是付费 api目前微信使用改接口校验是否被屏蔽 https://weixin110.qq.com/cgi-bin/mmspamsupport-bin/newredirectconfirmcgi?main_type=2&evil_type=20&source=2&url=https%3A%2F%2Fcandy.one--><!-- [域名怎么查询是否被微信封 微信检测网站拦截查询](https://blog.csdn.net/weixin_34290096/article/details/93135542) --><p><a href="http://qbview.url.cn/getResourceInfo?appid=31&amp;url=http://www.wangzhesha.com" target="_blank" rel="noopener">http://qbview.url.cn/getResourceInfo?appid=31&amp;url=http://www.wangzhesha.com</a><br>参数 appid= 31 默认的<br>url 需要检查的url</p><p>如果被检查的 URL 没有被拦截，则会直接跳转到目标 url 上，如果被拦截了，则给出拦截提示，只要解析返回信息，就能知道检查的 url 是否被拦截了。</p><p>目前微信使用改接口校验是否被屏蔽<br><a href="https://weixin110.qq.com/cgi-bin/mmspamsupport-bin/newredirectconfirmcgi?main_type=2&amp;evil_type=20&amp;source=2&amp;url=https%3A%2F%2Fcandy.one" target="_blank" rel="noopener">https://weixin110.qq.com/cgi-bin/mmspamsupport-bin/newredirectconfirmcgi?main_type=2&amp;evil_type=20&amp;source=2&amp;url=https%3A%2F%2Fcandy.one</a></p><!-- [如何检测域名或网址被微信停止访问了？](https://www.zhihu.com/question/42101054/answer/860915504)评论区之前很多人反馈说微信长链转短链失效的问题，实际上是因为官方已经停止该接口。后来一直因为太忙（主要是懒）没有更新，最新的方式其实更加简单，大致的原理就是 --><!-- [如何理解微信域名检测、防封，微信跳转技术](https://www.yisu.com/zixun/306064.html)一、微信检测手段微信检测违规的两个手段：a）系统的自动检测 b）微信工作人员的人工检测。二、域名被封常见因素三、域名检测方法1、利用微信公众号接口 生成微信短连接2、网页版微信抓包3、“官方”检测接口      下面这个是网上找到的另外一个说是可以检测地址的接口，看这Url确实像是个检测地址的接口对吧？呵呵，但是实际也没什么用..打开没反应，不跳转，页面也没有任何输出..       https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxcheckurl?requrl=http%3A%2F%2Fwww.penhot.com4、可用接口http://qbview.url.cn/getResourceInfo?appid=31&url=http://www.wangzhesha.com四、防封方案--><p>#####\ 三方服务<br><!-- [微信域名拦截检测接口最新升级版](https://www.twblogs.net/a/5b8d13a82b717718833a9a5c?lang=zh-cn) --><br>微信域名检测试用接口: <a href="http://wx.rrbay.com/pro/wxUrlCheck.ashx?url=http://www.teu7.cn" target="_blank" rel="noopener">http://wx.rrbay.com/pro/wxUrlCheck.ashx?url=http://www.teu7.cn</a><br><!-- `{"State":true, "Data":"www.teu7.cn","Msg":"屏蔽"}  {"State":true, "Data":"jingdong.com","Msg":"正常"}  {"State":false,"Data":"jingdong.com","Msg":"非法访问，访问被拒绝,进qq群交流:xxxx"}  {"State":false,"Data":"jingdong.com","Msg":"歇一歇,访问太快了,进qq群交流:xxxx"}  {"State":false,"Data":"jingdong.com","Msg":"服务暂停,请联系管理员!"} ` --><br>&lt;!– </p><pre><code>{&quot;State&quot;:true,&quot;Code&quot;:&quot;101&quot;,&quot;Data&quot;:&quot;http%3a%2f%2fwww.teu7.cn&quot;,&quot;Msg&quot;:&quot;屏蔽&quot;}{&quot;State&quot;:true,&quot;Code&quot;:&quot;102&quot;,&quot;Data&quot;:&quot;https%3a%2f%2ffrphup.universalbeijingresort.com%2fubr%2findex.html&quot;,&quot;Msg&quot;:&quot;正常&quot;}</code></pre><p>–&gt;</p><p>域名检测界面：<a href="http://wx.rrbay.com/" target="_blank" rel="noopener">http://wx.rrbay.com/</a><br>微信域名检测可以检查域名也可以检测链接,api检测链接的时,url参数一定要编码</p><!-- [如何检测域名或网址被微信停止访问了？](https://www.zhihu.com/question/42101054/answer/1787251134) --><p>域名检测工具地址：<a href="http://www.urlzt.com" target="_blank" rel="noopener">www.urlzt.com</a><br>注册登录地址：<a href="https://dwz.cn/TzLUYNU2" target="_blank" rel="noopener">https://dwz.cn/TzLUYNU2</a></p><blockquote><p>注册登录才可以使用域名检测功能</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2021.8.31 星期三 &lt;/p&gt;




&lt;h1 id=&quot;政策等&quot;&gt;&lt;a href=&quot;#政策等&quot; class=&quot;headerlink&quot; title=&quot;政策等&quot;&gt;&lt;/a&gt;政策等&lt;/h1
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="miniapp" scheme="http://yoursite.com/categories/sum/miniapp/"/>
    
    
      <category term="miniapp" scheme="http://yoursite.com/tags/miniapp/"/>
    
  </entry>
  
  <entry>
    <title>前端单元测试-React测试和快照</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%89%8D%E7%AB%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-react%E6%B5%8B%E8%AF%95%E5%92%8C%E5%BF%AB%E7%85%A7/"/>
    <id>http://yoursite.com/sum/jsplus/前端单元测试-react测试和快照/</id>
    <published>2022-08-13T00:00:00.000Z</published>
    <updated>2022-09-02T05:51:20.922Z</updated>
    
    <content type="html"><![CDATA[<p>推荐的工具：Jest ，React 测试库。<!-- react文档-测试概览 --><br>如果你想断言或者操纵你的渲染组件，你可以使用react-testing-library, Enzyme, 或者React的 TestUtils。<!-- jest 文档-react测试-DOM测试​ --></p><p>react测试技巧: <a href="https://zh-hans.reactjs.org/docs/testing-recipes.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/testing-recipes.html</a><br>jest-快照测试: <a href="https://jestjs.io/zh-Hans/docs/snapshot-testing" target="_blank" rel="noopener">https://jestjs.io/zh-Hans/docs/snapshot-testing</a><br>React 测试库: <a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank" rel="noopener">https://testing-library.com/docs/react-testing-library/intro/</a><br>Test Renderer: <a href="https://zh-hans.reactjs.org/docs/test-renderer.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/test-renderer.html</a><br>Test Utilities: <a href="https://reactjs.org/docs/test-utils.html#act" target="_blank" rel="noopener">https://reactjs.org/docs/test-utils.html#act</a></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* # utils */</span></span><br><span class="line"><span class="keyword">import</span> ReactTestUtils <span class="keyword">from</span> <span class="string">'react-dom/test-utils'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">'react-dom/test-utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* # react-dom 的 render 在jest中也可以应用，结合act */</span></span><br><span class="line"><span class="keyword">import</span> &#123; render, unmountComponentAtNode &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* # create react app 包含了jest可以使用的 react-test-renderer*/</span></span><br><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @testing-library/react */</span></span><br><span class="line"><span class="keyword">import</span> &#123; act, render, cleanup &#125; <span class="keyword">from</span> <span class="string">"@testing-library/react"</span>;</span><br><span class="line"><span class="comment">// &gt; This is a light wrapper around the react-dom/test-utils act function.</span></span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>单元测试都少不了jest 做断言，mock<!-- ，快照 -->等。</li><li>快照可以用enzyme 和 testing-library。<br>如果不关心组件实现细节，遵从用户/浏览器可以用testing-library。<br>enzyme 老牌了。testing-library介绍：<blockquote><p>The @testing-library family of packages helps you test UI components in a user-centric way.<br>enzyme 可以测组件实现细节，有3种渲染方式。而且都可以测其他框架ui/dom。</p></blockquote></li></ol><p style="text-align:right"> 2022.8.13 星期六 : </p><p># w3<br># react文档 - API REFERENCE</p><h2 id="1-1-Test-Utilities"><a href="#1-1-Test-Utilities" class="headerlink" title="1-1 Test Utilities"></a>1-1 Test Utilities</h2><p>Test Utilities: <a href="https://reactjs.org/docs/test-utils.html#act" target="_blank" rel="noopener">https://reactjs.org/docs/test-utils.html#act</a></p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>ReactTestUtils 可搭配你所选的测试框架，轻松实现 React 组件测试。在 Facebook 内部，我们使用 Jest 来轻松实现 JavaScript 测试。你可以从 Jest 官网的 React 教程中了解如何开始使用它。</p><blockquote><p>我们推荐使用 React Testing Library，它使得针对组件编写测试用例就像终端用户在使用它一样方便。<br>当使用的 React 版本 &lt;= 16 时，可以使用 Enzyme 的测试工具，通过它能够轻松对 React 组件的输出进行断言、操控和遍历。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom/client'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">'react-dom/test-utils'</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container;</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(container);</span><br><span class="line">  container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'can render and update a counter'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 首先测试 render 和 componentDidMount</span></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.createRoot(container).render(<span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> button = container.querySelector(<span class="string">'button'</span>);</span><br><span class="line">  <span class="keyword">const</span> label = container.querySelector(<span class="string">'p'</span>);</span><br><span class="line">  expect(label.textContent).toBe(<span class="string">'You clicked 0 times'</span>);</span><br><span class="line">  expect(<span class="built_in">document</span>.title).toBe(<span class="string">'You clicked 0 times'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再测试 render 和 componentDidUpdate</span></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    button.dispatchEvent(<span class="keyword">new</span> MouseEvent(<span class="string">'click'</span>, &#123;<span class="attr">bubbles</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">  &#125;);</span><br><span class="line">  expect(label.textContent).toBe(<span class="string">'You clicked 1 times'</span>);</span><br><span class="line">  expect(<span class="built_in">document</span>.title).toBe(<span class="string">'You clicked 1 times'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>### 参考<br>#### act()<br>为断言准备一个组件，包裹要渲染的代码并在调用 act() 时执行更新。这会使得测试更接近 React 在浏览器中的工作方式。</p><blockquote><p>如果你使用了 react-test-renderer，它也提供了与 act 行为相同的函数。</p></blockquote><p>### 其他工具方法<br>Simulate<br>使用可选的 eventData 事件数据来模拟在 DOM 节点上触发事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">act()</span><br><span class="line">mockComponent()</span><br><span class="line">isElement()</span><br><span class="line">isElementOfType()</span><br><span class="line">isDOMComponent()</span><br><span class="line">isCompositeComponent()</span><br><span class="line">isCompositeComponentWithType()</span><br><span class="line">findAllInRenderedTree()</span><br><span class="line">scryRenderedDOMComponentsWithClass()</span><br><span class="line">findRenderedDOMComponentWithClass()</span><br><span class="line">scryRenderedDOMComponentsWithTag()</span><br><span class="line">findRenderedDOMComponentWithTag()</span><br><span class="line">scryRenderedComponentsWithType()</span><br><span class="line">findRenderedComponentWithType()</span><br><span class="line">renderIntoDocument()</span><br><span class="line">Simulate</span><br></pre></td></tr></table></figure><h2 id="1-2-Test-Renderer"><a href="#1-2-Test-Renderer" class="headerlink" title="1-2 Test Renderer"></a>1-2 Test Renderer</h2><p>Test Renderer: <a href="https://zh-hans.reactjs.org/docs/test-renderer.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/test-renderer.html</a></p><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p>这个 package 提供了一个 React 渲染器，用于将 React 组件渲染成纯 JavaScript 对象，无需依赖 DOM 或原生移动环境。<br>这个 package 提供的主要功能是在不依赖浏览器或 jsdom 的情况下，返回某个时间点由 React DOM 或者 React Native 平台渲染出的视图结构（类似与 DOM 树）快照。</p><p>1-你可以使用 Jest 的快照测试功能来自动保存当前 JSON 树结构到一个文件中，并在测试中检查它是否被修改：了解更多。<br>2-你也可以通过遍历输出来查找特定节点，并对它们进行断言。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TestRenderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ## 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Link</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;props.page&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testRenderer = TestRenderer.create(</span><br><span class="line">  &lt;Link page=<span class="string">"https://www.facebook.com/"</span>&gt;Facebook&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log(testRenderer.toJSON());</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ &#123; type: 'a',</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/   props: &#123; href: 'https:/</span><span class="regexp">/www.facebook.com/</span><span class="string">' &#125;,</span></span><br><span class="line"><span class="string">//   children: [ '</span>Facebook<span class="string">' ] &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* ## 2 */</span></span><br><span class="line"><span class="string">function MyComponent() &#123;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;SubComponent foo="bar" /&gt;</span></span><br><span class="line"><span class="string">      &lt;p className="my"&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function SubComponent() &#123;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;p className="sub"&gt;Sub&lt;/p&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const testRenderer = TestRenderer.create(&lt;MyComponent /&gt;);</span></span><br><span class="line"><span class="string">const testInstance = testRenderer.root;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">expect(testInstance.findByType(SubComponent).props.foo).toBe('</span>bar<span class="string">');</span></span><br><span class="line"><span class="string">expect(testInstance.findByProps(&#123;className: "sub"&#125;).children).toEqual(['</span>Sub<span class="string">']);</span></span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>TestRenderer.create()<br>通过传来的 React 元素创建一个 TestRenderer 实例。它并不使用真实的 DOM，但是它依然将组件树完整地渲染到内存，以便于你对它进行断言。此时将返回一个 TestRenderer 实例。</p><p>TestRenderer.act()<br>与 react-dom/test-utils 中的 act() 相似，TestRender.act 为断言准备一个组件。可以使用 act() 来包装 TestRenderer.create 和 testRenderer.update。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TestRenderer</span><br><span class="line">TestRenderer.create()</span><br><span class="line">TestRenderer.act()</span><br><span class="line">TestRenderer instance</span><br><span class="line">testRenderer.toJSON()</span><br><span class="line">testRenderer.toTree()</span><br><span class="line">testRenderer.update()</span><br><span class="line">testRenderer.unmount()</span><br><span class="line">testRenderer.getInstance()</span><br><span class="line">testRenderer.root</span><br><span class="line">TestInstance</span><br><span class="line">testInstance.find()</span><br><span class="line">testInstance.findByType()</span><br><span class="line">testInstance.findByProps()</span><br><span class="line">testInstance.findAll()</span><br><span class="line">testInstance.findAllByType()</span><br><span class="line">testInstance.findAllByProps()</span><br><span class="line">testInstance.instance</span><br><span class="line">testInstance.type</span><br><span class="line">testInstance.props</span><br><span class="line">testInstance.parent</span><br><span class="line">testInstance.children</span><br></pre></td></tr></table></figure><h2 id="1-3-JavaScript-环境要求"><a href="#1-3-JavaScript-环境要求" class="headerlink" title="1-3 JavaScript 环境要求"></a>1-3 JavaScript 环境要求</h2><p># react文档 - 测试</p><h2 id="0-1-测试概览"><a href="#0-1-测试概览" class="headerlink" title="0-1 测试概览"></a>0-1 测试概览</h2><p>测试概览: <a href="https://zh-hans.reactjs.org/docs/testing.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/testing.html</a></p><p>现在有许多种测试 React 组件的方法。大体上可以被分为两类：</p><ul><li>渲染组件树 在一个简化的测试环境中渲染组件树并对它们的输出做断言检查。</li><li>运行完整应用 在一个真实的浏览器环境中运行整个应用（也被称为“端到端（end-to-end）”测试）。</li></ul><p>推荐的工具<br><a href="https://jestjs.io" target="_blank" rel="noopener"><strong>Jest</strong></a> 是一个 JavaScript 测试运行器。它允许你使用 jsdom 操作 DOM 。尽管 jsdom 只是对浏览器工作表现的一个近似模拟，对测试 React 组件来说它通常也已经够用了。Jest 有着十分优秀的迭代速度，同时还提供了若干强大的功能，比如它可以模拟 modules 和 timers 让你更精细的控制代码如何执行。</p><p><a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank" rel="noopener"><strong>React 测试库</strong></a>是一组能让你不依赖 React 组件具体实现对他们进行测试的辅助工具。它让重构工作变得轻而易举，还会推动你拥抱有关无障碍的最佳实践。虽然它不能让你省略子元素来浅（shallowly）渲染一个组件，但像 Jest 这样的测试运行器可以通过 mocking 让你做到。</p><h2 id="0-2-测试技巧"><a href="#0-2-测试技巧" class="headerlink" title="0-2 测试技巧"></a>0-2 测试技巧</h2><p>测试技巧: <a href="https://zh-hans.reactjs.org/docs/testing-recipes.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/testing-recipes.html</a></p><blockquote><p>此章节假设你正在使用 Jest 作为测试运行器。如果你使用不同的测试运行器，你可能需要调整 API，但整体的解决方案是相同的。在测试环境章节阅读更多关于设置测试环境的细节。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建/清理</span><br><span class="line">act()</span><br><span class="line">渲染</span><br><span class="line">数据获取</span><br><span class="line">mock 模块</span><br><span class="line">事件</span><br><span class="line">计时器</span><br><span class="line">快照测试</span><br><span class="line">多渲染器</span><br><span class="line">缺少什么?</span><br></pre></td></tr></table></figure><p>### 创建/清理<br>对于每个测试，我们通常希望将 React 树渲染给附加到 document的 DOM 元素。这点很重要，以便它可以接收 DOM 事件。当测试结束时，我们需要“清理”并从 document 中卸载树。<br>常见的方法是使用一对 beforeEach 和 afterEach 块，以便它们一直运行，并隔离测试本身造成的影响：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unmountComponentAtNode &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">  container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 退出时进行清理</span></span><br><span class="line">  unmountComponentAtNode(container);</span><br><span class="line">  container.remove();</span><br><span class="line">  container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>### act</p><blockquote><p>act 名称来自 Arrange-Act-Assert 模式。</p></blockquote><p>在编写 UI 测试时，可以将渲染、用户事件或数据获取等任务视为与用户界面交互的“单元”。react-dom/test-utils 提供了一个名为 <a href="https://zh-hans.reactjs.org/docs/test-utils.html#act" target="_blank" rel="noopener">act()</a> 的 helper，它确保在进行任何断言之前，与这些“单元”相关的所有更新都已处理并应用于 DOM：<br>这有助于使测试运行更接近真实用户在使用应用程序时的体验。</p><p>你可能会发现直接使用 act() 有点过于冗长。为了避免一些样板代码，你可以使用 <a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank" rel="noopener">React 测试库</a>，这些 helper 是使用 act() 函数进行封装的。</p><p>### 渲染<br>通常，你可能希望测试组件对于给定的 prop 渲染是否正确。</p><p>### 数据获取<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render, unmountComponentAtNode &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">"react-dom/test-utils"</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">"./user"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">  container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 退出时进行清理</span></span><br><span class="line">  unmountComponentAtNode(container);</span><br><span class="line">  container.remove();</span><br><span class="line">  container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">"渲染用户数据"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fakeUser = &#123;</span><br><span class="line">    name: <span class="string">"Joni Baez"</span>,</span><br><span class="line">    age: <span class="string">"32"</span>,</span><br><span class="line">    address: <span class="string">"123, Charming Avenue"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  jest.spyOn(global, <span class="string">"fetch"</span>).mockImplementation(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">      json: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(fakeUser)</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用异步的 act 应用执行成功的 promise</span></span><br><span class="line">  <span class="keyword">await</span> act(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">id</span>=<span class="string">"123"</span> /&gt;</span></span>, container);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(container.querySelector(<span class="string">"summary"</span>).textContent).toBe(fakeUser.name);</span><br><span class="line">  expect(container.querySelector(<span class="string">"strong"</span>).textContent).toBe(fakeUser.age);</span><br><span class="line">  expect(container.textContent).toContain(fakeUser.address);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理 mock 以确保测试完全隔离</span></span><br><span class="line">  global.fetch.mockRestore();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>### mock 模块<br>有些模块可能在测试环境中不能很好地工作，或者对测试本身不是很重要。使用虚拟数据来 mock 这些模块可以使你为代码编写测试变得更容易。<br>考虑一个嵌入第三方 GoogleMap 组件的 Contact 组件：</p><p>### 事件</p><blockquote><p>React 测试库为触发事件提供了一个更简洁 helper。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... // 创建/清理</span></span><br><span class="line">it(<span class="string">"点击时更新值"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onChange = jest.fn();</span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span>, container);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取按钮元素，并触发点击事件</span></span><br><span class="line">  <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"[data-testid=toggle]"</span>);</span><br><span class="line">  expect(button.innerHTML).toBe(<span class="string">"Turn on"</span>);</span><br><span class="line"></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    button.dispatchEvent(<span class="keyword">new</span> MouseEvent(<span class="string">"click"</span>, &#123; <span class="attr">bubbles</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(onChange).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">  expect(button.innerHTML).toBe(<span class="string">"Turn off"</span>);</span><br><span class="line"></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      button.dispatchEvent(<span class="keyword">new</span> MouseEvent(<span class="string">"click"</span>, &#123; <span class="attr">bubbles</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(onChange).toHaveBeenCalledTimes(<span class="number">6</span>);</span><br><span class="line">  expect(button.innerHTML).toBe(<span class="string">"Turn on"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>### 计时器</p><p>### 快照测试<br>像 Jest 这样的框架还允许你使用 toMatchSnapshot / toMatchInlineSnapshot 保存数据的“快照”。有了这些，我们可以“保存”渲染的组件输出，并确保对它的更新作为对快照的更新显式提交。</p><p>在这个示例中，我们渲染一个组件并使用 pretty 包对渲染的 HTML 进行格式化，然后将其保存为内联快照：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">"应渲染问候语"</span>, () =&gt; &#123;</span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, container);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(</span><br><span class="line">    pretty(container.innerHTML)</span><br><span class="line">  ).toMatchInlineSnapshot(); <span class="comment">/* ... 由 jest 自动填充 ... */</span></span><br><span class="line"></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"Jenny"</span> /&gt;</span></span>, container);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(</span><br><span class="line">    pretty(container.innerHTML)</span><br><span class="line">  ).toMatchInlineSnapshot(); <span class="comment">/* ... 由 jest 自动填充 ... */</span></span><br><span class="line"></span><br><span class="line">  act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"Margaret"</span> /&gt;</span></span>, container);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  expect(</span><br><span class="line">    pretty(container.innerHTML)</span><br><span class="line">  ).toMatchInlineSnapshot(); <span class="comment">/* ... 由 jest 自动填充 ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通常，进行具体的断言比使用快照更好。这类测试包括实现细节，因此很容易中断，并且团队可能对快照中断不敏感。选择性地 mock 一些子组件可以帮助减小快照的大小，并使它们在代码评审中保持可读性。</p><p>### 多渲染器</p><h2 id="3-1-jest-快照测试"><a href="#3-1-jest-快照测试" class="headerlink" title="3-1 jest-快照测试"></a>3-1 jest-快照测试</h2><p>jest-教程-快照测试: <a href="https://jestjs.io/zh-Hans/docs/snapshot-testing" target="_blank" rel="noopener">https://jestjs.io/zh-Hans/docs/snapshot-testing</a></p><p>每当你想要确保你的UI不会有意外的改变，快照测试是非常有用的工具。</p><p>典型的做法是在渲染了UI组件之后，保存一个快照文件， 检测他是否与保存在单元测试旁的快照文件相匹配。 若两个快照不匹配，测试将失败：有可能做了意外的更改，或者UI组件已经更新到了新版本。</p><p>### Jest快照测试<br>测试React组件可以采用类似的方法。 你只需要测试对应的React树的序列号值即可，而不需要渲染整个React程序。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'../Link'</span>;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders correctly'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> tree = renderer</span><br><span class="line">    .create(<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">page</span>=<span class="string">"http://www.facebook.com"</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>)</span><br><span class="line">    .toJSON();</span><br><span class="line">  expect(tree).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>#### 更新快照<br><code>jest --updateSnapshot</code> 或<code>jest -u</code>.<br>如果你想限制只重新生成一部分的快照文件，你可以使用–testNamePattern 来正则匹配想要生成的快照名字。</p><p>#### 交互式快照模式<br>进入交互式快照模式后，Jest会让你浏览失败的快照，并让你可以看到失败用例的输出日志。<br>这样，你就可以选择更新快照，或者跳至下一步。</p><p>#### 内联快照<br>#### 属性匹配器</p><p>### 最佳实践<br>#### 1. 视快照如代码<br>#### 2. 测试应是确定性的<br>#### 3. 使用合理的快照描述</p><h2 id="3-2-jest-测试React程序"><a href="#3-2-jest-测试React程序" class="headerlink" title="3-2 jest-测试React程序"></a>3-2 jest-测试React程序</h2><p>jest-框架指南-测试React程序: <a href="https://jestjs.io/zh-Hans/docs/tutorial-react" target="_blank" rel="noopener">https://jestjs.io/zh-Hans/docs/tutorial-react</a><br>在Facebook，我们使用 Jest 测试 React 应用程序。</p><!--\### 使用Create React Ap 如果你是 React 新手，我们建议使用  -->Create React App。 它已经包含了 可用的 Jest！ 您只需要添加 react-test-renderer 来渲染快照。<br><!-- \### 不使用Create React App​如果你已经有一个应用，你仅需要安装一些包来使他们运行起来。 我们使用babel-jest包和babel-preset-react，从而在测试环境中转换我们代码 --><p>现在，使用React的test renderer和Jest的快照特性来和组件交互，获得渲染结果和生成快照文件：</p><p>Link.test.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'../Link'</span>;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'changes the class when hovered'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> component = renderer.create(</span><br><span class="line">    &lt;Link page=<span class="string">"http://www.facebook.com"</span>&gt;Facebook&lt;<span class="regexp">/Link&gt;,</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  let tree = component.toJSON();</span></span><br><span class="line"><span class="regexp">  expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ manually trigger the callback</span></span><br><span class="line"><span class="regexp">  renderer.act(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    tree.props.onMouseEnter();</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ re-rendering</span></span><br><span class="line"><span class="regexp">  tree = component.toJSON();</span></span><br><span class="line"><span class="regexp">  expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ manually trigger the callback</span></span><br><span class="line"><span class="regexp">  renderer.act(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    tree.props.onMouseLeave();</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ re-rendering</span></span><br><span class="line"><span class="regexp">  tree = component.toJSON();</span></span><br><span class="line"><span class="regexp">  expect(tree).toMatchSnapshot();</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>Snapshot Testing with Mocks, Enzyme and React 16+​<br>快照测试在 Enzyme 和 React 16+ 中使用时有一个注意事项。 如果您使用以下方式模拟模块：</p><h3 id="DOM测试​"><a href="#DOM测试​" class="headerlink" title="DOM测试​"></a>DOM测试​</h3><p>如果你想断言或者操纵你的渲染组件，你可以使用react-testing-library, Enzyme, 或者React的 TestUtils。 接下来我们讲两个 react-testing-library 和Enzyme的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __tests__/CheckboxWithLabel-test.js</span></span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123;shallow&#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line"><span class="keyword">import</span> CheckboxWithLabel <span class="keyword">from</span> <span class="string">'../CheckboxWithLabel'</span>;</span><br><span class="line"></span><br><span class="line">Enzyme.configure(&#123;<span class="attr">adapter</span>: <span class="keyword">new</span> Adapter()&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'CheckboxWithLabel changes the text after click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Render a checkbox with label in the document</span></span><br><span class="line">  <span class="keyword">const</span> checkbox = shallow(<span class="xml"><span class="tag">&lt;<span class="name">CheckboxWithLabel</span> <span class="attr">labelOn</span>=<span class="string">"On"</span> <span class="attr">labelOff</span>=<span class="string">"Off"</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  expect(checkbox.text()).toEqual(<span class="string">'Off'</span>);</span><br><span class="line"></span><br><span class="line">  checkbox.find(<span class="string">'input'</span>).simulate(<span class="string">'change'</span>);</span><br><span class="line"></span><br><span class="line">  expect(checkbox.text()).toEqual(<span class="string">'On'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>### 自定义转译器​</p><p># enzyme 和 react-testing-library<br><!-- [react前端自动化测试： jest + enzyme ](https://www.cnblogs.com/susu8/p/9512393.html)\$_PS: 介绍了react组件测试的各个情况，包括组件wrapper，方法，事件模拟，生命周期等 --></p><h2 id="enzyme"><a href="#enzyme" class="headerlink" title="enzyme"></a>enzyme</h2><p>Enzyme: <a href="https://github.com/enzymejs/enzyme" target="_blank" rel="noopener">https://github.com/enzymejs/enzyme</a><br>Enzyme 文档: <a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener">https://enzymejs.github.io/enzyme/</a></p><p><a href="https://www.piotrstaniow.pl/goodbye-enzyme" target="_blank" rel="noopener">Time to say goodbye - Enzyme.js</a><br><!-- [是时候说再见了，Enzyme.js](https://www.infoq.cn/article/1b1xze82hfssd168m2k7) --><br>最后，GitHub Insights 工具提供了有关两者使用情况的有趣统计数据。在撰写本文时，在 GitHub 上托管的开源存储库中：<br>354,059 个存储库依赖 Enzyme<br>2,440,909 个存储库依赖 React Testing Library</p><!-- \#0 [【译】使用Enzyme和React Testing Library测试React Hooks](https://cloud.tencent.com/developer/article/1651156) --><p><a href="https://css-tricks.com/testing-react-hooks-with-enzyme-and-react-testing-library/" target="_blank" rel="noopener">Testing React Hooks With Enzyme and React Testing Library</a><br><!-- \$_PS: 介绍了通过两个库进行react组件测试的详细。包括shadow/渲染，组件mount/生命周期，点击/事件等。 --></p><!-- \#1 [【前端单元测试入门02】react的单元测试之Enzyme](https://www.cnblogs.com/vvjiang/p/8599980.html#shallow-render和mount的效率对比) --><!-- 那么问题来了，mount存在的价值是什么，render就可以测试子组件，render还不需要jsdom和额外的配置。当然是有价值的，shallow和mount因为都是dom对象的缘故，所以都是可以模拟交互的，而render是不能的。 --><p>简而言之，Enzyme主要包括三个测试：<br>一个是浅渲染的shallow，这个生成虚DOM对象，所以渲染最快，然而它并不能测试子组件的相关代码。<br>另一个是DOM渲染mount，它会生成完整的DOM节点，所以可以测试子组件。但是要依赖一个用jsdom模拟的浏览器环境。<br>最后一个是HTML文本渲染render，它会将react组件渲染为html文本，然后在内部通过Cheerio自动生成一个Cheerio对象。<br><!-- END: #1 --></p><!-- \#2 [react dom交互测试(enzyme)以及快照测试(snapshot) #265](https://github.com/frontend9/fe9-library/issues/265) --><!-- ### 渲染方式enzyme有3种渲染方式：render、mount、shallow，先了解下区别。render: render采用的是第三方库Cheerio的渲染，渲染结果是普通的html结构，对于snapshot使用render比较合适。### shallow和mount:shallow和mount对组件的渲染结果不是html的dom树，而是react树，如果你chrome装了react devtool插件，他的渲染结果就是react devtool tab下查看的组件结构，而render函数的结果是element tab下查看的结果。这些只是渲染结果上的差别，更大的差别是shallow和mount的结果是个被封装的 ReactWrapper，可以进行多种操作，譬如find()、parents()、children()等选择器进行元素查找；state()、props()进行数据查找，setState()、setprops()操作数据；simulate()模拟事件触发。 --><h3 id="使用推荐"><a href="#使用推荐" class="headerlink" title="使用推荐:"></a>使用推荐:</h3><p>shallow只渲染当前组件，只能能对当前组件做断言；<br>mount会渲染当前组件以及所有子组件，对所有子组件也可以做上述操作。<br>一般交互测试都会关心到子组件，我使用的都是mount。<br>但是mount耗时更长，内存啥的也都占用的更多，如果没必要操作和断言子组件，可以使用shallow。</p><!-- 三种渲染方式速度对比： --><!-- END: #2 --><!-- \#3 [组件测试](https://thinkbucket.github.io/docsite/docs/react/7.test/component-test/) --><!-- ### 组测试基础概念#### 快照测试#### 浅渲染浅渲染（shallow rendering）意思就是只渲染组件中的第一层，这样测试执行器就不需要关心 DOM 和执行环境了。 --><h4 id="全渲染"><a href="#全渲染" class="headerlink" title="全渲染"></a>全渲染</h4><p>全渲染（full rendering）就是完整渲染出当前组件及其所有子组件，就像在真实浏览器渲染那样，当组件内部直接改变了 DOM 时，就需要使用全渲染来测试。全渲染需要真实地模拟 DOM 环境，流行的做法有以下几种：</p><p>使用 JSDOM：使用 JS 模拟 DOM 环境，能满足90%的使用场景。这是 Jest 内部所使用的全渲染框架。<br>使用 Cheerio：类似 JSDOM，更轻的实现，类似 jQuery 的语法。这是 Enzyme 内部使用的全渲染框架。<br>使用 Karma：在真实的浏览器中执行测试，也支持在多个浏览器中依次执行测试，使用的是真实DOM 环境，但速度稍慢。</p><h3 id="组件测试框架"><a href="#组件测试框架" class="headerlink" title="组件测试框架"></a>组件测试框架</h3><h4 id="Jest-组件测试"><a href="#Jest-组件测试" class="headerlink" title="Jest 组件测试"></a>Jest 组件测试</h4><h4 id="Enzyme-组件测试"><a href="#Enzyme-组件测试" class="headerlink" title="Enzyme 组件测试"></a>Enzyme 组件测试</h4><p>Enzyme 提供 3 种不同的方式来测试组件：</p><p>shallow：推荐的方式，浅渲染，只会渲染本地组件内容（只渲染不包含 children 的组件），引用的外部组件不会渲染，提供更好的隔离性。<br>render：如果 shallow 不能满足，才会使用它，能够渲染所有的子组件。基于 Cheerio 来模拟 DOM 环境（Cheerio 是类似 JSDOM 的另一框架）。<br>mount：类似 render，会做全渲染，对测试生命周期非常有用，能够访问到组件的生命周期方法，比如 componentDidUpdate 等。一般用于集成测试。<br>Enzyme Selector</p><p>推荐：一般组件的快照测试使用 shallow 方法即可。<br>推荐：如果要测试子组件，并且对组件的生命周期等方法不怎么关注，使用 render 方法。<br>推荐：如果要测试组件生命周期方法、子组件，使用 mount 方法。</p><h3 id="编写组件测试"><a href="#编写组件测试" class="headerlink" title="编写组件测试"></a>编写组件测试</h3><h4 id="测试-rendering"><a href="#测试-rendering" class="headerlink" title="测试 rendering"></a>测试 rendering</h4><h4 id="测试-props"><a href="#测试-props" class="headerlink" title="测试 props"></a>测试 props</h4><h4 id="测试-events"><a href="#测试-events" class="headerlink" title="测试 events"></a>测试 events</h4><h4 id="测试-event-handlers"><a href="#测试-event-handlers" class="headerlink" title="测试 event handlers"></a>测试 event handlers</h4><!-- END: #3 --><h2 id="enzyme-VS-react-testing-library"><a href="#enzyme-VS-react-testing-library" class="headerlink" title="enzyme VS react-testing-library"></a>enzyme VS react-testing-library</h2><!-- [【翻译】enzyme 和 react-testing-library 之间的不同](https://evanhongyousan.github.io/2020/10/30/Difference-between-enzyme-and-react-testing-library/) --><p>原文: # 71 <a href="https://techdoma.in/react-js-testing/difference-between-enzyme-and-react-testing-library" target="_blank" rel="noopener">Difference between enzyme and react-testing-library</a></p><h3 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h3><p>Enzyme 是由 Airbnb 推出的流行的测试库。它已经发布了很长一段时间，且 react 官方文档建议减少使用 Enzyme 作为编写测试用例的模板。Enzyme 的 API 旨在通过模仿 jQuery 的 API 来实现直观和灵活的 DOM 操作和遍历。</p><h3 id="React-Testing-Library"><a href="#React-Testing-Library" class="headerlink" title="React Testing Library"></a>React Testing Library</h3><p>React Testing Library – 一个非常通用的名字，它作为一个测试库，旨在解决与其他测试库不同的用例。React Testing Library 迫使你编写不脆弱的测试 – 测试并不是测试具体实现，而是测试组件的功能。它鼓励编写代码的最佳实践，并使代码具备可测试性，和测试正确的条件。</p><blockquote><p>更新–React Testing Library 现在改名为@testing-library/react。</p></blockquote><p>让我们来看看 Enzyme 与@testing-library/react 的一些区别。<br><!-- \$_PS: 从配置，概念（组件测试 or dom测试），渲染机制(enzyme 有3种方式)，强制更新组件，实例方法，约束性（组件内部方法） 等5个方面详细比较了区别。 --></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>#### Case 1 - 设置<br>在 Enzyme 中，你需要配置适配器，使其与 React 16 一起工作。还有其他的第三方适配器可以使 Enzyme 与这些库一起工作。<br>在 @testing-library/react 中，不需要太多的设置。你必须安装 @testing-library/react npm 模块，然后就可以了。<code>npm install --save-dev react-testing-library</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mport Enzyme <span class="keyword">from</span> <span class="string">"enzyme"</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">"enzyme-adapter-react-16"</span>;</span><br><span class="line"></span><br><span class="line">Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br></pre></td></tr></table></figure></p><p>#### Case 2 概念差异<br>当你在 Enzyme 中编写测试时，你有方法检查类的状态属性，检查传递给组件的 props 是什么。但是如果你是用道具和状态来测试组件，那就意味着你的测试很脆弱。如果明天有人改变了状态变量的名称，那么你的测试就会失败。即使组件的功能是一样的，只是因为组件中使用的状态变量名重名了，测试就会失败。由此可见单元测试的脆性。</p><p>而@testing-library/react 没有测试状态或道具的方法。相反，它测试的是 dom，也就是用户正在与之交互的东西。</p><p>@testing-library/react 的指导原则之一是<br>如果涉及到渲染组件，它处理的是 DOM 节点而不是组件实例，也不应该鼓励处理组件实例。</p><p>所以，你没有得到组件实例的方法，也没有自己调用组件的方法。相反，你就像用户一样在 DOM 上工作。想测试对服务器的异步函数调用吗？从 DOM 中获取按钮，点击它，模拟 API，然后在 DOM 中检查结果。</p><p>#### Case 3 没有强制更新()或强制重新渲染组件<br>在 Enzyme 中，你有 ForceUpdate 方法来重新渲染组件。如果你在组件内部窥探一些箭头函数（组件内部的箭头函数是错误的），那么你将不得不强制更新组件。</p><p>在@testing-library/react 中，你没有任何这样的方法。相反，它只使用 DOM 进行测试。</p><p>#### Case 4 没有浅层或深层的渲染<br>在@testing-library/react 中，你没有直接的方法来测试组件的实例。所以，在 React 测试库中，没有对组件进行浅层或深层的渲染。</p><p>Case 5 约束性<br>Enzyme 不是一个强约束（opionated）的库，它提供了访问组件内部的方法，即组件的实例方法、状态和道具。它提供了访问组件内部的方法，即组件的方法、状态和属性。但是 Enzyme 也提供了访问组件的 DOM 的方法，所以通过使用 Enzyme，你可以选择测试组件的内部结构，即组件的方法，状态和属性。</p><p>所以通过使用 Enzyme，你可以选择测试组件的内部，也可以选择不测试。Enzyme 并不强制执行任何关于你应该如何测试组件的意见。</p><p>@testing-library/react 是强约束（opionated）的库。它只提供给你渲染组件和访问 DOM 的方法，不提供访问组件的方法。它不提供访问组件内部的方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然@testing-library/react 的目标是与 Enzyme 竞争，并鼓励你从用户的角度编写可测试的代码和对应测试，但它们都有用例。你不能用一个代替另一个。有时你确实需要测试组件内部的状态变化或功能，尽管从用户的角度来看，它可能没有意义。在这些情况下，需要用 Enzyme 来测试实例方法。React Testing Library 很适合测试组件的 DOM，因为它允许你像用户使用它一样进行测试。</p><!-- END: #71 --><h3 id="＠testing-library-react"><a href="#＠testing-library-react" class="headerlink" title="＠testing-library/react"></a>＠testing-library/react</h3><!-- \# 72 [React单元测试--- 以Jest为例](https://www.cnblogs.com/SamWeb/p/13599947.html) --><!-- 那怎么渲染？怎么查看渲染出来内容呢？因为我们是在命令行中跑测试，而不是在浏览器中进行测试？渲染的话，目前有两个测试库enzyme和@testing-library/react, 提供了渲染方法。查看内容，则是Jest内置了jsdom, jsdom提供了DOM的无头实现，也就是说在命令行中跑测试，在测试中仍然可以获取到document, document.body 等DOM 元素，也就可以使用documet.getElementId() 等DOM 方法来查出内容，也可以click 来测试浏览器的交互形为。jsdom也称为Jest浏览器环境。 --><p>enzyme和@testing-library/react，怎么选择呢？<strong>现在倾向于＠testing-library/react</strong>,<br>－是因为它对react hooks支持比较好，<br>二是，它的测试更符合用户形为，渲染组件，查找元素，和用户使用浏览器没有什么区别。<br>＠testing-library/react也鼓励我们，写测试要把注意力放到用户身上，测试要模拟真实用户的形为，而不是测试组件的实现细节，<!-- 这样，测试完成后，对组件更有信心。什么是测试实现细节呢？就是测试组件状态是不是对的，直接调用组件中的方法。 --><br>如果你了解Enzyme的话，它就提供了wrapper.state方法，可以直接获取到组件的状态，wapper.instance可以直接调用组件的方法。<br><!-- 为什么不测试组件的实现细节？测试组件的实现细节有什么不好吗？有两个不好的地方，一是使用组件时，谁管你内部是怎么实现的，用户只管好不好用，有没有达到预期效果，测试实现细节显得没有什么意义。二是维护成本太高，今天组件的状态叫curValue, 明天可能叫currentValue, 这样测试就要改来改去，但这样的修改对组件来说，功能没有受到任何的影响，按理说，测试是不需要改的。＠testing-library/react并没有提供测试实现细节的功能，只提供了getByText()等测试dom的功能。 --><br><!-- 自己配置一个测试环境，稍微有点麻烦，幸好create-react-app内置了@test-library/react，使用它创建项目，可以直接写测试。使用create-react-app 创建项目后，就可以看一下@test-library/react库了。React单元测试，就是渲染，查找元素，进行判断，是不是符合预期，也就是断言。React test libaray 提供了render()方法进行渲染，它接受一个React element, 然后把它渲染成DOM, 插入到body元素上。提供了*Text()等方法来查找元素，jest-dom提供了断言。写一个简单的例子，组件加载的时候显示loading， 然后请求数据， 展示数据。App.js修改如下 --></p><!-- END: #72 --><!-- # 其他[Unit Testing in React: Full Guide on Jest and Enzyme Testing](https://djangostars.com/blog/what-and-how-to-test-with-enzyme-and-jest-full-instruction-on-react-component-testing/) --><!-- # react 测试### hooks 测试[如何对 react hooks 进行单元测试](https://segmentfault.com/a/1190000020058166) -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐的工具：Jest ，React 测试库。&lt;!-- react文档-测试概览 --&gt;&lt;br&gt;如果你想断言或者操纵你的渲染组件，你可以使用react-testing-library, Enzyme, 或者React的 TestUtils。&lt;!-- jest 文档-react测试-DOM测试​ --&gt;&lt;/p&gt;
&lt;p&gt;react测试技巧: &lt;a href=&quot;https://zh-hans.reactjs.org/docs/testing-recipes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-hans.reactjs.org/docs/testing-recipes.html&lt;/a&gt;&lt;br&gt;jest-快照测试: &lt;a href=&quot;https://jestjs.io/zh-Hans/docs/snapshot-testing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jestjs.io/zh-Hans/docs/snapshot-testing&lt;/a&gt;&lt;br&gt;React 测试库: &lt;a href=&quot;https://testing-library.com/docs/react-testing-library/intro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://testing-library.com/docs/react-testing-library/intro/&lt;/a&gt;&lt;br&gt;Test Renderer: &lt;a href=&quot;https://zh-hans.reactjs.org/docs/test-renderer.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-hans.reactjs.org/docs/test-renderer.html&lt;/a&gt;&lt;br&gt;Test Utilities: &lt;a href=&quot;https://reactjs.org/docs/test-utils.html#act&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://reactjs.org/docs/test-utils.html#act&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="react.js" scheme="http://yoursite.com/tags/react-js/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="jest" scheme="http://yoursite.com/tags/jest/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD 学习</title>
    <link href="http://yoursite.com/sum/jsplus/CI%E5%92%8CCD%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/sum/jsplus/CI和CD学习/</id>
    <published>2022-08-08T00:00:00.000Z</published>
    <updated>2022-09-02T05:51:20.914Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://you img base url/../assets/images/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BA%A4%E4%BB%98%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg?e=1677084656&token=your qiniu access key:Ly2sCRvLUuILJgEATDFD5lmsrqY=" alt="持续集成、部署和交付的关系"></p><p style="text-align:right"> 2022. 星期 : </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时“持续交付”也包含了持续部署流程。</p><p>归根结底，我们没必要纠结于这些语义，您只需记得 CI/CD 其实就是一个流程（通常形象地表述为管道），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI/CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。<br>来源：<br><!-- [CI/CD是什么？](https://blog.csdn.net/weixin_41044151/article/details/114374207) --></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><!-- \# 1-0 [CICD持续集成/持续部署](https://blog.csdn.net/anzhenxi3529/article/details/121596458) --><p>CI / CD的采用改变了开发人员和测试人员如何发布软件。</p><p>最初是瀑布模型，后来是敏捷开发，现在是DevOps，这是现代开发人员构建出色的产品的技术路线。随着DevOps的兴起，出现了持续集成（Continuous Integration）、持续交付（Continuous Delivery） 、持续部署（Continuous Deployment） 的新方法。<!-- 传统的软件开发和交付方法正在迅速变得过时。从历史上看，在敏捷时代，大多数公司会每月，每季度，每两年甚至每年发布部署/发布软件。然而，现在，在DevOps时代，每周，每天，甚至每天多次是常态。当SaaS正在占领世界时，尤其如此，您可以轻松地动态更新应用程序，而无需强迫客户下载新组件。很多时候，他们甚至都不会意识到正在发生变化。开发团队通过软件交付流水线（Pipeline）实现自动化，以缩短交付周期，大多数团队都有自动化流程来检查代码并部署到新环境。今天，我们将介绍什么是CI / CD / CD，以及现代软件公司如何使用工具将部署代码的流程自动化。 --></p><p>持续集成的重点是将各个开发人员的工作集合到一个代码仓库中。通常，每天都要进行几次，主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。<br>持续交付的目的是最小化部署或释放过程中固有的摩擦。它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。<br>持续部署是一种更高程度的自动化，无论何时对代码进行重大更改，都会自动进行构建/部署。<br><!-- 这些阶段中的每一个都是交付管道的一部分 。在Humble和Farley的书《持续交付：可靠的软件版本中，通过构建，测试和部署自动化》，解释“对软件的每次更改，都会在发布过程中经历一个复杂的过程。该过程涉及构建软件，然后通过多个测试和部署阶段进行这些构建。反过来，这需要许多人之间的合作，也许需要几个团队之间的合作。部署管道对此过程进行建模，并且它在持续集成和发布管理工具中的实现，使您能够在从版本控制转移到各种测试和部署，以向用户发布时查看和控制每个更改的进度。” --></p><!-- 下一步是什么？ --><!-- END: #1-0 --><!-- s4 \# 1-1 [什么是CI/CD](https://www.cnblogs.com/yf2196717/p/14909194.html)s4 [什么是CI/CD](https://blog.z0ukun.com/?p=2935) PS: 和1-0 开头一样的。1-0是概要。--><!-- ### DevOps --><p>DevOps是Development和Operations的组合，是一种方法论，是一组过程、方法与系统的统称，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟。</p><!-- DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。具体来说，就是在软件交付和部署过程中提高沟通与协作的效率，旨在更快、更可靠的的发布更高质量的产品。也就是说DevOps是一组过程和方法的统称，并不指代某一特定的软件工具或软件工具组合。各种工具软件或软件组合可以实现DevOps的概念方法。其本质是一整套的方法论，而不是指某种或某些工具集合，与软件开发中设计到的OOP、AOP、IOC（或DI）等类似，是一种理论或过程或方法的抽象或代称。在了解了什么是DevOps之后、我们来看看到底什么是CI/CD？CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。现在我们把CI/CD拆分开、我们先来看看什么是CI？ --><!-- ### 4、Agile Development --><p>最后我们再来看看上面是敏捷开发，这个称呼似乎还没有所谓的简称，而且这个称呼似乎在国内被滥用了。敏捷开发着重于一种开发的思路，拥抱变化和快速迭代。如何实现敏捷开发，目前似乎尚没有完善的工具链，更多的是一种概念性，调侃的说法“既想马尔跑得快，又想马儿不吃草”的另外一种说法。</p><!-- 上图揭示了敏捷开发的一些内涵和目标，似乎有点儿一本真经的胡说八道的意思。对于上面概念性的内容每个人的理解都有所不同。就好比CGI 这个词，即可以理解成CGI这种协议，也可以理解成实现了CGI协议的软件工具，都没有问题，咬文嚼字过犹不及。最后我们通过下面的图来看看前面讲到的CI、CD和DevOps之间的关系 ： --><!-- END: #1-1 --><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><!-- \# 1 [一文理解什么是持续集成、持续交付、持续部署（CI、CD、CO）](https://baijiahao.baidu.com/s?id=1711138194908886692&wfr=spider&for=pc) --><!-- ![持续集成、部署和交付的关系](../assets/images/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BA%A4%E4%BB%98%E7%9A%84%E5%85%B3%E7%B3%BB.jpeg) --><p>持续集成Continuous Integration<br>集成是将更新的代码合并或者提交到主干源码仓库中。在这个合并或者提交的过程中，都伴随着执行一系列的质量保证活动如代码规范检查、单元测试、安全扫描等来确保代码的质量。<br><!-- 持续集成是在版本控制的基础上，通过频繁的代码提交、自动化构建和单元测试加快集成周期和问题反馈速度，从而及时验证系统可用性。为了保证后续的系统质量，在持续集成过程中，还会加入代码规范扫描、安全漏洞扫描、集成测试等活动，用来保证代码形成过程符合质量要求。持续集成的频率达到每天多次、频繁的集成，可以提前发现问题尽早解决冲突，使后续的持续集成更顺畅。 --><br>持续部署Continuous Deployment<br>部署是将制品安装到不同的运行环境的技术操作，如测试环境、准生产环境、生产环境等都需要部署操作。<br><!-- 持续部署则是通过自动化的手段将部署的操作过程进行简化，降低部署的复杂度，使得部署是一个随时可进行的快速活动。所以持续部署并不特指通过质量验证的制品自动部署到生产环境的特定环节。在持续集成过程中不断生成可执行的制品，需要尽快验证是否存在功能性能等方面的问题，或者尽可能快速的让最终用户可以使用这些功能。通过持续部署到测试环境、准生成环境中，可以使测试团队尽快开始测试，开发团队获得快速的反馈并响应。使研发和测试的协同加快了进程。通过持续部署到生产环境，让最终用户可见，则可以快速获得最终用户的使用反馈，体现需求的市场价值。 --></p><p>持续交付Continuous Delivery<br><!-- 从在不同角色的角度对交付进行解读会有不同含义。对于产品研发团队来说，产品的版本更新迭代和交付，版本通过各阶段测试达到可提供给客户使用的状态即为可交付。对于项目实施团队来说，持续交付是要将客户要求实现的功能部署到客户的生产环境，通过验收即为交付。对于最终用户来说，持续交付是最终用户可以使用相关的功能即为交付。 --><br>持续交付是指持续的将各类变更（包括新功能、缺陷修复、配置变化、实验等）安全、快速、高质量地落实到生产环境或用户手中的能力。持续交付的能力通过自动化流水线的方式实现，减少研发过程中不必要的浪费，近而缩短整个研发过程中所有需求的交付周期。持续交付是一个整体过程，从一个业务端的想法到系统功能可以面对客户的全流程。<br><!-- END: #1 --></p><p>极限编程<br><!-- \# 5-2 [持续集成、持续交付(CI/CD)开篇，先来唠唠嗑](https://zhuanlan.zhihu.com/p/433300867) --><br>现在稍微有点规模的系统，很多都是采用分布式/微服务架构，将一个大系统拆分为很多个功能模块进行开发、测试、发布、管理<!-- 等，如果全部流程都采用人工的形式进行的话，效率肯定是超级不高效滴。 -->而且现在很多项目都采用极限编程的模式，将原有比较复杂的过程分解为更小的周期进行管理，将开发的成果快速的体现给用户，如果单纯人工操作，就需要大量的人力成本才能达到要求(频繁的开发、测试、部署是很耗时的)，另外很容出错。所以自动化的集成和交付是很有必要的<!-- ，接下来就开始这系列的学习和分享，小伙伴们一起哦。 --></p><blockquote><p>极限编程(ExtremeProgramming，简称XP)是一个轻量级的、灵巧的软件开发方法；同时它也是一个非常严谨和周密的方法；XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。 —摘自百度百科</p></blockquote><!-- Jenkins 简介及安装 --><!-- END: #5-2 --><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><!-- \#5 [你知道什么是CI/CD吗？不懂？五分钟让你彻底理解！](https://zhuanlan.zhihu.com/p/381514438) [什么是持续集成（CI）/持续交付（CD）管道？](https://baijiahao.baidu.com/s?id=1695709744830554078&wfr=spider&for=pc)[一篇文章了解CI/CD管道全流程](https://zhuanlan.zhihu.com/p/365053677)PS: 一篇文章挪动。 --><p>持续集成(CI)：代码提交<br>技术：GitHub、Gitlab、SVM、BitBucket。<br>持续集成(CI)：静态代码分析<br>技术：GitHub、Gitlab、SVM、BitBucket。<br>持续集成(CI)：构建<br>技术：Jenkins、Bamboo CI、Circle CI、Travis CI、Maven、Azure DevOps。<br>构建验证测试(BVT)/烟雾测试和单元测试：<br>工件存储：存储库工具(如Jfrog Artifactory)用于存储二进制文件，如.rar、.war、.exe、Msi等<br>持续集成(CI)：测试阶段<br>技术：Selenium、Appium、Jmeter、SOAP UI，、Tarantula。<br>集成测试：集成测试是使用诸如Cucumber、Selenium等工具执行的<br>负载平衡和压力测试：负载平衡和压力测试也使用自动化测试工具(如Selenium、JMeter等)执行，<br>技术：Spinnaker、Argo CD、Tekton CD。<br><!-- \### 持续部署：bake和部署 --><br>持续交付(CD)：Bake是指从源代码中创建一个不可变的映像实例，该实例在生产环境中具有当前配置。这些配置可能是数据库更改和其他基础设施更新之类的内容。Spinnaker可以触发Jenkins来执行这个任务，而有些组织更喜欢使用Packer。<br>持续交付(CD)：Deploy<br>持续交付(CD)：验证<br>持续交付(CD)：监控<br>技术：Zabbix、Nagios、Prometheus、Elastic Search、Splunk、Appdynamics、Tivoli。<br>持续交付(CD)：反馈和协作工具<br>技术：JIRA、ServiceNow、Slack、电子邮件、Hipchat。</p><!-- END: #5 --><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>git hooks,<br>Jenkins，travis, Hudson，gitLab-runner<br>jira, 禅道,confluence, </p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://you img base url/../assets/images/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E3%80%81%E9%83%A8%E7%BD%B2%E5%9
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化实现</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/sum/jsplus/前端工程化实现/</id>
    <published>2022-07-25T00:00:00.000Z</published>
    <updated>2023-02-22T14:09:20.937Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2022.7.25 星期一 : </p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>H5部署规范: <a href="http://doc.jd.com/jdfe-web/h5_deploy_standard/#部署前" target="_blank" rel="noopener">http://doc.jd.com/jdfe-web/h5_deploy_standard/#部署前</a></p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>git 工程流程 - 需求开发管理。</p><p>分支创建，<br>提交commit，<br>git 管理流程<br>merge 和 code reivew<br>回滚</p><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><p>html规范<br>css规范<br>js规范：eslint， react，</p><p>Eslint &amp; Prettier</p><blockquote><p>现在我们按照官网的推荐方式，把 prettier 集成到 eslint 的校验中。<br>安装解决冲突需要用到的两个依赖</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Eslint<br>Prettier<br>Commitlint<br>Husky<br><!-- Jest --><br><!-- GitHub Actions --><br><!-- Semantic Release --><br>Linter<br>changlog</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><h2 id="多端化"><a href="#多端化" class="headerlink" title="多端化"></a>多端化</h2><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><ol><li>组件库。</li><li>共用taro 运行时等。<h3 id="和原生小程序的关系"><a href="#和原生小程序的关系" class="headerlink" title="和原生小程序的关系"></a>和原生小程序的关系</h3></li></ol><h2 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h2><p>jDos。<br>pubfree， swm等。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>以前为什么没有做？没有收益？耗时多？<br>优秀的开源库都有单测。<br>变强了。 后续都会添加单测。</p><h3 id="订单单测成果展示"><a href="#订单单测成果展示" class="headerlink" title="订单单测成果展示"></a>订单单测成果展示</h3><h3 id="实现工作"><a href="#实现工作" class="headerlink" title="实现工作"></a>实现工作</h3><p>jest 框架。</p><ol><li>配置和文件目录结构。</li><li>module mock。taro等。</li><li>覆盖率。</li><li>报告。<br>结果分析</li><li>快照</li><li>接口mock</li><li>分支测试</li><li>组件操作</li><li>阈值设置。<br>自动生成测试用例。</li></ol><h2 id="监控和告警"><a href="#监控和告警" class="headerlink" title="监控和告警"></a>监控和告警</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h3 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h3><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>烛龙监控平台。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>测出什么问题？</p><h2 id="全流程实践"><a href="#全流程实践" class="headerlink" title="全流程实践"></a>全流程实践</h2><h3 id="结果收益"><a href="#结果收益" class="headerlink" title="结果收益"></a>结果收益</h3><p>前端你又偷懒了</p><h2 id="工程化思考"><a href="#工程化思考" class="headerlink" title="工程化思考"></a>工程化思考</h2><p>不能只做需求，了解业务，寻求更优的技术解决方案。</p><h2 id="京购小程序流程规范"><a href="#京购小程序流程规范" class="headerlink" title="京购小程序流程规范"></a>京购小程序流程规范</h2><h2 id="前端通道委员会"><a href="#前端通道委员会" class="headerlink" title="前端通道委员会"></a>前端通道委员会</h2><p>fe.jd.com</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2022.7.25 星期一 : &lt;/p&gt;



&lt;h2 id=&quot;规范&quot;&gt;&lt;a href=&quot;#规范&quot; class=&quot;headerlink&quot; title=&quot;规范&quot;&gt;&lt;/a&gt;规范&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化思考</title>
    <link href="http://yoursite.com/sum/jsplus/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/sum/jsplus/前端工程化思考/</id>
    <published>2022-07-25T00:00:00.000Z</published>
    <updated>2022-09-02T05:51:20.924Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p style="text-align:right"> 2022.7.25 星期一 : </p><p>这也意味着对我们的要求已经不再是“前端开发”，而是 “前端工程师”，时代要求我们要有工程化的思维和工程化解决问题的能力。</p><h1 id="大义-前端的尽头是哪里？"><a href="#大义-前端的尽头是哪里？" class="headerlink" title="大义:前端的尽头是哪里？"></a>大义:前端的尽头是哪里？</h1><p>前端(或者工程)的出路在哪里？<br><!-- 宇宙的尽头不是铁岭 --></p><p>技术框架不断更新，vue2-&gt;vue3, react 18, taro, 各种小程序，uniapp，rn,flutter，electron等。<br>版本管理svn-&gt;git；项目管理：单工程，多工程，monoresposi; 构建工具：grunt, gulp, webpack,rollup,parcel, snow;<br>babel, eslint；typescript； next.js；pm2等。<br>node服务层,serverless；jenkens, k8s；sass,pass;云服务等。<br>低代码，可视化；webassembly, cocos, 白鹭;webgl, ai,算法/机器学习,区块链/物联网,web3等。</p><p><strong>知其然知其所以然。</strong><br><strong>一通百通。</strong><br>最后剩下的能力是什么。通用的，跨行业的。<br><!-- 找到前端（学习）的出路，方式方法。 --></p><p>大前端或全栈，架构师都不是最终通路。<!-- 二舅 --></p><blockquote><p>前端工程化一定是大趋势，但不建议大家盲目地追求工程化。<br><!-- > 中台亦是如此，不要为了中台而中台，先想明白要解决什么问题。 --></p></blockquote><h1 id="前端工程化了解"><a href="#前端工程化了解" class="headerlink" title="前端工程化了解"></a>前端工程化了解</h1><h2 id="基础定义-了解"><a href="#基础定义-了解" class="headerlink" title="基础定义/了解"></a>基础定义/了解</h2><!-- \# 1 [什么是前端工程化？](https://blog.csdn.net/SuperJane_123/article/details/123944969) --><h3 id="前端工程化的定义"><a href="#前端工程化的定义" class="headerlink" title="前端工程化的定义"></a>前端工程化的定义</h3><p>前端工程化就是指遵循一定的标准和规范，通过工具去提高效率，降低成本的一种手段。<!-- 这些年呢被广泛关注和探讨，究其原因主要是前端应用现在功能要求不断提高，业务逻辑越来越复杂。那作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半边江山。从传统的网站到现在的h5、移动app、桌面应用以及小程序，前端技术几乎是无所不能的全面覆盖。在这些表现的背后呢实际上是前端行业对开发人员的要求发生了天翻地覆的变化。 -->…以前刀耕火种的方式已经完全不符合当下对开发效率的要求了，前端工程化就是在这样的背景下被提上台面，成为咱们前端工程师必备的手段之一。</p><h3 id="前端工程化主要解决的问题"><a href="#前端工程化主要解决的问题" class="headerlink" title="前端工程化主要解决的问题"></a>前端工程化主要解决的问题</h3><ul><li>传统语言或语法的弊端(es6、es7等新特性；sass、less预编器等)</li><li>无法使用模块化/组件化</li><li>重复的机械式工作(如部署上线前需要手动压缩代码及资源文件、部署过程需要手动上传代码到服务器)</li><li>代码风格统一、质量保证</li><li>依赖后端服务接口支持(部分功能开发时需要等待后端服务接口提前完成)</li><li>整体依赖后端项目</li></ul><h3 id="前端工程化的表现"><a href="#前端工程化的表现" class="headerlink" title="前端工程化的表现"></a>前端工程化的表现</h3><p><strong>一切以提高效率、降低成本、质量保证为目的的手段都属于「工程化」</strong></p><p>示例图以最简单的项目开发流程为例，每个步骤都可以通过工程化的方式大大提高开发效率<br><img src="http://you img base url/../assets/images/前端工程化流程.png?e=1677084656&token=your qiniu access key:A5Iz6G0ew_Y1YZrzL9kOUfu2hDs=" alt="前端工程化流程"></p><h3 id="工程化-≠某个工具"><a href="#工程化-≠某个工具" class="headerlink" title="工程化 ≠某个工具"></a>工程化 ≠某个工具</h3><p>这里强调一下，工程化并不等于某一个具体的工具，为什么这么说呢？因为现阶段有部分工具功能过于强大，比如webpack，这让很多新手误认为工程化就是webpack，只要用了webpack就代表有了工程化。其实不是这样子的，工具并不是工程化的核心，工程化的核心应该是对项目整体的一种规划或架构，而工具在这过程中只是用来帮我们落地去实现的这种规划或架构的一种手段。</p><!-- END: #1 --><h2 id="进一步阐述"><a href="#进一步阐述" class="headerlink" title="进一步阐述"></a>进一步阐述</h2><p>前端工程化是对<strong>模块化，组件化，规范化，自动化</strong>的高度概括和总结凝练，是一个更高层次的思想，也就是说实现前端工程化应该从模块化，组件化，规范化，自动化四个方面着手</p><ul><li>模块化（js 模块化、css 模块化、资源模块化）</li><li>组件化（复用现有的 UI 结构、样式、行为）</li><li>规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、Git 分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><!-- \# 2 [前端工程化概述，带你全面深刻了解前端工程化思想](https://baijiahao.baidu.com/s?id=1692418103713611670&wfr=spider&for=pc)2 什么是前端工程化？* 在我看来，所有能降低成本，并且能提高效率的事情的总称为工程化* 众所周知，软件工程化关注的是性能，稳定性，可用性，可维护性等方面，一切以这些为目标的工作都是"前端工程化"，更多的是往高效，稳定，可用，可维护的方向发展3 前端为什么需要工程化？随者前端的快速发展，现在的前端”太大，太广“，”复杂“，"大前端"，"微前端"等词的出现，前端已经不再止于前端了更有甚者，可以说前端不再是后端的附属品了，可以说，前端已经愈加成熟4 前端工程化要解决哪些问题？存在即合理，前端工程化的出现，主要为了解决如下情况:4.1 提高前端工程师的开发效率提高开发效率从以下这几个方面入手:    1，扩展javascript，html，css本身的语言能力    2，解决重复的工作    3，模块化，组件化    4，解决功能复用和变更问题    5，解决开发和产品环境差异问题    6，解决发布流程问题4.2 进行高效的多人协作前端工程化正是在保存工程稳定的情况下进行顺利协作4.3 保证项目的可维护性我们知道软件工程化处理正是为了项目工程的可维护性4.4 提高项目的开发质量在以上情况的实现下，项目的开发质量必然得到保证5 前端工程化发展的四个阶段我个人看来前端工程化包括如下阶段:第一阶段:库/框架选型 前端的库和框架大致有jquery,zepto,underscore,angular,react,vue）第二阶段:简单构建优化 构建工具有（grunt,gulp）第三阶段:js/css模块化开发 （AMD/CommonJS/UMD/ES6 Module Less/Sass/Stylus）第四阶段:组件化开发与资源管理[分治思想] 比如:微信小程序工程化6 前端工程化的深究前端工程化是对**模块化，组件化，规范化，自动化**的高度概括和总结凝练，是一个更高层次的思想，也就是说实现前端工程化应该从模块化，组件化，规范化，自动化四个方面着手前端模块化1，在工程化的基础上，模块化的职责在于模块管理和资源加载2，模块化的常用工具有:Nodejs，npm，webpack，parcel，rollup等前端组件化1，组件化趋势的发展存在很大的优势，它自由，灵活，可复用，大大提高了开发的效率2，它的应用实践，我觉得微信小程序的目录结构应用的是组件化的思想前端规范化关于规范化的工具主要有:eslint,styleint前端自动化1，自动化阶段包括构建，测试，部署三个阶段2，自动化构建工具有grunt，gulp，对文件进行压缩，校验，资源合并等处理方式3，自动化测试借助于一些单元测试框架(Chai,Karma,Mocha)，UI测试框架(Jest,Enzyme,Selenium Webdriver)测试功能代码，其次还有性能测试-Benchmark，覆盖率测试-Istanbul，持续集成(travis-ci,codecov)帮助我们高效得完成测试工作4，自动化部署使用pm2，项目是一个迭代开发的过程，使用pm2工具可用简化开发流程，大大提高开发效率7 总结通过上面，我们大致了解了前端工程化的知识，但是前端工程化可能远不止于上面所提到知识，学无止境，要知道我们是很难跟上前端快速的更新迭代，我只能从多方面发展和完善自己的知识，紧跟前端技术的脚步，争取取得更大的进步！ --><!-- END: #2 --><h2 id="工程化课程"><a href="#工程化课程" class="headerlink" title="工程化课程"></a>工程化课程</h2><!-- \# 3 [什么是前端工程化](https://zhuanlan.zhihu.com/p/497987971) --><p>1、什么是前端工程化？<br>简单来说，前端工程化可以提升开发体验、提高开发效率和质量、提升应用的访问性能，一切以提高效率、降低成本、质量保证为目的的手段都属于工程化。前端工程化不等同于Webpack，它主要包含从编码、发布到运维的整个前端研发生命周期，把软件工程相关的方法和思想应用到前端开发。</p><p>2、为什么大厂会着重考察前端工程化？<br>随着前端技术的不断发展和变革，其业务逻辑逐渐变得复杂多样，企业对于前端的应用功能要求也跟着不断提高，例如优化开发流程，提高编码效率和质量，提高项目的可维护性…从一个项目搭建再到部署上线，这里面的每一个过程我们都可以通过前端工程化，提高工作效率。这也是为什么大厂会要求员工会前端工程化的一个重要原因。</p><p>其次，前端工程化是大厂前端开发人员的必备技能，从开发，规范，测试，lint，构建，部署，监控，集成，微服务等多个维度，以组合拳的形式，场景化的提升前端工程师的认知。</p><p>3、为什么要学习前端工程化？<br>有人说：我不进大厂是不是就不需要学习【前端工程化】了。</p><p>大家都知道，早期的前端开发只是实现页面，在一些场景下被认为只是日常的一项简单工作，或只是某个项目的”附属品”，但随着需求的增加，前端开发的复杂度和规模也越来越庞大，在这种情况下，前端工作已经无法抛开工程化单独开发了。懂工程化是前端开发人员的刚需，不懂工程化，连项目都不会启动。前端工程化是前端工程师的必备技能，不管是创建项目还是开发发布项目，前端工程化已然成为行业公认的项目提效主流解决方案，是高级开发者必会、必用的一环。</p><p>从就业升职来看，掌握了前端工程化的同学，你就获得了显著的职业竞争优势，它将成为你晋升前端leader，或者架构师的重要基石，所以，可以说前端工程化是非学不可，所有前端同学都绕不开这个问题，如果你现在还不了解前端工程化，将注定与大厂无缘。</p><p>从技术能力来看，遇到项目只会开发，不懂原理，长此以往下去，你就只能做一名普通程序员，只能搬砖，更加无法成为架构师。说的再现实些，现在职场内卷那么严重，不懂前端工程化，未来有可能连工作都找不到。</p><p>从薪资来看，同样是前端开发，“前端工程化” 是高薪和底薪岗位的关键分水岭，要求掌握“前端工程化”的岗位，起薪≥30K，不要求掌握“前端工程化”的岗位，起薪≥ 10K。先人一步掌握前端工程化，就等于提前掌握了高薪密码。</p><p>4、这样一门复杂的技术，都要学什么？<br>5、如何系统化学习前端工程化？<br><!-- END: #3 --></p><p># 4 <a href="https://mp.weixin.qq.com/s/6dIypbLDdHsLfZm2Bfb2RQ" target="_blank" rel="noopener">漫谈前端工程化基建和架构设计</a><br>另一方面，我很理解求职者，他们也面临困惑。</p><ul><li>该如何避免相似的工作做了3年，却没能积累下3年的工作经验？</li><li>该如何从繁杂且千篇一律的业务需求中抽身出来，花时间总结经验、提高自己？</li><li>该如何为团队带来更高的价值，体现经验和能力？</li></ul><p>### 从前端工程化基建和架构设计的价值谈起<br>这里的“好项目”是指：你能在项目中从0到1打造应用的基础设施、确定应用的工程化方案、实现应用构建和发布的流程、设计应用中的公共方法和底层架构。</p><p>只有系统地研究这些内容，开发者才能真正打通自身的“任督二脉”，实现个人和团队价值的最大化。</p><p>我将上述内容总结定义为：前端工程化基建和架构设计。<br>### 我理解的“前端工程化基建和架构设计”</p><h2 id="工程化实现"><a href="#工程化实现" class="headerlink" title="工程化实现"></a>工程化实现</h2><!-- [超全面的前端工程化配置指南！](https://mp.weixin.qq.com/s/9lyaPrrn1YpMt0FQ5kythg)PS: eslint,prettier, commmitlint, git action 等配置 --><!-- [什么是前端工程化？](https://www.jianshu.com/p/e43154521bb8)[什么是前端工程化？](http://www.uml.org.cn/AJAX/202104312.asp)PS: 基础内容。没必要 --><h2 id="工程化思考"><a href="#工程化思考" class="headerlink" title="工程化思考"></a>工程化思考</h2><p><a href="https://www.zhihu.com/question/433854153/answer/1618951221" target="_blank" rel="noopener">什么是前端工程化？</a><br>2020 年的 1024，我司举办了一场内部技术大会，我分享的主题是：《Worktile 前端工程之路》，我也认真的思考了一下题主的问题：什么是前端工程化。前端工程化每个人都有不一样的理解，也没有一个权威和标准的定义，只要我们清楚为什么要工程化和工程化的意义那么具体的定义就变得不那么重要了。</p><p><a href="https://www.zhihu.com/question/433854153/answer/1631075326" target="_blank" rel="noopener">什么是前端工程化？</a><br>谢邀。前端工程化一定是大趋势，但不建议大家盲目地追求工程化，对于大部分规模不大的前端团队而言，工程体系的建设和规范并不是当务之急。<br>本篇内容来自于阿里巴巴淘系技术部高级前端技术专家阿大受 InfoQ 采访邀约的分享。</p><!-- [什么是前端工程化？](https://www.zhihu.com/question/433854153/answer/1683741056)“前端工程化”顾名思义就是使用工程化的方法去构建前端应用。说到为什么工程化和什么是工程化，我们不得不说的就是前端的发展史。PS: 结合历史，构建的部署的那一套 --><h1 id="工程化内容"><a href="#工程化内容" class="headerlink" title="工程化内容"></a>工程化内容</h1><p>同 #工程化实现<br>参考：!前端工程化流程图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p style=&quot;text-align:right&quot;&gt; 2022.7.25 星期一 : &lt;/p&gt;

&lt;p&gt;这也意味着对我们的要求已经不再是“前端开发”，而是 “前端工程师”，时代要求我们要有工程化的思维和工程化解决问题的能力。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="sum" scheme="http://yoursite.com/categories/sum/"/>
    
      <category term="jsplus" scheme="http://yoursite.com/categories/sum/jsplus/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
</feed>
