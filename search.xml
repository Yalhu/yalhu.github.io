<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博文状态</title>
    <url>/prepared/</url>
    <content><![CDATA[<p>博文状态: 计划和正在更新的博文         </p>
<h2 id="一-计划中"><a href="#一-计划中" class="headerlink" title="一 计划中"></a>一 计划中</h2><h3 id="onGoing"><a href="#onGoing" class="headerlink" title="onGoing"></a>onGoing</h3><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h3 id="preparing"><a href="#preparing" class="headerlink" title="preparing"></a>preparing</h3><ol start="4">
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> aboutme  </li>
</ul>
</li>
</ol>
<a id="more"></a>
<!-- ### needTime(relex) -->
<h3 id="relex"><a href="#relex" class="headerlink" title="relex"></a>relex</h3><ol>
<li></li>
<li>webRTC 研究  </li>
</ol>
<h3 id="considering"><a href="#considering" class="headerlink" title="considering"></a>considering</h3><ol>
<li>ssr/vpn  </li>
</ol>
<h2 id="二-需完善-新定义"><a href="#二-需完善-新定义" class="headerlink" title="二 需完善/新定义"></a>二 需完善/新定义</h2><h3 id="fixing"><a href="#fixing" class="headerlink" title="fixing"></a>fixing</h3><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> burnedBrain </li>
</ul>
</li>
</ol>
<h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a>updating</h3><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h3 id="watching"><a href="#watching" class="headerlink" title="watching"></a>watching</h3><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> 基于Hexo+NexT的博客搭建指导：性能、自动化、备份     </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> angular.js 坑</li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> vjs on work  </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> css使用记录：     </li>
</ul>
</li>
</ol>
<h2 id="三-下划线-不计划（目前为止）"><a href="#三-下划线-不计划（目前为止）" class="headerlink" title="三 下划线/不计划（目前为止）"></a>三 下划线/不计划（目前为止）</h2><h3 id="abandon"><a href="#abandon" class="headerlink" title="abandon"></a>abandon</h3><ol>
<li>mongo with php/mongo   </li>
</ol>
<h3 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h3><p><del>_webpack_5-loaders</del><br><del>_webpack_6-plugins</del> </p>
]]></content>
  </entry>
  <entry>
    <title>Js使用记录-兼容性</title>
    <url>/sum/js/js%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<p style="text-align:right">2020.1.13 星期一 13:34 </p>


<h2 id="IOS-Safari"><a href="#IOS-Safari" class="headerlink" title="IOS/Safari"></a>IOS/Safari</h2><ol>
<li>IOS 10  不支持 async/await; 但是支持Promise   </li>
<li>IOS 浏览器，<code>window.location.href=&#39;javascript:if(typeof openQuitAppClick === \&#39;function\&#39;){openQuitAppClick();}window.location.href=\&#39;&#39;.product_url(&#39;%d.html&#39;).&#39;\&#39;;;console&#39;</code><br> 上面的地址不会跳转，需要在后边加上一个<code>;console</code>。 可能和安全策略有关系</li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>页面可视化编辑器设计</title>
    <url>/sum/jsplus/%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>参考（已经yinxiang）：<br><a href="https://juejin.im/post/5dc81428e51d4523632ee793" target="_blank" rel="noopener">Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5</a><br><a href="https://zhuanlan.zhihu.com/p/67096132" target="_blank" rel="noopener">页面可视化搭建工具技术要点</a><br><a href="https://blog.csdn.net/philip502/article/details/77838856" target="_blank" rel="noopener">页面可视化编辑器设计</a>    </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx配置</title>
    <url>/sum/ser/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p style="text-align:right">2019.12.16 星期一  2108 </p>

<h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><ol start="0">
<li>nginx 配置和 cgi, fast cgi. 和php-fpm   </li>
<li>cd /usr/local/nginx/config/site-enable<br> nginx.conf  里面有<code>include sites-enabled/*</code></li>
<li>可以配置访问日志，并定义格式；有变量可以使用。access_log，error log；log_format name。<br> 然后可以根据日志，做一些其他操作。比如，pv，访问/接口，报错，统计等。    </li>
<li><p>nginx （php项目）访问502，可能是 root 文件夹权限不够。<br> chmode 777 /var/www/html  </p>
</li>
<li><p>在重启云主机（系统）之后，执行 nginx -t 是OK的，然而在执行 nginx -s reload 的时候报错<br>nginx: [error] invalid PID number “” in “/run/nginx.pid”</p>
</li>
</ol>
<p>经过查找，找到<a href="http://www.cnblogs.com/yuqianwen/p/4285686.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuqianwen/p/4285686.html</a><br>需要先执行<br>nginx -c /etc/nginx/nginx.conf</p>
<p>nginx.conf文件的路径可以从nginx -t的返回中找到。</p>
<p>nginx -s reload</p>
<ol start="5">
<li><p>Nginx负载均衡的几种模式：轮询，权重轮询，IP_Hash（可以解决Session失效重新登录问题；配合upstream），Fair，Url_hash    </p>
</li>
<li><p>(ajax:post) 访问405： 因为用rewrite 重写了 host/mtouch/project.html  到/var/www/hosts<br> get请求是没问题的。用ajax 提交post请求报405.<br> 网上有说把，post 转为get 的。但是未采用，担心参数等问题。<br> 最后用proxy 代理，还需要设置头部。</p>
<ul>
<li>proxy_set_header  Host  $host;  作用web服务器上有多个站点时，用该参数header来区分反向代理哪个域名。比如下边的代码举例。</li>
<li>proxy_set_header X-Forwarded-For  $remote_addr; 作用是后端服务器上的程序获取访客真实IP，从该header头获取。部分程序需要该功能。</li>
</ul>
</li>
<li>X-Forwarded-For： 记录访问ip 来源/路径   </li>
<li><p>rewrite 和proxy 的区别<br> rewrite        <regex>        <replacement>        <flag>;<br> IF判断和内置全局环境变量</flag></replacement></regex></p>
</li>
<li><p>在nginx中配置proxy_pass代理转发时<br>如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。</p>
</li>
</ol>
<p>假设下面四种情况分别用 <a href="http://192.168.1.1/proxy/test.html" target="_blank" rel="noopener">http://192.168.1.1/proxy/test.html</a> 进行访问。<br>第一种：<br>location /proxy/ {<br>    proxy_pass <a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/test.html" target="_blank" rel="noopener">http://127.0.0.1/test.html</a></p>
<p>第二种（相对于第一种，最后少一个 / ）<br>location /proxy/ {<br>    proxy_pass <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/proxy/test.html" target="_blank" rel="noopener">http://127.0.0.1/proxy/test.html</a></p>
<p>第三种：<br>location /proxy/ {<br>    proxy_pass <a href="http://127.0.0.1/aaa/" target="_blank" rel="noopener">http://127.0.0.1/aaa/</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/aaa/test.html" target="_blank" rel="noopener">http://127.0.0.1/aaa/test.html</a></p>
<p>第四种（相对于第三种，最后少一个 / ）<br>location /proxy/ {<br>    proxy_pass <a href="http://127.0.0.1/aaa" target="_blank" rel="noopener">http://127.0.0.1/aaa</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/aaatest.html" target="_blank" rel="noopener">http://127.0.0.1/aaatest.html</a></p>
<ol start="6">
<li>alias。 阅读打卡，vue 单页应用 两个项目，使用同一域名。<br> 开始直接代码到 8088, js,css 文件的content-type错误，导致页面空白。<br> 添加/readingpunch_admin   alias  就好了。<br>readingpunch.config<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  readingpunch.dangdang.com;</span><br><span class="line"></span><br><span class="line">    root /var/www/html/readingPunch;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location /readingpunch_admin&#123;  ## succ:  http://readingpunch.dangdang.com/readingpunch_admin </span><br><span class="line">        alias  /var/www/html/readingPunch_admin/readingpunch_admin/;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    location /activityData&#123; ## succ: http://readingpunch.dangdang.com/activityData</span><br><span class="line">        proxy_pass http://localhost:8088/activityData;  ## 不加/readingpunch_admin  alias   js,css 文件路径出错404，而且content-type不对</span><br><span class="line">    &#125;</span><br><span class="line">	location /experienceData&#123; ## succ: http://readingpunch.dangdang.com/experienceData</span><br><span class="line">        proxy_pass http://localhost:8088;   ## 不加/readingpunch_admin  alias   js,css 文件路径出错404，而且content-type不对</span><br><span class="line">    &#125;  </span><br><span class="line">	</span><br><span class="line">    location /activityStatic&#123; ## 路径问题：http://readingpunch.dangdang.com/activityStatic?a=2342  =》http://readingpunch.dangdang.com/activityStatic/?a=2342</span><br><span class="line">        alias  /var/www/html/readingPunch_admin/readingpunch_admin/;</span><br><span class="line">    &#125;</span><br><span class="line">    location /participantStatic&#123;  ## ## 路径问题：和上面一样</span><br><span class="line">        alias  /var/www/html/readingPunch_admin/readingpunch_admin;</span><br><span class="line">    &#125;</span><br><span class="line">    ## 正则有问题</span><br><span class="line">    location ^/(activityData|activityStatic|experienceData|participantStatic)&#123;</span><br><span class="line">        # proxy_pass http://localhost:8088;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /readingpunch/?$query_string;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>reading_punch_admin.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8088;</span><br><span class="line">    server_name  readingpunch.dangdang.com;</span><br><span class="line"></span><br><span class="line">    root /var/www/html/readingPunch_admin;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /readingpunch_admin/?$query_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ .*\.php?$ &#123;</span><br><span class="line">        include     fastcgi.conf;</span><br><span class="line">        # access_log  /var/log/httpd/access_log ;</span><br><span class="line">        fastcgi_max_temp_file_size 0;</span><br><span class="line">        fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_connect_timeout 3200;</span><br><span class="line">        fastcgi_send_timeout 3200;</span><br><span class="line">        fastcgi_read_timeout 3200;</span><br><span class="line">        gzip on;</span><br><span class="line"></span><br><span class="line">        # fastcgi_param RUNTIME_ENVIRONMENT &apos;develop&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>testreadingpunch.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  testreadingpunch.dangdang.com;</span><br><span class="line"></span><br><span class="line">    root /var/www/html/readingpunch_test;</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    rewrite /activityData /readingpunch_admin  break;  ## succ: </span><br><span class="line">    rewrite /activityStatic /readingpunch_admin break; ## error: 跳到readingpunch_admin，然后路由到了 activityData； 并不是当前路由</span><br><span class="line">    rewrite /participantStatic /readingpunch_admin/participantStatic break;  ## 错误： 404</span><br><span class="line"></span><br><span class="line">	### Uncaught SyntaxError: Unexpected token &apos;&lt;&apos;；</span><br><span class="line">	### Resource interpreted as Stylesheet but transferred with MIME type text/html: </span><br><span class="line">	location /experienceData &#123; </span><br><span class="line">        rewrite /experienceData  break;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    location /experienceData &#123;  ## 路径问题：http://readingpunch.dangdang.com/experienceData?a=2342  =》http://readingpunch.dangdang.com/experienceData/?a=2342</span><br><span class="line">        alias /var/www/html/readingpunch_test/readingpunch_admin;</span><br><span class="line">    &#125;</span><br><span class="line">	location /experienceData &#123;  ## 错误： 下面两个都是404</span><br><span class="line">        # rewrite /readingpunch_admin/ break;</span><br><span class="line">		rewrite /readingpunch_admin break;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	######  前台页面配置  #######</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	location / &#123;  ## succ：</span><br><span class="line">        try_files $uri $uri/ /readingpunch/?$query_string;</span><br><span class="line">        root /var/www/html/readingpunch_test;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	## error： js，css文件解析出错：（下面的配置应该写到 location  /上面，但是为了好看/区分配置  写到了下面）</span><br><span class="line">	### Uncaught SyntaxError: Unexpected token &apos;&lt;&apos;；</span><br><span class="line">	### Resource interpreted as Stylesheet but transferred with MIME type text/html: </span><br><span class="line">	location /activityList &#123; </span><br><span class="line">        rewrite /readingpunch  break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 英语单词</title>
    <url>/ins/ens/characters-2020/</url>
    <content><![CDATA[<a id="more"></a> 
<h2 id="202001"><a href="#202001" class="headerlink" title="202001"></a>202001</h2><p>阅读打卡：<br>1) 老外常用“punch in and out”来表示“上下班打卡”。<br>Don’t forget to punch in and out. (上下班都要记得打卡。)<br>其实这和在酒店入住登记和结账时用的“check in”以及“check out”有异曲同工之理。<br>2) 同时，“punch in”还能表示“用拳击(某人鼻、眼、脸或腹等部位)”。<br>3) 此外，我们还可以用“clock in”和“clock out”来表示上下班的打卡。</p>
<h2 id="2019-6"><a href="#2019-6" class="headerlink" title="2019.6"></a>2019.6</h2><p>scintilla: 火花<br>    a tiny trace or spark of a specified quality or feeling.</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>ens</category>
      </categories>
      <tags>
        <tag>ens</tag>
      </tags>
  </entry>
  <entry>
    <title>流程图软件选择</title>
    <url>/sum/others/%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.26 星期日 23：11</p>

<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p># <a href="https://ld.sogou.com/article?aid=2137797" target="_blank" rel="noopener">几款免费流程图制作软件</a><br>一、免费流程图软件<br>以下免费软件可以用来绘制流程图。<br>介绍顺序是按照体积从小到大：EVE、Diagram Designer、Dia、EDraw Mind Map、OOo Draw。<br>EVE v3.56｜73kb｜超小的神奇矢量绘图程序        </p>
<p>直接引用Zenzen的介绍吧：一个小巧免费的流程图绘制工具，Diagram Designer。速度飞快，无需安装。</p>
<p>Dia（主页）是基于GTK的图形（diagram）绘制程序，适用于Linux, Unix和Windows，以GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，        </p>
<p>推荐！EDraw Mind Map（官网English｜中文化主页）作为国产免费软件，终结了流程图软件“好用则价高，免费则难用”的局面。<br>EDraw Mind Map体积小巧、功能丰富、作为免费软件，完全可以满足普通用户绘制流程图的需求。        </p>
<p>如同MS Office的Word/Powerpoint中有画图功能一样，OpenOffice.org也具有画图功能        </p>
<p># <a href="https://www.zhihu.com/question/19799559" target="_blank" rel="noopener">哪个免费的流程图制作软件最好用？</a><br>个人最常用axure，画面元素多对效果呈现要求高的人推荐使用    </p>
<p>微软的Visio制作工艺流程很方便啊，<br>从前使用Visio，但是Visio画出来的图真心很丑，而且版本更新之后也没什么提升，还经常容易卡死，图就白画了</p>
<p>其实我觉得mindManager最好用，不过要收费</p>
<p>如果能翻墙 Flowchart Maker &amp; Online Diagram Software 是一个非常好的选择，全免费，同时可以把文件即时同步到谷歌云盘，超级方便。</p>
<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>都有模版。有的是网页在线的。<br>文档什么的不是非常重要，先找一个练练手。专业要求不是很高<br>x-mind，mind manager做思维导图，processon/迅捷 也有读书笔记的模版，支持图片和大纲。<br>axure，office word/excl/ppt/visio 也都可以制作。还有上面提到的一些小工具。    </p>
<p>迅捷和process on差不多都是在线网页；亿图需下载软件，看起来好像更专业。visio是micro旧有的。<br>上面三个都是中文，有付费/会员 高级使用权限。<br>导出（不同格式文件），分享/协作 等都是可以实现的。      </p>
<p>迅捷中发现了泳道（最近同事有用到），免费（需注册），在线，读书笔记等。先上上手<br>$PS: 同事好像用的是“泳道” 在线编辑工具。解锁更多图形也需要邀请好友     </p>
<h2 id="ED-Edraw"><a href="#ED-Edraw" class="headerlink" title="ED Edraw"></a>ED Edraw</h2><p><a href="https://www.edrawsoft.com/cn/" target="_blank" rel="noopener">https://www.edrawsoft.com/cn/</a><br>220种绘图类型，设计更轻松<br>创建流程图，信息图，组织结构图，科学教育插画，网络图，思维导图以及更多。 免费例子下载。        </p>
<p>打造强大的综合图形图表设计软件！<br>亿图图示专家是一款综合图形图表制作软件，<br>它包含丰富的实例和模版，帮助您轻松创建流程图、网络拓扑图、组织结构图、商业图表、工程图，思维导图、软件设计图和平面布局图等。<br>亿图采用更智能和人性化的绘制方式，包括丰富的图形模板库和特色实例库，大程度帮助设计者降低工作量，更快捷阐述设计思想，提升创作灵感。</p>
<h2 id="迅捷"><a href="#迅捷" class="headerlink" title="迅捷"></a>迅捷</h2><p>迅捷画图：<a href="https://www.liuchengtu.com/" target="_blank" rel="noopener">https://www.liuchengtu.com/</a><br>一款小白也会用的在线流程图/思维导图    </p>
<h2 id="ProcessON"><a href="#ProcessON" class="headerlink" title="ProcessON"></a>ProcessON</h2><p>ProcessON:<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a><br>免费在线作图，实时协作<br>ProcessOn 支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等</p>
<p>1) ProcessOn是一个在线作图工具的聚合平台，<br>它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，<br>您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作<br>2) 团队协作、头脑风暴<br>3) 海量图库，知识分享</p>
<p>$PS: 有详细文档<br>$PS: 免费只支持9个文件，需要邀请好友，集赞等增加     </p>
<h2 id="visio"><a href="#visio" class="headerlink" title="visio"></a>visio</h2><p><a href="https://support.office.com/zh-cn/visio" target="_blank" rel="noopener">https://support.office.com/zh-cn/visio</a><br>创建数据可视化工具图表：<a href="https://support.office.com/zh-cn/article/创建数据可视化工具图表-17211b46-d144-4ca2-9ea7-b0f48f0ae0a6" target="_blank" rel="noopener">https://support.office.com/zh-cn/article/创建数据可视化工具图表-17211b46-d144-4ca2-9ea7-b0f48f0ae0a6</a></p>
<p style="text-align:right">23：38</p>]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Layui使用记录</title>
    <url>/sum/jsplus/layui%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.23 星期四 14：45</p>

<p>layui文档：<a href="https://www.layui.com/doc/element/layout.html" target="_blank" rel="noopener">https://www.layui.com/doc/element/layout.html</a>     </p>
<!-- 当当号后台使用 -->
<p>当当号后台审核   </p>
<h2 id="入手评测"><a href="#入手评测" class="headerlink" title="入手评测"></a>入手评测</h2><p>1) <strong>返璞归真</strong>，自己写的模块，可以按需引入。也可以全部引入。<br>2) UI样式不必修改，因为是给后台使用的。原有ui基本可以使用。<br>3) 动态（按需）引入，需要在<code>layui.use()</code>的回调中写js；有些模块涉及到样式，虽然模块在js中没有使用，但是需要声明模块引入，比如表单，上下拉等。<br>4) layui的模块无法全局引用，需要通过window传递；导致debug困难，所有js都在layui的回调中，控制台取不到debug对象。<br>5) 同理，layui外部的代码和layui里面的代码 通信（互相调用）费事。比如，样式在初始化渲染后，会把原先的dom隐藏掉，建立新的，如果通过js动态修改数据需要修改layui渲染的新dom，有时还需要进行re-redener或者reload.    </p>
<h3 id="网友讨论"><a href="#网友讨论" class="headerlink" title="网友讨论"></a>网友讨论</h3><p>包括作者（贤心），从某逼乎<br>layui另辟蹊径，专门给后端人员提供了一套简单好用的前端框架/ui/模板；<br>后端人员取到数据，直接可以渲染，一个表格或者表单提交数据。   </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于完全没有基础的后端人员，又没有特殊的需求，样式方便也没有太多修改。layui来说可以说很合适。<br>听说另一个extjs，界面样式老套（没有接触过，看样子，确实和现在的风格不符）   </p>
<p>如果有前端，有特殊需求的话，还是交给前端去判断吧。前端专用框架bootstarp，jquery ui，vue,element-ui等，可以方便引入第三方插件，前端写起来也比较顺手，调试修改都比较快。<br>如果时间比较紧，又没有特殊需求，layui是完全可以接受的。毕竟’开箱即用‘。可以节省大量时间      </p>
<h2 id="layer"><a href="#layer" class="headerlink" title="layer"></a>layer</h2><ol start="0">
<li>该组件比较常用，可以单独使用js，全局可以直接使用     </li>
<li>不同类型弹窗，都有api直接方便操作，比如:<code>layer.msg();layer.alert();layer.load(icon, options)</code></li>
<li>层级影响，如果不放到body外面位置会比较怪。可以取消遮罩层    <blockquote>
<p>这里content是一个DOM，注意：最好该元素要存放在body最外层，否则可能被其它的相对元素所影响</p>
</blockquote>
</li>
<li>content可以是 $(‘#id’), 该html中的内容页可以通过layui渲染。弹窗显示内容未layui渲染之后的<br>~~ date弹窗组件闪现问题也没那么明显~~   </li>
<li>layer loading是全页面遮罩的，不能设置某个div元素。<br>需要借助插件 loading     </li>
</ol>
<p style="text-align:right">15:58</p><br><p style="text-align:right">2019.8.10 星期六 14：41 </p>

<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><ol>
<li>如果date是在一个layer中，需要设置触发条件为trigger:click。 否则 date组件不稳定  </li>
</ol>
<h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><ol>
<li>获取表单组件值的方式，在新版本才生效<blockquote>
<p>其中「取值」功能为 layui 2.5.5 开始新增</p>
</blockquote>
</li>
</ol>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><ol>
<li>初始化，会把原先的表格隐藏掉。新建一个，导致js中动态添加进body的内容并不会显示在渲染后的表格中   </li>
<li>默认排序方式，是根据td中html 排序的。<br>也就是说td中的html,或者属性等都会内容会影响排序结果<br>而且排序是默认的字符串排序方式，即： 1，11，14，2，3，4，42，5<br>1）单独把排序数据放在一个display：none的标签中；2）重新渲染表格</li>
<li>如果自定义排序（不使用服务端排序） 打开表头默认给的 排序小箭头，会直接按照 小箭头 采用layui默认排序，而不是自定义<br>方式：1）只能不设置小箭头的排序方式，只让它显示。然后通过js 控制className 为正确的样式<br> 虽然会报错：没有排序的field，不用搭理<br> 2） 不使用layui的小箭头，自己给表头上插入 小箭头。    <pre><code>不合适，那干脆自己写table样式了   
</code></pre> 3） 去修改源码，或者 做纠正     </li>
<li>导出xls数据，为当前表格展示的内容。即使是获取的所有数据（然后用自带分页展示），也是展示当前页<br>可以用table.exportFile() 直接导出数据。<br>$_Next: 但是，文件名  怎么命名啊？？ </li>
</ol>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>loading        </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>jslib</tag>
      </tags>
  </entry>
  <entry>
    <title>文档在线预览</title>
    <url>/sum/js/%E6%96%87%E6%A1%A3%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88/</url>
    <content><![CDATA[<p># <a href="https://blog.csdn.net/csdn_cjgu/article/details/69389474" target="_blank" rel="noopener">[Office Online 在线预览]</a><br>2017年04月06日 14:41:39 csdn_cjgu 阅读数：8359<br>首先，office的在线预览无疑问是在不用下载的前提下通过浏览器直接进行浏览，所以针对浏览器的版本不同系统是有要求的，具体的浏览器支持情况可以查看官方提供的文档：点我查看</p>
<p>利用office online 平台进行office 文档的在线查看，主旨在于获取文档的具体地址，通过Office 平台提供的链接地址指向需要预览的文档地址即可，例：<br><a href="http://view.officeapps.live.com/op/view.aspx?src=http%3a%2f%2fvideo.ch9.ms%2fbuild%2f2011%2fslides%2fTOOL-532T_Sutter.pptx" target="_blank" rel="noopener">http://view.officeapps.live.com/op/view.aspx?src=http%3a%2f%2fvideo.ch9.ms%2fbuild%2f2011%2fslides%2fTOOL-532T_Sutter.pptx</a><br>这个链接分为了两部分，一部分是 <a href="http://view.officeapps.live.com/op/view.aspx?src=，后面那个是具体的文档地址，用URLEncode进行处理的链接地址" target="_blank" rel="noopener">http://view.officeapps.live.com/op/view.aspx?src=，后面那个是具体的文档地址，用URLEncode进行处理的链接地址</a></p>
<p>通过拼接的地址即可实现office 的在线预览<br>需要注意的是：office 在线预览限制</p>
<ol>
<li>文档访问地址不能直接使用 ip，需要通过域名访问，并且端口必须是 80 端口</li>
<li>文档的格式（必须为以下格式之一）：<br>Word：docx、docm、dotm、dotx<br>Excel：xlsx、xlsb、xls、xlsm<br>PowerPoint：pptx、ppsx、ppt、pps、pptm、potm、ppam、potx、ppsm</li>
<li>文档的大小：Word 和 PowerPoint 文档必须小于 10 兆字节;Excel 必须小于五兆字节（通过office web app 部署的本地服务器可以设置文档大小）</li>
</ol>
<p># <a href="https://www.zhihu.com/question/24530006" target="_blank" rel="noopener">如何利用Office Online实现文档在线预览？</a><br>利用其它成熟公司开发的在线预览，包括baidu，华为云等。大多需要付费，但是功能全<br>自己部署  Office Web Apps Server ，有要求，软件要求和硬件要求<br>Office Web Apps Server<br>Collabora online    </p>
<p>可以用百度文库的技术啊，开放出来了：<a href="https://cloud.baidu.com/product/doc.html" target="_blank" rel="noopener">https://cloud.baidu.com/product/doc.html</a><br>可以使用成熟的I Doc View在线文档预览：<a href="http://www.idocv.com" target="_blank" rel="noopener">http://www.idocv.com</a><br>可以用 易度云的文档API：<a href="http://viewer.everydo.com" target="_blank" rel="noopener">http://viewer.everydo.com</a><br>可以看看这个 ekoz/kbase-doc<br>可以用插件pageoffice试试。<br>Office的配置很复杂而且Windows Server 很贵，可以试试这个产品，应该是价廉物美啦：<a href="https://ibisheng.cn" target="_blank" rel="noopener">https://ibisheng.cn</a><br>用永中的吧，除了产品，品牌和服务更有保证    </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Node库</title>
    <url>/sum/ser/node%E5%BA%93/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.20 星期一 </p>


<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>http,request,axios等<br>当时只是做一个图片下载和上传（cdn），尝试找php中curl发现并不需要。只是网络请求就可以了。<br>上传图片的时候，只是因为格式不对，和接口定义的不一致，需要上传表格类型数据    </p>
<p>$NOTE: 在用pipe传递流的时候，需要注意监听error,<strong>而且要在pipe之前</strong>。否则error没有handle，就会出错，导致这个进程结束。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request(imgUrl,&#123;<span class="attr">timeout</span>:<span class="number">2000</span>&#125;)</span><br><span class="line">.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">// $PS:  需要写在pipe前面监听error</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request图片失败err:'</span>,err.code)</span><br><span class="line">    <span class="keyword">return</span> reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">.pipe(fs.createWriteStream(<span class="string">'image-temp.jpg'</span>))</span><br><span class="line">.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="request上传表单"><a href="#request上传表单" class="headerlink" title="request上传表单"></a>request上传表单</h3><p>request：<a href="https://github.com/request/request#forms" target="_blank" rel="noopener">https://github.com/request/request#forms</a><br>For multipart/form-data we use the form-data library by @felixge. For the most cases, you can pass your upload form data via the formData option.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.post(<span class="string">'http://service.com/upload'</span>, &#123;<span class="attr">form</span>:&#123;<span class="attr">key</span>:<span class="string">'value'</span>&#125;&#125;)</span><br><span class="line">request.post(<span class="string">'http://service.com/upload'</span>).form(&#123;<span class="attr">key</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line"><span class="comment">// ## form-data </span></span><br><span class="line"><span class="keyword">const</span> form = r.form();</span><br><span class="line">form.append(<span class="string">'my_field'</span>, <span class="string">'my_value'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = &#123;</span><br><span class="line">  my_field: <span class="string">'my_value'</span>,</span><br><span class="line">  my_buffer: Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]),</span><br><span class="line">  my_file: fs.createReadStream(__dirname + <span class="string">'/unicycle.jpg'</span>),</span><br><span class="line">  attachments: [</span><br><span class="line">    fs.createReadStream(__dirname + <span class="string">'/attachment1.jpg'</span>),</span><br><span class="line">    fs.createReadStream(__dirname + <span class="string">'/attachment2.jpg'</span>)</span><br><span class="line">  ],</span><br><span class="line">  custom_file: &#123;</span><br><span class="line">    value:  fs.createReadStream(<span class="string">'/dev/urandom'</span>),</span><br><span class="line">    options: &#123;</span><br><span class="line">      filename: <span class="string">'topsecret.jpg'</span>,</span><br><span class="line">      contentType: <span class="string">'image/jpeg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">request.post(&#123;<span class="attr">url</span>:<span class="string">'http://service.com/upload'</span>, <span class="attr">formData</span>: formData&#125;, <span class="function"><span class="keyword">function</span> <span class="title">optionalCallback</span>(<span class="params">err, httpResponse, body</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'upload failed:'</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Upload successful!  Server responded with:'</span>, body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/5744990/how-to-upload-a-file-from-node-js" target="_blank" rel="noopener">how to upload a file from node.js</a>  </p>
<p><a href="https://segmentfault.com/q/1010000000095621" target="_blank" rel="noopener">nodejs 如何读取远程的图片并显示出来?</a><br><code>request(&#39;http://abc.com/abc.png&#39;).pipe(fs.createWriteStream(&#39;abc.png&#39;));</code></p>
<p><a href="https://stackoverflow.com/questions/28245729/what-is-the-equivalent-of-curl-upload-file-in-node-request" target="_blank" rel="noopener">What is the equivalent of curl –upload-file in node-request</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.createReadStream(filePath).pipe(request.put(putURL,options,<span class="function"><span class="keyword">function</span>(<span class="params">err, httpsResponse, body</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( err ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<p><a href="https://code.i-harness.com/zh-CN/q/680d47" target="_blank" rel="noopener">node.js javascript使用curl - 在nodejs中相当于curl？</a><br><del>由于看起来像node-curl已经死了，我已经分叉了它，重新命名并修改了它，使之更像curl，并在Windows下编译。node-libcurl</del></p>
<h2 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h2><p>gm功能强大,node-images使用简单；两者都需要安装GraphicsMagick或者ImageMagick；实际通过安装GraphicsMagick成功的<br>$PS: 安装完记得配置环境变量</p>
<p># <a href="https://www.cnblogs.com/vipzhou/p/4798769.html" target="_blank" rel="noopener">nodejs图片裁剪、缩放、水印</a><br>关于nodejs下图片的裁剪、水印，网上的模块很多，主要如下：<br>gm：<a href="https://github.com/aheckmann/gm" target="_blank" rel="noopener">https://github.com/aheckmann/gm</a><br>node-canvas：<a href="https://github.com/Automattic/node-canvas" target="_blank" rel="noopener">https://github.com/Automattic/node-canvas</a><br>node-images：<a href="https://github.com/zhangyuanwei/node-images" target="_blank" rel="noopener">https://github.com/zhangyuanwei/node-images</a><br>Cloudinary：<a href="http://cloudinary.com/documentation/node_image_manipulation" target="_blank" rel="noopener">http://cloudinary.com/documentation/node_image_manipulation</a></p>
<p>这里推荐使用gm模块，首先是安装：<br>先要安装GraphicsMagick或者ImageMagick，因为gm是基于这两种图形处理工具包的。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p># <a href="https://cnodejs.org/topic/51355c05df9e9fcc580e97e4" target="_blank" rel="noopener">node内三种mysql的库，mysql,libmysqlclient,mysql-native，到底哪个效率高些？</a>    </p>
<p>shinohane 1楼•6 年前<br>个人还是认为mysql会好于剩下两个……虽然效率低～但由于是纯js实现，把服务器移到Windows上的时候可以不那么复杂（偶尔会有这种需求……）      </p>
<p>zhiyu 5楼•6 年前<br>性能可接受的情况下，mysql应该是目前最好的选择，而且支持连接池。     </p>
<p>chappakochappako 8楼•6 年前<br>如果不太考虑性能的话，当然是选 mysql。维护的人多，更新的快，用的人也多  </p>
<p>chappako 3楼•6 年前<br>看下面的一些对比，你应该会有自己的选择。有的时候效率并不是最重要的<br>NPM地址<br>mysql <a href="https://npmjs.org/package/mysql" target="_blank" rel="noopener">https://npmjs.org/package/mysql</a><br>mysql-libmysqlclient <a href="https://npmjs.org/package/mysql-libmysqlclient" target="_blank" rel="noopener">https://npmjs.org/package/mysql-libmysqlclient</a><br>mysql-native <a href="https://npmjs.org/package/mysql-native" target="_blank" rel="noopener">https://npmjs.org/package/mysql-native</a></p>
<p>最后更新时间<br>mysql last updated a month ago<br>mysql-libmysqlclient last updated 25 days ago<br>mysql-native last updated 7 months ago</p>
<p>上个月下载次数<br>mysql  29 323<br>mysql-libmysqlclient 1 026<br>mysql-native 334</p>
<p>项目维护人数<br>mysql  5人<br>mysql-libmysqlclient 1人<br>mysql-native 1人</p>
<p>依赖其的项目<br>mysql  104<br>mysql-libmysqlclient 10<br>mysql-native 0</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>代理工具</title>
    <url>/sum/others/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://zhubangbang.com/charlesproxy" target="_blank" rel="noopener">抓包工具Charles的使用教程</a>   </p>
<p>不需要用同一个wifi，网线也可以，应该是在一个网段<br>手机设置代理后，提示建立连接，同意即可。        </p>
<h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h2><ol>
<li>设置https。需要本机安装证书，启用ssl   </li>
<li>单个文件（比如js）map到本地文件   </li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql学习</title>
    <url>/sum/ser/mysql%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.5 星期日 21：00</p>

<p>## </p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>#### 更新字段值<br>UPDATE book_comment SET title=left(content,10) WHERE product_id=24243060;         </p>
<p>#### 查找有无数据<br><a href="https://blog.csdn.net/linshichen/article/details/52919383" target="_blank" rel="noopener">Mysql判断记录是否存在</a><br>select count(*) from tablename where col = ‘col’;<br>select 1 from tablename where col = ‘col’ limit 1;<br>执行这条sql语句，所影响的行数不是0就是1。<br>特别解释下limit 1，mysql在找到一条记录后就不会往下继续找了。性能提升很多。</p>
<p>#### 查看<br>select * from book_comment limit 10\G       </p>
<h3 id="查字段（名称，类型）"><a href="#查字段（名称，类型）" class="headerlink" title="查字段（名称，类型）"></a>查字段（名称，类型）</h3><p>show columns from site_book_comment;</p>
<p>select column_name,column_comment,data_type from information_schema.columns where table_name=’查询表名称’ and table_schema=’数据库名称’<br>select COLUMN_NAME,DATA_TYPE,COLUMN_COMMENT from information_schema.COLUMNS where table_name = ‘表名’ and table_schema = ‘数据库名称’;</p>
<p>// 2) <a href="https://blog.csdn.net/god_wen/article/details/79271032" target="_blank" rel="noopener">mysql 查看表中字段的数据类型</a><br>// 2_1 查询结果显示<br>desc 表名;<br>show columns from 表名;<br>describe 表名;<br>// 2_2 sql语句显示<br>show create table 表名;<br>// 2_3:还可以通过专门的管理表来查看<br>use information_schema<br>select * from columns where table_name=’表名’;</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><a href="https://www.cnblogs.com/whgk/p/6179612.html" target="_blank" rel="noopener">[MySQL(五) MySQL中的索引详讲]</a><br>三、索引的分类　　<br>注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引<br>　　　　　　　　　　　　MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换<br>　　　　　　　　　　　　MEMORY/HEAP存储引擎：支持HASH和BTREE索引</p>
<p>1、索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、      </p>
<p>1.1、单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。<br>1.1.1、普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。<br>1.1.2、唯一索引：索引列中的值必须是唯一的，但是允许为空值，<br>1.1.3、主键索引：是一种特殊的唯一索引，不允许有空值。</p>
<p>1.2、组合索引<br>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说　</p>
<p>1.3、全文索引<br>全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。</p>
<p>1.4、空间索引<br>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。<br>在创建空间索引时，使用SPATIAL关键字。</p>
<p>要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。具体细节看下面　　　</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>实际用了MySQL-Front，sqlYog，还有基于php的mysql-admin</p>
<p># <a href="https://www.cnblogs.com/william-lee/p/7065061.html" target="_blank" rel="noopener">MySQL客户端工具的选择</a><br># <a href="https://www.zhihu.com/question/20423448" target="_blank" rel="noopener">[大家常用哪个MySQL客户端工具，除了命令行那个mysql之外？]</a>     </p>
<p># <a href="https://blog.csdn.net/lidujun1028/article/details/54616000" target="_blank" rel="noopener">[7款经典的MySQL客户端软件]</a>   </p>
<ol>
<li>EMS MySQL Manager<br>　　强大的mysql管理工具，允许用户通过图形界面创建或编辑数据库对象，并提供通过sql语句管理用户和权限，通过图形界面建立sql语句，自动生成html格式的数据库文档，导入/导出数据，查看/编辑blob字段等功能。     </li>
<li><p>MySQL-Front<br>　　mysql数据库的图形工具，主要特性包括多文档界面，语法突出，拖拽方式的数据库和表格，可编辑/可增加/删除的域，可编辑/可插入/删除的记录，可显示的成员，可执行的SQL 脚本，提供与外程序接口，保存数据到CSV文件等。</p>
</li>
<li><p>Navicat for MySQL<br>　　一套适用于MySQL数据库系统地图形化数据库管理、报告以及监控的工具。新版本具有高性能的、具有商业智能的、强大的备份功能，此外还有许多的改进。含简体中文文件。</p>
</li>
<li>MySqlYog<br>　　MySqlYog软件是纯JAVA编写的软件，可以运行于WINDOWS，LINUX，UNIX系统，基本版本可以实现对数据库的基本管理，可视化创建表，视图，触发器，数据库的热备份，恢复,可远程管理系统等功能。</li>
</ol>
<ol start="5">
<li>MySQL Browser</li>
<li>Workbench</li>
<li>Sequel Pro</li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离</title>
    <url>/sum/jsplus/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB(023)/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.3 星期五 23：45 </p>

<p>前后端分离开发痛点<br>解决问题：文档，mock data/mock server，自动化测试<br>上面三个单拆开来，都不难；关键是怎么和自动测试集合在一起    </p>
<p>还有 契约测试：基于持续集成与自动化测试</p>
<blockquote>
<p>契约测试：当我们定义好了这个API的规范时，这个API就可以称为是前后端之间的契约，这种设计方式称之为契约式测试  </p>
</blockquote>
<!-- [你是如何构建 Web 前端 Mock Server 的？](https://www.zhihu.com/question/35436669) -->
<h2 id="分述"><a href="#分述" class="headerlink" title="分述"></a>分述</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>许多写文档的库，比如：jsDoc、apidoc，swagger，showDoc，<br>YUIDoc、Dox、Docco、JSDuck   </p>
<p>$BLOB:[文档注释生成库调研]</p>
<p>根据一定的规则，写文档。也可以直接从注释中生成。   </p>
<h3 id="mock-data"><a href="#mock-data" class="headerlink" title="mock data"></a>mock data</h3><p>如果只是mock data/mock server 是比较简单的。<br>mock data的库：fakejs, mockjs<br>方式：<br>1) 代码中硬编码(直接写数据)<br>2) 封装拦截器<br>3) 为所有接口统一添加前缀<br>4) 代理。server代理，工具代理<br>webpack-dev-server,nginx<br>Fiddler、charles; chrome 插件($PS: 应该可以实现)   </p>
<p>mock server：json-server，express，mockjs，…<br>有的代价比较大，比如express；直接mock data简单。只是没有网络请求，但是不影响异步，可以封装Promise   </p>
<h3 id="测试-自动测试"><a href="#测试-自动测试" class="headerlink" title="测试/自动测试"></a>测试/自动测试</h3><p>单个接口：get 可以直接在浏览器url请求<br>post等需要借助工具/插件：postman，runapi,36nu<br><!-- http://runapi.showdoc.cc/     --><br><!-- http://www.36nu.com/apiTest --></p>
<p>如果多个接口要测试，需要写测试用例/导入测试数据，可以自动测试<br>正常情况，非正常情况（参数判断，返回判断，边界值，异常）   </p>
<p>需要写脚本测试，可以建表格导入不同的测试数据，也可以测试性能。生成报告？？<br>上述不包括性能测试。有比较强大的可以顺带测试性能的，比如基于java的（$PS: 咱也不熟）  </p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="以前做法"><a href="#以前做法" class="headerlink" title="以前做法"></a>以前做法</h3><p>hybris 开发：json server 试成功也没有用（chrome设置也可以直接请求json文件）<br>直接引入fakejs和fake data ，硬编码。<br>fake相较于mock简单，造假能力也丰富，不同于mock的语法、规则，没有占位符，api（命名）一看就懂   </p>
<p>danghao一期：没有发送请求，硬编码数据，需要的地方用Promise返回数据。（当时已经证明接口是通的）<br>danghao二期: 发送请求，用webpack-dev-server 做了代理（都代理到同一个接口了），请求回来的数据直接硬编码，也没有fake  </p>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>首先没有文档，需要文档，这是最主要的。<br>其次，最好可以对后端的接口做自动测试，通过后再接入，不需要挨个去测后端的接口（即使后端测完，也需要验证；而且他们测的也不全/正确）<br>mock data也少不了     </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="showdoc"><a href="#showdoc" class="headerlink" title="showdoc"></a>showdoc</h3><p><a href="https://www.showdoc.cc/" target="_blank" rel="noopener">https://www.showdoc.cc/</a><br>适合写文档，单纯的文档。可以有多个页面，可以写api文档，字典，说明书、术规范说明文档<br>可以团队管理，自己搭环境    </p>
<p>没有mock data能力，也没有导出数据。测试更没有    </p>
<h3 id="swagger-ui"><a href="#swagger-ui" class="headerlink" title="swagger-ui"></a>swagger-ui</h3><p><a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-ui</a><br>$PS: 有在线编辑器<br><a href="http://swagger.io" target="_blank" rel="noopener">http://swagger.io</a><br>swagger语法写起来比较复杂，虽然功能看起来很强大，yaml语法似乎写起来也省事（$PS: 只用缩进看起来有晃眼）<br>可以对接口进行测试（try it out），接口可以提供访问白名单？？   </p>
<p>和jsdocs 比起来，还是jsdoc对前端友好一些。但是jsdoc貌似只生成文档，在js中写写注释还是不错的。如果写js库的话，可以考虑<br>fakejs/mockjs 只生成mock数据，或拦截请求，没有文档   </p>
<p>postman 只对接口进行测试，可以写requests,可以添加到scenarios 做自动测试，也有ASSERTIONS<br>同样不是文档，也无法mock data   </p>
<h3 id="rap2"><a href="#rap2" class="headerlink" title="rap2"></a>rap2</h3><p><a href="http://rap2.taobao.org/repository" target="_blank" rel="noopener">http://rap2.taobao.org/repository</a><br><a href="https://github.com/thx/RAP/" target="_blank" rel="noopener">https://github.com/thx/RAP/</a><br>文档：twiki  $PS: 好像还是rap1<br>上面是公开的在线地址，也可以自己搭建<br>建仓库，有model概念，团队管理，写文档，mock data/mock server ，还有状态    </p>
<p>关键这个2，页面不鲁棒：不是加载半天不出来，就是提交缓慢<br>$PS: 可能和作者后端不熟有关   </p>
<p>如果要做测试，可以配合postman一起使用      </p>
<h3 id="yapi"><a href="#yapi" class="headerlink" title="yapi"></a>yapi</h3><p><a href="http://yapi.demo.qunar.com/project/" target="_blank" rel="noopener">http://yapi.demo.qunar.com/project/</a><br><a href="https://github.com/YMFE/yapi/" target="_blank" rel="noopener">https://github.com/YMFE/yapi/</a><br>文档：<a href="https://yapi.ymfe.org/documents/index.html" target="_blank" rel="noopener">https://yapi.ymfe.org/documents/index.html</a>        </p>
<p>需要自己搭，公共的没有管理权限；权限管理，可视化接口管理，Mock Server，自动化测试，数据导入，插件机制<br>功能还是比较强大的：<br>接口（接口列表，测试集合），动态，数据管理，设置（项目，环境，请求，token，全局mock），wiki    </p>
<p>mock data： 参数支持（rap2没有试成功）；json-schema；json（mockjs+json5）；拖动排序<br>    还有高级mock（自定义mock数据，rap2的话，还需要自己写点东西），测试校验<br>自动化测试：环境配置（方便测试不同环境，线上/测试/本地）；服务端测试；全局变量<br>数据导入/导出：json，swagger，har，postman； html，插件还支持word<br>二次开发：勾子函数，全局api  </p>
<p>唯一弱于rap2的是版本管理，但是有tag； 感觉tag和版本管理没有关系，但是这个不影响目前使用，因为目前还没有不同版本的需求<br>yapi还有收藏，文档也比较全，有技术团队支持（去哪儿），完全中文开放<br>部署貌似也简单   </p>
<h3 id="rap2-和api共同问题"><a href="#rap2-和api共同问题" class="headerlink" title="rap2 和api共同问题"></a>rap2 和api共同问题</h3><p>和rap2相同的不足是，相同的路径，即使url不同，也会是同一个接口。<br>rap2 可以根据 ${method} 区分get，post,delete等（rest风格）；yapi 有query？？<br>$PS: 上面的方式都没有尝试过，不确定        </p>
<p>提需求了，实现不实现就不知道了<br>rap2: <a href="https://github.com/thx/RAP/issues/1304" target="_blank" rel="noopener">不同url可以返回不同的接口数据</a><br>    $PS: Yalhu提的<br>    <a href="https://github.com/YMFE/yapi/issues/49#issuecomment-488746153" target="_blank" rel="noopener">yapi 下个版本需求收集</a><br>yapi：<a href="https://github.com/YMFE/yapi/issues/867" target="_blank" rel="noopener">接口地址是否允许重复开关</a>  </p>
<p>danghao接口地址都是<code>/index</code> :<code>/index?control=user&amp;action=</code>,<code>/index?control=order&amp;action=,/index?</code><br>在rap2和yapi看来这都是同一个接口，虽然可以根据参数动态返回数据；但这毕竟是当一个接口对待的，用yapi无法实现测试，测线上数据     </p>
<p>需要和后端确认，接口路径是不是都是这一个，还是有不同的路径可以访问<br>如果都是一个路径，需要包装做拦截，如果不做webpack-dev-server代理，需要baseUrl。yapi的自动测试也难以实现了      </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然选yapi了， rap2 页面慢就有点难忍；还有文档，部署，团队方面<br>$PS: yapi（8k）的star比rap（9k）少，rap2（3k）。 出现晚？？    </p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="mock-data-1"><a href="#mock-data-1" class="headerlink" title="mock data"></a>mock data</h3><p><a href="https://github.com/nuysoft/Mock/wiki" target="_blank" rel="noopener">https://github.com/nuysoft/Mock/wiki</a><br><!-- http://mockjs.com/examples.html#Array --><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> baseURL=process.env.NODE_ENV === <span class="string">'development'</span> ? <span class="string">'http://yapi.demo.qunar.com/mock/1304'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data=fakeData <span class="comment">// 1) 代码中硬编码(直接写数据)</span></span><br><span class="line">    fetch(BaseUrl+<span class="string">'/index'</span>)  <span class="comment">// 3) 为所有接口统一添加前缀 </span></span><br><span class="line">    fetch2(<span class="string">'/index'</span>) <span class="comment">// 2) 封装拦截器  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// let redirect = "http://" + ROOT + '/mockjsdata/' + projectId + url;</span></span><br><span class="line">    <span class="keyword">let</span> redirect=<span class="string">`<span class="subst">$&#123;RAP.protocol&#125;</span>://<span class="subst">$&#123;RAP.host&#125;</span>/app/mock/<span class="subst">$&#123;match.repositoryId&#125;</span>/<span class="subst">$&#123;match.method&#125;</span>/<span class="subst">$&#123;match.url&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="jsdoc文档"><a href="#jsdoc文档" class="headerlink" title="jsdoc文档"></a>jsdoc文档</h3><p><a href="http://usejsdoc.org/" target="_blank" rel="noopener">http://usejsdoc.org/</a><br>也可以给类添加文档。<br>$PS: 可以自定义数据结构吗？？ definitions / Mock.Random.extend<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * this is foo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>1 &#123;string&#125; param1 - this is param1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>2 &#123;Object&#125; param2 - this is param2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;&#125;</span> </span>- </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">funciton foo(param1,param2)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="swagger文档"><a href="#swagger文档" class="headerlink" title="swagger文档"></a>swagger文档</h3><p>// swagger 。可以是rest风格。可分隔文件<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">swagger:"2.0"</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="string">version:1.0.0</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Simple</span> <span class="string">API</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">A</span> <span class="string">simple</span> <span class="string">API</span> <span class="string">to</span> <span class="string">learn</span> <span class="string">how</span> <span class="string">to</span> <span class="string">write</span> <span class="string">OpenAPI</span> <span class="string">Specification</span></span><br><span class="line"><span class="attr">schemes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">simple.api</span></span><br><span class="line"><span class="attr">basePath:</span> <span class="string">/openapi101</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/persons:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">Gets</span> <span class="string">some</span> <span class="string">persons</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Returns</span> <span class="string">a</span> <span class="string">list</span> <span class="string">containing</span> <span class="string">all</span> <span class="string">persons.</span> <span class="string">The</span> <span class="string">list</span> <span class="string">supports</span> <span class="string">paging.</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pageSize</span></span><br><span class="line">         <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">         <span class="attr">description:</span> <span class="string">Number</span> <span class="string">of</span> <span class="string">persons</span> <span class="string">returned</span></span><br><span class="line">         <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pageNumber</span></span><br><span class="line">         <span class="attr">in:</span> <span class="string">query</span></span><br><span class="line">         <span class="attr">description:</span> <span class="string">Page</span> <span class="string">number</span></span><br><span class="line">         <span class="attr">type:</span> <span class="string">integer</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">200:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">A</span> <span class="string">list</span> <span class="string">of</span> <span class="string">Person</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/Persons"</span></span><br><span class="line">        <span class="attr">500:</span></span><br><span class="line">          <span class="string">$ref:</span> <span class="string">"#/responses/Standard500ErrorResponse"</span></span><br><span class="line">    <span class="attr">post:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">Creates</span> <span class="string">a</span> <span class="string">person</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Adds</span> <span class="string">a</span> <span class="string">new</span> <span class="string">person</span> <span class="string">to</span> <span class="string">the</span> <span class="string">persons</span> <span class="string">list.</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">person</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">body</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">The</span> <span class="string">person</span> <span class="string">to</span> <span class="string">create.</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/Person"</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">204:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">Persons</span> <span class="string">succesfully</span> <span class="string">created.</span></span><br><span class="line">        <span class="attr">400:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">Persons</span> <span class="string">couldn't</span> <span class="string">have</span> <span class="string">been</span> <span class="string">created.</span></span><br><span class="line">        <span class="attr">500:</span></span><br><span class="line">          <span class="string">$ref:</span> <span class="string">"#/responses/Standard500ErrorResponse"</span></span><br><span class="line">  <span class="string">/persons/&#123;username&#125;:</span></span><br><span class="line">    <span class="attr">get:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">Gets</span> <span class="string">a</span> <span class="string">person</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Returns</span> <span class="string">a</span> <span class="string">single</span> <span class="string">person</span> <span class="string">for</span> <span class="string">its</span> <span class="string">username.</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">username</span></span><br><span class="line">          <span class="attr">in:</span> <span class="string">path</span></span><br><span class="line">          <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">The</span> <span class="string">person's</span> <span class="string">username</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">responses:</span></span><br><span class="line">        <span class="attr">200:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">A</span> <span class="string">Person</span></span><br><span class="line">          <span class="attr">schema:</span></span><br><span class="line">            <span class="string">$ref:</span> <span class="string">"#/definitions/Person"</span></span><br><span class="line">        <span class="attr">404:</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">The</span> <span class="string">Person</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exists.</span></span><br><span class="line">        <span class="attr">500:</span></span><br><span class="line">          <span class="string">$ref:</span> <span class="string">"#/responses/Standard500ErrorResponse"</span></span><br><span class="line"><span class="attr">definitions:</span></span><br><span class="line">  <span class="attr">Person:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">firstName:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">lastName:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">username:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">2019.5.4 星期六 02：13 </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实用</title>
    <url>/sum/jsplus/vue%E5%AE%9E%E7%94%A8/</url>
    <content><![CDATA[<p style="text-align:right">2019.4.14 星期日 17:30</p>


<h1 id="vue实用"><a href="#vue实用" class="headerlink" title="vue实用"></a>vue实用</h1><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>### 1 一般父子组件。<br>1) 通过prop,和$emit  $danghao:ContentNav 切换<br>2) parent/root,children  或者父组件中可以用 $refs调用子组件  $danghao:定时发布<br>如何实时响应？<br>如果修改父组件的值？</p>
<p>### 2 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”<br>1) 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：     </p>
<blockquote>
<p>.sync 修饰符的 v-bind 不能和表达式一起使用    $PS: 同v-model<br>将 v-bind.sync 用在一个字面量的对象上是无法正常工作的  </p>
</blockquote>
<p>2) 比如表单的数据v-model。定义表单自己的数据，然后在声明周期中把父组件的值赋给 表单自己定义的值    $danghao: ContenNav nav组件的active 值；帐号信息 申请描述  </p>
<p>### 根/父组件 值为异步获取/更新<br>1) 如果要直接引用<code>$root.$data.userInfo</code> 或<code>$root.userInfo</code>, 属性的值，需要注意数据类型正确。不能直接给一个空值<code>userInfo: {}</code> 属性也需要赋值 <code>user:{tags:[]}</code>,因为使用了tags的值<br>2) 如果可以确定 子组件 装载时，根组件的异步获取的数据已经成功，可以在子组件的生命周期中重新赋值<br>3) 通过watch 监听数据的变化      </p>
<p>？ 子组件直接使用的 父/根 组件的值 会不会 同步更新视图  </p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>1） 为什么组件data是一个函数？多个/不同实例间 不共用相同的数据<br>2）data：组件数据。<br>computed：根据data或者其他数据 过滤的数据，可以缓存，只要源数据发生变动。<br>也可以有set方法     </p>
<blockquote>
<p>计算属性是基于它们的响应式依赖进行缓存的<br>method: 每次调用都会执行。如果你不希望有缓存，请用方法来替代。<br>watch(侦听属性): 数据变化时执行异步或开销较大的操作时    </p>
</blockquote>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>Vuex:<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a><br>## 一 安装<br>Vuex 依赖 Promise。如果你支持的浏览器并没有实现<br>## 二 vuex是什么   </p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。<br>状态管理模式:state,view,action<br>### 三 开始<br>## 四 核心概念<br>State：单一状态树（可module）。唯一数据源。多实例也可返回函数，相当与vue的data<br>Getter：相当与vue的计算属性，可缓存。可通过属性和方法访问<br>Mutation:可直接修改State，不能使用异步 。可用常量来管理所有事件类型，<br>Action：提交mutation非直接修改状态 ，可以包含异步。 可以多个异步组合<br>Module: 多种便捷方式，可以减少命名空间的书写  </p>
</blockquote>
<p>辅助函数 和 对象展开运算符  ：<code>...mapState，...mapGetters，...mapMutations，...mapActions</code><br>## 五 项目结构<br>根目录下可index 和根级别的action,mutation,module   </p>
<p>## 六 插件     $Skip    </p>
<p>## 七 严格模式<br><code>strict: true</code>.生产时要去掉<br>## 八 表单处理<br>当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手：      在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。      </p>
<p>另一个方法是使用带有 setter 的双向绑定计算属性：    </p>
<p>## 测试   $Skip<br>## 热重载  $Skip   </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>JS模式-7：设计模式</title>
    <url>/pdf/js/js%E6%A8%A1%E5%BC%8F/7_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p style="text-align:right">2019.4.7 星期日 17:57</p>


<p>1 单体<br>2 工厂<br>3 迭代器<br>4 装饰者<br>5 策略<br>6 外观<br>7 代理<br>8 中介者<br>9 观察者        </p>
<h2 id="7-1-单体-Singleton"><a href="#7-1-单体-Singleton" class="headerlink" title="7.1 单体 Singleton"></a>7.1 单体 Singleton</h2><p>对象字面量   </p>
<h3 id="使用new操作符"><a href="#使用new操作符" class="headerlink" title="使用new操作符"></a>使用new操作符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uni=<span class="keyword">new</span> Universe()</span><br><span class="line"><span class="keyword">var</span> uni2=<span class="keyword">new</span> Universe()</span><br><span class="line">uni===uni2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>1) 全局变量存储<br>2) 构造函数的静态属性中缓存该实例<br>3) 将该实例包装在闭包中<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 2 构造函数的静态属性中缓存该实例</span></span><br><span class="line">funciton Universe()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> Universe.instance === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Universe.instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.bang=<span class="string">'Big'</span></span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    Universe.instance=<span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 隐式返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 3 将该实例包装在闭包中</span></span><br><span class="line">funciton Universe()&#123;</span><br><span class="line">    <span class="comment">// 缓存实例</span></span><br><span class="line">    <span class="keyword">var</span> instance=<span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.bang=<span class="string">'Big'</span></span><br><span class="line">    <span class="comment">// 重写构造函数</span></span><br><span class="line">    Universe=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方案3缺点：重写构造函数，会丢失所有初始定义和重新定义添加的属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">funciton Universe()&#123;</span><br><span class="line">    <span class="comment">// 缓存实例</span></span><br><span class="line">    <span class="keyword">var</span> instance=<span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.bang=<span class="string">'Big'</span></span><br><span class="line">    <span class="comment">// 重写构造函数</span></span><br><span class="line">    Universe=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保留原型属性</span></span><br><span class="line">    Universe.prototype=<span class="keyword">this</span></span><br><span class="line">    instance=<span class="keyword">new</span> Universe()</span><br><span class="line">    instance.construtor=Universe</span><br><span class="line"></span><br><span class="line">    instance.bang=<span class="string">'Big'</span></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 3.2 另一种方案：</span></span><br><span class="line"><span class="keyword">var</span> Universe</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance</span><br><span class="line">    Universe=<span class="function"><span class="keyword">function</span> <span class="title">Universe</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance) <span class="keyword">return</span> instance</span><br><span class="line">        instance=<span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>.bang=<span class="string">'big'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h2 id="7-2-工厂"><a href="#7-2-工厂" class="headerlink" title="7.2 工厂"></a>7.2 工厂</h2><p>目的是未来创建对象。通常定义在类或者类的静态方法中实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> corolla=CarMaker.factory(<span class="string">'Compact'</span>)</span><br><span class="line"><span class="keyword">var</span> solstice=CarMaker.factory(<span class="string">'Convertible'</span>)</span><br><span class="line"><span class="keyword">var</span> cherokee=CarMaker.factory(<span class="string">'SUV'</span>)</span><br><span class="line">corolla.drive()</span><br><span class="line">solstice.drive()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarMaker</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">CarMaker.prototype.drive=funciton()&#123;<span class="keyword">return</span> <span class="string">'Vromm, i have '</span>+<span class="keyword">this</span>.doors+<span class="string">' doors'</span>&#125;</span><br><span class="line">CarMaker.factory=funciton(type)&#123;</span><br><span class="line">    <span class="keyword">var</span> constr=type,newcar</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> CarMaker[constr]!==<span class="string">'funciton'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span>&#123;<span class="attr">name</span>:<span class="string">'Error'</span>,<span class="attr">message</span>:constr+<span class="string">'doesn\'t exist'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> CarMaker[constr].prototype.drive!==<span class="string">'function'</span>)&#123;</span><br><span class="line">        CarMaker[constr].prototype=<span class="keyword">new</span> CarMaker()</span><br><span class="line">    &#125;</span><br><span class="line">    newcar=<span class="keyword">new</span> CarMaker[constr]()</span><br><span class="line">    <span class="keyword">return</span> newcar</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义汽车制造商</span></span><br><span class="line">CarMaker.Compact=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.doors=<span class="number">4</span>&#125;</span><br><span class="line">CarMaker.SUV=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.doors=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置对象工厂"><a href="#内置对象工厂" class="headerlink" title="内置对象工厂"></a>内置对象工厂</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">n=<span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>)</span><br><span class="line">s=<span class="built_in">Object</span>(<span class="string">'1'</span>)</span><br><span class="line">b=<span class="built_in">Object</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">o.construtor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">s.construtor === <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-迭代器"><a href="#7-3-迭代器" class="headerlink" title="7.3 迭代器"></a>7.3 迭代器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element</span><br><span class="line"><span class="comment">// while(element=agg.next())</span></span><br><span class="line"><span class="keyword">while</span>(element=agg.hasNext())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> agg=(funciton()&#123;</span><br><span class="line">    <span class="keyword">var</span> index=<span class="number">0</span>,</span><br><span class="line">    data=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    length=data.length</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.hasNext()) reutnr <span class="literal">null</span></span><br><span class="line">            element=data[index]</span><br><span class="line">            index=index+<span class="number">2</span>  <span class="comment">// $PS: 此处可能是+1</span></span><br><span class="line">            <span class="keyword">return</span> element</span><br><span class="line">        &#125;,</span><br><span class="line">        hasNext:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> index&lt;length&#125;,</span><br><span class="line">        rewind:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;index=<span class="number">0</span>&#125;,</span><br><span class="line">        current:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> data[index]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="7-4-装饰者"><a href="#7-4-装饰者" class="headerlink" title="7.4 装饰者"></a>7.4 装饰者</h2><p>在运行时动态添加附加功能到对象中<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sale=<span class="keyword">new</span> Sale(<span class="number">100</span>)</span><br><span class="line">sale=sale.decorate(<span class="string">'fedtax'</span>)<span class="comment">// 增加联邦税</span></span><br><span class="line">sale=sale.decorate(<span class="string">'quebec'</span>) <span class="comment">// 增加省级税</span></span><br><span class="line">sale.getPrice() <span class="comment">// $112.88</span></span><br><span class="line"><span class="comment">// 另一情况，没有省级税，用加元</span></span><br><span class="line"><span class="keyword">var</span> sale=<span class="keyword">new</span> Sale(<span class="number">100</span>)</span><br><span class="line">sale.decorate(<span class="string">'fedtax'</span>)</span><br><span class="line">sale.decorate(<span class="string">'cdn'</span>)</span><br><span class="line">sale.getPrice() <span class="comment">// CDN$105.00</span></span><br></pre></td></tr></table></figure></p>
<p>### 实现1:每个装饰者成为一个对象，并且包含了应该被重载的方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sale</span>(<span class="params">price</span>)</span>&#123;<span class="keyword">this</span>.price=price||<span class="number">100</span>&#125;</span><br><span class="line">Sale.prototype.getPrice=<span class="function"><span class="keyword">function</span>(<span class="params">return this.price</span>)</span></span><br><span class="line"><span class="function"><span class="title">Sale</span>.<span class="title">decorators</span>=</span>&#123;&#125;</span><br><span class="line">Sale.decorators.fedtax=&#123;</span><br><span class="line">    getPrice:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> price=<span class="keyword">this</span>.uber.getPrice()</span><br><span class="line">        price += price * <span class="number">5</span> / <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Sale.decorators.money=&#123;</span><br><span class="line">    getPrice:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'$'</span>+<span class="keyword">this</span>.uber.getPrice().toFixed(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 神奇的decorate方法</span></span><br><span class="line">Sale.prototype.decorate=<span class="function"><span class="keyword">function</span>(<span class="params">decorator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    overrides=<span class="keyword">this</span>.constructor.decorators[decorator]</span><br><span class="line">    ,i,newObj</span><br><span class="line">    F.prototype=<span class="keyword">this</span></span><br><span class="line">    newObj=<span class="keyword">new</span> F()</span><br><span class="line">    newObj.uber=F.prototype</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> overrides)&#123;</span><br><span class="line">        <span class="keyword">if</span>(overrides.hasOwnProperty(i))&#123;</span><br><span class="line">            newObj[i]=overrides[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用列表实现"><a href="#使用列表实现" class="headerlink" title="使用列表实现"></a>使用列表实现</h3><p>利用js动态语言特性，不需要继承。不是每个装饰方法调用链中前面的方法，而是将结果做为参数传递到下一个方法<br>$PS: js面向对象中，好像是用了第一种方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sale</span>(<span class="params">price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price=(price&gt;<span class="number">0</span>) || <span class="number">100</span>  <span class="comment">// $PS: price &gt;0 返回的是一个boolean吧，怎么传递给price赋值</span></span><br><span class="line">    <span class="keyword">this</span>.decorators_list=[]</span><br><span class="line">&#125;</span><br><span class="line">Sale.decorators=&#123;&#125;</span><br><span class="line">Sale.decorators.fedtax=&#123;</span><br><span class="line">    getPrice:<span class="function"><span class="keyword">function</span>(<span class="params">price</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price += price * <span class="number">5</span> / <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Sale.prototype.decorate=<span class="function"><span class="keyword">function</span>(<span class="params">decorator</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorators_list.push(decorator)</span><br><span class="line">&#125;</span><br><span class="line">Sale.prototype.getPrice=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price=<span class="keyword">this</span>.price,i,max=<span class="keyword">this</span>.decorators_list.length,name</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i+=<span class="number">1</span>)&#123;</span><br><span class="line">        name=<span class="keyword">this</span>.decorators_list[i]</span><br><span class="line">        price=Sale.decorators[name].getPrice(price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-5-策略"><a href="#7-5-策略" class="headerlink" title="7.5 策略"></a>7.5 策略</h2><p>支持您在运行时选择算法。<br>一个例子是表单验证。创建具有validate方法的对象validator。不论表单的具体类型，都调用且返回相同结果：。。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=&#123;<span class="attr">first_name</span>:<span class="string">'Super'</span>,<span class="attr">last_name</span>:<span class="string">'Man'</span>,<span class="attr">age</span>:<span class="string">'unknow'</span>,<span class="attr">useranme</span>:<span class="string">'o_0'</span>&#125;</span><br><span class="line">validator.config=&#123;</span><br><span class="line">    first_name:<span class="string">'isNonEmpty'</span>,</span><br><span class="line">    age:<span class="string">'isNumber'</span>,</span><br><span class="line">    useranme:<span class="string">'isAplhaNum'</span></span><br><span class="line">&#125;</span><br><span class="line">validator.validate(data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(validator.hasErrors())&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(validator.message.join(<span class="string">'\n'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$PS: element UI：rules, props(vue,react)的类型检查类似都是这个格式<code>rule:[{name:{required:true}},],pros:{name:{type:String,required:true,default:&#39;&#39;},age:{}}</code><br>### 实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">validator.type.isNonEmpty=&#123;</span><br><span class="line">    validate:funciton(value)&#123;</span><br><span class="line">        <span class="keyword">return</span> value!==<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    instructions:<span class="string">'the value cannot be empty'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> validator=&#123;</span><br><span class="line">    types:&#123;&#125;, <span class="comment">// 所有可用的检查</span></span><br><span class="line">    messages:[], <span class="comment">// </span></span><br><span class="line">    config:&#123;&#125;, <span class="comment">// 当前验证配置，名称：验证类型</span></span><br><span class="line">    validate:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i,msg,type,checker,result_ok</span><br><span class="line">        <span class="keyword">this</span>.messages=[]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.hasOwnProperty(i))&#123;</span><br><span class="line">                type=<span class="keyword">this</span>.config[i]</span><br><span class="line">                checker=<span class="keyword">this</span>.types[type]</span><br><span class="line">                <span class="keyword">if</span>(!type)&#123;</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">// 不需要验证</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!checker)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> &#123;<span class="attr">name</span>:<span class="string">'ValidationError'</span>,<span class="attr">message</span>:<span class="string">'No handler to validate type '</span>+type&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result_ok=checker.validate(data[i])</span><br><span class="line">                <span class="keyword">if</span>(!result_ok)&#123;</span><br><span class="line">                    msg=<span class="string">'Invalid value for '</span>+i+checker.instructions  </span><br><span class="line">                    <span class="keyword">this</span>.message.push(msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hasErrors</span><br><span class="line">    &#125;,</span><br><span class="line">    hasErrors:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message.length!==<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-6-外观"><a href="#7-6-外观" class="headerlink" title="7.6 外观"></a>7.6 外观</h2><p>有时候，两个或更多方法可能普遍的被一起调用。这，创建另一个方法以包装重复的方法嗲用非常有意义<br>对重新设计和重构工作也有帮助。当需要替换一个具有不同实现对象时，不得不重新修改，而且新代码。通过外观模式，首先考虑新对象的api，然后继续在原有对象的前面创建一个外观。这样，。。。<br>$PS: 包装几个方法；或者，在原有的基础上再包一层，相当于穿衣服，所以叫外观。<br>$PS: Dangd-ReviewCode, 新的api可以在老的api，外面包一层<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myevent=&#123;</span><br><span class="line">    stop:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> e.preventDefault === <span class="string">'function'</span>) e.preventDefault()</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> e.stopPropagation === <span class="string">'function'</span>) e.stopPropagation()</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> e.returnValue === <span class="string">'boolean'</span>) e.returnValue=<span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> e.cancelBubble===<span class="string">'boolean'</span>) e.cancelBubble=<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-7-代理"><a href="#7-7-代理" class="headerlink" title="7.7 代理"></a>7.7 代理</h2><p>一个对象充当另一个对象的接口。<br>与外观合并多个方法调用不同。代理介于对象的客户端和对象本身，且对该对象的访问进行保护    </p>
<p>举例：客户端发起初始化请求，然后代理以一切正常做为响应。实际没有传递消息，直到客户端明显需要本体对象完成一些工作时，才将消息一并发出。   </p>
<p>1) 短时间内请求了多个，代理后可以一并发出。50ms的延迟对用户是不易察觉的。<br>2) 代理可以将结果缓存到新短的cache属性中<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码：略</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-8-中介者"><a href="#7-8-中介者" class="headerlink" title="7.8 中介者"></a>7.8 中介者</h2><p>多个对象互相通信，一定程度上不<br>中介者模式缓解了该问题并促进形成松耦合，且有助于提高可维护性。<br>独立对象并不直接通信，而是通过mediator对象。   </p>
<p>实例：玩家1，玩家2，计分板，中介者  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.points=<span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;</span><br><span class="line">Player.prototype.play=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.points+=<span class="number">1</span></span><br><span class="line">    mediator.played()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> scoreboard=&#123;</span><br><span class="line">    element:<span class="built_in">document</span>.getElementById(<span class="string">'result'</span>),</span><br><span class="line">    update:<span class="function"><span class="keyword">function</span>(<span class="params">score</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i,msg=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> score)&#123;</span><br><span class="line">            <span class="keyword">if</span>(score.hasOwnProperty(i))&#123;</span><br><span class="line">                msg+=<span class="string">'&lt;strong&gt;'</span>+i+<span class="string">'&lt;/strong&gt;'</span></span><br><span class="line">                msg+=score[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML=msg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mediator=&#123;</span><br><span class="line">    players:&#123;&#125;,</span><br><span class="line">    setup:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> players=<span class="keyword">this</span>.players</span><br><span class="line">        players.home=<span class="keyword">new</span> Play(<span class="string">'Home'</span>)</span><br><span class="line">        players.gest=<span class="keyword">new</span> Play(<span class="string">'Guest'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    played:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> players=<span class="keyword">this</span>.players,</span><br><span class="line">        score=&#123;</span><br><span class="line">            Home:players.home.points</span><br><span class="line">            Guest:players.guest.points</span><br><span class="line">        &#125;</span><br><span class="line">        scoreboard.update(score)</span><br><span class="line">    &#125;,</span><br><span class="line">    keypress:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        e=e||<span class="built_in">window</span>.event</span><br><span class="line">        <span class="keyword">if</span>(e.which===<span class="number">49</span>)&#123; <span class="comment">// 按键1</span></span><br><span class="line">            mediator.players.home.play()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(e.which===<span class="number">48</span>)&#123; <span class="comment">// 按键0</span></span><br><span class="line">            mediator.players.guest.play()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-9-观察者"><a href="#7-9-观察者" class="headerlink" title="7.9 观察者"></a>7.9 观察者</h2><p>所有浏览器事件<br>主要动机是促进形成松散耦合。并不是一个对象调用另一个对象，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称之为观察者，被观察的对象称为发布者或者主题。    </p>
<h3 id="示例1：杂志订阅"><a href="#示例1：杂志订阅" class="headerlink" title="示例1：杂志订阅"></a>示例1：杂志订阅</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> publisher=&#123;</span><br><span class="line">    subscribers:&#123;</span><br><span class="line">        any:[] <span class="comment">// 事件类型：订阅者</span></span><br><span class="line">    &#125;,</span><br><span class="line">    subscribe:<span class="function"><span class="keyword">function</span>(<span class="params">fn,type</span>)</span>&#123;</span><br><span class="line">        type=type || <span class="string">'any'</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type]===<span class="string">'undefined'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.subscribers[type]=[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.subscribers[type].push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribe:<span class="function"><span class="keyword">function</span>(<span class="params">fn,type</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.visitSubscribers(<span class="string">'unsubscribe'</span>,fn,type)</span><br><span class="line">    &#125;,</span><br><span class="line">    publish:<span class="function"><span class="keyword">function</span>(<span class="params">publication,type</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.visitSubscribers(<span class="string">'publish'</span>,publication,type)</span><br><span class="line">    &#125;,</span><br><span class="line">    visitSubscribers:<span class="function"><span class="keyword">function</span>(<span class="params">action,arg,type</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pubtype=type||<span class="string">'any'</span></span><br><span class="line">        ,subscribers=<span class="keyword">this</span>.subscribers[pubtype],i</span><br><span class="line">        ,max=subscribers.length</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i+=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(action===<span class="string">'action'</span>)&#123;</span><br><span class="line">                subscribers[i](arg)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(subscribers[i]===arg)&#123;</span><br><span class="line">                    subscribers.splice(i,<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePublisher</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> publisher)&#123;</span><br><span class="line">        <span class="keyword">if</span>(publisher.hasOwnProperty(i)&amp;&amp; <span class="keyword">typeof</span> publisher[i]===<span class="string">'function'</span>)&#123;</span><br><span class="line">            o[i]=publish[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    o.subscribers=&#123;<span class="attr">any</span>:[]&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> pager=&#123;</span><br><span class="line">    daily:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.publish(<span class="string">'big news today'</span>)&#125;,</span><br><span class="line">    monthly:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.publish(<span class="string">'interestion analysis'</span>,<span class="string">'monthly'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">makePublisher(pager)</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> joe=&#123;</span><br><span class="line">    drinkCoffee:<span class="function"><span class="keyword">function</span>(<span class="params">pager</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'just read'</span>+pager)</span><br><span class="line">    &#125;,</span><br><span class="line">    sundayPreNap:<span class="function"><span class="keyword">function</span>(<span class="params">monthly</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'about to fall asleep reading this'</span>+monthly)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pager注册Joe：joe向pager订阅</span></span><br><span class="line">pager.subscribe(joe.drinkCoffee)</span><br><span class="line">pager.subscribe(joe.sundayPreNap,<span class="string">'monthly'</span>)</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">pager.daily()</span><br><span class="line">pager.daily()</span><br><span class="line">pager.monthly()</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 2  joe成为发布者</span></span><br><span class="line">makePublisher(joe)</span><br><span class="line">joe.tweet=<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.publish(msg)</span><br><span class="line">&#125;</span><br><span class="line">pager.readTweets=funciton(tweet)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call big meeting! someone'</span>+tweet)</span><br><span class="line">&#125;</span><br><span class="line">joe.tweet(<span class="string">'hated the pager today'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="示例2：键盘按键游戏"><a href="#示例2：键盘按键游戏" class="headerlink" title="示例2：键盘按键游戏"></a>示例2：键盘按键游戏</h3><p>接受无限量玩家<br>中介者：mediator对象必须知道所有其他参与对象并调用他们的方法；<br>观察者更缺乏只能，主要依赖于对象观察某些事件并采取行动。比如scoreboard监听scorechange事件<br>调整使更解决浏览器：fire,on,remove;type;context    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码：略</span></span><br></pre></td></tr></table></figure>
<p style="text-align:right">20:28</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
        <category>js模式</category>
      </categories>
  </entry>
  <entry>
    <title>JS模式-5：对象创建模式</title>
    <url>/pdf/js/js%E6%A8%A1%E5%BC%8F/5_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p style="text-align:right">2019.4.5 星期五 19:09</p>

<p>$PS: 自检<br>1) namespace的缺点及解决方式：沙箱模式；<br>2) 私有属性和方法，静态成员（公共和私有，互通），特权方法，揭示模式<br>构造函数私有，对象字面量私有<br>3) 模块模式，声明依赖<br>4) 链式，对象常量，method()  </p>
<p>5.1 命名空间模式<br>5.2 声明依赖关系<br>5.3 私有属性和方法<br>5.4 模块模式<br>5.5 沙箱模式<br>5.6 静态成员<br>5.7 对象常量<br>5.8 链模式<br>5.9 method()方法        </p>
<a id="more"></a>
<p>P96-P123    </p>
<h2 id="5-1-命名空间模式-namesapce"><a href="#5-1-命名空间模式-namesapce" class="headerlink" title="5.1 命名空间模式  namesapce"></a>5.1 命名空间模式  namesapce</h2><p><code>MYAPP.modules.module1=...</code>  (大写也用于常量)<br>缺点：<br>1) 跟多前缀字符；2）全局一个实例意味任何部分代码都可以修改该实例；3）长嵌套名字更长/慢的属性解析查询<br>沙箱模式可解决  </p>
<h3 id="1-通用命名空间函数"><a href="#1-通用命名空间函数" class="headerlink" title="1 通用命名空间函数"></a>1 通用命名空间函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 不安全</span></span><br><span class="line"><span class="keyword">var</span> MYAPP=&#123;&#125;</span><br><span class="line"><span class="comment">// 1 修正</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> MYAPP === <span class="string">'undefined'</span>) &#123;<span class="keyword">var</span> MYAPP=&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> MYAPP=MYAPP || &#123;&#125;</span><br><span class="line"><span class="comment">// 2 附加检查会迅速导致大量重复代码  </span></span><br><span class="line">MYAPP.namesapce=<span class="function"><span class="keyword">function</span>(<span class="params">ns_sting</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts=ns_sting.split(<span class="string">'.'</span>), parent=MYAPP, i </span><br><span class="line">    <span class="comment">// 剥离最前面的冗余全局变量</span></span><br><span class="line">    <span class="keyword">if</span>(parts[<span class="number">0</span>] === <span class="string">'MYAPP'</span>) parts=parts.slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;parts.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> parent[parts[i]] === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">            parent[parts[i]]=&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        parent=parent[parent[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 使用</span></span><br><span class="line"><span class="comment">// 3-1 返回给一个变量</span></span><br><span class="line"><span class="keyword">var</span> module2=MYAPP.namesapce(<span class="string">'MYAPP.modules.module2'</span>)</span><br><span class="line"><span class="comment">// 3-2 忽略MYAPP</span></span><br><span class="line">MYAPP.namesapce(<span class="string">'modules.module2'</span>)</span><br><span class="line"><span class="comment">// 3-3 长命名空间</span></span><br><span class="line">MYAPP.namesapce(<span class="string">'once.upon.a.time.there.was.this.long.nested.property'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-2-声明依赖关系"><a href="#5-2-声明依赖关系" class="headerlink" title="5.2 声明依赖关系"></a>5.2 声明依赖关系</h2><p>优点： 1)显示的  2）更容易发现并解析  3）解析快；4）更小代码量（uglify）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFun=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event=YAHOO.util.Event,</span><br><span class="line">        dom=YAHOO.util.dom</span><br><span class="line">     <span class="comment">// 使用 event 和 dom 变量     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-3-私有属性和方法"><a href="#5-3-私有属性和方法" class="headerlink" title="5.3 私有属性和方法"></a>5.3 私有属性和方法</h2><p>没有像java的表示私有、保护、或公共属性和方法 ；所有都是公共的  </p>
<h3 id="1-私有成员"><a href="#1-私有成员" class="headerlink" title="1 私有成员"></a>1 私有成员</h3><p>闭包closure<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'iPod'</span></span><br><span class="line">    <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-特权方法-Privileged-Method"><a href="#2-特权方法-Privileged-Method" class="headerlink" title="2 特权方法 Privileged Method"></a>2 特权方法 Privileged Method</h3><p>可以访问私有成员的公共方法</p>
<h3 id="3-私有性失效"><a href="#3-私有性失效" class="headerlink" title="3 私有性失效"></a>3 私有性失效</h3><p>返回私有变量是一个引用类型<br>1）只返回需要的值类型；2）shallow/deep copy  </p>
<h3 id="4-对象字面量以及私有性"><a href="#4-对象字面量以及私有性" class="headerlink" title="4 对象字面量以及私有性"></a>4 对象字面量以及私有性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'my,oh my'</span></span><br><span class="line">    myobj=&#123;</span><br><span class="line">        getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 特权方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 实现2: 模式模块module pattern </span></span><br><span class="line"><span class="keyword">var</span> myobj=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'dsfs'</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="5-原型和私有性"><a href="#5-原型和私有性" class="headerlink" title="5 原型和私有性"></a>5 原型和私有性</h3><p>避免都创建一遍，故添加到构造函数的prototype属性；还可以隐藏共享的私有成员<br>组合：构造函数的私有属性和对象字面量的私有属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gadget</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有成员</span></span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'iPod '</span></span><br><span class="line">    <span class="comment">// 共有函数</span></span><br><span class="line">    <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Gadget.prototype=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> browser=<span class="string">'my webki'</span></span><br><span class="line">    <span class="comment">// 共有原型成员</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getBrowser:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> browser&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h3 id="6-私有方法揭示为公共方法"><a href="#6-私有方法揭示为公共方法" class="headerlink" title="6 私有方法揭示为公共方法"></a>6 私有方法揭示为公共方法</h3><p>揭示模块模式  revealing module rattern<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myarray</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> astr=<span class="string">'sdfs'</span>,toString=<span class="built_in">Object</span>.prototype.toString  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">haystack,needle</span>)</span>&#123;&#125;</span><br><span class="line">    myarray=&#123;isArray,indexOf,<span class="attr">inArray</span>:indexOf&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>如果发生意外，比如公共indexOf,但私有的indexOf安全，因此inArray继续正常  </p>
<h2 id="5-4-模块模式-Module-pattern"><a href="#5-4-模块模式-Module-pattern" class="headerlink" title="5.4 模块模式 Module pattern"></a>5.4 模块模式 Module pattern</h2><p>多种模式组合：命名空间，即时函数，私有和特权成员，声明依赖<br>使用广泛.js没有包package的特殊语法,该模式提供一种创建自包含非耦合代码片段。。<br>黑盒功能，并且可根据需求添加，替换，删除这些模块<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 命名空间</span></span><br><span class="line">MYAPP.namesapce(<span class="string">'MYAPP.utilities.array'</span>)</span><br><span class="line"><span class="comment">// 2 定义该模块:可提供私有作用域的即时函数，返回一个对象，具有公共接口的实际模块</span></span><br><span class="line">MYAPP.utilities.array=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 4 顶部可 声明司有关，任何依赖</span></span><br><span class="line">    <span class="keyword">var</span> ubbj=MYAPP.utilities.object </span><br><span class="line">    <span class="keyword">var</span> ops=<span class="built_in">Object</span>.prototype.toString </span><br><span class="line">    <span class="comment">// 2 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 3 公共接口添加方法</span></span><br><span class="line">        inArray:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        isArray:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h3 id="揭示模块模式"><a href="#揭示模块模式" class="headerlink" title="揭示模块模式"></a>揭示模块模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.array=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">var</span> ubbj=MYAPP.utilities.object, </span><br><span class="line">    <span class="keyword">var</span> ops=<span class="built_in">Object</span>.prototype.toString, </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    inArray=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    isArray=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 揭示公有api</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 3 公共接口添加方法</span></span><br><span class="line">        inArray,</span><br><span class="line">        isArray,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="创建构造函数的模块"><a href="#创建构造函数的模块" class="headerlink" title="创建构造函数的模块"></a>创建构造函数的模块</h3><p>比前面创建对象更为方便。任然使用模式模块，只不过返回函数，而不是对象<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.namesapce(<span class="string">'MYAPP.utilities.Array'</span>)</span><br><span class="line">MYAPP.utilities.Array=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 依赖，私有属性和方法  </span></span><br><span class="line">    <span class="keyword">var</span> ubbj=MYAPP.utilities.object ,</span><br><span class="line">    <span class="keyword">var</span> ops=<span class="built_in">Object</span>.prototype.toString ,</span><br><span class="line">    Constr;</span><br><span class="line">    <span class="comment">// 可选的一次性初始化过程</span></span><br><span class="line">    <span class="comment">// 公有API——构造函数</span></span><br><span class="line">    Constr=<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements=<span class="keyword">this</span>.toArray(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有API——原型</span></span><br><span class="line">    Constr.property=&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:MYAPP.utilities.Array,</span><br><span class="line">        version:'2.0',</span><br><span class="line">        toArray:function(obj)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回要分配给新命名空间的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> Constr</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> MYAPP.utilities.Array(obj)</span><br></pre></td></tr></table></figure></p>
<h3 id="将全局变量导入到模块中"><a href="#将全局变量导入到模块中" class="headerlink" title="将全局变量导入到模块中"></a>将全局变量导入到模块中</h3><p>可将参数传递到包装了模块的即时函数中。可以是任何值，通常是全局变量，甚至是全局对象本身的引用。加速解析，因为导入的变量成为了该函数的局部变量<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MYAPP.utilities.Array=(<span class="function"><span class="keyword">function</span>(<span class="params">app,global</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)(MYAPP,<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="5-5-沙箱模式"><a href="#5-5-沙箱模式" class="headerlink" title="5.5 沙箱模式"></a>5.5 沙箱模式</h2><p>解决命名空间模式缺点：无法是同一程序两个版本运行一个页面；需要长字符及解析</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="$使用"></a>$使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Sandbox(<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;   &#125;)</span><br><span class="line">Sandbox([<span class="string">'ajax'</span>,<span class="string">'event'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;   &#125;)</span><br><span class="line">Sandbox(<span class="string">'ajax'</span>,<span class="string">'event'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;   &#125;)</span><br><span class="line">Sandbox(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;   &#125;)</span><br><span class="line"><span class="comment">// ### 多次/嵌套</span></span><br><span class="line">Sandbox(<span class="string">'dom'</span>,funciton(box)&#123;</span><br><span class="line">    Sandbox(<span class="string">'ajax'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="$实现"></a>$实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1 增加模块,接受当前实例box做为参数，还可向该实例添加额外的属性和方法  </span></span><br><span class="line">Sandbox.modules=&#123;&#125;</span><br><span class="line">Sandbox.modules.dom=<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;box.getElement=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;&#125;</span><br><span class="line">Sandbox.modules.event=<span class="function"><span class="keyword">function</span>(<span class="params">box</span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// ### 2 实现构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sandbox</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args=<span class="built_in">Array</span>.property.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    callback=args.pop()</span><br><span class="line">    <span class="comment">// 模块可做为数组，或单独传递</span></span><br><span class="line">    modules=(args[<span class="number">0</span>]&amp;&amp;<span class="keyword">typeof</span> args[<span class="number">0</span>]===<span class="string">'string'</span>) ? args:args[<span class="number">0</span>]</span><br><span class="line">    ,i </span><br><span class="line">    <span class="comment">// 确保做为构造函数调用</span></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Sandbox))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sandbox(modules,callback)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向`this`添加的属性</span></span><br><span class="line">    <span class="keyword">this</span>.a=<span class="number">1</span></span><br><span class="line">    <span class="comment">// 向该核心 this 对象添加模块</span></span><br><span class="line">    <span class="keyword">if</span>(!modules||modules===<span class="string">'*'</span>)&#123;</span><br><span class="line">        modules=[]</span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> Sandbox.modules)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Sandbox.modules.hasOwnProperty(i))&#123;</span><br><span class="line">                modules.push(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化所需模块 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;modules.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">        Sandbox.modules[modules[i]](<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call the callback</span></span><br><span class="line">    callback(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 需要的任何原型属性</span></span><br><span class="line">Sandbox.property=&#123;</span><br><span class="line">    nam:<span class="string">'My application'</span>,</span><br><span class="line">    version:<span class="string">'1.0'</span>,</span><br><span class="line">    getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-静态成员"><a href="#5-6-静态成员" class="headerlink" title="5.6 静态成员"></a>5.6 静态成员</h2><p>从一个实例到另一个实例都不会发生改变的属性和方法。  </p>
<h3 id="共有静态成员"><a href="#共有静态成员" class="headerlink" title="共有静态成员"></a>共有静态成员</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Gadget=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Gadget.isShiny=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// ### 1.1 有时可以是静态方法与实例一起工作; 需要注意this；</span></span><br><span class="line">Gadget.prototype.isShiny=Gadget.isShiny</span><br><span class="line"><span class="comment">// ### 2 instance有助于确认是谁调用的</span></span><br><span class="line">Gadget.isShiny=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Gadget)&#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向原型添加一个普遍方法</span></span><br><span class="line">Gadget.property.isShiny=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Gadget.isShiny.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="私有静态成员"><a href="#私有静态成员" class="headerlink" title="私有静态成员"></a>私有静态成员</h3><p>1) 同一个构造函数创建的所有对象共享该成员<br>2) 构造函数外部不可访问该成员<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Gadget=(funciton()&#123;</span><br><span class="line">    <span class="keyword">var</span> counter=<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> NewGadget=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特权方法</span></span><br><span class="line">    NewGadget.property.getLastId=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 覆盖该构造函数</span></span><br><span class="line">    <span class="keyword">return</span> NewGadget</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<h2 id="5-7-对象常量"><a href="#5-7-对象常量" class="headerlink" title="5.7 对象常量"></a>5.7 对象常量</h2><p>创建一个私有属性，提供取值方法，不提供设置函数。（矫枉过正）<br>大写命名约定<br>$PS: 现在js已经有常量的概念了<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：声明常量与内置属性不冲突，比如toString，hasOwnProperty等，通过hasOwnproperty检查；</span></span><br><span class="line">    <span class="comment">// 并且加前缀，确保 名称之间互相适应</span></span><br><span class="line"><span class="keyword">var</span> constant=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> constants=&#123;&#125;</span><br><span class="line">    ,ownProp=<span class="built_in">Object</span>.property.hasOwnProperty</span><br><span class="line">    ,allowed=&#123;<span class="attr">string</span>:<span class="number">1</span>,<span class="attr">number</span>:<span class="number">1</span>,<span class="attr">boolean</span>:<span class="number">1</span>&#125;</span><br><span class="line">    ,prefix=(<span class="built_in">Math</span>.random()+<span class="string">'_'</span>).slice(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">set</span>:function(name,value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDefined(name)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span>(!ownProp.call(allowed,<span class="keyword">typeof</span> value)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            constants[prefix+name] = value</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        isDefined:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ownProp.call(constants,prefix+name)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>:function(name)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isDefined(name))&#123;</span><br><span class="line">                <span class="keyword">return</span> constants[prefix+name]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//  使用:检测，set，尝试更改，取值</span></span><br><span class="line">constant.isDefined(<span class="string">'maxwidt'</span>)</span><br><span class="line">constant.set(<span class="string">'maxwith'</span>,<span class="number">450</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="5-8-链模式-Chaining-Pattern"><a href="#5-8-链模式-Chaining-Pattern" class="headerlink" title="5.8 链模式  Chaining Pattern"></a>5.8 链模式  Chaining Pattern</h2><p>当创建的方法返回五任何意义的值时，可以返回this<br>优缺点<br>缺点：难以调试，步骤太多，无法知道哪一个方法失效。 火车失事 train wreck</p>
<h2 id="5-9-method-方法"><a href="#5-9-method-方法" class="headerlink" title="5.9 method()方法"></a>5.9 method()方法</h2><p>以类思考的程序员，是js更加类似类。作者回想起来并不值得推荐<br>语法糖：向编程语言中添加便利的功能  </p>
<p>然而实例向this添加方法的机制效率低下，每一实例都重新创建，并且耗更多内存空间。也就产生prototype<br>许多程序员对prototype陌生，因此将其隐藏在方法之后<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;.</span><br><span class="line">    method(<span class="string">'getName'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;).</span><br><span class="line">    method(<span class="string">'setName'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name;<span class="keyword">return</span> <span class="keyword">this</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现.this指构造函数   </span></span><br><span class="line"><span class="keyword">if</span>(type <span class="keyword">of</span> <span class="built_in">Function</span>.property.method!==<span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.property.method=<span class="function"><span class="keyword">function</span>(<span class="params">name,implemention</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.property[name]=implemention</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">21:06</p>

]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
        <category>js模式</category>
      </categories>
  </entry>
  <entry>
    <title>Jquery学习</title>
    <url>/sum/jsplus/jquery%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p style="text-align:right">2019.3.18 </p>


<h2 id="jQuery封装"><a href="#jQuery封装" class="headerlink" title="jQuery封装"></a>jQuery封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置符号：`+ - !`</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global,factory</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;(<span class="built_in">window</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    window.$=window.jQuery=function(</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init()</span><br><span class="line">    &#125;</span><br><span class="line">    jQuery.fn=jQuery.prototype=&#123;</span><br><span class="line">        init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jQuery.fn.init.prototype=jQuery.prototype</span><br><span class="line"></span><br><span class="line">)&#123;&#125;))</span><br></pre></td></tr></table></figure>
<h2 id="bind-on-实现"><a href="#bind-on-实现" class="headerlink" title="bind/on 实现"></a>bind/on 实现</h2><h2 id="ready"><a href="#ready" class="headerlink" title="ready()"></a>ready()</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>setInterval实现，通过setStyle（好像是这个函数）</p>
<h2 id="extend-扩展"><a href="#extend-扩展" class="headerlink" title="extend 扩展"></a>extend 扩展</h2>]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Fetch使用</title>
    <url>/sum/jsplus/fetch%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>MDN:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></p>
<a id="more"></a>
<p style="text-align:right">2019.3.14 四 16:01</p>

<!-- MDN:[使用 Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)     -->
<h2 id="json-格式数据处理"><a href="#json-格式数据处理" class="headerlink" title="json 格式数据处理"></a>json 格式数据处理</h2><p>最佳实践是在使用之前检查 content type 是否正确，比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(response.headers.get(<span class="string">"content-type"</span>) === <span class="string">"application/json"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// process your JSON further</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops, we haven't got JSON!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line"><span class="keyword">if</span>(response.ok) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为什么我不再使用Fetch-API开发应用"><a href="#为什么我不再使用Fetch-API开发应用" class="headerlink" title="为什么我不再使用Fetch API开发应用"></a>为什么我不再使用Fetch API开发应用</h2><p><a href="https://zhuanlan.zhihu.com/p/28206325" target="_blank" rel="noopener">[为什么我不再使用Fetch API开发应用]</a>        </p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>我们需要加上一句 response.json() 来从 response 流对象中获取数据，但这只是一点很小的代价。   </p>
<p>之前我提到的所有 http 工具库会把状态码错误的响应（比如404，500等）当成一个错误来处理，而 fetch 与 XMLHttpRequest 一样，只会在网络错误的情况下（比如 IP 地址无法解析，服务器不可访问或是不允许 CORS）reject 这个 promise。       </p>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>fetch 是一种底层的 api，它不会在我们处理这种一般情形时带来便利，你必须清楚明确地使用它。首先，JSON 必须先转换成字符串，然后还要设置 ‘Content-Type’ 头部，指出实体的类型是 JSON，否则服务器会把它当做普通的字符串处理。<br>$PS: axios 有instance       </p>
<h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><p>我的服务器使用基于 cookie 的认证方式，而 fetch 默认情况下不会发送 cookie<br>我的服务器需要知道客户端是否可以处理 JSON 数据<br>我的服务器在另一个子域名下，而 fetch 默认不启用 CORS<br>为了防御 XSRF 攻击，我的服务器要求每一个请求都必须带上一个 X-XSRF-TOKEN 头部，来证明请求确实是从我自己的页面发出的</p>
<h2 id="fetch-api不带cookie"><a href="#fetch-api不带cookie" class="headerlink" title="fetch api不带cookie"></a>fetch api不带cookie</h2><blockquote>
<p>fetch API 的一个特性是默认不发送 Cookie，只有设置适当的 credentials 时才会发送。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://example.com'</span>, &#123;</span><br><span class="line">    cache: <span class="string">'no-cache'</span>, <span class="comment">// *default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">    credentials: <span class="string">'same-origin'</span>, <span class="comment">// include, same-origin, *omit</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>[<a href="http://www.qingpingshan.com/jb/javascript/263396.html" target="_blank" rel="noopener">Fetch API Cookie问题</a>       </p>
<p>翻阅 Fetch Standard 才寻求到了答案。</p>
<p>A request has an associated credentials mode, which is “omit”, “same-origin”, or “include”. Unless stated otherwise, it is “omit”.</p>
<p>Request’s credentials mode controls the flow of credentials during a fetch. Credentials are HTTP cookies, TLS client certificates, and authentication entries. When request’s mode is “navigate”, its credentials mode is assumed to be “include” and fetch does not currently account for other values. If HTML changes here, this standard will need corresponding changes.</p>
<p>好嘛，Fetch 默认 credentials: ‘omit’ 。 那我们吧参数改成 include 就万事大吉了。</p>
<p>至于为什么 Fetch API 不带 cookie 一起飞，具体原因官方文档也有描述。</p>
<p>When request’s credentials mode is “include” it has an impact on the functioning of the CORS protocol other than including credentials in the fetch.</p>
<p>将 credentials 模式设置为 “include” 虽然能让请求包含 HTTP cookies TLS client certificates 和 authentication entries 这些内容，但它会影响到 CORS 协议的功能。</p>
<p>A request’s credentials mode is not necessarily observable on the server; only when credentials exist for a request can it be observed by virtue of the credentials being included. Note that even so, a CORS-preflight request never includes credentials.</p>
<p>请求的 credentials 模式没有必要对服务器可见，只有当 credentials 存在的时候才让服务器知晓。即便如此，CORS 预请求不会带上 credentials 。</p>
<p>The server developer therefore needs to decide whether or not responses “tainted” with credentials can be shared. And also needs to decide if requests necessitating a CORS-preflight request can include credentials. Generally speaking, both sharing responses and allowing requests with credentials is rather unsafe, and extreme care has to be taken to avoid the confused deputy problem.</p>
<p>开发人员应该自主决定是否确定要在请求内代上 credentials 。总之，无论是分发 responses 还是响应 requests，要带上 credentials 都是不安全的，开发人员需要非常注意这一点以避开这个派生问题。</p>
<p style="text-align:right">16:36</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell命令</title>
    <url>/sum/os/shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h1><ol>
<li>设置编码格式：工具条上有个地球的图标 可以设置，可能需要重启   </li>
<li>二次/跳转登录：在属性设置中，连接  通过 登录脚本  可以添加跳转或者进入文件夹(设置expect和send)。<br>复杂的还可以自己的写登录脚本（好像是.vbs）    </li>
<li>传输文件，比如imp.tar.gz 经常会失败，可能是因为跳转机二次登录，导致文件传输中把文件中某些信息 当做指令了。所以上传不成功<br>先传到跳转机，然后再同步到线上/st机器 <code>rsync -avP ./imp.tar.gz 10.5.60.199:/var/www/cim/</code> </li>
<li>删除乱码/中文文件或目录<br>ls -i //列出文件节点<br>find ./ -inum XXX（节点号） -print -exec rm -rf {} \;    //删除节点号文件<br>find . -inum XXXX（节点号） -exec mv {} file.txt \；   //其实我们还可以执行这个命令，修改乱码文件名为正常文件名  </li>
</ol>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>查找文件中内容<br>grep -nir “.top-bg” ./</p>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p>刷新DNS缓存： ipconfig /flushDNS<br>    ipconfig /all    </p>
<p>nslookup mix.dangdang.com   </p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><!-- [Xshell常用命令及使用教程](https://www.2cto.com/kf/201711/696431.html)    -->
<!-- \# [Linux系统下常见的Xshell运行命令——Xshell入门必看](https://blog.csdn.net/u013058618/article/details/55006518)      -->
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>查看的命令是cat host.xml；      </p>
<p>ls命令会把文件横向显示，看着不舒服，ll和ls -l是一样的效果，建议使用ll，因为它最简单    </p>
<p>在Linux系统下执行文件我们需要使用的的 ./文件名.sh</p>
<p>授权命令，chmod u+x <em>.sh  给sh文件授权，当然了我们也可以将</em>替换为具体的文件名</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>上传 rz -y (当前路径); 下载 sz file.text(只不过默认情况下是不能使用的，我们需要使用yum install lrzsz来安装)</p>
<p>$PS: 输入rz命令，看是否已经安装了lrzsz，如果没有安装则执行  yum   -y  install  lrzsz命令进行安装。<br>$PS: 另外：可以下载工具xftp去传输文件。<br>下载后，从xshell点击新建文件传输按钮，就会打开xftp工具，来更专业的传输文件。<br>快捷键：Ctrl+Alt+F</p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>sz filename<br>sz filename1 filename2<br>sz dir/*</p>
<p>文件夹及文件夹下的所有文件的复制【cp -r 源文件目录 目标文件目录】<br>[root@localhost /]# cp -r /soft/bak/* /home/bak</p>
<h3 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h3><p>编辑的命令是vi host.xml，然后按下i，进入修改模式，要不然就只是看，<br>如果我们突然不想修改时，按下ESC 然后在命令行中写下 :q! ? 然后回车就接触编辑，<br>如果我们是编辑完了需要保存，也需要按下ESC，然后输入 :wq 回车。<br>总结一下就是：编辑文件 vi，按下i进行编辑 ??保存结束编辑 ESC :wq 回车 ??不保存结束编辑 ESC :q! 回车</p>
<p>$PS: 使用vim  </p>
<p>设置编码格式：工具条上有个地球的图标 可以设置，可能需要重启   </p>
<h3 id="文件统计"><a href="#文件统计" class="headerlink" title="文件统计"></a>文件统计</h3><p><a href="https://www.linuxidc.com/Linux/2011-02/32390.htm" target="_blank" rel="noopener">Linux获取一个文件的行数或者字符数</a><br>wc命令主要对文件中的行数、字符数、字节数进行计数</p>
<p>-c     统计字节数，除非指定 -k 标志。如果指定 -k 标志，wc 命令统计字符数。<br>-k     统计字符数。指定 -k 标志等同于指定 -klwc 标志。如果把 -k 标志同其它标志一起使用，那么必须包含 -c 标志。否则，将会忽略 -k 标志。<br>-l     统计行数。<br>-m     统计字符数。这个标志不能与 -c 标志一起使用。<br>-w     统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</p>
<p>1字节（Byte）= 8位（bit）<br>在ASCII码中，一个英文字母（不分大小写）占一个字节的空间，<br>中文字符占两个字节</p>
<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>1.作用<br>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 </p>
<p>2.格式<br>grep [options]  </p>
<h3 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h3><p>du -sh /var/www/*<br>df -h </p>
<p style="text-align:right">2019.6.26 星期三 23：21 $1</p>

<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>在Linux下使用Crontab来添加定时任务执行shell文件．shell文件有数据库备份命令<br>查看/etc/crontab文件: vim  /etc/crontab     </p>
<p>除了root用户之外的用户可以执行crontab配置计划任务。<br>所有用户定义的crontab存储在目录/var/spool/cron下，任务会以创建者的身份被执行。<br>要以特定用户创建一个crontab，先以该用户登录，执行命令crontab -e，系统会启动在VISUAL或者EDITOR中指定的的编辑软件编辑crontab。<br>文件内容与/etc/crontab格式相同。示例如下：     </p>
<p>crontab文件格式：<br><code>*           *        *        *        *           command</code><br>minute（1-59）（或/1表示每分钟）    hour（1-23）（0表示0点）<br>day（1-31）   month（1-12）   week（1-6, 0表示周日）     </p>
<p>30 3,12 <em> </em> *  /home/test.sh     </p>
<p>#### crontab命令选项:<br>-u 指定一个用户<br>-l 列出(某个用户的)任务计划<br>-r 删除(某个用户的)任务<br>-e 编辑(某个用户的)任务</p>
<p>查看执行的日志 cat /var/log/cron</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  查看调度任务</span><br><span class="line">crontab -l //列出当前的所有调度任务</span><br><span class="line">crontab -l -u jp   //列出用户jp的所有调度任务</span><br><span class="line"></span><br><span class="line">11. 删除任务调度工作</span><br><span class="line">crontab -r   //删除所有任务调度工作</span><br><span class="line"></span><br><span class="line">12. 任务调度执行结果的转向</span><br><span class="line">例1：每天5：30执行ls命令，并把结果输出到/jp/test文件中</span><br><span class="line">30 5 * * * ls &gt;/jp/test 2&gt;&amp;1</span><br><span class="line">    注：2&gt;&amp;1 表示执行结果及错误信息。</span><br></pre></td></tr></table></figure>
<p>#### 特殊符号<br>1.星号(<em>)表示取值范围内的所有值。例如，</em>在hour的位置，表示每小时执行一次。<br>2.连字符(-)表示一个范围。例如，8-12表示8、9、10、11、12。<br>3.逗号(,)表示分割指定的数值。例如：3,5-7,9表示3,5,6,7,9。<br>4.正斜杠(/)表示步进值。例如，分钟的位置为<em>/5，表示每五分钟执行一次<br>5.“？”只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 </em><br>6.“#”字符：表示该月第几个周X。6#3表示该月第3个周五<br>7.“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X<br>8.“W”字符：指定离给定日期最近的工作日(周一到周五)   </p>
<p>#### 2 检查是否安装了crontab，<br>如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。<br><code>rpm -qa | grep conrtab</code></p>
<p>#### crontab服务的启动关闭<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sbin/service crond start //启动服务</span><br><span class="line">/sbin/service crond stop //关闭服务</span><br><span class="line">/sbin/service crond restart //重启服务</span><br><span class="line">/sbin/service crond reload //重新载入配置</span><br></pre></td></tr></table></figure></p>
<p>#1 <a href="https://www.cnblogs.com/zoulongbin/p/6187238.html" target="_blank" rel="noopener">[crontab命令概念]</a><br>#### 全局配置文件：<br>crontab在/etc目录下面存在cron.hourly,cron.daily,cron.weekly,cron.monthly,cron.d五个目录和crontab,cron.deny二个文件。</p>
<p>cron.daily是每天执行一次的job<br>cron.weekly是每个星期执行一次的job<br>cron.monthly是每月执行一次的job<br>cron.hourly是每个小时执行一次的job<br>cron.d是系统自动定期需要做的任务<br>crontab是设定定时任务执行文件<br>cron.deny文件就是用于控制不让哪些用户使用Crontab的功能</p>
<p>#### <strong>**</strong>定时任务书写要领<strong>**</strong><br>要领1：定时任务要加注释<br>要领2：定时任务命令或脚本结尾加 &amp;&gt;/dev/null 或 &gt;/dev/null 2&gt;&amp;1 或 1&gt;/dev/null 2&gt;/dev/null<br>要领3：定时任务执行shell脚本前加/bin/sh，定时任务执行shell脚本不必添加执行权限<br>要领4：定时任务命令或程序尽量写到脚本里，定时任务只要执行脚本即可<br>         注意操作步骤：<br>　　（1）、命令行执行<br>　　（2）、编写脚本<br>　　（3）、测试脚本<br>　　（4）、设置定时任务</p>
<p>要领5：生产任务程序不要随意打印输出信息<br>要领6：定时任务执行的脚本要规范路径 (例如 /server/script)<br>要领7：配置定时任务要规范操作过程<br>要领8：定时任务执行特殊的字符需要进行转义，否则会报错，例如 百分号% 转义 \%<br>要领9：定时任务脚本中如果涉及使用到环境变量，必须在脚本中重新定义，不然，定时任务识别不了<br><!-- end #1 --></p>
<p>### 其他定时任务指令<br>1、at<br>命令at从文件或标准输入中读取命令并在将来的一个时间执行，只执行一次。at的正常执行需要有守护进程atd<br>2、crontab<br>命令crontab用来设置、移除、列出服务crond表格，crond服务的作用类似atd，区别的地方在于crond可以设置任务多次执行。相对来说比atd更常用。<br>3、systemd.timer<br>crond和atd服务基于分钟的，意思是说它们每分钟醒来一次检查是否有任务需要执行。如果有任务的执行需要精确到秒，crond和atd是无能为力的。在基于systemd的系统上，可以通过计时器systemd.timer来实现精确到秒的计划任务。  </p>
<p style="text-align:right">2019.6.27 00：12 $1</p>



<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p><a href="https://blog.csdn.net/u013107656/article/details/52438939" target="_blank" rel="noopener">【Linux】后台运行进程的命令</a><br>一、简介<br>Linux提供了fg和bg命令，可以轻松调度正在运行的任务</p>
<blockquote>
<p>Ctrl-Z 挂起程序<br>bg %n   把程序调度到后台执行，bg后面的数字为作业号<br>jobs 查看正在运行的任务<br>fg %n  把程序调回到前台运行，这样在控制台上就只能等待任务完成<br>kill %n 管理后台的任务  </p>
</blockquote>
<p>【3】Linux后台运行进程有两种方式<br>command &amp;：后台运行，关掉终端会停止运行<br>nohup command &amp;：后台运行，关掉终端会继续运行</p>
<p>二、&amp;<br>【1】可以使用&amp;命令，把作业放到后台执行，实际是放入到一个作业队列中<br>jobs -l 可以查看当前的后台进程</p>
<p>三、nohup<br>【1】可以使用nohup命令运行进程，并且在退出帐号后可以继续运行，nohup就是不挂起(no hang up)<br>【2】一般形式：nohup command &amp;<br>【3】使用nohup命令提交作业，在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件</p>
<p><a href="https://blog.csdn.net/cqbamboo/article/details/44706011" target="_blank" rel="noopener">[Linux 的常用后台运行指令]</a><br>指令或符號        使用範例            說明<br>&amp;    % fasta &amp;    在背景中執行程式<br>jobs    % jobs    顯示送入背景之工作<br>kill    % kill (job#)    移除指定之批次工作<br>ctrl-z         暫停前景中執行之程式<br>bg    % bg    將暫停之工作送入背景執行<br>fg    % fg    將背景之工作拉回前景執行</p>
<p>5.如何结束一个job<br>如果你想结束一个正在运行的job，可以使用中断键（interrupt key，通常是Ctrl-C）来结束。<br>如果上面方法无法正常工作，那么你可以考虑使用Ctrl-Z（Suspend key）来暂停job，使用’jobs’命令来查看这个job的job number,然后通过’kill’命令来结束这个job.    </p>
<p>Linux下Ctrl-Z、Ctrl-C、Ctrl-D的具体含义<br>初识Linux，可能会对Ctrl-Z、Ctrl-C、Ctrl-D的具体含义混淆不清，因为这三个按键都能够在一些情况下使shell退出正在执行的命令或程序，提示用户输入下一个命令，从而对初识者造成假象，认为三个键的功能一样，但具体情况下哪个按键能起作用、起什么作用却拿捏不定。</p>
<p>Ctrl-Z：该键是linux下面默认的挂起键（Suspend Key），当键入Ctrl-Z时，系统会将正在运行的程序挂起，然后放到后台，同时给出用户相关的job信息。此时，程序并没有真正的停止，用户可以通过使用fg、bg命令将job恢复到暂停前的上下文环境，并继续执行。  </p>
<p>Ctrl-C：该键是linux下面默认的中断键（Interrupt Key），当键入Ctrl-C时，系统会发送一个中断信号给正在运行的程序和shell。具体的响应结果会根据程序的不同而不同。一些程序在收到这个信号后，会立即结束并推出程序，一些程序可能会忽略这个中断信号，还有一些程序在接受到这个信号后，会采取一些其他的动作（Action）。当shell接受到这个中断信号的时候，它会返回到提示界面，并等待下一个命令。  </p>
<p>Ctrl-D：该键是Linux下面标准输入输出的EOF。在使用标准输入输出的设备中，遇到该符号，会认为读到了文件的末尾，因此结束输入或输出。</p>
<h1 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h1><p>原文出自：<a href="http://www.hangge.com" target="_blank" rel="noopener">www.hangge.com</a>  转载请保留原文链接：<a href="https://www.hangge.com/blog/cache/detail_2499.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_2499.html</a><br>3，通过网络同步时间<br>（1）首先安装 ntpdate 命令：<br>yum install -y ntpdate</p>
<p>（2）接着执行如下命令开始同步：<br>ntpdate 0.asia.pool.ntp.org<br>若上面的时间服务器不可用，也可以改用如下服务器进行同步：<br>time.nist.gov<br>time.nuri.net<br>0.asia.pool.ntp.org<br>1.asia.pool.ntp.org<br>2.asia.pool.ntp.org<br>3.asia.pool.ntp.org</p>
<p>（3）最后执行如下命令将系统时间同步到硬件，防止系统重启后时间被还原。<br>hwclock –systohc</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>X-Shell学习</title>
    <url>/sum/os/x-shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p style="text-align:right">2019.2.17 星期日 11:38</p>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p># <a href="https://www.cnblogs.com/perseverancevictory/p/4910145.html" target="_blank" rel="noopener">Xshell学习–菜鸟篇</a><br>1）关于Xshell<br>网上更多的资料里提到的SSH客户端是putty，因为简单、开源、免费。但是也正是由于功能过于简单，所以在这里推荐大家使用Xshell。<br>Xshell最初并不能免费使用，而且也没有带中文语言，所以导致用户非常少，但是现在已经可以免费安装并且能设置中文，相信使用的人会越来越多。    </p>
<p>简单说下个人认为Xshell的优点：<br>1，界面设计简洁，很人性化，用起来让人觉得很舒服。<br>2，支持标签，打开多个链接的时候很方便。<br>3，可以保存密码。（至于安全问题，见仁见智吧，个人觉得，如果能拿到保存在电脑上的密码，至少需要攻陷或者能够控制你的PC机，而这样的情况下，不管是每次登录都手工输入密码还是用密钥，结果都是一样的）<br>4，支持rz和sz命令，这两个命令在传输少量小文件时非常方便。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="快捷设置"><a href="#快捷设置" class="headerlink" title="快捷设置"></a>快捷设置</h3><ol>
<li>默认选中复制    </li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://www.2cto.com/kf/201711/696431.html" target="_blank" rel="noopener">Xshell常用命令及使用教程</a>   </p>
<h2 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h2><ol>
<li>跳转机登录/二次登录/自动执行脚本   </li>
</ol>
<h2 id="Xftp"><a href="#Xftp" class="headerlink" title="Xftp"></a>Xftp</h2><p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。<br>Xftp 是一个基于 MS windows 平台的功能强大的SFTP、FTP 文件传输软件。     </p>
<p>Xftp是一个功能强大的SFTP、FTP 文件传输软件。使用了 Xftp 以后，MS Windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。Xftp 能同时适应初级用户和高级用户的需要。它采用了标准的 Windows 风格的向导，它简单的界面能与其他 Windows 应用程序紧密地协同工作，此外它还为高级用户提供了众多强劲的功能特性。     </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>Linux教程-Runoob</title>
    <url>/w3/ser/linux%E6%95%99%E7%A8%8B-runoob/</url>
    <content><![CDATA[<p>toc and abstract.  </p>
<p>linux教程-runoob:<a href="http://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-tutorial.html</a><br><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全</a>  </p>
<p style="text-align:right">2019.2.16 星期六 17:56</p>

<!-- $PS: 1.13 就学习了    -->
<p>Linux 英文解释为 Linux is not Unix。<br><a id="more"></a></p>
<p>1. Linux 简介<br>2. Linux 安装<br>3. Linux 系统启动过程<br>4. Linux 系统目录结构<br>5. Linux 忘记密码解决方法<br>6. Linux 远程登录<br>7. Linux 文件基本属性<br>8. Linux 文件与目录管理<br>9. Linux 用户和用户组管理<br>10. Linux 磁盘管理<br>11. Linux vi/vim<br>12. linux yum 命令  </p>
<h2 id="1-Linux-简介"><a href="#1-Linux-简介" class="headerlink" title="1 Linux 简介"></a>1 Linux 简介</h2><p>Linux内核最初只是由芬兰人李纳斯·托瓦兹（Linus Torvalds）在  </p>
<p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。  </p>
<p>Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h3 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h3><p>Linux的发行版说简单点就是将Linux内核与应用软件做一个打包。</p>
<p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。    </p>
<h3 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h3><p>并且在服务器领域确定了地位，通常服务器使用LAMP（Linux + Apache + MySQL + PHP）或LNMP（Linux + Nginx+ MySQL + PHP）组合。   </p>
<p>### Linux vs Windows   </p>
<h2 id="2-Linux-安装"><a href="#2-Linux-安装" class="headerlink" title="2 Linux 安装"></a>2 Linux 安装</h2><h2 id="3-Linux-系统启动过程"><a href="#3-Linux-系统启动过程" class="headerlink" title="3 Linux 系统启动过程"></a>3 Linux 系统启动过程</h2><p>可以分为5个阶段：<br>1) 内核的引导。<br>2) 运行 init。<br>3) 系统初始化。<br>4) 建立终端 。<br>5) 用户登录系统。  </p>
<p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。<br>init 程序首先是需要读取配置文件 /etc/inittab。   </p>
<h2 id="4-Linux-系统目录结构"><a href="#4-Linux-系统目录结构" class="headerlink" title="4 Linux 系统目录结构"></a>4 Linux 系统目录结构</h2><p>### note1<br>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。  </p>
<p>文件系统的最顶层是由根目录开始的，系统使用 / 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。   </p>
<p>### note2<br>1) 系统启动必须<br>/boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。<br>/etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。<br>/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。<br>/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中    </p>
<p>2) 指令集合：<br>/bin：存放着最常用的程序和指令<br>/sbin：只有系统管理员能使用的程序和指令。   </p>
<p>3) 外部文件管理：<br>/dev ：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。<br>/media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。<br>/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。  </p>
<p>4) 临时文件：<br>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。<br>/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。<br>/tmp：这个目录是用来存放一些临时文件的。    </p>
<p>5) 账户：<br>/root：系统管理员的用户主目录。<br>/home：用户的主目录，以用户的账号命名的。<br>/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<br>/usr/bin：系统用户使用的应用程序与指令。<br>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。<br>/usr/src：内核源代码默认的放置目录。    </p>
<p>6) 运行过程中要用：<br>/var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。<br>/proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。   </p>
<p>7) 扩展用的：<br>/opt：默认是空的，我们安装额外软件可以放在这个里面。<br>/srv：存放服务启动后需要提取的数据（不用服务器就是空）  </p>
<h2 id="5-Linux-忘记密码解决方法"><a href="#5-Linux-忘记密码解决方法" class="headerlink" title="5 Linux 忘记密码解决方法"></a>5 Linux 忘记密码解决方法</h2><p>重新安装系统吗？当然不用！进入单用户模式更改一下root密码即可。  </p>
<h2 id="6-Linux-远程登录"><a href="#6-Linux-远程登录" class="headerlink" title="6 Linux 远程登录"></a>6 Linux 远程登录</h2><p>Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为 22。<br>Window系统上 Linux 远程登录客户端有SecureCRT, Putty, SSH Secure Shell等，本文以Putty为例来登录远程服务器。<br>$PS: 用 X-Shell  </p>
<h3 id="使用密钥认证机制远程登录linux"><a href="#使用密钥认证机制远程登录linux" class="headerlink" title="使用密钥认证机制远程登录linux"></a>使用密钥认证机制远程登录linux</h3><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。<br>SSH 为建立在应用层和传输层基础上的安全协议。        </p>
<h2 id="7-Linux-文件基本属性"><a href="#7-Linux-文件基本属性" class="headerlink" title="7 Linux 文件基本属性"></a>7 Linux 文件基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。<br>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：<br>dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot   </p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。<br>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。  </p>
<p>每个文件的属性由左边第一部分的10个字符来确定<br>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。<br>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。<br>对于 root 用户来说，一般情况下，文件的权限对其不起作用。   </p>
<p>当为[ d ]则是目录<br>当为[ - ]则是文件；<br>若是[ l ]则表示为链接文档(link file)；<br>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
<h3 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h3><p>1、chgrp：更改文件属组   chgrp [-R] 属组名 文件名<br>2、chown：更改文件属主，也可以同时更改文件属组  chown [–R] 属主名 文件名 ，chown [-R] 属主名：属组名 文件名<br>3、chmod：更改文件9个属性<br>Linux文件属性有两种设置方法，一种是数字，一种是符号。<br>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。<br>可以使用 u, g, o 来代表三种身份的权限！<br>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x<br>+(加入)，-(除去)，=(设定)  </p>
<p>chmod [-R] xyz 文件或目录： chmod 777 .bashrc<br>chmod u=rwx,g=rx,o=r 文件名：  chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限  </p>
<p>将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限：chmod  a-x test1  </p>
<h2 id="8-Linux-文件与目录管理"><a href="#8-Linux-文件与目录管理" class="headerlink" title="8 Linux 文件与目录管理"></a>8 Linux 文件与目录管理</h2><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。<br>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。  </p>
<h3 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h3><p>接下来我们就来看几个常见的处理目录的命令吧：<br>ls: 列出目录  -a -d -l   $PS:-al<br>cd：切换目录 [相对路径或绝对路径]  $PS:~ 亦即是 /root 这个目录; cd ..<br>pwd：显示目前的目录 -P $PS: Print Working Directory<br>    &gt; 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail<br>    &gt; 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！<br>mkdir：创建一个新的目录 -m -p<br>    mkdir -p test1/test2/test3/test4  $PS:没办法直接创建此目录啊！要加参数 -p<br>    mkdir -m 711 test2<br>rmdir：删除一个空的目录  -p ：连同上一级『空的』目录也一起删除； $PS: 仅能删除空<br>cp: 复制文件或目录  -a==-pdr, -d,-f,-i,-l,-s,-u<br>rm: 移除文件或目录   -fir<br>mv: 移动文件与目录，或修改文件与目录的名称  -fiu<br>你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。       </p>
<h3 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h3><p>Linux系统中使用以下命令来查看文件的内容：$PS: 参数自己查，可以用man命令<br>cat  由第一行开始显示文件内容<br>tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！<br>nl   显示的时候，顺道输出行号！<br>more 一页一页的显示文件内容<br>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！<br>head 只看头几行<br>tail 只看尾巴几行<br>### note<br>1.Linux 链接概念<br>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。     </p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。…<br>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。   </p>
<p>软连接:符号连接（Symbolic Link）。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。…<br>A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。  </p>
<h2 id="9-Linux-用户和用户组管理"><a href="#9-Linux-用户和用户组管理" class="headerlink" title="9 Linux 用户和用户组管理"></a>9 Linux 用户和用户组管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。  </p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：<br>用户账号的添加、删除与修改。<br>用户口令的管理。<br>用户组的管理。</p>
<h3 id="一、Linux系统用户账号的管理"><a href="#一、Linux系统用户账号的管理" class="headerlink" title="一、Linux系统用户账号的管理"></a>一、Linux系统用户账号的管理</h3><p>useradd 选项 用户名<br>userdel 选项 用户名<br>usermod 选项 用户名:  修改帐号<br>passwd 选项 用户名:用户口令的管理,用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。  </p>
<h3 id="Linux系统用户组的管理"><a href="#Linux系统用户组的管理" class="headerlink" title="Linux系统用户组的管理"></a>Linux系统用户组的管理</h3><p>groupadd 选项 用户组<br>groupdel 用户组<br>groupmod 选项 用户组<br>newgrp root:如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。  </p>
<h3 id="三、与用户账号有关的系统文件"><a href="#三、与用户账号有关的系统文件" class="headerlink" title="三、与用户账号有关的系统文件"></a>三、与用户账号有关的系统文件</h3><p>1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件。<br>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。<br>这个文件对所有用户都是可读的。它的内容类似下面的例子：<br>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：<br>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell<br>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。<br>8)系统中有一类用户称为伪用户（pseudo users）。<br>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。<br>常见的伪用户如下所示：<br>bin 拥有可执行的用户命令文件<br>sys 拥有系统文件<br>adm 拥有帐户文件<br>uucp UUCP使用<br>lp lp或lpd子系统使用<br>nobody NFS使用<br>#### 拥有帐户文件<br>### 四、添加批量用户  </p>
<h2 id="10-Linux-磁盘管理"><a href="#10-Linux-磁盘管理" class="headerlink" title="10 Linux 磁盘管理"></a>10 Linux 磁盘管理</h2><p>Linux磁盘管理常用三个命令为df、du和fdisk。<br>df：列出文件系统的整体磁盘使用量   [-ahikHTm]<br>du：检查磁盘空间使用量      [-ahskm]   :du [-ahskm] 文件或目录名称<br>    Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的<br>fdisk：用于磁盘分区   [-l]   </p>
<p>磁盘格式化: mkfs [-t 文件系统格式] 装置文件名<br>磁盘检验: fsck [-t 文件系统] [-ACay] 装置名称<br>磁盘挂载: mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点<br>磁盘卸除: umount [-fn] 装置文件名或挂载点    </p>
<h2 id="11-Linux-vi-vim"><a href="#11-Linux-vi-vim" class="headerlink" title="11 Linux vi/vim"></a>11 Linux vi/vim</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。<br>但是目前我们使用比较多的是 vim 编辑器。   </p>
<h3 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h3><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。  </p>
<h3 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h3><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：<br>1) 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。<br>以下是常用的几个命令：<br>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。<br>: 切换到底线命令模式，以在最底一行输入命令。    </p>
<p>2) 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。     </p>
<p>3) 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。<br>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>q 退出程序<br>w 保存文件<br>按ESC键可随时退出底线命令模式。 </p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p>### vi/vim 使用实例  </p>
<h4 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h4><p>第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等<br>移动光标的方法<br>你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键<br>搜索替换<br>删除、复制与贴上   </p>
<p>第二部份：一般模式切换到编辑模式的可用的按钮说明<br>进入输入或取代的编辑模式<br>第三部份：一般模式切换到指令行模式的可用的按钮说明<br>指令行的储存、离开等指令<br>vim 环境的变更  </p>
<h2 id="12-linux-yum-命令"><a href="#12-linux-yum-命令" class="headerlink" title="12 linux yum 命令"></a>12 linux yum 命令</h2><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。<br>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。      </p>
<p>yum [options] [command] [package …]  </p>
<p style="text-align:right">20:15</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Js使用记录2</title>
    <url>/sum/js/js%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<p style="text-align:right">2019.2.12 星期二 </p>


<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol>
<li><code>~~</code>等价于<code>Math.floor</code>. ~~3.6=3(=~(~3.6)=~(-4+1)); ~3.6 = -4 (-(3+1))<br> 反码(~)：二进制进行反码计算时。1变成0，0变成1。<br> 举例子~6,6的二进制是110在机器上补足32位在110之前补码0。那么反码为111…..001，此时的反码减去1得111…..111000，那么原反码减去相减的码得到0000….000111此时的十进制为-7<br> 那么加上原来减去的1得到-7+1就是~6了。（这个我也不是很懂。大牛们指正下）</li>
<li><p>字符串为空的true和false判断.注意 <code>!</code>判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">''</span>,s1=<span class="string">'  '</span>; </span><br><span class="line">!s==<span class="literal">true</span><span class="comment">// true</span></span><br><span class="line">!s1==<span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">s==<span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">s1==<span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>js保留两位小数:tofixed 返回字符串，不能直接进行数字操作,需要转为数字  </p>
</li>
<li>单例/字面量 定义时无法使用单例的方法   </li>
<li>未定义的全局变量不可以直接使用，需要用window.varity,比如定义对象的属性值时   </li>
<li>int,long,float,double的 +, -, *  运算性能是一样的，除法运算比较慢，占用时间较多，要尽量避免除法。<br>即：加，减，乘的运算时间与数据类型无关，所以可以随意使用更精确的float、double型，不影响程序速度。   </li>
<li>console.log(3+2?’1’:’2’)  //1<br> console.log(3+2&amp;&amp;4) // 4<br> console.log(3+2) // 5</li>
</ol>
<ol start="6">
<li><p>对象数组去重<br> <a href="https://blog.csdn.net/cheeso/article/details/83348710" target="_blank" rel="noopener">js 删除两个数组中id相同的对象</a>   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = res.data</span><br><span class="line"><span class="keyword">let</span> arr1 = [...this.list]</span><br><span class="line">arr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arrlist = arr1.map(<span class="function"><span class="params">v</span> =&gt;</span> v.id)</span><br><span class="line">    <span class="keyword">return</span> !arrlist.includes(item.id)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">this</span>.data2 = arr</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取月份最后一天。比如2月最后一天, <code>new Date(2019,2,0).getDate()</code></p>
</li>
</ol>
<h3 id="DOM-相关"><a href="#DOM-相关" class="headerlink" title="DOM 相关"></a>DOM 相关</h3><ol>
<li>获取select选择option <code>this.selectedIndex; this.selectedOptions[0]</code></li>
<li><p>获取图片的元素宽高<br>需要等img加载完成后才可以获取到，否则第一次是空。除非，有缓存或者加载图片比js执行快<br># <a href="https://www.cnblogs.com/intangible/p/7202317.html" target="_blank" rel="noopener">js获取图片信息（一）—–获取图片的原始尺寸</a>    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"oImg"</span>), w,h;</span><br><span class="line"><span class="keyword">if</span> (oImg.naturalWidth) &#123;</span><br><span class="line">　　<span class="comment">// HTML5 browsers</span></span><br><span class="line">　　w = oImg.naturalWidth;</span><br><span class="line">　　h = oImg.naturalHeight;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// IE 6/7/8</span></span><br><span class="line">　　<span class="keyword">var</span> nImg = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="comment">//      nImg.src = oImg.src;</span></span><br><span class="line">　　nImg.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　w = nImg.width;</span><br><span class="line">　　　　h = nImg.height;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(w + <span class="string">"  "</span> + h)</span><br><span class="line">　　&#125;</span><br><span class="line">　　nImg.src = oImg.src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准浏览器使用document.documentElement，低版本IE使用document.body  </p>
</li>
<li><p>原生方式事件代理bind，父元素绑定</p>
</li>
<li>事件绑定once实现   </li>
<li>ready：DOMContendLoaded . onload:window,img</li>
<li>a标签click，href先后顺序<br> “a标签onclick事件会在href属性生效前优先执行！”！<br>解决方法: 在onclick事件上做个setTimeout的短暂延时，使得onclick里面的事件因延时,在地址栏网址被修改后再去捕捉最新的地址栏链接！<br>[<a href="https://www.jb51.net/article/103151.htm" target="_blank" rel="noopener">详解Html a标签中href和onclick用法、区别、优先级别</a><br>Html A标签中 href 和 onclick 同时使用的问题 优先级别<br>1 顺序<br>ie 6 : href 先触发 onclick 后触发<br>其他浏览器 先触发onlick 后触发 href<br>2 <code>href=&quot;javascript: xxx()&quot;</code><br>不能传入this作为参数<br>onclick可以<br>3 优先触发的方法如果返回 false 导致后一个事件不被触发<br>6 总结：<br>1) 在不需要传递this作为方法的参数时候，推荐<br>只使用href=”JavaScript: “<br>2) 如果需要使用this参数，推荐<br>代码如下<br><code>&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;doSomthing(this)&quot; &gt;</code></li>
</ol>
<p><a href="http://www.cnblogs.com/iyangyuan/p/3979957.html" target="_blank" rel="noopener">html中a标签href属性的一个坑</a><br>此URL后边有一个name参数，只不过参数的值竟然带了空格，这样的链接，直接用android浏览器访问，是没有问题的，但用ios的浏览器访问，这就是一个错误的URL，会报错的！</p>
<p>所以，我们会想到编码，name参数的值，可以用encodeURIComponent()方法进行编码，然后再拼接到URL上，这样就安全了（encodeURIComponent是js原生方法，直接用即可）。</p>
<p>由此可见：“万恶”的href属性，在调用openURL传参时自动解码，而onclick属性则保持参数原封不动。</p>
<p>因此，小菜强烈不推荐使用a标签的href属性调用js，onclick方法非常的科学，非常的稳定，非常的正确，href的本意就是用来跳转URL，就不要用它来执行js啦。其实更好的做法是绑定事件，那样代码更好管理，看起来也整洁。   </p>
<ol start="4">
<li>javascript中获取dom元素高度和宽度<!-- [javascript中获取dom元素高度和宽度]<https://www.cnblogs.com/gopark/p/9008175.html>   -->
</li>
</ol>
<p>javascript中获取dom元素高度和宽度的方法如下：<br>网页可见区域宽： document.body.clientWidth<br>网页可见区域高： document.body.clientHeight<br>网页可见区域宽： document.body.offsetWidth (包括边线的宽)<br>网页可见区域高： document.body.offsetHeight (包括边线的高)<br>网页正文全文宽： document.body.scrollWidth<br>网页正文全文高： document.body.scrollHeight<br>网页被卷去的高： document.body.scrollTop<br>网页被卷去的左： document.body.scrollLeft          </p>
<p>对应的dom元素的宽高有以下几个常用的：<br>元素的实际高度：document.getElementById(“div”).offsetHeight<br>元素的实际宽度：document.getElementById(“div”).offsetWidth<br>元素的实际距离左边界的距离：document.getElementById(“div”).offsetLeft<br>元素的实际距离上边界的距离：document.getElementById(“div”).offsetTop</p>
<ol start="5">
<li><p>滚动到顶部。滚动条在Y轴上的滚动距离，文档的总高度,浏览器视口的高度<br>$BLOB: 滚动条操作25## ## 判断div是否滚动到底部<br># <a href="https://www.jb51.net/article/42744.htm" target="_blank" rel="noopener">[判断滚动条到底部的JS代码]</a>    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滚动条在Y轴上的滚动距离</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> scrollTop = <span class="number">0</span>, bodyScrollTop = <span class="number">0</span>, documentScrollTop = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.body)&#123;</span><br><span class="line">　　　　bodyScrollTop = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.documentElement)&#123;</span><br><span class="line">　　　　documentScrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollTop = (bodyScrollTop - documentScrollTop &gt; <span class="number">0</span>) ? bodyScrollTop : documentScrollTop;</span><br><span class="line">　　<span class="keyword">return</span> scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文档的总高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollHeight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> scrollHeight = <span class="number">0</span>, bodyScrollHeight = <span class="number">0</span>, documentScrollHeight = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.body)&#123;</span><br><span class="line">　　　　bodyScrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.documentElement)&#123;</span><br><span class="line">　　　　documentScrollHeight = <span class="built_in">document</span>.documentElement.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; <span class="number">0</span>) ? bodyScrollHeight : documentScrollHeight;</span><br><span class="line">　　<span class="keyword">return</span> scrollHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浏览器视口的高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWindowHeight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> windowHeight = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">　　　　windowHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　windowHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> windowHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(getScrollTop() + getWindowHeight() == getScrollHeight())&#123;</span><br><span class="line">　　　　alert(<span class="string">"you are in the bottom!"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动端JS判断手势方向<br>当出现滚动时候，获取y轴距离的时候要加上滚动高度，不然高度差一直是0<br><a href="https://www.cnblogs.com/ranyonsue/p/7404173.html" target="_blank" rel="noopener">[移动端JS判断手势方向]</a>    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移动端判断滑动方向：左右上下滑动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAngle</span>(<span class="params">dx, dy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(-dy,dx) * <span class="number">180</span> / <span class="built_in">Math</span>.PI;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDirection</span>(<span class="params">startx,starty,endx,endy</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dx =endx-startx;</span><br><span class="line">    <span class="keyword">var</span> dy =endy-starty</span><br><span class="line">    dy+=(getScrollTop()-scrollStartTop) <span class="comment">// scroll will have influence on y,beacuse when scroll dy is always less then 10</span></span><br><span class="line">    <span class="comment">// console.log('dx ,dy:',dx,dy)</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(dx)&lt;<span class="number">2</span>&amp;&amp;<span class="built_in">Math</span>.abs(dy)&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* if(Math.abs(dy)&lt;15)&#123;</span></span><br><span class="line"><span class="comment">        if(dx&lt;-10)&#123;</span></span><br><span class="line"><span class="comment">            result=4</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(dx&gt;10)&#123;</span></span><br><span class="line"><span class="comment">            result=2</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="keyword">var</span> angle = getAngle(dx,dy);</span><br><span class="line">    <span class="comment">// if(angle &gt;= -45 &amp;&amp; angle &lt; 45) &#123; </span></span><br><span class="line">    <span class="keyword">if</span>(angle &gt;= <span class="number">-25</span> &amp;&amp; angle &lt; <span class="number">25</span>) &#123; </span><br><span class="line">        result = <span class="number">2</span>; </span><br><span class="line">    <span class="comment">// &#125;else if (angle &gt;= 45 &amp;&amp; angle &lt; 135) &#123; </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">25</span> &amp;&amp; angle &lt; <span class="number">155</span>) &#123; </span><br><span class="line">        result = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// &#125;else if (angle &gt;= -135 &amp;&amp; angle &lt; -45) &#123; </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">-155</span> &amp;&amp; angle &lt; <span class="number">-25</span>) &#123; </span><br><span class="line">        result = <span class="number">3</span>; </span><br><span class="line">    <span class="comment">// &#125; else if ((angle &gt;= 135 &amp;&amp; angle &lt;= 180) || (angle &gt;= -180 &amp;&amp; angle &lt; -135)) &#123; </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((angle &gt;= <span class="number">155</span> &amp;&amp; angle &lt;= <span class="number">180</span>) || (angle &gt;= <span class="number">-180</span> &amp;&amp; angle &lt; <span class="number">-155</span>)) &#123; </span><br><span class="line">        result = <span class="number">4</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if ( Math.abs(dx) &gt; Math.abs(dy) &amp;&amp; dx &gt; 0 ) &#123;</span></span><br><span class="line"><span class="comment">        // alert("left 2 right");</span></span><br><span class="line"><span class="comment">        result=2</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if ( Math.abs(dx) &gt; Math.abs(dy) &amp;&amp; dx &lt; 0 ) &#123;</span></span><br><span class="line"><span class="comment">        // alert("right 2 left");</span></span><br><span class="line"><span class="comment">        result=4</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if ( Math.abs(dy) &gt; Math.abs(dx) &amp;&amp; dy &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">        // alert("top 2 bottom");</span></span><br><span class="line"><span class="comment">        result=3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if ( Math.abs(dy) &gt; Math.abs(dx) &amp;&amp; dy &lt; 0 ) &#123;</span></span><br><span class="line"><span class="comment">        // alert("bottom 2 top");</span></span><br><span class="line"><span class="comment">        result=1</span></span><br><span class="line"><span class="comment">    &#125; else&#123;</span></span><br><span class="line"><span class="comment">        // alert("just touch");</span></span><br><span class="line"><span class="comment">        result=0</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">// console.log('y x angle',dy,dx,angle,result);</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addEventListener IE兼容</p>
</li>
<li><p>为什么不用try  catch 处理</p>
</li>
<li><p>不能用frag的innerHTML，需要用 fragment.appendChild(some element)<br><a href="https://stackoverflow.com/questions/8202195/using-document-createdocumentfragment-and-innerhtml-to-manipulate-a-dom" target="_blank" rel="noopener">using document.createDocumentFragment() and innerHTML to manipulate a DOM</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">frag.innerHTML = aWholeHTMLDocument;</span><br></pre></td></tr></table></figure>
</li>
<li><p>追加html，<code>element.insertAdjacentHTML(position, text);</code><br>position 是相对于 element 元素的位置，并且只能是以下的字符串之一：<br>beforebegin：在 element 元素的前面。<br>afterbegin：在 element 元素的第一个子节点前面。<br>beforeend：在 element 元素的最后一个子节点后面。<br>afterend：在 element 元素的后面。</p>
</li>
</ol>
<p>text 是字符串，会被解析成 HTML 或 XML，并插入到 DOM 树中。</p>
<!-- [原生 js 如何追加 html](https://segmentfault.com/q/1010000007420031) -->
<ol>
<li><p>原生手动触发click. dom.click() 或者document.createEvent();dispatchEvent(Event)<br><a href="http://www.cnblogs.com/jetwu/archive/2011/11/07/2239631.html" target="_blank" rel="noopener">JS中手动触发事件</a><br><code>void initEvent(String eventTypeArg,boolean canBubbleArg,boolean cancelableArg)</code> HTMLEvents,MouseEvents,UIEvents</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all)&#123; <span class="comment">//For Ie</span></span><br><span class="line">     fireOnThis.click();</span><br><span class="line"> &#125;</span><br><span class="line"> elseif (<span class="built_in">document</span>.createEvent) &#123;<span class="comment">//FOR DOM2</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> ev = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</span><br><span class="line">     ev.initEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">     fireOnThis.dispatchEvent(ev);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>光标定位到最后位置    </p>
</li>
<li><p>js获取伪类。最后通过给元素切换类名，不同的类名下，对应不同的伪类css样式.<br> 还有方法计算值，是利用元素的属性<code>content: attr(data-value)</code><br><a href="https://www.zhihu.com/question/264684026" target="_blank" rel="noopener">js能获取，修改伪类元素:before或:after吗？</a>   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sheet = style.sheet <span class="comment">// 获取到stylesheet</span></span><br><span class="line"><span class="comment">// Use addRule or insertRule to inject styles</span></span><br><span class="line">sheet.addRule(<span class="string">'.red::before'</span>,<span class="string">'color: green'</span>);</span><br><span class="line">sheet.insertRule(<span class="string">'.red::before &#123; color: green &#125;'</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>// <a href="http://www.webhek.com/post/pseudo-element.html" target="_blank" rel="noopener">用JavaScript获取伪元素(Pseudo-Element)属性的方法</a></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> color = <span class="built_in">window</span>.getComputedStyle(</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.element'</span>), <span class="string">':before'</span>).getPropertyValue(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ol>
<li>promise.all 返回：只要都resolve或者只要有catch</li>
<li>promise.finally 兼容</li>
<li>async 实现不按顺序请求：paWeibo，imgsLoading 都没有实现  </li>
<li>async 没有finally</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://www.jb51.net/article/42327.htm" target="_blank" rel="noopener">ajax与302响应代码测试</a><br><a href="http://www.cnblogs.com/dudu/p/ajax_302_found.html" target="_blank" rel="noopener">ajax与302响应</a><br>也就是说，重定向是由浏览器自动透明的完成的。所以服务器将302响应发给浏览器时，浏览器并不是直接处理ajax的回调，而是先执行302重定向。这就是上面例子中为什么获取不到xhr.status为302的值。</p>
<p>一个ajax请求的重定向大致流程是这样的：</p>
<p>ajax –&gt; browser –&gt; server –&gt; 302 –&gt; browser(redirect) –&gt; server –&gt; browser –&gt; ajax callback<br>注意，上面ajax获取不到xhr的status是有一个前提：即，服务器为response设置了<em>Location</em> header。</p>
<p>因为，浏览器在发现Location的header时就会自动跳转到Location所指定的URL地址，类似于用js来进行重定向；不过这个重定向只有浏览器知道。<br>所以，在ajax接口返回302时，而没有设置Location的header时，这个xhr的status值还是能获取到的，下图是在浏览器控制台测试的结果：</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Php使用记录</title>
    <url>/sum/ser/php%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p style="text-align:right">2019.2.12 星期二 </p>

<p>php 文档：<a href="https://www.php.net/manual/zh/dbase.installation.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/dbase.installation.php</a><br>    <a href="https://www.php.net/manual/en/dbase.installation.php" target="_blank" rel="noopener">https://www.php.net/manual/en/dbase.installation.php</a><br>php 扩展安装地址： <a href="http://pecl.php.net/" target="_blank" rel="noopener">http://pecl.php.net/</a>        </p>
<p>pecl： 可以按照 wget，npm,composer  理解<br>linux: 1.yum或者apt-get安装        2.使用pecl安装  3.(wget) phpize安装——以redis为例  4.直接安装（类似windows）</p>
<ol start="0">
<li>nginx 配置和 cgi, fast cgi. 和php-fpm<br> php 5 的项目，改动文件需要执行 <code>service php-fpm restart</code>.<br> 而php 7 不需要。</li>
<li>`&lt;?php phpinfo(); ?&gt;  函数会直接输出/查看php 的相关配置信息。  </li>
<li>查看php安装的扩展：phpinfo()，php -m，get_loaded_extensions()函数</li>
<li>php 输出错误信息，可以修改配置。也可以在php文件中，写函数。<br> 1) display_errors:On,log_errors:On ,error_log: 将出错信息输出到一个文本文件<br> 2) ini_set(‘display_errors’,1);  ini_set(‘error_log’, dirname(<strong>FILE</strong>) . ‘/error_log.txt’)<br> ini_set(‘display_errors’, true);<br> error_reporting(E_ALL ^ E_WARNING ^ E_NOTICE);</li>
<li>php 语法报错：PHP号称变量可以直接调用，原来是假的。<br> <code>Notice: Undefined offset</code>：初始化数组变量：$a[] = 0<br> 1） 更改php.ini文件中error_repoting的参数为”EALL &amp; Notice “,<br> 2） 简单的可以在当前文件的最前面加上一句”error_reporting(填offset:接下去的那个数字);<br> 3） 其实在报错的那一行前面加一个@符号，屏蔽错误就ok了。非常简单。  </li>
<li>文件可以设置报错级别：error_reporting(0);</li>
</ol>
<ol>
<li>php 5 不支持数组新写法 等php7 的语法：<code>$arr=[1,2,3];</code><br> 有的项目中，会导致页面空白，也不报错。</li>
</ol>
<ol>
<li>php 可以引入不同的配置文件 conf.inc,db.conf.inc; conf.test.inc 等<br> 可以在fastcgi_params配置php服务器nginx环境变量。或者直接写在nginx.conf, fastcgi.conf配置中。<br> 两种方式调用：<code>$env = getenv(&#39;RUNTIME_ENVIROMENT&#39;);$env = $_SERVER[&#39;RUNTIME_ENVIROMENT&#39;];</code> <!-- 参考：[为PHP设置服务器(Apache/Nginx)环境变量](https://blog.csdn.net/ebw123/article/details/47418555)   -->
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastcgi_param RUNTIME_ENVIROMENT &apos;DEV&apos;;</span><br><span class="line">fastcgi_param MYSQL_USERNAME &apos;root&apos;;</span><br><span class="line">fastcgi_param MYSQL_PASSWORD &apos;root&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>在Mix_pc Coupon中使用方式如下如下
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # 0 ConfigEvn.inc </span></span><br><span class="line"><span class="comment">//该常量决定使用哪个环境的的配置 可以的值 Online,Test,prod</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'MIXENV'</span>])&amp;&amp;!<span class="keyword">empty</span>($_SERVER[<span class="string">'MIXENV'</span>]))&#123;</span><br><span class="line">	defined(<span class="string">"DIR_ENV"</span>) <span class="keyword">or</span> define(<span class="string">"DIR_ENV"</span>, $_SERVER[<span class="string">'MIXENV'</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	defined(<span class="string">"DIR_ENV"</span>) <span class="keyword">or</span> define(<span class="string">"DIR_ENV"</span>, <span class="string">'Online'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// # 1 CouponConf.inc. </span></span><br><span class="line"><span class="comment">// 引入不同的配置文件   </span></span><br><span class="line"><span class="keyword">if</span>(!defined(<span class="string">'DIR_ENV'</span>)) &#123;</span><br><span class="line">	<span class="keyword">include</span> <span class="string">'ConfigEvn.inc'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span> DIR_ENV.<span class="string">'/CouponConf.inc'</span>;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>php 对象属性<code>$obj-&gt;attr</code>. 数组值 <code>$arr[&#39;index&#39;]</code></li>
<li>php 比较大小（接口code）:  ‘111ssd’ == 111,  ‘sss’==0.<br> 取字符串前面的数字，如果没有就是0.    </li>
<li><p>php默认赋值需要通过三元操作符，不能通过短路运算符(js)<br>php:<code>$b=$a?$a:&#39;&#39;</code><br> js:<code>var b=a||&#39;&#39;</code></p>
</li>
<li><p>foreach遍历数组的顺序是按照值存入数组的先后顺序进行遍历的，此为线性遍历，不受数组键值的大小顺序影响。</p>
 <!-- [PHP 数组遍历顺序理解](https://www.jb51.net/article/19948.htm) -->
<p> 在PHP中, 数组是用一种HASH结构(HashTable)来实现的, PHP使用了一些机制, 使得可以在O(1)的时间复杂度下实现数组的增删, 并同时支持线性遍历和随机访问<br> 也就是说, PHP中遍历数组的顺序, 是和元素的添加先后相关的, 那么, 现在我们就很清楚的知道, 文章开头的问题的输出是:</p>
<p> 所以, 如果你想在数字索引的数组中按照索引大小遍历, 那么你就应该使用for, 而不是foreach </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for($i=0,$l=count($arr); $i&lt;$l; $i++) &#123; </span><br><span class="line">	//这个时候,不能认为是顺序遍历(线性遍历) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>php 通过<code>file_get_contents(&#39;php://input&#39;)</code>获取前端提交的json数据。在用fetch的时候，传了json<code>$_POST</code>接收不到，jquery的ajax可以，做dangd收藏的时候使用的fetch，是把数据手动改成form-data/<a href="http://www.form-encodedurl" target="_blank" rel="noopener">www.form-encodedurl</a>    </li>
</ol>
<p><a href="https://www.cnblogs.com/cqingt/p/5853566.html" target="_blank" rel="noopener">PHP接收JSON格式的数据</a><br>在API服务中，目前流行采用json形式来交互。</p>
<p>给前端调用的接口输出Json数据，这个比较简单，只需要组织好数据，用json_encode($array) 转化一下，前端就得到json格式的数据。</p>
<p>接收前端提交的json数据稍微复杂一点，原因是：PHP默认识别的数据类型是application/x-<a href="http://www.form-urlencoded标准的数据类型。因此，对型如text/xml" target="_blank" rel="noopener">www.form-urlencoded标准的数据类型。因此，对型如text/xml</a> 或者 soap 或者 application/octet-stream 和application/json格式之类的内容无法解析，如果用$_POST数组来接收就会失败！</p>
<p>此时可以使用$GLOBALS[‘HTTP_RAW_POST_DATA’]  或  file_get_contents(‘php://input’) 来获取提交的数据</p>
<p>查看手册，可以发现$GLOBALS[‘HTTP_RAW_POST_DATA’]  和  $_POST的区别：<br>$_POST：通过 HTTP POST 方法传递的变量组成的数组，是自动全局变量。</p>
<p>$GLOBALS[‘HTTP_RAW_POST_DATA’] ：总是产生 $HTTP_RAW_POST_DATA 变量包含有原始的 POST 数据。此变量仅在碰到未识别 MIME 类型的数据时产生。$HTTP_RAW_POST_DATA 对于 enctype=”multipart/form-data” 表单数据不可用。也就是说基本上$GLOBALS[‘HTTP_RAW_POST_DATA’] 和 $_POST是一样的。但是如果post过来的数据不是PHP能够识别的，你可以用 $GLOBALS[‘HTTP_RAW_POST_DATA’]来接收，比如 text/xml 或者 soap 等等。</p>
<p>补充说明：PHP默认识别的数据类型是application/x-<a href="http://www.form-urlencoded标准的数据类型。" target="_blank" rel="noopener">www.form-urlencoded标准的数据类型。</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js常用方法</title>
    <url>/sum/js/js%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p style="text-align:right">2019.2.5 星期三 16:35</p>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^| )"</span>+name+<span class="string">"=([^;]*)(;|$)"</span>)</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="built_in">document</span>.cookie.match(reg)</span><br><span class="line">    <span class="keyword">return</span> (arr?arr[<span class="number">2</span>]:<span class="literal">null</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 设置存储数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStorage</span>(<span class="params">key, val, cookie, day</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = key + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(val),</span><br><span class="line">        days = (<span class="keyword">typeof</span>(day) == <span class="string">'undefined'</span> || day == <span class="number">0</span>) ? <span class="number">3650</span> : day,<span class="comment">// 过期时间，默认10年</span></span><br><span class="line">        exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    exp.setTime(exp.getTime() + days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    cookie = cookie + <span class="string">";domain="</span> + cookieDomain + <span class="string">";path=/;expires="</span> + exp.toGMTString();</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除存储数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delStorage</span>(<span class="params">key, cookie</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($.trim(key))&#123;</span><br><span class="line">        <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            cval = getStorage(key, <span class="string">'cookie'</span>);</span><br><span class="line">        exp.setTime(exp.getTime() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(cval != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">document</span>.cookie = key + <span class="string">"="</span> + cval + <span class="string">";domain="</span> + cookieDomain + <span class="string">";path=/;expires="</span> + exp.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除存储数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearStorage</span>(<span class="params">cookie</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">document</span>.cookie.match(<span class="regexp">/[^ =;]+(?=\=)/g</span>);</span><br><span class="line">    <span class="keyword">if</span>(key)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = key.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">                cval = getStorage(key[i], <span class="string">'cookie'</span>);</span><br><span class="line">            exp.setTime(exp.getTime() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">document</span>.cookie = key[i] + <span class="string">"="</span> + cval + <span class="string">";domain="</span> + cookieDomain + <span class="string">";path=/;expires="</span> + exp.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数节流/去抖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (!previous) &#123;</span><br><span class="line">            previous = <span class="built_in">Date</span>.now()</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previous + wait &gt;= <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                <span class="comment">// console.log(timer)</span></span><br><span class="line">                clearTimeout(timer)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// console.log(timer)</span></span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// console.log(timer)</span></span><br><span class="line">                previous = <span class="built_in">Date</span>.now()</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous = <span class="built_in">Date</span>.now()</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/sum/js/js%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p style="text-align:right">2018.12.10 星期一 10:13 </p>

<p>String: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a>   </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>字符串字面量<br>String 函数将其他值生成或转换成字符串<br>### 模板字面量,<br>### 转义字符<br>### 长字符串<br>字符串写成多行: + 运算符;<br>其二，可以在每行末尾使用反斜杠字符（“\”），以指示字符串将在下一行继续。确保反斜杠后面没有空格或任何除换行符之外的字符或缩进; 否则反斜杠将不会工作   </p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>### 从字符串中获取单个字符<br>charAt 方法,字符串当作一个类似数组的对象(数值索引)      </p>
<p>### 字符串比较:比较操作符(&gt;/&lt;/&gt;=/&lt;=)     </p>
<h3 id="基本字符串和字符串对象的区别"><a href="#基本字符串和字符串对象的区别" class="headerlink" title="基本字符串和字符串对象的区别"></a>基本字符串和字符串对象的区别</h3><p>字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。<br><!-- JavaScript会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。    --></p>
<p>当使用 eval时，基本字符串和字符串对象也会产生不同的结果。eval 会将基本字符串作为源代码处理; 而字符串对象则被看作对象处理, 返回对象。 例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1 String / new String</span></span><br><span class="line"><span class="keyword">var</span> s_prim = <span class="string">"foo"</span>; <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s_obj = <span class="keyword">new</span> <span class="built_in">String</span>(s_prim);  <span class="comment">// String &#123;"foo"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s_prim); <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s_obj);  <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 eval </span></span><br><span class="line">s1 = <span class="string">"2 + 2"</span>;               <span class="comment">// creates a string primitive</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"2 + 2"</span>);   <span class="comment">// creates a String object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(s1));      <span class="comment">// returns the number 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(s2));      <span class="comment">// returns the string "2 + 2"</span></span><br></pre></td></tr></table></figure></p>
<p>## 属性<br>String.prototype   </p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>String.fromCharCode()<br>$PS:ES6<br>String.fromCodePoint():通过一串 码点 创建字符串。<br>String.raw():通过模板字符串创建字符串   </p>
<p>## 字符串泛型方法      </p>
<h2 id="String-实例"><a href="#String-实例" class="headerlink" title="String 实例"></a>String 实例</h2><p>### 属性<br>String.prototype.constructor:用于创造对象的原型对象的特定的函数。<br>String.prototype.length:返回了字符串的长度。<br>N:用于访问第N个位置的字符，其中N是小于 length 和 0之间的正整数。这些属性都是“只读”性质，不能编辑。    </p>
<h3 id="跟HTML无关的方法"><a href="#跟HTML无关的方法" class="headerlink" title="跟HTML无关的方法"></a>跟HTML无关的方法</h3><p>String.prototype.charAt():返回特定位置的字符。<br>String.prototype.charCodeAt():返回表示给定索引的字符的Unicode的值。<br>String.prototype.normalize():返回调用字符串值的Unicode标准化形式。<br><del>String.prototype.quote() :设置嵌入引用的引号类型。</del>      </p>
<p>String.prototype.localeCompare():返回一个数字表示是否引用字符串在排序中位于比较字符串的前面，后面，或者二者相同。       </p>
<p>String.prototype.indexOf():从字符串对象中返回首个被发现的给定值的索引值，如果没有找到则返回-1。<br>String.prototype.lastIndexOf():从字符串对象中返回最后一个被发现的给定值的索引值，如果没有找到则返回-1。     </p>
<p>String.prototype.toLocaleLowerCase():根据当前区域设置，将符串中的字符转换成小写。对于大多数语言来说，toLowerCase的返回值是 一致的。<br>String.prototype.toLocaleUpperCase():根据当前区域设置，将字符串中的字符转换成大写，对于大多数语言来说，toUpperCase的返回值 是一致的。<br>String.prototype.toLowerCase():将字符串转换成小写并返回。<br>String.prototype.toUpperCase():将字符串转换成大写并返回。       </p>
<p>String.prototype.toString():返回用字符串表示的特定对象。重写 Object.prototype.toString 方法。<br>String.prototype.toSource() :返回一个对象文字代表着特定的对象。你可以使用这个返回值来创建新的对象。重写Object.prototype.toSource 方法。    $PS:This API has not been standardized.<br>String.prototype.valueOf():返回特定对象的原始值。重写 Object.prototype.valueOf 方法。       </p>
<p>String.prototype.trim():从字符串的开始和结尾去除空格。参照部分 ECMAScript 5 标准。<br>String.prototype.trimLeft() :从字符串的左侧去除空格。$PS:This API has not been standardized.<br>String.prototype.trimRight() :从字符串的右侧去除空格。$PS:This API has not been standardized.      </p>
<p>String.prototype.concat():连接两个字符串文本，并返回一个新的字符串。<br>String.prototype.substring():返回在字符串中指定两个下标之间的字符。<br>String.prototype.substr():通过指定字符数返回在指定位置开始的字符串中的字符。<br>String.prototype.slice():摘取一个字符串区域，返回一个新的字符串。<br>String.prototype.split():通过分离字符串成字串，将字符串对象分割成字符串数组。       </p>
<p>String.prototype.search():对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。<br>String.prototype.match():使用正则表达式与字符串相比较。<br>String.prototype.replace():被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。     </p>
<p>$PS: ES6<br>String.prototype.codePointAt():返回使用UTF-16编码的给定位置的值的非负整数。     </p>
<p>String.prototype.includes():判断一个字符串里是否包含其他字符串。<br>String.prototype.startsWith():判断字符串的起始位置是否匹配其他字符串中的字符。<br>String.prototype.endsWith():判断一个字符串的结尾是否包含其他字符串中的字符。        </p>
<p>String.prototype.repeat():返回指定重复次数的由元素组成的字符串对象。<br>String.prototype.padEnd():在当前字符串尾部填充指定的字符串， 直到达到指定的长度。 返回一个新的字符串。<br>String.prototype.padStart():在当前字符串头部填充指定的字符串， 直到达到指定的长度。 返回一个新的字符串。<br>$PS: ES6 end    </p>
<p>String.prototype<a href>@@iterator</a>:返回一个新的迭代器对象，该对象遍历字符串值的索引位置，将每个索引值作为字符串值返回。     </p>
<p>## HTML wrapper methods<br>下面的方法被限制使用，因为只对可用的HTML标签和属性提供部分支持。<br>String.prototype.anchor()<br>String.prototype.link()<br>$PS:大多遗弃,比如:String.prototype.bold()   </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>### 将其他值转换成字符串<br>使用 String() 方法将其它对象转化为字符串可以被认为是一种更加安全的做法，虽然该方法底层使用的也是 toString() 方法，但是针对 null/undefined/symbols，String() 方法会有特殊的处理</p>
<p>$PS: toString<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object undefined]"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// "null"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// String &#123;"null"&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// String &#123;"undefined"&#125;</span></span><br><span class="line"><span class="comment">// ## Error</span></span><br><span class="line"><span class="literal">null</span>.toString() <span class="comment">//VM1110:1 Uncaught TypeError: Cannot read property 'toString' of null </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="literal">null</span>).toString() <span class="comment">// null</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>).toString() <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 数组的toString 方法 </span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]].toString()  <span class="comment">// "1,2,3,1,2,3"</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]].toString() <span class="comment">// "1,2,3,1,2,3,1,2,3"</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],&#123;<span class="attr">a</span>:<span class="number">2</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;].toString() <span class="comment">// "1,2,3,1,2,3,[object Object]"</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">11:22 </p>



]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Js正则表达式</title>
    <url>/sum/js/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p style="text-align:right">2018.12.10 星期一 12:33 </p>

<p>RegExp:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a>   </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>字面量, 构造函数和工厂符号都是可以的：<br>/pattern/flags<br>new RegExp(pattern [, flags])<br>RegExp(pattern [, flags])   </p>
<p>m:多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。<br>y:粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。  </p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ab+c/i;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/</span>, <span class="string">'i'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式中特殊字符的含义"><a href="#正则表达式中特殊字符的含义" class="headerlink" title="正则表达式中特殊字符的含义"></a>正则表达式中特殊字符的含义</h2><p>字符类别（Character Classes）:<code>\d,\D,\w,...</code><br>字符集合（Character Sets）: <code>[],[^],[1-9]</code><br>边界（Boundaries）:<code>\b,\B,^,$</code><br>分组（grouping）与反向引用（back references）:<code>(x),(?:x),\n</code><br>数量词（Quantifiers）:<code>*,*?,+,+?,?    ?=,?!,|,   {n},{n,},{n,m}</code><br>断言（Assertions）: <code>x(?=y), x(?!y)</code>    </p>
<p><code>.</code>:(点号，小数点) 匹配任意单个字符，但是行结束符除外：\n \r \u2028 或 \u2029。<br>在字符集中，点( . )失去其特殊含义，并匹配一个字面点( . )。<br>需要注意的是，m 多行（multiline）标志不会改变点号的表现。因此为了匹配多行中的字符集，可使用<code>[^]</code> （当然你不是打算用在旧版本 IE 中），它将会匹配任意字符，包括换行符。     </p>
<p><code>[\b]</code>匹配一个退格符（backspace）（不要与 \b 混淆）     </p>
<p><code>(x)</code>:匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。<br>例如，/(foo)/ 匹配且捕获 “foo bar.” 中的 “foo”。被匹配的子字符串可以在结果数组的元素 [1], …, [n] 中找到，或在被定义的 RegExp 对象的属性 $1, …, $9 中找到。<br>捕获组（Capturing groups）有性能惩罚。如果不需再次访问被匹配的子字符串，最好使用非捕获括号（non-capturing parentheses），见下面。   </p>
<p><code>(?:x)</code>:匹配 x 不会捕获匹配项。这被称为非捕获括号（non-capturing parentheses）。匹配项不能够从结果数组的元素 [1], …, [n] 或已被定义的 RegExp 对象的属性 $1, …, $9 再次访问到。      </p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>RegExp.prototype:允许为所有正则对象添加属性。<br>RegExp.length:值为 2。<br>Properties inherited from Function:arity, caller, constructor, length, name</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>全局对象 RegExp 自身没有方法, 不过它会继承一些方法通过原型链<br>Methods inherited from Function:apply, call, toSource, toString     </p>
<h2 id="RegExp-实例"><a href="#RegExp-实例" class="headerlink" title="RegExp 实例"></a>RegExp 实例</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>RegExp.prototype.constructor<br>RegExp.prototype.global<br>RegExp.prototype.ignoreCase<br>RegExp.prototype.lastIndex<br>RegExp.prototype.multiline:是否开启多行模式匹配（影响 ^ 和 $ 的行为）。<br>RegExp.prototype.source:正则对象的源模式文本。<br>RegExp.prototype.sticky :是否开启粘滞匹配。<br>Properties inherited from Object:<code>__parent__, __proto__</code>        </p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>RegExp.prototype.exec()<br>RegExp.prototype.test()<br>RegExp.prototype.toSource() :返回一个字符串，其值为该正则对象的字面量形式。覆盖了Object.prototype.toSource 方法.<br>RegExp.prototype.toString():返回一个字符串，其值为该正则对象的字面量形式。覆盖了<br>Methods inherited from Object:   </p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>+++++++++++++++++++</p>
<h1 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec</a>   </p>
<p>如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。<br>如果匹配失败，exec() 方法返回 null。    </p>
<p>### result:<br>[0]    匹配的全部字符串<br>[1], …[n ] : 括号中的分组捕获<br>index:匹配到的字符位于原始字符串的基于0的索引值<br>input:原始字符串<br>### re<br>lastIndex: 下一次匹配开始的位置    25<br>ignoreCase: 是否使用了 “i” 标记使正则匹配忽略大小写    true<br>global: 是否使用了 “g” 标记来进行全局的匹配.    true<br>multiline: 是否使用了 “m” 标记使正则工作在多行模式（也就是，^ 和 $ 可以匹配字符串中每一行的开始和结束（行是由 \n 或 \r 分割的），而不只是整个输入字符串的最开始和最末尾处。）   </p>
<p>false<br>source    正则匹配的字符串<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex1 = <span class="built_in">RegExp</span>(<span class="string">'foo*.'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'table football, foosball'</span>;</span><br><span class="line"><span class="keyword">var</span> array1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((array1 = regex1.exec(str1)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;array1[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regex1.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: "Found foot. Next starts at 9."</span></span><br><span class="line">  <span class="comment">// expected output: "Found foos. Next starts at 19."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## return    </span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/quick\s(brown).+?(jumps)/ig</span>;</span><br><span class="line"><span class="keyword">var</span> result = re.exec(<span class="string">'The Quick Brown Fox Jumps Over The Lazy Dog'</span>);</span><br><span class="line"><span class="comment">// (3) ["Quick Brown Fox Jumps", "Brown", "Jumps", index: 4, input: "The Quick Brown Fox Jumps Over The Lazy Dog", groups: undefined]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>### 查找所有匹配<br>当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。<br>当你这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。（test() 也会更新 lastIndex 属性）。   </p>
<p>注意：不要把正则表达式字面量（或者RegExp构造器）放在 while 条件表达式里。由于每次迭代时 lastIndex的属性都被重置，如果匹配，将会造成一个死循环。并且要确保使用了’g’标记来进行全局的匹配，否则同样会造成死循环。      </p>
<p>### 结合 RegExp 字面量使用 exec()<br>你也可以直接使用 exec() 而不是创建一个 RegExp  对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="regexp">/(hello \S+)/</span>.exec(<span class="string">'This is a hello world!'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>
<h1 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>当你想要知道一个模式是否存在于一个字符串中时，就可以使用 test()（类似于 String.prototype.search() 方法），<br>差别在于test返回一个布尔值，而 search 返回索引（如果找到）或者-1（如果没找到）；<br>若想知道更多信息（然而执行比较慢），可使用exec() 方法（类似于 String.prototype.match() 方法）。<br>和 exec() (或者组合使用),一样，在相同的全局正则表达式实例上多次调用test将会越过之前的匹配。     </p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/foo/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is at 0</span></span><br><span class="line">regex.test(<span class="string">'foo'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is now at 3</span></span><br><span class="line">regex.test(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h1 id="RegExp-1-9"><a href="#RegExp-1-9" class="headerlink" title="RegExp.$1-$9"></a>RegExp.$1-$9</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n</a>   </p>
<blockquote>
<p>该特性是非标准的，请尽量不要在生产环境中使用它！ </p>
</blockquote>
<h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>$1, …, $9 属性是静态的, 他不是独立的的正则表达式属性. 所以, 我们总是像这样子使用他们RegExp.$1, …, RegExp.$9.    </p>
<p>属性的值是只读的而且只有在正确匹配的情况下才会改变.     </p>
<p>括号匹配项是无限的, 但是RegExp对象能捕获的只有九个. 你可以通过返回一个数组索引来取得所有的括号匹配项.   </p>
<p>这些属性可以在String.replace 方法中替换字符串. 在这种情况下, 不用在前面加上RegExp。下面的例子将详细说明. 当正则表达式中不包含括号, 脚本中的 $n’s 就是字面上的意思 (当n是正整数).</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>$n 在 String.replace中的应用节<br>以下脚本用 replace() 方法去匹配一个first last格式的 nameString 实例 输出last first格式. 在替换文本里, 脚本用 $1 和 $2 表示正则表达式中的括号匹配项的结果.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'John Smith'</span>;</span><br><span class="line">str.replace(re, <span class="string">'$2, $1'</span>); <span class="comment">// "Smith, John"</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>; <span class="comment">// "John"</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span>; <span class="comment">// "Smith"</span></span><br></pre></td></tr></table></figure></p>
<p>\===========================================<br>和正则相关的字符串API<br># String.prototype.search()<br><code>str.search(regexp)</code><br>如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。     </p>
<p># String.prototype.match()     </p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>返回值:array<br>如果字符串匹配到了表达式，会返回一个数组，数组的第一项是进行匹配完整的字符串，之后的项是用圆括号捕获的结果。如果没有匹配到，返回null    </p>
<h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>如果正则表达式不包含 g 标志，则 str.match() 会返回和 RegExp.exec() 相同的结果。而且返回的 Array 拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以0开始）。     </p>
<p>如果正则表达式包含 g 标志，则该方法返回一个 Array ，它包含所有匹配的子字符串而不是匹配对象。捕获组不会被返回(即不返回index属性和input属性)。如果没有匹配到，则返回  null 。     </p>
<p>### API选择<br>如果你需要知道一个字符串是否匹配一个正则表达式 RegExp ，可使用 search() 。<br>如果你只是需要第一个匹配结果，你可能想要使用 RegExp.exec() 。($PS:不是match吗)<br>如果你想要获得捕获组，并且设置了全局标志，你需要用 RegExp.exec() 。     </p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \### 例子：使用 match   </span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'For more information, see Chapter 3.4.5.1'</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/see (chapter \d+(\.\d)*)/i</span>;</span><br><span class="line"><span class="keyword">var</span> found = str.match(re);</span><br><span class="line"><span class="comment">// (3) ["see Chapter 3.4.5.1", "Chapter 3.4.5.1", ".1", index: 22, input: "For more information, see Chapter 3.4.5.1", groups: undefined]</span></span><br><span class="line"><span class="comment">// '.1' 是被'(\.\d)'捕获的最后一个值。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 例子：match 使用全局（global）和忽略大小写（ignore case）标志</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[A-E]/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches_array = str.match(regexp);</span><br><span class="line"><span class="built_in">console</span>.log(matches_array); <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ###  使用match()，不传参数 节</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"Nothing will come of nothing."</span>;</span><br><span class="line">str.match();   <span class="comment">// returns [""]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 一个非正则表达式对象作为参数</span></span><br><span class="line"><span class="comment">// 当参数是一个字符串或一个数字，它会使用new RegExp(obj)来隐式转换成一个 RegExp。如果它是一个有正号的正数，RegExp() 方法将忽略正号。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">"NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript."</span>,</span><br><span class="line">str2 = <span class="string">"My grandfather is 65 years old and My grandmother is 63 years old."</span>,</span><br><span class="line">str3 = <span class="string">"The contract was declared null and void."</span>;</span><br><span class="line">str1.match(<span class="string">"number"</span>);   <span class="comment">// "number" 是字符串。返回["number"]</span></span><br><span class="line">str1.match(<span class="literal">NaN</span>);        <span class="comment">// NaN的类型是number。返回["NaN"]</span></span><br><span class="line">str1.match(<span class="literal">Infinity</span>);   <span class="comment">// Infinity的类型是number。返回["Infinity"]</span></span><br><span class="line">str1.match(+<span class="literal">Infinity</span>);  <span class="comment">// 返回["Infinity"]</span></span><br><span class="line">str1.match(-<span class="literal">Infinity</span>);  <span class="comment">// 返回["-Infinity"]</span></span><br><span class="line">str2.match(<span class="number">65</span>);         <span class="comment">// 返回["65"]</span></span><br><span class="line">str2.match(+<span class="number">65</span>);        <span class="comment">// 有正号的number。返回["65"]</span></span><br><span class="line">str3.match(<span class="literal">null</span>);       <span class="comment">// 返回["null"]</span></span><br></pre></td></tr></table></figure>
<h1 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace</a>  </p>
<p>注意：原字符串不会改变。   </p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p><code>str.replace(regexp|substr, newSubStr|function)</code><br>regexp (pattern):一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。<br>substr (pattern):一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。<br>newSubStr (replacement): 用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。<br>function (replacement):一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。     </p>
<h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。<br>在进行全局的搜索替换时，正则表达式需包含 g 标志。   </p>
<h3 id="使用字符串作为参数"><a href="#使用字符串作为参数" class="headerlink" title="使用字符串作为参数"></a>使用字符串作为参数</h3><p>替换字符串可以插入下面的特殊变量名：<br>变量名    代表的值<br><code>$$</code>插入一个 “$”。<br>$&amp;    插入匹配的子串。<br>$`    插入当前匹配的子串左边的内容。<br>$’    插入当前匹配的子串右边的内容。<br>$n    假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始    </p>
<h3 id="指定一个函数作为参数"><a href="#指定一个函数作为参数" class="headerlink" title="指定一个函数作为参数"></a>指定一个函数作为参数</h3><p>你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。<br>函数的返回值作为替换字符串。 (注意:  上面提到的特殊替换参数在这里不能被使用。)<br>另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。    </p>
<p>下面是该函数的参数：<br>变量名    代表的值<br>match    匹配的子串。（对应于上述的$&amp;。）<br>p1,p2, …    假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）<br>offset    匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）<br>string    被匹配的原字符串。      </p>
<p>(精确的参数个数依赖于replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 is nondigits, p2 digits, and p3 non-alphanumerics</span></span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">' - '</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newString = <span class="string">'abc12345#$*%'</span>.replace(<span class="regexp">/([^\d]*)(\d*)([^\w]*)/</span>, replacer);</span><br><span class="line"><span class="built_in">console</span>.log(newString);  <span class="comment">// abc - 12345 - #$*%</span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>### 1 在 replace() 中使用正则表达式<br>### 2 在 replace() 中使用 global 和 ignore 选项<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \### 3 交换字符串中的两个单词     </span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"John Smith"</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(re, <span class="string">"$2, $1"</span>); <span class="comment">// Smith, John</span></span><br><span class="line"><span class="comment">// \### 4 使用行内函数来修改匹配到的字符。  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">styleHyphenFormat</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">upperToHyphenLower</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span> + match.toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> propertyName.replace(<span class="regexp">/[A-Z]/g</span>, upperToHyphenLower);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// styleHyphenFormat('borderTop') 将返回 'border-top'。</span></span><br><span class="line"><span class="comment">// var newString = propertyName.replace(/[A-Z]/g, '-' + '$&amp;'.toLowerCase());  // won't work</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 5 将华氏温度转换为对等的摄氏温度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2c</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">str, p1, offset, s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((p1<span class="number">-32</span>) * <span class="number">5</span>/<span class="number">9</span>) + <span class="string">"C"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">String</span>(x);</span><br><span class="line">  <span class="keyword">var</span> test = <span class="regexp">/(\d+(?:\.\d*)?)F\b/g</span>;</span><br><span class="line">  <span class="keyword">return</span> s.replace(test, convert);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 6 使用行内函数和正则来避免循环节</span></span><br><span class="line"><span class="comment">// 下例把某种模式的字符串转换为一个对象数组（其元素为对象）。</span></span><br><span class="line"><span class="comment">// 输入：一个由 x，- 和 _ 组成的字符串。</span></span><br><span class="line"><span class="comment">// 输出：一个数组对象。'x' 产生一个 'on' 状态，'-'（连接符）产生一个 'off' 状态，而 '_' （下划线）表示 'on' 状态的长度。</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'x-x_'</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// var str='---x---x---x---' // 2</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'_x_x___x___x___'</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> retArr = [];</span><br><span class="line">str.replace(<span class="regexp">/(x_*)|(-)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p1) &#123; retArr.push(&#123; <span class="attr">on</span>: <span class="literal">true</span>, <span class="attr">length</span>: p1.length &#125;); &#125;</span><br><span class="line">  <span class="keyword">if</span> (p2) &#123; retArr.push(&#123; <span class="attr">on</span>: <span class="literal">false</span>, <span class="attr">length</span>: <span class="number">1</span> &#125;); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(retArr); </span><br><span class="line"><span class="comment">// [&#123; on: true, length: 1 &#125;,&#123; on: false, length: 1 &#125;,&#123; on: true, length: 2 &#125;] //1</span></span><br><span class="line"><span class="comment">// [&#123;on: true, length: 2&#125;, &#123;on: true, length: 4&#125;,&#123;on: true, length: 4&#125;,&#123;on: true, length: 4&#125;]  // 3</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">19:32</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Cluster学习</title>
    <url>/sum/others/MySQL%20Cluster%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/gomysql/p/3664783.html" target="_blank" rel="noopener">[MySQL Cluster搭建与测试]</a>       </p>
<!-- \# [MySQL Cluster技术详解](https://blog.csdn.net/JesseYoung/article/details/38726561)    -->
<h2 id="1-MySQL-Cluster简介"><a href="#1-MySQL-Cluster简介" class="headerlink" title="1 MySQL Cluster简介"></a>1 MySQL Cluster简介</h2><p>MySQL集群是一种在无共享架构（SNA，Share Nothing Architecture）系统里应用内存数据库集群的技术。这种无共享的架构可以使得系统使用低廉的硬件获取高的可扩展性。 MySQL集群是一种分布式设计，目标是要达到没有任何单点故障点。因此，任何组成部分都应该拥有自己的内存和磁盘。任何共享存储方案如网络共享，网络文件系统和SAN设备是不推荐或不支持的。通过这种冗余设计，MySQL声称数据的可用度可以达到99.999%。   </p>
<p>实际上，MySQL集群是把一个叫做NDB的内存集群存储引擎集成与标准的MySQL服务器集成。它包含一组计算机，每个都跑一个或者多个进程，这可能包括一个MySQL服务器，一个数据节点，一个管理服务器和一个专有的一个数据访问程序。它们之间的关系如下图所示：<br><!-- ![MySQL Cluster节点关系图](https://img-blog.csdn.net/20140821104155439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmVzc2VZb3VuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)    --></p>
<p>MySQL Cluster 使用了一个专用的基于内存的存储引擎NDB，这样做的好处是速度快， 没有磁盘I/O的瓶颈，但是由于是基于内存的，所以数据库的规模受系统总内存的限制， 如运行NDB的MySQL服务器一定要内存够大，比如4G, 8G, 甚至16G。NDB引擎是分布式的，它可以配置在多台服务器上来实现数据的可靠性和扩展性，理论上 通过配置2台NDB的存储节点就能实现整个数据库集群的冗余性和解决单点故障问题。  </p>
<h2 id="2-MySQL-Cluster特点"><a href="#2-MySQL-Cluster特点" class="headerlink" title="2 MySQL Cluster特点"></a>2 MySQL Cluster特点</h2><h3 id="2-1-特性"><a href="#2-1-特性" class="headerlink" title="2.1 特性"></a>2.1 特性</h3><p>1.通过自动分片实现高水平的写入扩展能力<br>MySQL Cluster 自动将表分片（或分区）到不同节点上，使数据库可以在低成本的商用硬件上横向扩展，同时保持对应用程序完全应用透明。<br>2.99.999% 的可用性<br>凭借其分布式、无共享架构，MySQL Cluster 可提供 99.999% 的可用性，确保了较强的故障恢复能力和在不停机的情况下执行预定维护的能力。<br>3.SQL 和NoSQL API<br>MySQL Cluster 让用户可以在解决方案中整合关系数据库技术和NoSQL技术中的最佳部分，从而降低成本、风险和复杂性。<br>4.实时性能<br>MySQL Cluster 提供实时的响应时间和吞吐量，能满足最苛刻的 Web、电信及企业应用程序的需求。<br>5.具有跨地域复制功能的多站点集群<br>跨地域复制使多个集群可以分布在不同的地点，从而提高了灾难恢复能力和全球 Web 服务的扩展能力。<br>6.联机扩展和模式升级<br>为支持持续运营，MySQL Cluster 允许向正在运行的数据库模式中联机添加节点和更新内容，因而能支持快速变化和高度动态的负载。  </p>
<h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>1.基于内存，数据库的规模受集群总内存的大小限制<br>2.多个节点通过网络实现通讯和数据同步、查询等操作，因此整体性受网络速度影响  </p>
<h2 id="3-功能模块介绍"><a href="#3-功能模块介绍" class="headerlink" title="3 功能模块介绍"></a>3 功能模块介绍</h2><p>MySQL cluster配置中，由3个不同功能的服务构成，每个服务由一个专用的守护进程提供，一项服务也叫做一个节点，下面来介绍每个节点的功能：      </p>
<p>管理(MGM)节点：<br>管理节点，用来实现整个集群的管理，理论上一般只启动一个，而且宕机也不影响 cluster 的服务，这个进程只在cluster 启动以及节点加入集群时起作用， 所以这个节点不是很需要冗余，理论上通过一台服务器提供服务就可以了。管理节点的作用是管理MySQL集群内的其他节点，如提供配置数据、启动并停止节点、运行备份等。由于管理节点负责管理其他节点的配置，应在启动其他节点之前首先启动管理节点。     </p>
<p>数据节点：<br>数据节点用于保存集群的数据。数据节点的数目与副本的数目相关，是片段的倍数。例如，对于两个副本，每个副本有两个片段，那么就有4个数据节点。<br>数据节点可以和管理节点(MGM)处在不同的机器上，也可以在同一个机器上面，集群中至少要有一个数据节点，2个以上时就能实现集群的高可用保证，数据节点增加时，集群的处理速度会变慢。      </p>
<p>SQL节点：<br>SQL节点是用来访问集群数据的节点，是应用和数据节点之间的一个桥梁。Cluster中可以有多个sql节点，通过每个sql节点查询到的数据都是一致的，通常来说，sql节点越多，分配到每个sql节点的负载就越小，系统的整体性能就越好。        </p>
<p>以上三种逻辑上不同节点物理上可以存放在不同的服务器上，也可以存放在相同的服务器上。</p>
<h2 id="4-环境准备及节点分布"><a href="#4-环境准备及节点分布" class="headerlink" title="4 环境准备及节点分布"></a>4 环境准备及节点分布</h2><p>操作系统为：CentOS release 6.3 (Final)<br>Cluster版本为：mysql-cluster-gpl-7.2.12-linux2.6-x86_64.tar.gz<br>节点分布如下：</p>
<h1 id="mongo-集群"><a href="#mongo-集群" class="headerlink" title="mongo 集群"></a>mongo 集群</h1><!-- \# [[高可用的MongoDB集群]](https://www.jianshu.com/p/2825a66d6aed)    -->
<p>使用集群的目的就是提高可用性。高可用性H.A.（High Availability）指的是通过尽量缩短因日常维护操作（计划）和突发的系统崩溃（非计划）所导致的停机时间，以提高系统和应用的可用性。它与被认为是不间断操作的容错技术有所不同。HA系统是目前企业防止核心计算机系统因故障停机的最有效手段。<br>HA的三种工作方式：</p>
<p>主从方式 （非对称方式）<br>工作原理：主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。</p>
<p>双机双工方式（互备互援）<br>工作原理：两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。</p>
<p>集群工作方式（多服务器互备方式）<br>工作原理：多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管</p>
<p>作者：davidpp<br>链接：<a href="https://www.jianshu.com/p/2825a66d6aed" target="_blank" rel="noopener">https://www.jianshu.com/p/2825a66d6aed</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Generator 函数的语法</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/17-Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.12.3 星期一 10:51 </p>

<p>1. 简介<br>2. next 方法的参数<br>3. for…of 循环<br>4. Generator.prototype.throw()<br>5. Generator.prototype.return()<br>6. next()、throw()、return() 的共同点<br>7. yield* 表达式<br>8. 作为对象属性的 Generator 函数<br>9. Generator 函数的this<br>10. 含义<br>11. 应用   </p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'can this output when defined'</span>) <span class="comment">// only next can output</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br></pre></td></tr></table></figure>
<p>1) Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>2) 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态</p>
<p>####<br>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。<br>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。</p>
<p>####<br>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。</p>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态<br>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。   </p>
<p>yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行   </p>
<p>yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。       </p>
<p>1) Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。<br>2) 另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。<br>3) 另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。<br>4) yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>$TODO:<br>上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。  </p>
<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。<br>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。  </p>
<h2 id="2-next-方法的参数"><a href="#2-next-方法的参数" class="headerlink" title="2 next 方法的参数"></a>2 next 方法的参数</h2><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。   </p>
<p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。<br>如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。     </p>
<p>可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-for…of-循环"><a href="#3-for…of-循环" class="headerlink" title="3 for…of 循环"></a>3 for…of 循环</h2><p>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。<br>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers(); <span class="comment">// x:1,y:2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个利用 Generator 函数和for…of循环，实现斐波那契数列的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 Generator 函数为它加上这个接口，就可以用了。     </p>
<h2 id="4-Generator-prototype-throw"><a href="#4-Generator-prototype-throw" class="headerlink" title="4 Generator.prototype.throw()"></a>4 Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。<br>throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。   </p>
<p>上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。   </p>
<p>如果 Generator 函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。<br>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。<br>throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。    </p>
<p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。   </p>
<p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。   </p>
<h2 id="5-Generator-prototype-return"><a href="#5-Generator-prototype-return" class="headerlink" title="5 Generator.prototype.return()"></a>5 Generator.prototype.return()</h2><p>可以返回给定的值，并且终结遍历 Generator 函数。<br>如果return方法调用时，不提供参数，则返回值的value属性为undefined。<br>如果 Generator 函数内部有try…finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers();</span><br></pre></td></tr></table></figure></p>
<h2 id="6-next-、throw-、return-的共同点"><a href="#6-next-、throw-、return-的共同点" class="headerlink" title="6 next()、throw()、return() 的共同点"></a>6 next()、throw()、return() 的共同点</h2><p>next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。</p>
<p>next()是将yield表达式替换成一个值。<br>throw()是将yield表达式替换成一个throw语句。<br>return()是将yield表达式替换成一个return语句。  </p>
<h2 id="7-yield-表达式"><a href="#7-yield-表达式" class="headerlink" title="7 yield* 表达式"></a>7 yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。<br>这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line"><span class="comment">//   foo();</span></span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。    </p>
<h2 id="8-作为对象属性的-Generator-函数"><a href="#8-作为对象属性的-Generator-函数" class="headerlink" title="8 作为对象属性的 Generator 函数"></a>8 作为对象属性的 Generator 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-Generator-函数的this"><a href="#9-Generator-函数的this" class="headerlink" title="9 Generator 函数的this"></a>9 Generator 函数的this</h2><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。   </p>
<p>但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。<br>Generator 函数也不能跟new命令一起用，会报错。<br>###  那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？<br>下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。<br>上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 一个办法就是将obj换成F.prototype。再将F改成构造函数，就可以对它执行new命令了。   </p>
<h2 id="11-含义"><a href="#11-含义" class="headerlink" title="11 含义"></a>11 含义</h2><p>### Generator 与状态机<br>### Generator 与协程<br>### Generator 与上下文<br>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。   </p>
<h2 id="12-应用"><a href="#12-应用" class="headerlink" title="12 应用"></a>12 应用</h2><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。  </p>
<p>###（1）异步操作的同步化表达<br>这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。<br>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。<br>下面是另一个例子，通过 Generator 函数逐行读取文本文件。   </p>
<p>###（2）控制流管理<br>如果有一个多步操作非常耗时，采用回调函数/采用 Promise<br>Generator 函数可以进一步改善代码运行流程.然后，使用一个函数，按次序自动执行所有步骤。  </p>
<p>注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。   </p>
<p>利用for…of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。  </p>
<h3 id="（3）部署-Iterator-接口"><a href="#（3）部署-Iterator-接口" class="headerlink" title="（3）部署 Iterator 接口"></a>（3）部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。  </p>
<p>###（4）作为数据结构<br>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。   </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>NSIS实用</title>
    <url>/sum/others/NSIS%E5%AE%9E%E7%94%A8/</url>
    <content><![CDATA[<p style="text-align:right">2018.11.12 星期一 16:40</p>

<p>文档:<a href="http://nsis.sourceforge.net/Docs/" target="_blank" rel="noopener">http://nsis.sourceforge.net/Docs/</a>  </p>
<p>Windows: sendMessage,LB_GETTEXT<br><a href="https://docs.microsoft.com/en-us/windows/desktop/Controls/lb-gettext" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/Controls/lb-gettext</a><br><a href="https://msdn.microsoft.com/en-us/library/ms909674.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/ms909674.aspx</a>  </p>
<blockquote>
<p>NSIS (Nullsoft Scriptable Install System) is a professional open source system to create Windows installers. It is designed to be as small and flexible as possible and is therefore very suitable for internet distribution.</p>
</blockquote>
<p>功能复杂需要利用一些插件:MUI2.nsh,LogicLib.nsh,nsDialogs.nsh,nsExec    </p>
<p>实例:集成解决方案. 之前是v2<br>v2-nsDialogs:Listbox,删除有bug;v3修复,又新提案许多api   </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>支持x86,x64<br>目录结构: Bin,Contrib,Docs,Examples,Include,Menu,Plugins,Stubs,<br>makensis.exe,NSIS.chm,NSIS.exe,…</p>
<p>每个插件基本也是上面的目录结构,拷贝到相应文件夹即可.<br>Docs:文档,有text,html等各种格式,nsis是chm<br>Plugins:v3下会有两个子文件夹:x86-ansi,x86-unicode(根据电脑下载安装);下载的插件可能有四个文件夹,包括x64的   </p>
<p>有的nsi文件是ansi码,用notepad++,vscode等打开 中文是乱码,需要设置编码方式<br>vscode 默认打开文件是utf-8, 没有选择ansi码的,可以选择GBK编码方式,属于ANSI编码  </p>
<p>如果是utf-8编码,编译的时候通不过.需要用gbk编码方式重新保存   </p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>GuiNsis(图形界面),Venis IX(编辑器),VSCode<br>后面两个需要配置编译程序位置,即makensis.exe   </p>
<p>VSCode安装插件: nsis , C+S+B,编译出来, 右下角弹框 直接run<br>VSCode不能在侧边栏显示about/Funtions/View, 而Venis IX 就可以.虽然vscode查找方便,但还是没view   </p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>用<strong>指令</strong>操作<br>不区分大小写<br>函数名不区分大小写,仍然使用js的写法: 开头大写的表示类,比如custom Page, btn/操作函数小写+动词开头<br>不光函数名,语法本身不区分大小写,比如变量名<br>不支持数组,直接进行栈操作($PS:很优秀,比如函数传参,getNextIP)        </p>
<h3 id="字符串-数字操作"><a href="#字符串-数字操作" class="headerlink" title="字符串/数字操作"></a>字符串/数字操作</h3><!-- 字串连接可以用 `+`   $PS:不知道哪里看到的,应该不行  -->
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StrCpy 用户变量(目标) 字串 \[最大长度] \[起始偏移]  </span><br><span class="line">StrLen 用户变量(长度输出) 字串  </span><br><span class="line"></span><br><span class="line">IntFmt 用户变量(输出) 格式 数字字串   (这个指令其实就是 C++ 里的 wsprintf 函数)  </span><br><span class="line">IntOp  用户变量(输出) 值1 操作 [值2]</span><br><span class="line"></span><br><span class="line">;连接字串</span><br><span class="line">StrCpy $0 &quot;字串1&quot;</span><br></pre></td></tr></table></figure>
<p>api简单,不支持数组;<br>需要扩展插件: WordFunc.nsh, StrFunc.nsh,    </p>
<p>Validate_IP_function:<a href="http://nsis.sourceforge.net/Validate_IP_function" target="_blank" rel="noopener">http://nsis.sourceforge.net/Validate_IP_function</a>  </p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>可以建目录, 复制,删除文件等操作,判断文件是否存在<br>支持迭代拷贝目录结构 <code>/r</code>  </p>
<p>可以直接写文件, 写行, 查找后修改 etc..<br>有写ini文件的指令,十分方便<br>也有写注册表,创建快捷方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WriteINIStr &quot;$INSTDIR\db\config\db.ini&quot; &quot;mysqld&quot; &quot;basedir&quot; &apos;$INSTDIR\db&apos;</span><br><span class="line"></span><br><span class="line">FileOpen $0 &apos;$INSTDIR\db_cluster\ndb_mgm\config\db.ini&apos; w ;r,w,a</span><br><span class="line">IfErrors done</span><br><span class="line">FileWrite $0 &quot;[ndb_mgmd default] $\r$\n&quot;</span><br><span class="line">done:    # 标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WriteRegStr HKLM &quot;Software\Microsoft\Windows\CurrentVersion\Uninstall\$&#123;APPNAME&#125;&quot; &quot;DisplayName&quot; &quot;$&#123;APPNAME&#125;&quot;</span><br><span class="line">WriteRegStr HKLM &quot;Software\Microsoft\Windows\CurrentVersion\Uninstall\$&#123;APPNAME&#125;&quot; &quot;UninstallString&quot; &quot;$AMBASEDIR\uninstall.exe&quot;</span><br><span class="line">WriteUninstaller &quot;$AMBASEDIR\uninstall.exe&quot;</span><br><span class="line"></span><br><span class="line">CreateDirectory &quot;$SMPROGRAMS\AcuManager&quot;</span><br><span class="line">CreateShortCut &quot;$SMPROGRAMS\AcuManager\Register.lnk&quot; &quot;$AMBASEDIR\Register9.exe&quot;</span><br><span class="line">CreateShortCut &quot;$SMPROGRAMS\AcuManager\Uninstall.lnk&quot; &quot;$AMBASEDIR\uninstall.exe&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exec &apos;&quot;$INSTDIR\someprogram.exe&quot; some parameters&apos;</span><br><span class="line">ExecWait &apos;&quot;$INSTDIR\someprogram.exe&quot;&apos; $0</span><br><span class="line">DetailPrint &quot;程序返回: $0&quot;</span><br><span class="line">nsExec::ExecToLog /TIMEOUT=120000 &apos;&quot;$AMBASEDIR\db\data\update_force.bat&quot;&apos;</span><br><span class="line">Sleep 1000</span><br><span class="line"></span><br><span class="line">; 调用一个插件，使用“插件::命令 \[参数]”。    </span><br><span class="line">nsDialogs::Create 1018</span><br><span class="line">nsDialogs::Show</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Var [/GLOBAL] 变量名  区段或函数内定义的变量必须使用 /GLOBAL 标记   </p>
<p>已经注册变量:$0、$1、$2、$3、$4、$5、$6、$7、$8、$9、$R0、$R1、$R2、$R3、$R4、$R5、$R6、$R7、$R8、$R9   </p>
<p>许多常量:$PROGRAMFILES,$PROGRAMFILES,$DESKTOP,$WINDIR,$SMSTARTUP, $DOCUMENTS<br><code>$$(转义$),$\r,$\n,$\t</code>    </p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 注释</span><br><span class="line"># 注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">注释</span><br><span class="line">注释</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Name /* 注释 */ mysetup</span><br><span class="line">File &quot;我的文件&quot; ;注释</span><br></pre></td></tr></table></figure>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>条件判断或执行代码循环可以使用 StrCmp、IntCmp、IfErrors、Goto 和其它来实现，但是还有更方便直观的方式来实现。LogicLib 提供了很多简单的宏来做条件或联合逻辑判断<br>${If} $0 == $1  <code>==</code>后面需要空格,用来判断${If}的参数个数<br>$PS: 结合标记. 标记应该可以多层嵌套,比起if/else 深层嵌套能较少缩进吧,就是标记跳来跳去不知道麻烦否   </p>
<h3 id="标记和跳转"><a href="#标记和跳转" class="headerlink" title="标记和跳转"></a>标记和跳转</h3><p>标记可以跳转,逻辑就不行了<br><del>标记结束的地方可能是遇到下一条指令为止</del><br>标记就是标记,用来做跳转;标记没有什么结束位置,不同于Function/Section有End; 脚本/指令是一条一条往下执行的,跳转到标记就会一直顺序执行    </p>
<blockquote>
<p>标记是 Goto 指令的目标，或各种分支指令 (比如 IfErrors、MessageBox、IfFileExists 和 StrCmp) 的目标。标记必须存在于一个区段或函数里。标记是局限于该范围里的，这意味着这些指令只能访问和它们同处于一个区段或函数的标记。<br>相对跳转  和标记不一样，在任何你可用到标记的地方你也都可以相对跳转。相对跳转由数字标定。<br>一条指令就是在安装程序运行时可以被执行的所有命令。MessageBox、Goto、GetDLLVersion、FileRead、SetShellVarContext 都是指令。AddSize、Section、SectionGroup、SectionEnd、SetOverwrite (和所有处于编译器标记)、Name、SetFont、LangString 都不是指令，因为它们在编译时就被执行。<br>需要注意的是宏指令并不是真正意义上的一条指令，在编译时会被展开为若干条指令，所以你不能用相对跳转来跳过一条宏指令。 </p>
</blockquote>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>1. nsis语言中可以没有引号,除非是字符串中间有空格,或者特殊符号比如参数是<code>#</code>等($PS:不知道从文档那个地方看到的). 比较下面例子中,两个${LineFind} 指令中几个参数, 有无引号都可以都可以执行成功<br>2. ${LineFind} 最后的回调函数中,必须要有<code>Push $var</code> 结束(example中都是在结尾,Push StopLineFind/‘StopLineFind’ 不好使,必须是$0,$1/$2也可以)<br><!-- $PS: 早发现的问题,没注意,花费了一天多时间(主要是编译时间长) --><br>3. <code>IfErrors 0 +2</code> 如果没有+2, 下一个指令(本例子中MessageBox) 也会执行;+1 也执行,即跳转到下一行. +2 是没有错误的跳转标记, +2 表示跳过了下面的一条,执行后面的指令   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ## 可以没有 双引号</span><br><span class="line">$&#123;LineFind&#125; $INSTDIR\ARCManager\inc\db.php &quot;&quot; 4 &quot;replaceMongoHosts&quot;</span><br><span class="line">IfErrors 0 +2</span><br><span class="line">MessageBox MB_OK &quot;Config mongo hosts error !&quot;</span><br><span class="line"></span><br><span class="line">$&#123;LineFind&#125; &quot;$INSTDIR\config\AcuManager.xml&quot; &quot;&quot; &quot;3&quot; replaceLocalIP</span><br><span class="line">IfErrors 0 +2</span><br><span class="line">MessageBox MB_OK &quot;Config local IP error !&quot;</span><br></pre></td></tr></table></figure>
<h2 id="bugs-注意事项"><a href="#bugs-注意事项" class="headerlink" title="bugs/注意事项"></a>bugs/注意事项</h2><h3 id="nsis"><a href="#nsis" class="headerlink" title="nsis"></a>nsis</h3><p>0. 注意SetOutPath 和 InstallDir,$INSTDIR 路径联系<br>1. 版本信息<br>VIProductVersion 必须是四位的:[版本字串_X.X.X.X]<br>VIAddVersionKey:在文件信息中看不到.’并不是windows的bug,可能是什么文件没有打包进来’   </p>
<p>版本信息在win7等一些电脑中看不到(?有疑问)   </p>
<p>2. 多语言：如果是单语言，把多余的语言注释掉，并不完全是set language 先后顺序,有自己选择语言逻辑,和检测系统默认语言有关   </p>
<blockquote>
<p>不像定义使用花括号 - {} 一样，语言字串使用圆括号 - ()。<br>如果你想在 .onInit 函数里更改语言，需要注意的是在 .onInit 里的语言字串将仍旧使用基于用户的默认 Windows 语言检测到的语言，因为语言的初始化在 .onInit 之后。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; Set languages (first is default language)   # $PS: 没关系,是系统默认  </span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;English&quot;</span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;SimpChinese&quot;</span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;TradChinese&quot;</span><br><span class="line">!insertmacro MUI_RESERVEFILE_LANGDLL</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>3. 标记如果没有跳转/Return等,会顺着执行下一个指令, 发生if 和 else 都执行的情况<br><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;WordFind&#125;</span> <span class="string">"C:\io.sys C:\logo.sys"</span> <span class="string">":\lo"</span> <span class="string">"E+1&#123;"</span> <span class="variable">$R0</span></span><br><span class="line"><span class="keyword">IfErrors</span> notfound found</span><br><span class="line"><span class="comment">## 1</span></span><br><span class="line">found:</span><br><span class="line"><span class="keyword">MessageBox</span> <span class="params">MB_OK</span> <span class="string">"The IP had added to server list"</span> <span class="params">IDOK</span> end</span><br><span class="line">notfound:</span><br><span class="line"><span class="keyword">MessageBox</span> <span class="params">MB_OK</span> <span class="string">'Not found'</span></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2 </span></span><br><span class="line">notfound: </span><br><span class="line"><span class="keyword">MessageBox</span> <span class="params">MB_OK</span> <span class="string">"Must include local IP!"</span> </span><br><span class="line"><span class="keyword">Abort</span></span><br><span class="line">found:</span><br></pre></td></tr></table></figure></p>
<p>4. 有些文档,网站都不知道入口在哪里,比如:nsDialogs,Validate IP function<br>Validate IP function:<a href="http://nsis.sourceforge.net/Validate_IP_function" target="_blank" rel="noopener">http://nsis.sourceforge.net/Validate_IP_function</a><br>NSIS nsDialogs Plug-in:<a href="http://nsis.sourceforge.net/Docs/nsDialogs/Readme.html" target="_blank" rel="noopener">http://nsis.sourceforge.net/Docs/nsDialogs/Readme.html</a>  </p>
<p>5. File 指令 /x 参数编译不过. 老同志做法:目录不多,分开拷贝吧   </p>
<blockquote>
<p>File [/nonfatal] [/a] ([/r] [/x 文件|通配符 […]] (文件|通配符) […] | /oname=输出路径\文件名 输入路径\文件名)<br>使用 /x 开关可以用来来排除文件或目录。<br>$PS: nsis 可能根据 名字 来检索,所以/x不能是路径, 可以是文件夹名或者文件名, 支持通配符<br>File /r /x Config ..\MyProgram*.*<br>where “Config” is a directory “MyProgram\Plugins\Config”. NSIS searches only by name and it will be wrong to set any subfolders (e.g. “/x Plugins\Config” or “/x $INSTDIR\MyProgram\Plugins\Config\”). There is one lack: if you have the same folders in different directories, using the /r switch, both matching directories and files will be searched.<br><a href="http://www.itdaan.com/blog/2012/01/27/1f8b1d77fabf573444e606ce2e9a6a.html" target="_blank" rel="noopener">文件/x不排除声明的文件/目录</a><br><a href="https://stackoverflow.com/questions/9031175/nsis-file-x-doesnt-exclude-files-directories-as-claimed/16292431" target="_blank" rel="noopener">NSIS - File /x doesn’t exclude files/directories as claimed</a><br>(<a href="https://stackoverflow.com/questions/9031175/nsis-file-x-doesnt-exclude-files-directories-as-claimed" target="_blank" rel="noopener">https://stackoverflow.com/questions/9031175/nsis-file-x-doesnt-exclude-files-directories-as-claimed</a>)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># test</span><br><span class="line">; File /r &apos;aculearn-idm\db\*.*&apos; /x &apos;aculearn-idm\db\data\acldatabase\*.*&apos; ;编译不过</span><br><span class="line">; File /r /x &apos;aculearn-idm\db\data\acldatabase&apos; &apos;aculearn-idm\db\*.*&apos; ;可以编译过,不能排除</span><br><span class="line">; File /r /x aculearn-idm\db\data\acldatabase\*.* aculearn-idm\db\*.* ;可以编译过,不能排除</span><br><span class="line">; File /r /x &apos;acldatabase\*.*&apos; &apos;aculearn-idm\db\*.*&apos; ;可以编译过,不能排除</span><br><span class="line">## success</span><br><span class="line">File /r /x *.MYD /x &apos;*.MYI&apos; /x &apos;*.frm&apos; &apos;aculearn-idm\db\*.*&apos; ;可以编译过,也可以排除</span><br><span class="line">File /r /x acldatabase &apos;aculearn-idm\db\*.*&apos; ;可以编译过,也可以排除,排除了文件夹</span><br><span class="line">CreateDirectory &quot;$INSTDIR\db\data\acldatabase&quot;</span><br><span class="line"></span><br><span class="line"># 文档示例</span><br><span class="line">File /r /x CVS 我的工程\*.*</span><br><span class="line">File /r /x *.res /x *.obj /x *.pch source\*.*</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>6. 有些指令必须在Function或Section中使用,比如:StrcCpy,MessageBox;<br>$PS:没确认是不是指令必须写在函数或区块中<br>7. 一个nsi文件可以include另一个nsh文件. 页面跳转,变量等都是在内存中存储, 只要include的位置,就可以在nsi和nsh中正确使用变量   </p>
<h3 id="2-nsDialogs"><a href="#2-nsDialogs" class="headerlink" title="2 nsDialogs"></a>2 nsDialogs</h3><p>没有监听blur/focus的事件,也没有方法主动获取焦点,所以有些需要无法实现<br>1.1 Listbox API:NSD_LB_DelString以及clear参数个数问题, v3修复好了<br><!-- [NSIS listbox使用技巧](https://blog.csdn.net/pkrobbie/article/details/4403992)   
[NSIS listbox使用技巧](http://www.voidcn.com/article/p-hisorveu-ve.html)    --><br>1.2 Listbox API:NSD_LB_GetItemText (v3)无法获取内容,即使在page LEAVE 回调函数中<br><a href="http://forums.shoutcast.com/showthread.php?t=345386" target="_blank" rel="noopener">Using listboxes in nsDialogs</a><br>$SOL:把获取Listbox设置过程,设置到添加函数中了      </p>
<p>用SendMessage 指令也无法获取<br>1.3 Listbox API:NSD_LB_GetItemData 未定义, nsh文件中定时时少了 下划线.<br>上述两个API都没有在文档中提及,不知道是否是因为有bug,没完成       </p>
<p>2. NSD_CreateIPAddress:点击Next 会改变页面样式,包括下面几个按钮;点击返回,上一个自定义页面,字体都加粗,变大导致页面布局混乱; 而且这个控件有时候选择输出后输入不是很好   </p>
<p>-9. Move data between ListBoxes<br><!-- [Move data between ListBoxes](http://nsis.sourceforge.net/Move_data_between_ListBoxes) --></p>
<h3 id="3-nsArray"><a href="#3-nsArray" class="headerlink" title="3 nsArray"></a>3 nsArray</h3><p>需要自己下载安装<br>1. /at和/key的区分: nsArray::Set $ips /at=$1 $0<br>/at 后面参数需要数字,通过nsDialog-LisBox API 获取到长度的变量$1 可能是个字符串,不能通过/at传递, 需要 通过/key设置 nsArray<br>2. nsArray 定义的 数组变量 好像不需要声明也可以使用, 如果声明,即使使用了变量($ips/ips),编译结束都会有warnings:6001: Variable “ips” not referenced or never set, wasting memory!<br>而且定义数组变量的话,引用可能会导致混乱,比如var serverIPs,currIPs, 造成Droplist和ListBox 数据相同(上一步/下一步的时候,下拉框和列表框的内容一致了;开始/初始化时也会个列表框添加currIPs的内容)<br>Tips:变量不用声明,直接使用     </p>
<p>nsArray 是一个’对象类数组’: key=&gt;1,value=&gt;’value’,并不是真正的数组–索引为数字,而是用对象的key; 删除/添加 下标/索引 并不会随着增减,因为是对象的key    </p>
<h3 id="4-wordFunc"><a href="#4-wordFunc" class="headerlink" title="4 wordFunc"></a>4 wordFunc</h3><p>插件(安装包有,不需要下载) 没有docs; $PS: strFunc有docs<br>docs:<a href="http://nsis.sourceforge.net/Docs/AppendixE.html#wordfind" target="_blank" rel="noopener">http://nsis.sourceforge.net/Docs/AppendixE.html#wordfind</a><br>但是Doc可以在NSIS文档的附录中找到       </p>
<p>for NSIS 2.07 and below users:<a href="https://nsis.sourceforge.io/WordReplace" target="_blank" rel="noopener">https://nsis.sourceforge.io/WordReplace</a>   </p>
<h3 id="Windows-OS"><a href="#Windows-OS" class="headerlink" title="Windows OS"></a>Windows OS</h3><p>#### 1 GetVersion (Windows) plug-in: <a href="https://nsis.sourceforge.io/GetVersion_(Windows)_plug-in" target="_blank" rel="noopener">https://nsis.sourceforge.io/GetVersion_(Windows)_plug-in</a>   </p>
<blockquote>
<p>Windows 8 or above detection<br>If using NSIS 3.0 or above, use the ManifestSupportedOS installer attribute and the bundled WinVer.nsh<br>If using NSIS 2.46 or below, use !packhdr to embed additional supported OS GUIDs and an updated WinVer.nsh<br>#### 2 Get Windows version: <a href="https://nsis.sourceforge.io/Get_Windows_version" target="_blank" rel="noopener">https://nsis.sourceforge.io/Get_Windows_version</a><br>$PS: for nsis3<br>实际文档还是以安装目录下include文件夹下WinVer.nsh为标准   </p>
</blockquote>
<p>#### 3 Display Windows OS Name in a string:<a href="https://nsis.sourceforge.io/Display_Windows_OS_Name_in_a_string" target="_blank" rel="noopener">https://nsis.sourceforge.io/Display_Windows_OS_Name_in_a_string</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name &quot;Windows OS Name&quot;</span><br><span class="line">OutFile &quot;OSName.exe&quot;</span><br><span class="line"></span><br><span class="line">Function &quot;GetWIN&quot;</span><br><span class="line">    ReadRegStr $0 HKLM &quot;SOFTWARE\Microsoft\Windows\CurrentVersion&quot; ProductName</span><br><span class="line">    StrCmp $0 &quot;&quot; +1 +2</span><br><span class="line">    ReadRegStr $0 HKLM &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion&quot; ProductName</span><br><span class="line">FunctionEnd</span><br><span class="line"></span><br><span class="line">Function .onInit</span><br><span class="line">    Call &quot;GetWin&quot;</span><br><span class="line">    MessageBox MB_OK|MB_ICONINFORMATION $0</span><br><span class="line">    Quit</span><br><span class="line">FunctionEnd</span><br><span class="line"></span><br><span class="line">Section -Ghost</span><br><span class="line">    ; Hide Me</span><br><span class="line">Sectionend</span><br></pre></td></tr></table></figure></p>
<h3 id="IpConfig-plugin"><a href="#IpConfig-plugin" class="headerlink" title="IpConfig plugin"></a>IpConfig plugin</h3><p>IpConfig plugin: <a href="https://nsis.sourceforge.io/IpConfig_plugin" target="_blank" rel="noopener">https://nsis.sourceforge.io/IpConfig_plugin</a><br>IP-plugin: <a href="https://nsis.sourceforge.io/IP_plug-in" target="_blank" rel="noopener">https://nsis.sourceforge.io/IP_plug-in</a><br>一个主机上可能有多个IP: LoopBack IP ,Automatic Private IP Address (no DHCP server),Network IP,Internet IP   </p>
<p>所以还需要 CheckIP, VersionCheck   </p>
<p>acumanager 用的<code>IpConfig::GetAllIPV4Addresses</code>;但是没有找到该函数,<br>而且还用了IP-plugin 的Checkip, versionCheck</p>
<p>其它:<br><a href="http://lzquan.iteye.com/blog/339618" target="_blank" rel="noopener">NSIS获取本机IP地址写入配置文件</a><br><a href="https://blog.csdn.net/so185582/article/details/5409493" target="_blank" rel="noopener">https://blog.csdn.net/so185582/article/details/5409493</a>  </p>
<h3 id="nsExec"><a href="#nsExec" class="headerlink" title="nsExec"></a>nsExec</h3><p>nsExec:<a href="https://nsis.sourceforge.io/Docs/nsExec/nsExec.txt" target="_blank" rel="noopener">https://nsis.sourceforge.io/Docs/nsExec/nsExec.txt</a><br>执行命令 不弹窗, 有timeout,还可以输出结果到栈或者窗口log<br>其它: ExecCmd为NSIS提供了运行命令行不显示黑框的功能  </p>
<h3 id="NsSCM"><a href="#NsSCM" class="headerlink" title="NsSCM"></a>NsSCM</h3><p>NsSCM plug-in: <a href="https://nsis.sourceforge.io/NsSCM_plug-in" target="_blank" rel="noopener">https://nsis.sourceforge.io/NsSCM_plug-in</a><br>nsSCM stands for Service Control Manager.    </p>
<p>nsSCM::Remove, 没有Stop 也可以移除; 以防作怪,还是先停止<br>$PS: <code>nsExec::ExecToLog &#39;&quot;$INSTDIR\aculearn-idm\db_cluster\ndb_mgm\bin\ndb_mgmd&quot; --remove=&quot;Aculearn Database MGM&quot;&#39;</code> 并不能删除 服务<br><code>nsExec::ExecToLog &#39;net start MongoDB&#39;</code>可以启动服务   </p>
<h3 id="Dump-log-to-file"><a href="#Dump-log-to-file" class="headerlink" title="Dump_log_to_file"></a>Dump_log_to_file</h3><p>Dump_log_to_file: <a href="https://nsis.sourceforge.io/Dump_log_to_file" target="_blank" rel="noopener">https://nsis.sourceforge.io/Dump_log_to_file</a><br><a href="https://nsis.sourceforge.io/Docs/AppendixD.html#dumplogtofile" target="_blank" rel="noopener">https://nsis.sourceforge.io/Docs/AppendixD.html#dumplogtofile</a>   </p>
<h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>NsisXML plug-in (by Wizou):<a href="https://nsis.sourceforge.io/NsisXML_plug-in_(by_Wizou)" target="_blank" rel="noopener">https://nsis.sourceforge.io/NsisXML_plug-in_(by_Wizou)</a><br>XML plug-in:<a href="https://nsis.sourceforge.io/mediawiki/index.php?title=XML_plug-in&amp;oldid=21646" target="_blank" rel="noopener">https://nsis.sourceforge.io/mediawiki/index.php?title=XML_plug-in&amp;oldid=21646</a>   </p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; Define your application name</span><br><span class="line">!define APPNAME &quot;AcuManager&quot;</span><br><span class="line">!define APPNAMEANDVERSION &quot;AcuManager&quot;</span><br><span class="line">!define PatchNumber &quot;20180817&quot;</span><br><span class="line"></span><br><span class="line">; Modern interface settings</span><br><span class="line">!include &quot;MUI2.nsh&quot;</span><br><span class="line">!include &quot;LogicLib.nsh&quot;</span><br><span class="line">!include &quot;x64.nsh&quot;</span><br><span class="line">!include &quot;TextFunc.nsh&quot;</span><br><span class="line">!include &quot;WordFunc.nsh&quot;</span><br><span class="line">!include &quot;nsDialogs.nsh&quot;</span><br><span class="line">!include &quot;Registry.nsh&quot;</span><br><span class="line"></span><br><span class="line">!define MUI_ABORTWARNING</span><br><span class="line">!define MUI_FINISHPAGE_RUN &quot;$INSTDIR\aculearn-idm\Register9.exe&quot;</span><br><span class="line"></span><br><span class="line">!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipWhenUpgrade</span><br><span class="line">!insertmacro MUI_PAGE_WELCOME</span><br><span class="line">!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipWhenUpgrade</span><br><span class="line">!insertmacro MUI_PAGE_LICENSE &quot;..\..\CODE\ExportRelease\Others\license.rtf&quot;</span><br><span class="line">Page custom nsDialogsIPPage nsDialogsIPPageLeave</span><br><span class="line">!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipWhenUpgrade</span><br><span class="line">!define MUI_PAGE_CUSTOMFUNCTION_LEAVE DirectorySelected</span><br><span class="line">!insertmacro MUI_PAGE_DIRECTORY</span><br><span class="line">!insertmacro MUI_PAGE_INSTFILES</span><br><span class="line">!define MUI_PAGE_CUSTOMFUNCTION_PRE SkipWhenUpgrade2</span><br><span class="line">!insertmacro MUI_PAGE_FINISH</span><br><span class="line"></span><br><span class="line">!insertmacro MUI_UNPAGE_CONFIRM</span><br><span class="line">!insertmacro MUI_UNPAGE_INSTFILES</span><br><span class="line"></span><br><span class="line">; Set languages (first is default language)</span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;English&quot;</span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;SimpChinese&quot;</span><br><span class="line">!insertmacro MUI_LANGUAGE &quot;TradChinese&quot;</span><br><span class="line">!insertmacro MUI_RESERVEFILE_LANGDLL</span><br><span class="line"></span><br><span class="line">!include &quot;StringDef.nsh&quot;</span><br><span class="line"></span><br><span class="line">; Request application privileges for Windows Vista</span><br><span class="line">RequestExecutionLevel admin</span><br><span class="line"></span><br><span class="line">; Main Install settings</span><br><span class="line">Name &quot;$&#123;APPNAMEANDVERSION&#125;&quot;</span><br><span class="line">InstallDir &quot;$PROGRAMFILES&quot;</span><br><span class="line">InstallDirRegKey HKLM &quot;Software\AculearnIDM&quot; &quot;installDir&quot;</span><br><span class="line">OutFile &quot;acumanager_setup.exe&quot;</span><br><span class="line"></span><br><span class="line">Caption $(WINCAPTION)</span><br><span class="line">Icon &quot;..\Bin\Others\install.ico&quot;</span><br><span class="line">UninstallIcon &quot;..\Bin\Others\uninstall.ico&quot;</span><br><span class="line">SetDateSave on</span><br><span class="line">SetDatablockOptimize on</span><br><span class="line">SetPluginUnload manual</span><br><span class="line">CRCCheck off</span><br><span class="line">BGGradient FFFFFF 000080 000000</span><br><span class="line">BrandingText &quot;(C)2001-2018, AcuLe@rn&quot;</span><br><span class="line"></span><br><span class="line">;!ifndef NOINSTTYPES ; only if not defined</span><br><span class="line">;  InstType $(FULLINSTALL)</span><br><span class="line">;  InstType $(STUDIOLIVEINSTALL)</span><br><span class="line">;!endif</span><br><span class="line"></span><br><span class="line">;--------------------------------</span><br><span class="line">;Version Information</span><br><span class="line">VIProductVersion &quot;10.0.0.1&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;ProductName&quot; &quot;AcuManager&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;Comments&quot; &quot;AcuManager Installer&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;CompanyName&quot; &quot;Aculearn Pte Ltd.&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;LegalTrademarks&quot; &quot;AcuLe@rn&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;LegalCopyright&quot; &quot;(C)2001-2018, AcuLe@rn&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;FileDescription&quot; &quot;AcuManager Installer&quot;</span><br><span class="line">VIAddVersionKey /LANG=$&#123;LANG_ENGLISH&#125; &quot;FileVersion&quot; &quot;10.0.1&quot;</span><br><span class="line"></span><br><span class="line">;--------------------------------</span><br><span class="line"></span><br><span class="line">Var LOCALIPS</span><br><span class="line">Var AMBASEDIR</span><br><span class="line"></span><br><span class="line">LangString WINCAPTION $&#123;LANG_ENGLISH&#125; &quot;yalhu Software Installation - $&#123;APPNAME&#125;&quot;</span><br><span class="line">LangString WINCAPTION $&#123;LANG_SIMPCHINESE&#125; &quot;安装yalhu的软件 - $&#123;APPNAME&#125;&quot;</span><br><span class="line">LangString STATUS_CLEAN $&#123;LANG_ENGLISH&#125; &quot;Clean Up...&quot;</span><br><span class="line">LangString STATUS_CLEAN $&#123;LANG_SIMPCHINESE&#125; &quot;清空...&quot;</span><br><span class="line">LangString STATUS_SERVICE $&#123;LANG_ENGLISH&#125; &quot;Install hello setup Sync Service...&quot;</span><br><span class="line">LangString STATUS_SERVICE $&#123;LANG_SIMPCHINESE&#125; &quot;正在安装hello同步服务...&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Section &quot;hello&quot; Section1</span><br><span class="line">	SetOutPath &quot;$INSTDIR\db_cluster&quot;</span><br><span class="line">	File /r &apos;aculearn-idm\db_cluster\*.*&apos;</span><br><span class="line"></span><br><span class="line">SectionEnd</span><br><span class="line">Section &quot;Uninstall&quot;</span><br><span class="line">	Delete &quot;$INSTDIR\Uninstall.exe&quot;</span><br><span class="line">	Delete &quot;$INSTDIR\data\*.*&quot;</span><br><span class="line"></span><br><span class="line">	RMDir /r &quot;$INSTDIR\&quot;</span><br><span class="line"></span><br><span class="line">	DeleteRegKey /ifempty HKCU &quot;Software\Modern UI Test&quot;</span><br><span class="line">SectionEnd</span><br></pre></td></tr></table></figure>
<p style="text-align:right">17:36</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Vuejs文档9-对比</title>
    <url>/w3/jslib/vuejs%E6%96%87%E6%A1%A3/vuejs%E6%96%87%E6%A1%A39-%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>对比其他框架</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React 和 Vue 有许多相似之处，它们都有：   </p>
<ul>
<li>使用 Virtual DOM</li>
<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>
</ul>
<h3 id="运行时性能"><a href="#运行时性能" class="headerlink" title="运行时性能"></a>运行时性能</h3><p>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。<br>如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。      </p>
<p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。   </p>
<h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><p>#### JSX vs Templates<br>在 React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。<br>在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。      </p>
<p>事实上 Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是模板。任何合乎规范的 HTML 都是合法的 Vue 模板，这也带来了一些特有的优势：  </p>
<p>####   组件作用域内的 CSS<br>除非你把组件分布在多个文件上 (例如 CSS Modules)，CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的 (比如 styled-components、glamorous 和 emotion)  </p>
<p>如果你是一个 CSS-in-JS 的爱好者，许多主流的 CSS-in-JS 库也都支持 Vue (比如 styled-components-vue 和 vue-emotion)。这里 React 和 Vue 主要的区别是，Vue 设置样式的默认方法是单文件组件里类似 style 的标签。   </p>
<p>单文件组件让你可以在同一个文件里完全控制 CSS，将其作为组件代码的一部分。<br>最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在 <code>&lt;style&gt;</code> 标签内。      </p>
<h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><h4 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h4><p>1) Vue 和 React 都提供了强大的路由来应对大型应用。<br>2) React (比如 Flux、Redux)，而这些状态管理模式甚至 Redux 本身也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式 (Vuex)，     </p>
<p>两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，   </p>
<p>3) Vue 提供了 Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack，Browserify，甚至 no build system。React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：<br>而要注意的是这些限制是故意设计的，  </p>
<h4 id="向下扩展"><a href="#向下扩展" class="headerlink" title="向下扩展"></a>向下扩展</h4><p>React 学习曲线陡峭，  </p>
<h3 id="原生渲染"><a href="#原生渲染" class="headerlink" title="原生渲染"></a>原生渲染</h3><p>React Native 能使你用相同的组件模型编写有本地渲染能力的 APP (iOS 和 Android)。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 Weex 会进行官方合作，   </p>
<h2 id="AngularJS-Angular-1"><a href="#AngularJS-Angular-1" class="headerlink" title="AngularJS (Angular 1)"></a>AngularJS (Angular 1)</h2><p>在 API 与设计两方面上 Vue.js 都比 AngularJS 简单得多<br>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 AngularJS 制定的规则，   </p>
<p>### 数据绑定<br>AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。<br>### 指令与组件<br>在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。在 AngularJS 中，每件事都由指令来做，而组件只是一种特殊的指令。<br>$PS: angularjs有组件的概念吗,是module区分的<br>###  运行时性能<br>Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p>
<h2 id="Angular-原本的-Angular-2"><a href="#Angular-原本的-Angular-2" class="headerlink" title="Angular (原本的 Angular 2)"></a>Angular (原本的 Angular 2)</h2><p>$PS: 没有多少实质内容;</p>
<p>## MobX<br>Mobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。   </p>
<p>## Preact 和其它类 React 库<br>## Ember<br>## Knockout<br> MVVM 领域内的先驱，并且追踪依赖。  它最低能支持到 IE6      </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>vuejs文档</category>
      </categories>
  </entry>
  <entry>
    <title>js数组API</title>
    <url>/sum/js/js%E6%95%B0%E7%BB%84API(034)/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.30 星期二 11:00</p><br><a id="more"></a><br><br># 方法<br>## 分类<br><!-- \#1 [Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/) --><br>## 属性<br>Array.length,Array.prototype,Array.prototype[@@unscopables]<br>## 方法<br>Array.from(), Array.isArray(), <del>Array.observe()</del>, Array.of()<br>实例方法 Array.prototype<br>concat(),  copyWithin(),  entries(),  every(),  fill(),  filter(),  find(),  findIndex(),  flat(),  flatMap(),  forEach(),  includes(),  indexOf(),  join(),  keys(),  lastIndexOf(),  map(),  pop(),  push(),  reduce(),  reduceRight(),  reverse(),  shift(),  slice(),  some(),  sort(),  splice(),  toLocaleString(),  toSource(),  toString(),  unshift(),  values()<br>Array.prototype<a href>@@iterator</a><br><del>Array.unobserve()</del><br>get Array[@@species]<br><!-- $end-#1 --><br>### 版本区分<br>#### 在ES5中，一共有9个Array方法<br>indexOf,  lastIndexOf,    every,    some, forEach,   map, filter,    reduce,   reduceRight<br><br>#### ES6扩展<br>扩展运算符,  Array.from(),   Array.of()<br>copyWithin(),   find() 和 findIndex(),   fill(),   entries()，keys() 和 values(),   includes(),   flat()，flatMap()<br><br>### 是否改变原数组<br>#### 不改变<br>slice,concat,扩展运算符（spread）, map, filter,reduce,<br>#### 改变<br>splice, push/pop,unshift/shift, copyWithin,<br><br>## 方法介绍<br>array.API(callback[, thisArg])<br>callback 被调用时传入三个参数：元素值，元素的索引，原数组。<br>thisArg:执行回调 函数时用作this的值(参考对象)。<br><br>### 执行函数   return/not return<br>forEach() 方法对数组的每个元素执行一次提供的函数。  return:undefined,并且不可链式调用<br><br>reduce() 方法对<strong>累计器和</strong>数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。<br>arr.reduce(callback[, initialValue])    cb-return:accumulator<br>cb参数: accumulator 累计器, currentValue , currentIndex , array<br><br>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。<br>indexOf()/lastIndexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。<br><br>### return:new array<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。<br>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br><br><br>### return-true/false  cb-return<br>every()方法测试数组的所有元素是否都通过了指定函数的测试。<br>some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试。<br><br><br>### 改变数组的操作<br>reverse() 方法颠倒数组中元素的位置，并返回该数组的引用。<br>arr.sort([compareFunction]) 方法用原地算法对数组的元素进行排序，并返回排序后的数组<br>shift()/pop() 方法从数组中删除第一个元素，并返回该元素的值。<br>array.splice(start[, deleteCount[, item1[, item2[, …]]]])<br><br>### 其他(不改变数组操作)<br>var new_array = old_array.concat(value1[, value2[, …[, valueN]]]) 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br><br>arr.slice(begin, end)  方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。<br><br>str = arr.join(separator)   方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。<br><br>var newArray = arr.flat(depth)  方法会递归到指定深度将所有子数组连接，并返回一个新数组。<br>$PS: 实验API;默认1层,转为一层参数为Infinity;还可用于移除空项;<br>arr.fill(value[, start[, end]])  方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br><br>arr.toString()  返回一个字符串，表示指定的数组及其元素。  // expected output: “1,2,a,1a”<br><br>### Array方法<br>Array.isArray(obj)  用于确定传递的值是否是一个 Array。<br>// 鲜为人知的事实：其实 Array.prototype 也是一个数组。<br>Array.isArray(Array.prototype);<br><br>Array.of(element0[, element1[, …[, elementN]]])<br><br>Array.from(arrayLike[, mapFn[, thisArg]])  方法从一个类似数组或可迭代对象中创建一个新的数组实例。  方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。<br><br>### forEach<br>#### 如果数组在迭代时被修改了，则其他元素会被跳过。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>];</span><br><span class="line">words.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">  <span class="keyword">if</span> (word === <span class="string">"two"</span>) &#123;</span><br><span class="line">    words.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// four</span></span><br></pre></td></tr></table></figure><br><br>#### 退出循环<br>$PS: 根据定义,要退出循环就不能用该api<br>退出整个循环使用break会报错，使用return也不能跳出循环。<br>而是只用于跳过本次循环，而不是整个循环.使用some/every后则可以跳出整个循环<br><br>针对这个问题可以使用数组的另外两个方法some()与every()：<br>some()当内部return true时跳出整个循环<br>every()当内部return false时跳出整个循环<br><!-- 参考: [break 或 continue 循环函数](http://www.jstips.co/zh_cn/javascript/break-continue-loop-functional/) --><br><br>其它:<br>throw,空跑循环,神奇改数组大法,最应该使用的every,骚年用for吧<br><!-- [如何在Array.forEach的循环里break](http://jser.me/2014/04/02/如何在Array.forEach的循环里break.html) --><br><br>#### $PS_跳出循环<br><!-- \#2 [JS跳出循环：break，continue，return](https://my.oschina.net/jingyao/blog/793426) --><br>1. break<br>说明：break语句会使运行的程序立刻退出包含在最内层的循环，或者退出一个switch语句。<br>注意：由于它是用来退出循环或者switch语句，所以只有当它出现在这些语句时，这种形式的break语句才是合法的。<br><br>2. continue<br>说明： continue语句和break语句相似。所不同的是，它不是退出一个循环，而是开始循环的一次新迭代。<br>注意： continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内，在其它地方使用都会引起错误！<br><br>3. return<br>说明： return语句就是用于指定函数返回的值。 当执行return语句时，即使函数主体中还有其他语句，函数执行也会停止！<br>注意：return语句只能出现在函数体内，出现在代码中的其他任何地方都会造成语法错误！<br><!-- $end-#2 --><br><br><br># 数组操作注意事项<br><!-- \# [给初学者：JavaScript 中数组操作注意点]   --><br>1. 不要用 for_in 遍历数组<br>1. 不要用 JSON.parse(JSON.stringify()) 深拷贝数组<br>1. 不要用 arr.find 代替 arr.some<br>1. 不要用 arr.map 代替 arr.forEach<br><br><br><p style="text-align:right">11:58</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/sum/js/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96(024)/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.22 星期一 </p>

<h2 id="颗粒化"><a href="#颗粒化" class="headerlink" title="颗粒化"></a>颗粒化</h2><p>柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。<br><!-- \#1 [前端开发者进阶之函数柯里化Currying](https://www.cnblogs.com/pigtail/p/3447660.html) --><br><!-- \#2 [邂逅函数柯里化](https://segmentfault.com/a/1190000008263193#articleHeader0)
\#3 [前端高手必备：详解 JavaScript 柯里化](https://juejin.im/entry/58b316d78d6d810058678579) 
\#4 [浅析 JavaScript 中的 函数 currying 柯里化](https://www.cnblogs.com/zztt/p/4142891.html)
 --><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-提高适用性。"><a href="#1-提高适用性。" class="headerlink" title="1 提高适用性。"></a>1 提高适用性。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">i</span>) </span>&#123;<span class="keyword">return</span> i * i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dubble</span>(<span class="params">i</span>) </span>&#123;<span class="keyword">return</span> i *= <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">handeler, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.map(handeler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 未currying ,每次都需要 map(handle,list)</span></span><br><span class="line">map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">map(dubble, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="comment">// ## currying,定义的时候绑定handle,直接传数据就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">    __args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> __inargs = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, __args.concat(__inargs));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapSQ = currying(map, square);</span><br><span class="line"><span class="keyword">var</span> mapDB = currying(map, dubble);</span><br><span class="line">mapSQ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">mapDB([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<p>$PS: 利用闭包,绑定</p>
<h3 id="2-延迟执行"><a href="#2-延迟执行" class="headerlink" title="2 延迟执行"></a>2 延迟执行</h3><p>柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # 0 简单:只能两个括号 $PS: 其实和第一条一样,利用闭包</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"><span class="keyword">var</span> add1 = add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"><span class="keyword">var</span> add10 = add(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">1</span>)); <span class="comment">// 输出11</span></span><br><span class="line"><span class="comment">// # 1 每次都是新结果,可以混合传参</span></span><br><span class="line"><span class="comment">// ## 1 直接定义  \#1</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,c; c = _args[i++];) &#123;</span><br><span class="line">                sum += c</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Array</span>.prototype.push.apply(_args, <span class="built_in">arguments</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)();<span class="comment">//10</span></span><br><span class="line">add(<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>)(<span class="number">4</span>)() <span class="comment">// 21 // 正确</span></span><br><span class="line"><span class="comment">// ## 2 利用toString  #3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">            <span class="keyword">return</span> _adder;</span><br><span class="line">        &#125;;</span><br><span class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> adder.apply(<span class="literal">null</span>, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果，可自由组合的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">//f 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// f 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// f 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">3</span>,<span class="number">5</span>).toString()) <span class="comment">// 14</span></span><br><span class="line">alert(add(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// alert: 6  true </span></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">1)当使用console.log，或者进行运算时，隐式转换就会发生。</span></span><br><span class="line"><span class="comment">2) 当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString/vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。</span></span><br><span class="line"><span class="comment">3) 其中valueOf的优先级会toString高一点。    */</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 2 原来基础上增加</span></span><br><span class="line"><span class="comment">// ## 2.1_加法 不可以混合,只有第一个参数有意义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>)</span>&#123;<span class="comment">//n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">        n+=m;</span><br><span class="line">        <span class="built_in">arguments</span>.callee.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;<span class="comment">//引用当前正在调用的函数本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alert(add(1)(2)(3)/*.toString()*/);</span></span><br><span class="line"><span class="comment">//alert(add(1)(2)(3)(4)/*.toString()*/);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2.1_乘法 不可以混合,只有第一个参数有意义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count=n;</span><br><span class="line">    <span class="keyword">var</span> tem=<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">        count=count*m;</span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;</span><br><span class="line">    tem.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// f 22*3*4</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>,<span class="number">3</span>)) <span class="comment">// f 30=2*3*5</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>,<span class="number">3</span>).toString) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2.2 通用写法 \#1 \#2  可以混合传参</span></span><br><span class="line"><span class="keyword">var</span> curring = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return function () &#123; // \#4 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> cb; <span class="comment">// </span></span><br><span class="line">        <span class="comment">// return arguments.callee; // \#4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> multi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// \#2</span></span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> argsArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    argsArray.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        total += item;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">/* \#4</span></span><br><span class="line"><span class="comment">    for (var i = 0, c; c = arguments[i++];) &#123;</span></span><br><span class="line"><span class="comment">        total += c;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calc = curring(multi);</span><br><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(calc()); <span class="comment">// 21 //空白调用时才真正计算</span></span><br><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)()<span class="comment">// 27 // 是在原来(21)的基础上增加的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-固定易变因素。"><a href="#3-固定易变因素。" class="headerlink" title="3 固定易变因素。"></a>3 固定易变因素。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>,</span><br><span class="line">    _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, _args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单点</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [].prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 0 直观写法 #2</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(ctx, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPrime1=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash=&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash[n]!==<span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;<span class="built_in">Math</span>.sqrt(n);i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> hash[n]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hash[n]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">Function</span>.prototype.toMemory=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash=&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fun=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[n]!==<span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[n]=fun.call(<span class="literal">null</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;<span class="built_in">Math</span>.sqrt(n);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">isPrime2=isPrime2.toMemory();</span><br></pre></td></tr></table></figure>
<p style="text-align:right">17:00</p>



]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流与去抖</title>
    <url>/sum/js/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E6%8A%96(024)/</url>
    <content><![CDATA[<!-- \#[Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/) -->
<p>### Debounce<br>The Debounce technique allow us to “group” multiple sequential calls in a single one.<br>Resize,keypress on autocomplete form with Ajax request  </p>
<p>### Throttle<br>By using _.throttle, we don’t allow to our function to execute more than once every X milliseconds.     </p>
<p>The main difference between this and debouncing is that throttle guarantees the execution of the function regularly, at least every X milliseconds.     </p>
<p>Infinite scrolling</p>
<p>### requestAnimationFrame (rAF)</p>
<p>### Conclusion<br>debounce: Grouping a sudden burst of events (like keystrokes) into a single one.<br>throttle: Guaranteeing a constant flow of executions every X milliseconds. Like checking every 200ms your scroll position to trigger a CSS animation.<br>requestAnimationFrame: a throttle alternative. When your function recalculates and renders elements on screen and you want to guarantee smooth changes or animations. Note: no IE9 support.     </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>节流：间隔一定时间触发回调来控制函数调用频率<br>拖拽功能，射击游戏，计算鼠标移动的距离，Canvas 模拟画板功能，<del>搜索联想</del>   </p>
<p>监听滚动事件判断是否到页面底部自动加载更多：<br>给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；<br>如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次      </p>
<p>去抖：对于连续的事件响应我们只需要执行一次回调<br>resize/scroll 触发统计事件，文本输入的验证, $PS: 搜索联想应该在这里<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (!previous) &#123;</span><br><span class="line">            previous = <span class="built_in">Date</span>.now()</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previous + wait &gt;= <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                clearTimeout(timer)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                previous = <span class="built_in">Date</span>.now()</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previous = <span class="built_in">Date</span>.now()</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">17:00</p>



]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习</title>
    <url>/sum/jsplus/react%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.18 星期四 9:46</p>

<p>不是MVC,只是View;需要配合使用,router,flux/redux等<br>单向数据流,不是双向数据绑定,<br>视图更新(响应式):通过setState触发生命周期,进行diff算法,更新<br>css/样式文件, 行内css/css对象:伪类/动画困难; 库:css modules,style component,动画支持…<br>UI:ant Design(antd)    </p>
<p>基于: v16.5</p>
<h2 id="React-顶层-API"><a href="#React-顶层-API" class="headerlink" title="React 顶层 API"></a>React 顶层 API</h2><!-- > $from:API:React 顶层 API    -->
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16.5 react.development.js</span></span><br><span class="line"><span class="keyword">var</span> React = &#123;</span><br><span class="line">    Children: &#123; <span class="comment">// ### 3 转换元素</span></span><br><span class="line">        map: mapChildren,  <span class="comment">// 如果children是一个Fragment，它将被视为一个子组件并且不会被遍历。</span></span><br><span class="line">        forEach: forEachChildren,</span><br><span class="line">        count: countChildren,</span><br><span class="line">        toArray: toArray,</span><br><span class="line">        only: onlyChild</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ### 1  组件(Components)</span></span><br><span class="line">    Component: Component,</span><br><span class="line">    PureComponent: PureComponent,</span><br><span class="line"></span><br><span class="line">    createContext: createContext,</span><br><span class="line">    <span class="comment">// ### 5 Refs</span></span><br><span class="line">    createRef: createRef,</span><br><span class="line">    forwardRef: forwardRef,</span><br><span class="line">    <span class="comment">// ### 4 片段(Fragments)</span></span><br><span class="line">    Fragment: REACT_FRAGMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    StrictMode: REACT_STRICT_MODE_TYPE,</span><br><span class="line">    unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,</span><br><span class="line">    unstable_Profiler: REACT_PROFILER_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ### 2 创建 React 元素  </span></span><br><span class="line">    createElement: createElementWithValidation,</span><br><span class="line">    createFactory: createFactoryWithValidation,</span><br><span class="line">    <span class="comment">// ### 3 转换元素 ,还有上面的Children</span></span><br><span class="line">    cloneElement: cloneElementWithValidation,</span><br><span class="line">    isValidElement: isValidElement,</span><br><span class="line"></span><br><span class="line">    version: ReactVersion,</span><br><span class="line"></span><br><span class="line">    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ## 2 参考</span></span><br><span class="line">React. createElement/cloneElement( type,[props],[...children])</span><br><span class="line">React.createFactory(type)</span><br><span class="line">React.isValidElement(object)</span><br></pre></td></tr></table></figure>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>每一个 JSX 元素都是调用 React.createElement(component, props, …children) 的语法糖，<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Hello toWhat=<span class="string">"World"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 编译成不使用JSX的代码:</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Hello, &#123;<span class="attr">toWhat</span>: <span class="string">'World'</span>&#125;, <span class="literal">null</span>),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="ES6-ES5"><a href="#ES6-ES5" class="headerlink" title="ES6/ES5"></a>ES6/ES5</h2><p>### 自定义组件<br>### props<br>### 设置初始化 State(状态)<br>### 事件/绑定this:$PS始终指向定义时的对象<br>如果你想更稳妥的方法，你有以下选择：<br>4.1 在构造函数中绑定方法。<br>4.2 使用箭头函数，例如，onClick={(e) =&gt; this.handleClick(e)}。<br>4.0 保持使用 createReactClass。<br>4.3 使用箭头绑定方法  语法是实验性的，并且这个语法将来可能会发生变化，或者这个提案可能不会纳入语言范畴。    </p>
<p>4.4 bind(this),箭头函数也是绑定了this<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ### 设置初始化 State(状态)</span></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: props.initialCount&#125;;</span><br><span class="line">        <span class="comment">// #### 4.1 这一行很重要！</span></span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;  <span class="comment">// #### 4.1 / 4.2 </span></span><br><span class="line">        alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// #### 4.3 这里使用箭头绑定方法.   警告：这个语法是实验性的！</span></span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; // </span></span><br><span class="line">         <span class="comment">// 因为 `this.handleClick` 是绑定的，所以我们可以使用它作为一个事件处理程序。</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            </span><br><span class="line">            &lt;button </span><br><span class="line">                <span class="comment">// #### 4.1 /4.3 </span></span><br><span class="line">                onClick=&#123;<span class="keyword">this</span>.handleClick&#125;   </span><br><span class="line">                <span class="comment">// #### 4.2</span></span><br><span class="line">                onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;</span><br><span class="line">                <span class="comment">// #### 4.4 bind 和 4.2 箭头函数  相同</span></span><br><span class="line">                onChange=&#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.changTextValue() &#125;.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">            &gt;  </span><br><span class="line">                Say hello</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Greeting.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: 'Mary'</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ## ES5</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ### 1 </span></span><br><span class="line"><span class="regexp">var createReactClass = require('create-react-class');</span></span><br><span class="line"><span class="regexp">var Greeting = createReactClass(&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ### 2</span></span><br><span class="line"><span class="regexp">    getDefaultProps: function() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            name: 'Mary'</span></span><br><span class="line"><span class="regexp">        &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ### 3</span></span><br><span class="line"><span class="regexp">    getInitialState: function() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;count: this.props.initialCount&#125;;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ### 4.0 在 createReactClass() 中，并不需要这么做，因为方法可以自动绑定。</span></span><br><span class="line"><span class="regexp">    handleClick: function() &#123;</span></span><br><span class="line"><span class="regexp">        alert(this.state.message);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    render: function() &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/</span>h1&gt;;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">                Say hello</span><br><span class="line">            &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="组件-模块和类"><a href="#组件-模块和类" class="headerlink" title="组件,模块和类"></a>组件,模块和类</h2><p>函数式组件和类组件:如果你需要使用 ref ，你需要将组件转化成 类(class)组件，就像需要 生命周期方法 或者 state 一样。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1 函数式组件和类组件      </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ### 2 代表 DOM 标签的 React 元素：和 用户定义的组件</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Welcome;</span><br></pre></td></tr></table></figure></p>
<h3 id="非受控组件-VS-controlled-component"><a href="#非受控组件-VS-controlled-component" class="headerlink" title="非受控组件 VS controlled component"></a>非受控组件 VS controlled component</h3><p>单纯/不受控制的话,使用非受控组件很容易;<br>受控的话,不控制shouldUpdate,会一直更新;还需要做逻辑/设置onChange      </p>
<h3 id="高阶组件-VS-Mixin"><a href="#高阶组件-VS-Mixin" class="headerlink" title="高阶组件 VS Mixin"></a>高阶组件 VS Mixin</h3><p>React 最早也是使用 mixins 的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了 mixinx 转而使用 HoC，<!-- 关于mixin究竟哪里不好，可以参考React官方的这篇文章 [Mixins Considered Harmful](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)   --></p>
<!-- 在 Vue 中我们组合不同功能的方式是通过 mixin，而在React中我们通过 HoC (高阶组件）。      

而 Vue 一直是使用 mixin 来实现的。为什么 Vue 不采用 HoC 的方式来实现呢？  
1) 高阶组件本质就是高阶函数，React 的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。   
2) 但是Vue就不行了，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个高阶组件，那么这个被包装的组件就无法正常工作了。    -->
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>使用ES6 import/export<br>不用ES5 commomjs: require / module.exports<br>$BLOB:js模块规范    </p>
<h2 id="属性-props-和-状态-state"><a href="#属性-props-和-状态-state" class="headerlink" title="属性(props) 和 状态(state)"></a>属性(props) 和 状态(state)</h2><!-- > $from:API:react-component    -->
<h3 id="类属性-Class-Properties-defaultProps"><a href="#类属性-Class-Properties-defaultProps" class="headerlink" title="类属性(Class Properties):defaultProps"></a>类属性(Class Properties):defaultProps</h3><p>defaultProps 可以定义为组件类自身的属性，用来设置类的默认 props 。 这用于未定义的(undefined) props，但不用于 null props 。  </p>
<p>还有一个类属性:displayname:为调试目的显示不同的名称或者创建高阶组件时<br>$PS: 静态属性defaultProps,对应静态方法static getDefaultProps(): 在类定义时使用<br>$PS:另外的静态属性: propTypes; 详见 [## 静态类型检查]     </p>
<p>#### 实例获取类的静态属性(defaultProps可以被实例访问)      </p>
<blockquote>
<p>在函数和 ES6 classes(类) 中，defaultProps 被定义为组件本身的属性  </p>
</blockquote>
<p>上面的描述没有在ES6 中找到,react中实例可以获取类的静态属性可以用下面的解释:<br>正常情况下,类的静态属性,实例是无法直接获取的;但是在react中,静态方法getDeafultProps中super作为对象,指向父类非原型,所以实例可以访问类的静态属性了.<br>$PS_疑问:但是,在v16.5.2文档中没有找到这个静态方法啊   </p>
<blockquote>
<p>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br>第一种情况，super作为函数调用时，代表父类的构造函数。<br>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。     </p>
</blockquote>
<p>#### 用法<br>由于是用ES6 class语法创建组件，其内部只允许定义方法，而不能定义属性，class的属性只能定义在class之外。所以defaultProps要写在组件外部。   </p>
<p>组件内部:如果babel设置为es6的转码方式，会报错，因为定义静态属性不属于es6，而在es7的草案中。ES6的class中只有静态方法，没有静态属性。需要设置babel或者webpack(添加query-&gt; presets-&gt; stage-0)<br><!-- [React中static defaultProps报错问题详解](https://www.jianshu.com/p/29a025128990) --><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">/* static getDefaultProps()&#123;</span></span><br><span class="line"><span class="comment">        return &#123;&#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">// ## ES7  </span></span><br><span class="line">    <span class="keyword">static</span> defaultProps=&#123;</span><br><span class="line">        name: <span class="string">'XiaoHong'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> propTypes=&#123;</span><br><span class="line">        name: PropTypes.string,</span><br><span class="line">        sex: PropTypes.string.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## ES6 或者分离出来</span></span><br><span class="line">Hello.defaultProps=&#123;<span class="attr">name</span>:<span class="string">'xiaohong'</span>&#125;</span><br><span class="line">Hello.propsTypes=&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实例属性-Instance-Properties-props"><a href="#实例属性-Instance-Properties-props" class="headerlink" title="实例属性(Instance Properties): props"></a>实例属性(Instance Properties): props</h3><p>this.props 包含此组件的调用者定义的 props 。    </p>
<!-- > $from:主要概念:组件(Components) 和 属性(Props)      -->
<p>Props 是只读的<br>论你用函数或类的方法来声明组件, 它都无法修改其自身 props.     </p>
<p><strong>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</strong>    </p>
<p>当然， 应用 UI 总是动态的，并且随时有可以改变。 所以在下一节, 我们会介绍一个新的概念 state(状态) 。state 允许 React 组件在不违反上述规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。</p>
<h3 id="实例属性-Instance-Properties-state"><a href="#实例属性-Instance-Properties-state" class="headerlink" title="实例属性(Instance Properties): state"></a>实例属性(Instance Properties): state</h3><p>state(状态) 包含该组件的的特定数据，该数据可能随时间而变化。 状态是用户定义的，它应该是一个纯粹的 JavaScript 对象。<br>如果你不在 render() 中使用它，它就不应该是 state 。 例如，您可以直接在实例上放置定时器ID。</p>
<p>永远不要直接改变 this.state ，因为调用 setState() 之后可能会覆盖你所做的这个改变。 把 this.state 看作是不可变的。<br><!-- > $from:主要概念:组件(Components) 和 属性(Props)      --><br>#### 正确地使用 State(状态)<br>1) 不要直接修改 state(状态)<br>2) state(状态) 更新可能是异步的<br>React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新。<br>因为 this.props 和 this.state 可能是异步更新的，你不能依赖他们的值计算下一个state(状态)。<br>3) state(状态)更新会被合并<br>当你调用 setState()， React 将合并你提供的对象到当前的状态中。<br>例如，你的状态可能包含几个独立的变量：然后通过调用独立的 setState() 调用分别更新它们:<br>合并是浅合并，所以 this.setState({comments}) 不会改变 this.state.posts 的值，但会完全替换this.state.comments 的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>; <span class="comment">// 错误  这样将不会重新渲染一个组件：</span></span><br><span class="line"><span class="comment">// ### 2 </span></span><br><span class="line"><span class="comment">// 错误  可能导致 counter(计数器)更新失败：</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 应该使用第 2 种 setState() 的格式，它接收一个函数，而不是一个对象。</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// ### 3 </span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    fetchPosts().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        posts: response.posts</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetchComments().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        comments: response.comments</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><!-- ![react生命周期.png](../assets/images/react生命周期.png)     -->
<p>react生命周期: <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a>   </p>
<h3 id="Mounting-装载"><a href="#Mounting-装载" class="headerlink" title="Mounting(装载)"></a>Mounting(装载)</h3><p>当组件实例被创建并将其插入 DOM 时，将按以下顺序调用这些方法：</p>
<p>constructor(props)<br>static getDerivedStateFromProps(props, state)<br>render()<br>componentDidMount()</p>
<p>UNSAFE_componentWillMount()</p>
<h3 id="Updating-更新"><a href="#Updating-更新" class="headerlink" title="Updating(更新)"></a>Updating(更新)</h3><p>更新可以由对 props 或 state 的更改引起。当重新渲染组件时，按以下顺序调用这些方法：<br>static getDerivedStateFromProps(props, state)<br>shouldComponentUpdate(nextProps, nextState)<br>render()<br>getSnapshotBeforeUpdate(prevProps, prevState)<br>componentDidUpdate(prevProps, prevState, snapshot)</p>
<p>UNSAFE_componentWillUpdate()<br>UNSAFE_componentWillReceiveProps()</p>
<h3 id="Unmounting-卸载"><a href="#Unmounting-卸载" class="headerlink" title="Unmounting(卸载)"></a>Unmounting(卸载)</h3><p>componentWillUnmount()</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在生命周期方法中，或在任何子组件的构造函数中，渲染过程中出现错误时调用此方法。<br>componentDidCatch(error, info)</p>
<!-- 
\### 其他 APIs  setState(updater, [callback]),  setState(updater, [callback])
\### 类属性  defaultProps,displayName
\### 实例属性  props,state
 -->
<p>#### render<br>render() 方法是类组件中唯一必须的方法。<br>当被调用时，它会检查 this.props 和 this.state 并返回其中一个类型:React元素,数组和片段(fragments),Portals,字符串和数字,布尔值 或 null   </p>
<p>render() 函数应该是纯函数，这意味着它不会修改组件状态，每次调用它时返回相同的结果，它不会直接与浏览器交互。<br>如果您需要与浏览器交互，请改用 componentDidMount() 或其他生命周期方法执行你的工作。     </p>
<p>如果 shouldComponentUpdate() 方法返回 false ，render() 不会被调用。         </p>
<p>#### constructor<br>不应该在 constructor() 中调用 setState()。相反，如果您的组件需要使用本地 state，直接在构造函数中 将初始状态赋给 this.state 即可       </p>
<p>避免复制 属性(props) 到 状态(state) ！.仅在你故意要忽略 属性(props)更新时，使用此模式。    </p>
<p>#### static getDerivedStateFromProps(props, state)<br>这种方法适用于罕见用例 ，其 state(状态) 取决于 属性(props) 随着时间的推移而改变。 例如，实现一个 <transition> 组件可能会比较方便，该组件比较其前一个和下一个子 state (状态)，以决定哪些子元素可以进入和退出。   </transition></p>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><h2 id="refs和转发refs"><a href="#refs和转发refs" class="headerlink" title="refs和转发refs"></a>refs和转发refs</h2><!-- Refs 提供了一种访问在 render 方法中创建的 DOM 节点或 React 元素的方式。     

在少数情况下，你需要在常规数据流外强制修改子元素。被修改的子元素可以是 React 组件实例，或者是一个 DOM 元素。在这种情况下，React 提供了解决办法。    
(在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素。)  

\### 何时使用 Refs      
下面有一些正好使用 refs 的场景:
* 处理focus、文本选择或者媒体播放 ($PS:autoFocus一般方法`<input autoFocus={true}  />`)      
* 触发强制动画
* 集成第三方DOM库
如果可以通过声明式实现，就尽量避免使用 refs 。  

 -->
<h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p>对于更大的代码库我们建议使用 Flow 或者 TypeScript 来替代 PropTypes。<br>原因: 像 Flow 和 TypeScript 这样的静态类型检查器可以在运行代码之前识别某些类型的问题。 他们还可以通过添加自动完成功能来改善开发人员的工作流程。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line">App.propTypes=&#123;</span><br><span class="line">    name:PropTypes.string.isRequired,</span><br><span class="line">    todos: PropTypes.arrayOf(PropTypes.object).isRequired,</span><br><span class="line">    add:PropTypes.func.isRequired</span><br><span class="line">&#125;</span><br><span class="line">App.defaultProps=&#123;</span><br><span class="line">    name:<span class="string">'anonymous'</span>,</span><br><span class="line">    todos:[],</span><br><span class="line">    add:<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $PS:写在类声明中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getDefaultProps()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $PS 新的是属性</span></span><br><span class="line">    <span class="keyword">static</span> defaultProps=&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> propTypes=&#123;</span><br><span class="line">        name:PropTypes.string.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><p><code>\public\</code> 文件夹为web服务器,放置数据文件,比如json,可以通过fetch/ajax 异步获取数据         </p>
<h2 id="React-render-和reconciliation"><a href="#React-render-和reconciliation" class="headerlink" title="React.render()和reconciliation"></a>React.render()和reconciliation</h2><h2 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater, [callback])"></a>setState(updater, [callback])</h2><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><!-- $from: <http://react.css88.com/docs/react-component.html#setstate>      -->
<p>1) setState() <strong>排队更改组件的 state ，并通过更新 state 来告诉 React</strong> ，该组件及其子组件需要重新渲染。这是用于 响应事件处理程序 和 服务器响应 更新用户界面的主要方法。    </p>
<p>2) 记住 setState() <strong>作为一个请求，而不是立即命令来更新组件</strong>。为了更好的感知性能，React 可能会延迟它，然后合并多个setState()更新多个组件。 React不保证 state 更新就立即应用(重新渲染)。   </p>
<p>3) setState() 并不总是立即更新组件。它可能会 <strong>批量 或 延迟到后面更新</strong>。这使得在调用 setState() 之后立即读取 this.state 存在一个潜在的陷阱。 而使用 componentDidUpdate 或 setState 回调（setState(updater, callback)），在应用更新后，都将被保证触发。如果你需要根据先前的 state 设置 state，阅读下面的 updater 参数。</p>
<p>4) setState() <strong>总是会导致重新渲染，除非</strong> shouldComponentUpdate() 返回 false 。如果可变对象被使用，并且条件渲染逻辑不能在 shouldComponentUpdate() 中实现，只有当新 state 与先前 state 不同时调用 setState() 才能避免不必要的重新渲染。     </p>
<p>### 1  updater 函数<br>在这个签名中，第一个参数是的一个 updater 函数：<br>state 是对先前 state 的引用。 它不会直接突变。 相反，应该根据输入的 state 和 props 构建一个新的对象来表示更改。</p>
<p>### 2  一个对象<br>您可以随意的传递 一个对象 作为 setState() 的第一个参数，而不是一个函数：<br>这将执行 stateChange 的浅合并到新的 state<br>这种形式的 setState() 也是异步的，并且在同一周期内的多个调用可以被合并在一起执行批处理。    </p>
<p>同一周期中，后续调用将覆盖先前调用的值，所以数量只会增加一次。如果下一个 state 取决于当前的 state ，我们推荐使用 updater 函数形式： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1 updater 函数 </span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123; <span class="comment">// state:prevState</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: state.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// ### 2 一个对象</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">quantity</span>: <span class="number">2</span>&#125;)    </span><br><span class="line"><span class="comment">// 例如，如果您尝试在同一周期内多次增加项目数量，这将导致的结果相当于：      </span></span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">quantity</span>: state.quantity + <span class="number">1</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 正确updater函数</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: state.quantity + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### $PS: 一个对象  其他用法</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">todos</span>:_add(index,value)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_add</span>(<span class="params">index.value</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// do sth</span></span><br><span class="line">    retrun &#123;&#125; <span class="comment">// 返回一个对象   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解合并多个"><a href="#理解合并多个" class="headerlink" title="理解合并多个"></a>理解合并多个</h3><p>将多个 setState() 调用合并为一次更新。以后一个为准<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1.1 stateChange</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+index&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 1.2 和上面一样,虽然是updater,但是仍然用了this.state.count; 没有用 state参数 </span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+index&#125;))</span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state,props</span>)=&gt;</span>(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">10</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 3 正确的updater,会增加两次</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState,props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:preState.count+index&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState,props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:preState.count+index&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="updater-return问题"><a href="#updater-return问题" class="headerlink" title="updater return问题"></a>updater return问题</h3><p>1) 如果没有返回值<code>return</code>, 不会render,不论todos有没有改变<br>2) 有return, todos没有变化,也不会render<br>3) todos有变化,return {} / {others:’haha’} /{others:[]}/…  正常<br>4) todos有变化,return {todos:[]}, 根据返回的todos做更新:如果[]就为0,如果一个就是一个<br><!-- $PS: 之前的时候,this.setState({todos:this.state.todos.splice(index,1)}) 只会删除一次;不知道怎么弄的, 给Todolist 传data的时候没有用this.state?? 试过了,也不是这个原因    --></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><!-- \# [[揭密React setState]](http://imweb.io/topic/5b189d04d4c96b9b1b4c4ed6)   -->
<p>setState被调用之后，更新组件的过程，下面是一个简单的流程图。<br><!-- ![react setState流程图](../assets/images/react setState流程图.png)     --><br><!-- $PS: 原文中图是base64的 --></p>
<p>1) setState = function (partialState, callback) : 这里的partialState可以传object,也可以传function,它会产生新的state以一种Object.assgine（）的方式跟旧的state进行合并。<br>2) enqueueSetState: 1、将新的state放进数组里 2、用enqueueUpdate来处理将要更新的实例对象<br>3) enqueueUpdate: 当前如果正处于创建/更新组件的过程，就不会立刻去更新组件，而是先把当前的组件放在dirtyComponent里，所以不是每一次的setState都会更新组件~。  </p>
<p>这段代码就解释了我们常常听说的：setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新。<br>4) batchingStrategy: 1、如果当前事务正在更新过程中，则使用enqueueUpdate将当前组件放在dirtyComponent里。 2、如果当前不在更新过程的话，则执行更新事务。<br>5) transaction:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactBaseClassses.js</span></span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  将setState事务放进队列中</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- $end -->
<h2 id="Immutable-data-和-setstate"><a href="#Immutable-data-和-setstate" class="headerlink" title="Immutable data 和 setstate"></a>Immutable data 和 setstate</h2><p>$PS_原因:因为 state 跟 props 如果没变的话，本来就不该触发 render function。<br>所以在用setState的时候总是要产生一个新的物件，而不是直接对现有的做操作。    </p>
<p>使用PureComponent ,不是自己编写 shouldComponentUpdate,提升性能<br>避免(PureComponent对象/数组是引用不会进行更新)最简单的方法是不要突变(mutate) props 或 state 的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 1.1 不能这样  </span></span><br><span class="line">constnewObject = <span class="keyword">this</span>.state.obj</span><br><span class="line">newObject.id = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">obj</span>: newObject&#125;)  </span><br><span class="line"><span class="comment">// ### 1.2 也不能这样  </span></span><br><span class="line">constarr = <span class="keyword">this</span>.state.arr;</span><br><span class="line">arr.push(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">list</span>: arr&#125;) </span><br><span class="line"><span class="comment">// $PS1: 如果是PureComponent,仅会进项浅比较,不会更新. Component会更新  </span></span><br><span class="line"><span class="comment">// $PS2:通过赋值变量更改不会提示:  Do not mutate state directly. Use setState()</span></span><br><span class="line"><span class="comment">// 直接操作:this.setState(&#123;list:this.statelist.push(123)&#125;)  // 会提示:  Do not mutate state directly. Use setState()</span></span><br><span class="line"><span class="comment">// 个人高级没有差别</span></span><br><span class="line"><span class="comment">// $PS3: push/splice, += 不会提示 Do not mutate state directly. Use setState()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 正确用法</span></span><br><span class="line">handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="comment">// ### 2.1 concat 重写</span></span><br><span class="line">        words: state.words.concat([<span class="string">'marklar'</span>])</span><br><span class="line">        <span class="comment">// ### 2.2 ES6 对于数组支持展开语法 </span></span><br><span class="line">        words: [...state.words, <span class="string">'marklar'</span>],</span><br><span class="line">        <span class="comment">// ### 2.3 Object.assign  // 属于ES6语法，需要 polyfill。</span></span><br><span class="line">        words: <span class="built_in">Object</span>.assign(&#123;&#125;, colormap, &#123;<span class="attr">right</span>: <span class="string">'blue'</span>&#125;);</span><br><span class="line">        <span class="comment">// ### 2.4 JavaScript提案添加了对象展开符 ，能够更简单地更新对象而不突变对象。</span></span><br><span class="line">        words: &#123;...colormap, <span class="attr">right</span>: <span class="string">'blue'</span>&#125;;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-Immutable-数据结构"><a href="#使用-Immutable-数据结构" class="headerlink" title="使用 Immutable 数据结构"></a>使用 Immutable 数据结构</h3><p>Immutable.js 是解决上述问题的另外一个方法，其提供了通过结构共享实现(Structural Sharing)地不可变的(Immutable)、持久的(Persistent)集合<br>其他两个:seamless-immutable 和 immutability-helper      </p>
<p>提供了一种更简单的方式来追踪对象的改变，这正是我们实现 shouldComponentUpdate 所需要的。这将会提供可观的性能提升。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 0 下面是普通的JavaScript代码：</span></span><br><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> y = x;</span><br><span class="line">y.foo = <span class="string">'baz'</span>;</span><br><span class="line">x === y; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// ## 1 immutable.js </span></span><br><span class="line"><span class="keyword">const</span> SomeRecord = Immutable.Record(&#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> SomeRecord(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> y = x.set(<span class="string">'foo'</span>, <span class="string">'baz'</span>);</span><br><span class="line"><span class="keyword">const</span> z = x.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">x === y; <span class="comment">// false</span></span><br><span class="line">x === z; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">19:33</p>

<h2 id="ReactDOM-render-element-container-callback"><a href="#ReactDOM-render-element-container-callback" class="headerlink" title="ReactDOM.render(element, container[, callback])"></a>ReactDOM.render(element, container[, callback])</h2><p>渲染一个 React 元素到由 container 提供的 DOM 中，并且返回组件的一个 引用(reference) （或者对于 无状态组件 返回 null ）。    </p>
<p>如果 React 元素先前已经被渲染到了 container 中，那么将对其执行更新，并且对 DOM 只修改需要修改的地方，以反映最新的 React元素。   </p>
<p>如果提供了可选的回调，它将在组件渲染或更新后执行。  </p>
<blockquote>
<p>ReactDOM.render() 当前返回根 ReactComponent 实例的引用。但是，使用此返回值是历史遗留的，应该避免使用，因为在某些情况下，React 的未来版本可能会异步渲染组件。如果您需要引用根 ReactComponent 实例，优选的解决方案是绑定一个 ref 回调 到根元素。    </p>
</blockquote>
<p>### 用处<br>返回的根实例的引用,可以在全局调用 根实例 的属性/方法,比如state/props/refs,生命周期方法, change/toggle等. 这样就可以通过外部方式调用react实例方法 异步 向react 组件传递数据,比如外部jquery的ajax,CEF传递的数据.<br>同步数据,react组件内部可以直接使用      </p>
<p>回调函数callback其实是没有参数的，但是，当render方法变成异步方法之后，说不定就会向其注入一些参数了。具体的，拭目以待。<br><!-- [ReactDOM You Should](https://segmentfault.com/a/1190000010979268) --></p>
<p>#### 第二种方式<br>在componentDidMount中,可以把实例暴露出去,比如暴露到 windows 上<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  windows.__yourReactComp__ = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// somewhere </span></span><br><span class="line"><span class="keyword">if</span>(windows.__yourReactComp__.state.bar)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"you got it!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<!-- 参考:   
[reactjs – 从外部调用React组件方法](https://codeday.me/bug/20180208/131102.html)
$PS: 方法1
[怎么在window全局作用域下获取React变量](https://segmentfault.com/q/1010000004852644)
$PS: 方法2
 -->
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>遍历对象的时候用for报错:”*不能遍历的属性” ,估计是 Symbol<br>用了Object.keys(obj) (ES2017 引入了跟Object.keys配套的Object.values Object.entries) 遍历数组(obj对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。)        </p>
<h2 id="Todolist"><a href="#Todolist" class="headerlink" title="Todolist"></a>Todolist</h2><!-- 1) 只有添加事项用了immutable data,其他都不是;不是PureComponent感觉也没有什么影响     -->
<p>1) 所有input(add和change)使用了非受控组件defalutValue,只有onBlur/Enter的时候,才会触发更新;受控组件的话每次onChange都需要做更新<br>2) 切换isEdit中,TodoInput 组件input需要设置 autoFocus,否则点击其他事项的时候,上一个不会做切换<br><!-- $PS: 之前切换的时候,状态经常不会更新  --></p>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><p>高阶组件,转发refs,      </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js对象</title>
    <url>/sum/js/js%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.15 星期一 11:31</p>

<h1 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h1><p>可以通过new Object()， Object.create()方法，或者使用字面量标记（初始化标记）初始化对象。</p>
<h1 id="私有-公有-共有-属性-方法，静态属性-方法，特权方法"><a href="#私有-公有-共有-属性-方法，静态属性-方法，特权方法" class="headerlink" title="私有/公有/共有-属性/方法，静态属性/方法，特权方法"></a>私有/公有/共有-属性/方法，静态属性/方法，特权方法</h1><p>私有：是指属性和方法不能在new对象中读写；<br>静态：无需实例化就可以调用的方法就叫静态方法；<br>受保护：不能直接读写，只能通过一个包装方法对其进行操作；    </p>
<p>1、构造函数内部通过this声明的属性就是公有属性，通过var声明的就是私有属性。<br>2、所有定义在原型上方法都是“公有”的。   </p>
<!-- [javascript对象中私有、公用、静态、共有的定义区别](https://www.jianshu.com/p/b54e2b945caa) -->
<p>私有：只在对象内部能够访问，在构造函数内部直接调用var或function定义<br>公有：可以在对象外部访问，在构造函数内部用this定义<br><!-- 静态：在类上访问，在构造函数的对象上定义     --><br>共有：所有对象公用的变量或方法，是公有的，在构造函数的prototype原型上定义   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>; <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params"></span>)</span>&#123;num++;&#125; <span class="comment">// 私有方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"javscript"</span>; <span class="comment">// 公有属性</span></span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125; <span class="comment">// 公有方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book.isBook = <span class="literal">true</span>; <span class="comment">// 静态公有属性(对象实例不能访问)</span></span><br><span class="line">Book.checkBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  &#125;  <span class="comment">// 静态公有方法(对象实例不能访问)    </span></span><br><span class="line"></span><br><span class="line">Book.prototype.calcPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="keyword">this</span>.num;&#125; <span class="comment">// 实例共有方法</span></span><br><span class="line">Book.prototype.sell = <span class="literal">true</span>  <span class="comment">// 实例共有属性</span></span><br></pre></td></tr></table></figure>
<!-- [[js公有、私有、静态属性和方法的区别]](https://jingyan.baidu.com/article/d5c4b52bc2f71dda570dc575.html) -->
<p>而要了解js面向对象，就必需先了解js中什么是公有方法、特权方法、静态方法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1 公有属性和公有方法</span></span><br><span class="line"><span class="comment">// ## 2 私有属性和方法</span></span><br><span class="line"><span class="comment">// ### 3 静态属性和方法</span></span><br><span class="line"><span class="comment">// 在php中，无需实例化就可以调用的方法就叫静态方法，js也一样，无需实例化，即用new操作符实化对象，就可调用对象的方法和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">User.age = <span class="number">26</span>;<span class="comment">//静态属性</span></span><br><span class="line">User.myname = <span class="string">'fire子海'</span>;</span><br><span class="line">User.getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myname;<span class="comment">//如果这里使用this.name，返回的将是User，所有改用了myname，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(User.getName());<span class="comment">//output:fire子海</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 4 特权方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = name;<span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">var</span> age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//特权方法</span></span><br><span class="line">          <span class="keyword">return</span> name;<span class="comment">//私有属性和方法不能使用this调用</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">'fire子海'</span>,<span class="number">26</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getName());<span class="comment">//output:fire子海</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 5 静态类</span></span><br><span class="line"><span class="comment">// 对于静态方法和静态属性，我们无需像第三步中那样去创建，如果网友看过我那篇“js如何制作图片轮播”，就知道可以使用字面量的方式来创建。</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">   init:<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;,</span><br><span class="line">   getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">user.init(<span class="string">'fire子海'</span>,<span class="number">26</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.getName());<span class="comment">//output:fire子海</span></span><br></pre></td></tr></table></figure></p>
<p>## 6公有方法的调用规则<br><!-- [JavaScript 公有 私有 静态属性和方法](https://www.cnblogs.com/syomm/p/5681179.html) --><br>调用公有方法，我们必需先实例化对象 公有方法中通过this调用公有属性和特权方法，不能使用this调用静态方法和属性，必需裁通过对象本身调用，即对象名。公有方法也不能调用私有方法<br>使用静态方法时，无需实例化对象，便可以调用，对象实例不能调用对象的静态方法，只能调用实例自身的静态属性和方法。<br>特权方法通过this调用公有方法、公有属性，通过对象本身调用静态方法和属性，在方法体内直接调用私有属性和私有方法。<br>对象的私有方法和属性,外部是不可以访问的,在方法的内部不是能this调用对象的公有方法、公有属性、特权方法的      </p>
<h1 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h1><!-- \# [继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) -->
<p>当谈到继承时，JavaScript 只有一种结构：对象。<br>每个实例对象（object ）都有一个私有属性（称之为[[prototype]]）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象 ，层层向上直到一个对象的原型对象为 null。<br>根据定义，null 没有原型，并作为这个原型链中的最后一个环节。     </p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。</p>
<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 继承属性</span></span><br><span class="line"><span class="comment">// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：</span></span><br><span class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">// o 的 [[Prototype]] 有属性 b 和 c：</span></span><br><span class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></span><br><span class="line"><span class="comment">// 最后, o.[[Prototype]].[[Prototype]] 是 null.</span></span><br><span class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></span><br><span class="line"><span class="comment">// 根据定义，null 没有[[Prototype]].</span></span><br><span class="line"><span class="comment">// 综上，整个原型链如下: </span></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 继承方法</span></span><br><span class="line"><span class="comment">// 当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line"><span class="comment">// p是一个继承自 o 的对象</span></span><br></pre></td></tr></table></figure>
<h2 id="使用不同的方法来创建对象和生成原型链"><a href="#使用不同的方法来创建对象和生成原型链" class="headerlink" title="使用不同的方法来创建对象和生成原型链"></a>使用不同的方法来创建对象和生成原型链</h2><h3 id="语法结构创建的对象"><a href="#语法结构创建的对象" class="headerlink" title="语法结构创建的对象"></a>语法结构创建的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// o 这个对象继承了Object.prototype上面的所有属性</span></span><br><span class="line"><span class="comment">// o 自身没有名为 hasOwnProperty 的属性</span></span><br><span class="line"><span class="comment">// hasOwnProperty 是 Object.prototype 的属性</span></span><br><span class="line"><span class="comment">// 因此 o 继承了 Object.prototype 的 hasOwnProperty</span></span><br><span class="line"><span class="comment">// Object.prototype 的原型为 null</span></span><br><span class="line"><span class="comment">// 原型链如下:o ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 数组都继承于 Array.prototype </span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</span><br><span class="line"><span class="comment">// (Array.prototype 中包含 indexOf, forEach等方法)</span></span><br><span class="line"><span class="comment">// 原型链如下: a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 3 函数都继承于Function.prototype</span></span><br><span class="line"><span class="comment">// (Function.prototype 中包含 call, bind等方法)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链如下:f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $PS: </span></span><br><span class="line"><span class="keyword">var</span> o=&#123;&#125;</span><br><span class="line">o.constructor === <span class="built_in">Object</span>  <span class="comment">// true</span></span><br><span class="line">o.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line">o.prototype <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__=== <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__=== <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__=== <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器创建的对象"><a href="#构造器创建的对象" class="headerlink" title="构造器创建的对象"></a>构造器创建的对象</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。<br>在g被实例化时,g.[[Prototype]]指向了Graph.prototype      </p>
<h3 id="Object-create-创建的对象"><a href="#Object-create-创建的对象" class="headerlink" title="Object.create 创建的对象"></a>Object.create 创建的对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// d ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></span><br></pre></td></tr></table></figure>
<h3 id="class-关键字创建的对象"><a href="#class-关键字创建的对象" class="headerlink" title="class 关键字创建的对象"></a>class 关键字创建的对象</h3><p>使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 class, constructor，static，extends 和 super。<br>注意：检查属性是否undefined还不够。该属性可能存在，但其值恰好设置为undefined。      </p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>而不是其原型链上的某个属性，则必须使用所有对象从Object.prototype继承的 hasOwnProperty 方法。    </p>
<h3 id="错误实践：扩展原生对象的原型"><a href="#错误实践：扩展原生对象的原型" class="headerlink" title="错误实践：扩展原生对象的原型"></a>错误实践：扩展原生对象的原型</h3><p>经常使用的一个错误实践是扩展 Object.prototype 或其他内置原型。<br>扩展内置原型的唯一理由是支持JavaScript 引擎的新特性，如Array.forEach。      </p>
<h2 id="prototype和Object-getPrototypeOf"><a href="#prototype和Object-getPrototypeOf" class="headerlink" title="prototype和Object.getPrototypeOf"></a>prototype和Object.getPrototypeOf</h2><p>prototype是用于类的，而 Object.getPrototypeOf() 是用于实例的（instances），两者功能一致。<br><!-- $end --></p>
<h1 id="面向对象OOP-Tarena"><a href="#面向对象OOP-Tarena" class="headerlink" title="面向对象OOP-Tarena"></a>面向对象OOP-Tarena</h1><p>OOP三大特点: 封装 继承 多态   </p>
<h2 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h2><p>*继承: 父对象的成员(属性+方法)，子对象不用重复创建，就可直接使用！<br>为什么继承: 代码重用，节约内容——优点<br>原型对象: 专门保存一类子对象，共有成员的父对象。<br>原型对象不用手动创建！  </p>
<p>何时使用原型对象:今后，只要所有子对象，公用的属性和方法，都要放在原型对象中。   </p>
<p><strong>原型链(prototype chain)</strong>:由各级父对象的<strong>proto</strong>属性，逐级继承，形成的链式结果   </p>
<p>原型链控制着对象的属性的使用顺序:<br>优先使用当前对象本地的属性——自有属性；<br>如果自己没有，则延原型链向父级查找。<br>如果整个原型链上都没有，才返回undefined     </p>
<p>## 利用原型链:<br>1. 今后，只要所有子对象共有的属性和方法，都要集中定义在原型对象中。<br>2. 为内置对象，扩展新属性——解决浏览器兼容性问题。</p>
<p>### vs 作用域链:控制函数中变量的使用顺序<br>通常，作用域链中只包含两种对象:函数作用域(AO)和全局作用域(window)   </p>
<h2 id="原型和属性API"><a href="#原型和属性API" class="headerlink" title="原型和属性API"></a>原型和属性API</h2><h3 id="1-获得原型对象3种方式"><a href="#1-获得原型对象3种方式" class="headerlink" title="1.获得原型对象3种方式:"></a>1.获得原型对象3种方式:</h3><p>1.通过构造函数获得:<br>构造函数.prototype<br>2.通过子对象获得:<br><code>child.__proto__</code> 内部属性<br>Object.getPrototypeOf(obj)：获得obj的父级原型对象。 </p>
<h3 id="2-判断自有属性和共有属性"><a href="#2-判断自有属性和共有属性" class="headerlink" title="2.判断自有属性和共有属性:"></a>2.判断自有属性和共有属性:</h3><!-- 自有属性: 直接保存在当前对象本地的属性.     
构造函数中，凡是this.添加的属性都是自有属性。   
修改自有属性，不影响其他子对象。    

共有属性: 保存在原型链上的父对象中的属性。  
定义在原型对象中的属性，都是共有属性    
修改共有属性，会影响其他子对象。    
 -->
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1 自有属性: 判断"属性名"是否直接保存在obj对象本地。</span></span><br><span class="line"><span class="keyword">var</span> bool=obj.hasOwnProperty(<span class="string">"属性名"</span>); </span><br><span class="line"><span class="comment">// ## 2 共有属性: 不是自有，而且在原型链上有</span></span><br><span class="line">!obj.hasOwnProperty(<span class="string">"属性名"</span>)&amp;&amp;(obj.属性名!==<span class="literal">undefined</span>)   </span><br><span class="line"><span class="comment">// ## 3 判断原型链上是否包含指定属性:</span></span><br><span class="line">obj.属性名!==<span class="literal">undefined</span>  <span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">var</span> bool= <span class="string">"属性名"</span> <span class="keyword">in</span> obj  <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure>
<h3 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h3><p> 一般属性定义在哪儿，就用哪个对象修改该属性的值:<br>修改自有属性: obj.属性名=值;<br>修改共有属性: 构造函数.prototype.属性名=值<br>强行用子对象，修改原型对象中的属性:     </p>
<h3 id="删除对象的属性-delete-obj-属性名"><a href="#删除对象的属性-delete-obj-属性名" class="headerlink" title="删除对象的属性: delete obj.属性名"></a>删除对象的属性: delete obj.属性名</h3><p>只能删除自有属性。<br>要删除共有属性，必须删除原型对象的属性。        </p>
<p>### $PS_多态:同一个方法，在不同时刻，表现出不同的状态。<br>重写(override):如果子对象觉得父对象继承来的方法不好用，可在本地定义同名自有方法，覆盖父对象的方法。<br>为什么:为了体现子对象和父对象之间的差异！       </p>
<h1 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h1><!-- [Javascript面向对象编程（二）：构造函数的继承]  -->
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>一、 构造函数绑定<br>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：<br>二、 prototype模式<br>第二种方法更常见，使用prototype属性。<br>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。<br>三、 直接继承prototype<br>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。        </p>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。     </p>
<p>四、 利用空对象作为中介<br>五、 拷贝继承<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 一、 构造函数绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    Animal.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 二、 prototype模式  </span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"><span class="comment">// ## 三、 直接继承prototype  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Animal.prototype.species=<span class="string">'动物'</span></span><br><span class="line">Cat.prototype= Animal.prototype </span><br><span class="line">Cat.prototype.constructor=Cat <span class="comment">// 际上把Animal.prototype对象的constructor属性也改掉了！   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $PS: ES6  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype=<span class="built_in">Object</span>.create(Shape.prototype); <span class="comment">// ES6</span></span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 四、 利用空对象作为中介     </span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"><span class="comment">// ### 封装  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child,Parent</span>)</span>&#123; <span class="comment">//就是YUI库如何实现继承的方法。</span></span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Child.prototype.constructor = Cat;</span><br><span class="line">    Child.uber = Parent.prototype; <span class="comment">// 可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，</span></span><br><span class="line">                        <span class="comment">// 纯属备用性质。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 五、 拷贝继承   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child,Parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">    <span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="非构造函数的继承"><a href="#非构造函数的继承" class="headerlink" title="非构造函数的继承"></a>非构造函数的继承</h2><!-- [Javascript面向对象编程（三）：非构造函数的继承] -->
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Chinese=&#123;<span class="attr">nation</span>:<span class="string">'中国'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> Doctor=&#123;<span class="attr">career</span>:<span class="string">'医生'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## $l六：object</span></span><br><span class="line">functio object(o)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Doctor = object(Chinese);</span><br><span class="line">Doctor.career = <span class="string">'医生'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## $七：浅拷贝 extendCopy</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## $八：深拷贝 jQuery库使用的就是这种继承方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c=c||&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i]=== <span class="string">'object)&#123;</span></span><br><span class="line"><span class="string">            c[i] = (p[i].constructor===Array?[]:&#123;&#125;);</span></span><br><span class="line"><span class="string">            deepCopy(p[i],c[i])</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">            c[i] = p[i];</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return c;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Object构造函数"><a href="#Object构造函数" class="headerlink" title="Object构造函数"></a>Object构造函数</h1><!-- [Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) -->
<p>Object构造函数为给定值创建一个对象包装器。如果给定值是 null 或 undefined，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。        </p>
<p>当以非构造函数形式被调用时，Object 等同于 new Object()。        </p>
<h2 id="Object构造函数的属性"><a href="#Object构造函数的属性" class="headerlink" title="Object构造函数的属性"></a>Object构造函数的属性</h2><p>Object.length  值为1。<br>Object.prototype 可以为所有 Object 类型的对象添加属性。 </p>
<h2 id="Object构造函数的方法"><a href="#Object构造函数的方法" class="headerlink" title="Object构造函数的方法"></a>Object构造函数的方法</h2><p>Object.assign()：通过复制一个或多个对象来创建一个新的对象。<br>Object.create()：使用指定的原型对象和属性创建一个新对象。       </p>
<p>Object.defineProperty()：给对象添加一个属性并指定该属性的配置。<br>Object.defineProperties()：给对象添加多个属性并分别指定它们的配置。     </p>
<p>Object.setPrototypeOf()：设置对象的原型（即内部[[Prototype]]属性）。<br>Object.getPrototypeOf()：返回指定对象的原型对象。<br>Object.getOwnPropertyNames()：返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。<br>Object.getOwnPropertySymbols()：返回一个数组，它包含了指定对象自身所有的符号属性。      </p>
<p>Object.getOwnPropertyDescriptor()：返回对象指定的属性配置。     </p>
<p>Object.is()：比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。<br>Object.isExtensible()：判断对象是否可扩展。<br>Object.isFrozen()：判断对象是否已经冻结。<br>Object.isSealed()：判断对象是否已经密封。       </p>
<p>Object.preventExtensions()：防止对象的任何扩展。<br>Object.freeze()：冻结对象：其他代码不能删除或更改任何属性。<br>Object.seal()：防止其他代码删除对象的属性。     </p>
<p>Object.entries()：返回给定对象自身可枚举属性的[key, value]数组。<br>Object.keys()：返回一个包含所有给定对象自身可枚举属性名称的数组。<br>Object.values()：返回给定对象自身可枚举值的数组。       </p>
<p>$PS: Object.create和new的区别? (有什么意义吗)<br>Object.create使用现有的对象来提供新创建的对象的<strong>proto</strong>。<br>返回一个新对象，带着指定的原型对象和属性。<br>如果propertiesObject参数不是 null 或一个对象，则抛出一个 TypeError 异常。   </p>
<h2 id="Object-实例和Object-原型对象"><a href="#Object-实例和Object-原型对象" class="headerlink" title="Object 实例和Object 原型对象"></a>Object 实例和Object 原型对象</h2><p>JavaScript中的所有对象都来自Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。例如，其他构造函数的原型将覆盖constructor属性并提供自己的toString()方法。Object原型对象的更改将传播到所有对象，除非受到这些更改的属性和方法将沿原型链进一步覆盖。   </p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Object.prototype.constructor 特定的函数，用于创建一个对象的原型。<br><code>Object.prototype.__proto__</code>  指向当对象被实例化的时候，用作原型的对象。<br><code>Object.prototype.__noSuchMethod__</code>  当未定义的对象成员被调用作方法的时候，允许定义并执行的函数。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Object.prototype.hasOwnProperty(): 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。<br>Object.prototype.isPrototypeOf(): 返回一个布尔值，表示指定的对象是否在本对象的原型链中。<br>Object.prototype.propertyIsEnumerable(): 判断指定属性是否可枚举，   </p>
<p>Object.prototype.toString(): 返回对象的字符串表示。<br>Object.prototype.toLocaleString(): 直接调用 toString()方法。<br>Object.prototype.toSource() : 返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象。      </p>
<p>Object.prototype.valueOf(): 返回指定对象的原始值。<br>Object.prototype.watch() : 给对象的某个属性增加监听。<br>Object.prototype.unwatch() : 移除对象某个属性的监听。       </p>
<h1 id="创建对象的7种方式"><a href="#创建对象的7种方式" class="headerlink" title="[创建对象的7种方式]"></a>[创建对象的7种方式]</h1><p>最近在复习红宝书的对象一章，红宝书中一共提到了7种创建对象的方式（这里所说的对象更偏向于面向对象编程中的对象）。7种方式分别是：<br>工厂模式<br>构造函数模式<br>原型模式<br>构造函数和原型组合模式<br>动态原型模式<br>寄生构造模式<br>稳妥构造模式<br><!-- [JavaScript深入之创建对象的多种方式以及优缺点](JavaScript深入之创建对象的多种方式以及优缺点) --><br>&lt;!–  </p>
<h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><p>缺点：对象无法识别，因为所有的实例都指向一个原型<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'kevin'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p>优点：实例可以识别为一个特定的类型<br>缺点：每次创建实例时，每个方法都要被创建一次<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 构造函数模式优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getName = getName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="comment">// 优点：解决了每个方法都要被重新创建的问题</span></span><br><span class="line"><span class="comment">// 缺点：这叫啥封装……</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>优点：方法不会重新创建<br>缺点：1. 所有的属性和方法都共享 2. 不能初始化参数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'keivn'</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 原型模式优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 优点：封装性好了一点</span></span><br><span class="line"><span class="comment">// 缺点：重写了原型，丢失了constructor属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 原型模式优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: 'kevin',</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 优点：实例可以通过constructor属性找到所属构造函数</span></span><br><span class="line"><span class="comment">// 缺点：原型模式该有的缺点还是有</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4. 组合模式"></a>4. 组合模式</h3><p>构造函数模式与原型模式双剑合璧。<br>优点：该共享的共享，该私有的私有，使用最广泛的方式<br>缺点：有的人就是希望全部都写在一起，即更好的封装性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-动态原型模式"><a href="#4-1-动态原型模式" class="headerlink" title="4.1 动态原型模式"></a>4.1 动态原型模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************/</span></span><br><span class="line"><span class="comment">// 注意：使用动态原型模式时，不能用对象字面量重写原型</span></span><br><span class="line"><span class="comment">// 解释下为什么：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 并没有该方法</span></span><br><span class="line">person1.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释掉上面的代码，这句是可以执行的。</span></span><br><span class="line">person2.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了解释这个问题，假设开始执行var person1 = new Person('kevin')。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们回顾下 new 的实现步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">首先新建一个对象</span></span><br><span class="line"><span class="comment">然后将对象的原型指向 Person.prototype</span></span><br><span class="line"><span class="comment">然后 Person.apply(obj)</span></span><br><span class="line"><span class="comment">返回这个对象</span></span><br><span class="line"><span class="comment">注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你就是想用字面量方式写代码，可以尝试下这种：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype = &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: Person,</span><br><span class="line">            getName: function () &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'daisy'</span>);</span><br><span class="line"></span><br><span class="line">person1.getName(); <span class="comment">// kevin</span></span><br><span class="line">person2.getName();  <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-寄生构造函数模式"><a href="#5-1-寄生构造函数模式" class="headerlink" title="5.1 寄生构造函数模式"></a>5.1 寄生构造函数模式</h3><p>寄生构造函数模式，我个人认为应该这样读：<br>寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。  </p>
<p>也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'kevin'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="keyword">var</span> colors2 = SpecialArray(<span class="string">'red2'</span>, <span class="string">'blue2'</span>, <span class="string">'green2'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blue|green</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.toPipedString()); <span class="comment">// red2|blue2|green2</span></span><br></pre></td></tr></table></figure></p>
<p>你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。</p>
<p>但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。</p>
<p>在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>但是值得一提的是，上面例子中的循环：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    values.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以替换成：<code>values.push.apply(values, arguments);</code></p>
<h3 id="5-2-稳妥构造函数模式"><a href="#5-2-稳妥构造函数模式" class="headerlink" title="5.2 稳妥构造函数模式"></a>5.2 稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。<br>与寄生构造函数模式有两点不同：<br>1) 新创建的实例方法不引用 this<br>2) 不使用 new 操作符调用构造函数       </p>
<p>稳妥对象最适合在一些安全的环境中。<br>稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = person(<span class="string">'kevin'</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"daisy"</span>;</span><br><span class="line">person1.sayName(); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure></p>
<p>–&gt;</p>
<p style="text-align:right">15:55</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>this和call,apply,bind.md</title>
    <url>/sum/js/this%E5%92%8Ccall,apply,bind(041)/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.15 星期一 14:35</p>

<h2 id="this-几个实例"><a href="#this-几个实例" class="headerlink" title="this 几个实例"></a>this 几个实例</h2><p>this关键字被用于指代当前的对象，通常，this指代的是方法中正在被调用的对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1</span></span><br><span class="line"><span class="keyword">var</span> name=<span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> foo=&#123;</span><br><span class="line">    name:<span class="string">'foo'</span>,</span><br><span class="line">    hi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    bar:&#123;</span><br><span class="line">        name:<span class="string">'bar'</span>,</span><br><span class="line">        say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hello=foo.hi;</span><br><span class="line">hello();<span class="comment">// window</span></span><br><span class="line">foo.hi();<span class="comment">// foo</span></span><br><span class="line">foo.bar.say();<span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'obj'</span>,</span><br><span class="line">    times:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    print:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print(); <span class="comment">// 4个undefined</span></span><br><span class="line"><span class="comment">// ### 改进</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'obj'</span>,</span><br><span class="line">    times:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    print:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.times.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print(); <span class="comment">// 4个obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 3 </span></span><br><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    specialFunction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    anotherSpecialFunction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    getAsyncData: <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// myObj</span></span><br><span class="line">        cb();</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.getAsyncData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// window</span></span><br><span class="line">            that.specialFunction();</span><br><span class="line">            that.anotherSpecialFunction();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.specialFunction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.render();</span><br><span class="line"><span class="comment">/* cb: 在这种情况下--$PS:也就是回调函数，没有设置内部函数的this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置this时指向的默认对象）。 </span></span><br><span class="line"><span class="comment">同理setTimeout中的回调函数;如果使用箭头函数,this与封闭词法上下文的this保持一致</span></span><br><span class="line"><span class="comment">包括下面的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;button onclick=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span><br><span class="line">  Show inner <span class="keyword">this</span></span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="call-apply-和bind"><a href="#call-apply-和bind" class="headerlink" title="call,apply 和bind"></a>call,apply 和bind</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind:基于一个现有函数，创建一个新函数，同时提前绑定函数中的this为指定对象。<br>何时使用: 今后只要希望将一个对象和一个函数中的this，永久绑定，只能用bind。<br>原理：<br>1. 创建了一个新函数<br>2. 在新函数中调用了原函数<br>3. 永久绑定函数中的this为指定对象。    </p>
<p>用法:<br>基于fun创建一个新函数fun1，并永久绑定fun1中的this为obj<br>基于fun创建一个新函数fun1，并永久绑定fun1中的this为obj,同时永久绑定fun1中的参数值为参数1,….<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun1=fun.bind(obj);     </span><br><span class="line"><span class="keyword">var</span> fun1=fun.bind(obj,参数<span class="number">1</span>,...)</span><br></pre></td></tr></table></figure></p>
<p>$PS: 在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;<span class="attr">x</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;<span class="attr">x</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="call-apply和bind-比较"><a href="#call-apply和bind-比较" class="headerlink" title="call,apply和bind 比较"></a>call,apply和bind 比较</h3><p>#### call apply：IE8+<br>相同点:临时<em>借(调)用函数</em>，临时替换函数中的this为指定对象。<br>不同点:传递给借用的函数的参数：<br>call，要求每个参数独立传入<br>apply,要求所有参数用数组或集合方式整体传入。<br>强调: 不创建新函数，而是直接调用原函数。</p>
<p>#### bind: IE9+<br>相同:都是为了替换函数中的this为指定对象。<br>不同:<br>1.<em>创建一个新函数</em>。<br>2.永久绑定this为指定对象，且也可永久绑定部分参数值。<br>$PS: bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。   </p>
<p>$TODO: 模拟实现bind函数</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>为了巩固加深记忆，下面列举一些常用用法：<br>1、数组之间追加<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">"foo"</span> , &#123;<span class="attr">name</span>:<span class="string">"Joe"</span>&#125; , <span class="number">-2458</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"Doe"</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2);</span><br><span class="line"><span class="comment">/* array1 值为 [12 , "foo" , &#123;name:"Joe"&#125; , -2458 , "Doe" , 555 , 100] */</span></span><br></pre></td></tr></table></figure></p>
<p>2、获取数组中的最大值和最小值<br>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> ];</span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers), <span class="comment">//458</span></span><br><span class="line">maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span>); <span class="comment">//458</span></span><br></pre></td></tr></table></figure></p>
<p>3、验证是否是数组（前提是toString()方法没有被重写过）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functionisArray(obj)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、类（伪）数组使用数组方法<br><code>var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));</code></p>
<p>Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。</p>
<p>但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p>
<p>$PS: log函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">log(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//1</span></span><br><span class="line"><span class="comment">// ## 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ## 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    args.unshift(<span class="string">'(app)'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ## 0</span></span><br><span class="line"><span class="comment">// log=console.log.bind(this)</span></span><br><span class="line">log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>,<span class="string">'app|'</span>)</span><br><span class="line">log(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//app| 1 2</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">14:46</p>

<p style="text-align:right">2018.10.29 星期一 11:25</p>

<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p># <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">this</a>     </p>
<p>与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。</p>
<p>在绝大多数情况下，<strong>函数的调用方式决定了this的值。this不能在执行期间被赋值，并且在每次函数被调用时this的值也可能会不同</strong>。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的，ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行上下文内设置this的值）。<br>## 全局上下文<br>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">22</span></span><br><span class="line"><span class="keyword">this</span>.a <span class="comment">// 22</span></span><br></pre></td></tr></table></figure></p>
<p>## 函数上下文<br>在函数内部，this的值取决于函数被调用的方式。        </p>
<h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><p>因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象。<br>$PS: 可以理解成对象调用,即全局window调用,所以指向全局对象:window</p>
<p>然而，在严格模式下，this将保持他进入执行上下文时的值，所以下面的this将会默认为undefined。<br>所以，在严格模式下，如果 this 没有被执行上下文（execution context）定义，那它将保持为 undefined。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h3><p>$PS_兼容: #1 [Understanding JavaScript Bind ()]<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">    fToBind = <span class="keyword">this</span>,</span><br><span class="line">    fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">                                ? <span class="keyword">this</span></span><br><span class="line">                                : oThis,</span><br><span class="line">                            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数节"><a href="#箭头函数节" class="headerlink" title="箭头函数节"></a>箭头函数节</h3><p>在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象($PS: 也是当前定义是的上下文)  </p>
<h3 id="作为对象的方法节"><a href="#作为对象的方法节" class="headerlink" title="作为对象的方法节"></a>作为对象的方法节</h3><p>当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。    </p>
<p>#### 原型链中的 this<br>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。<br>#### getter 与 setter 中的 this<br>再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。</p>
<h3 id="作为构造函数节"><a href="#作为构造函数节" class="headerlink" title="作为构造函数节"></a>作为构造函数节</h3><p>当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。</p>
<h3 id="作为一个DOM事件处理函数节"><a href="#作为一个DOM事件处理函数节" class="headerlink" title="作为一个DOM事件处理函数节"></a>作为一个DOM事件处理函数节</h3><p>当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定）。    </p>
<h3 id="作为一个内联事件处理函数节"><a href="#作为一个内联事件处理函数节" class="headerlink" title="作为一个内联事件处理函数节"></a>作为一个内联事件处理函数节</h3><p>当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></span><br><span class="line">  Show this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上面的 alert 会显示button。注意只有外层代码中的this是这样设置的： --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></span><br><span class="line">  Show inner this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在这种情况下，没有设置内部函数的this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置this时指向的默认对象）。 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其他参考:<br><a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">Understanding JavaScript Bind ()</a></p>
<!-- \# [两句话理解js中的this](https://juejin.im/post/5a0d9ff4f265da432e5b91da) -->
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## example 1 </span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  obj = &#123;</span><br><span class="line">    length: <span class="number">5</span>,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.method(fn, <span class="number">1</span>); <span class="comment">// 10, 2</span></span><br><span class="line"><span class="comment">// ### 变化</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    length: <span class="number">5</span>,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="keyword">const</span> fun = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        fun()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(fn, <span class="number">1</span>); <span class="comment">// 10,10 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## example 2</span></span><br><span class="line"><span class="built_in">window</span>.val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    dbl: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val *= <span class="number">2</span>;</span><br><span class="line">        val *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.dbl(); <span class="comment">// 2 4</span></span><br><span class="line"><span class="keyword">var</span> func = obj.dbl;</span><br><span class="line">func(); <span class="comment">// 8 8</span></span><br></pre></td></tr></table></figure>
<p style="text-align:right">11:40</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js表达式和运算符</title>
    <url>/sum/js/js%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.15 星期一 10:11</p><br><!-- [表达式和运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators) --><br><br># 运算符<br>赋值运算符(Assignment operators)<br>比较运算符(Comparison operators)<br>算数运算符(Arithmetic operators)<br>位运算符(Bitwise operators)<br>逻辑运算符(Logical operators)<br>字符串运算符(String operators)<br>条件（三元）运算符(Conditional operator)<br>逗号运算符(Comma operator)<br>一元运算符(Unary operators)<br>关系运算符(Relational operator)<br><br>JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。<br>## 逗号运算符(Comma operator)<br>## 一元操作符<br>### delete<br>删除一个对象或一个对象的属性或者一个数组中某一个键值<br>你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。<br>$PS: var, let以及const创建的不可设置的属性不能被delete操作删除<br>如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。<br><br>##### 删除数组元素<br>删除数组中的元素时，数组的长度是不变的，例如删除a[3], a[4]，a[4]和a[3] 仍然存在变成了undefined。<br><br>delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。<br>如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3]分配一个undefined,但是这个数组元素仍然存在:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ### 不会被执行</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// 不会被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ### 会被执行</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line">trees[<span class="number">3</span>] = <span class="literal">undefined</span>; <span class="comment">// trees[3]=null </span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// this gets executed（会被执行）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### typeof<br>$PS: 用typeof操作符来确定是哪种基本类型，typeof是一个操作符，而不是一个函数，因此typeof后面的圆括号可有可无，用instanceof操作符来确定是哪种引用类型。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于关键词 true 和 null， typeof 操作符将会返回如下结果：   </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// returns "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// returns "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于预定义的对象，typeof 操作符将会返回如下结果：   </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Date</span>;     <span class="comment">// returns "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Function</span>; <span class="comment">// returns "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>;     <span class="comment">// returns "object"</span></span><br><span class="line"><span class="keyword">typeof</span> Option;   <span class="comment">// returns "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>;   <span class="comment">// returns "function"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $PS  </span></span><br><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line">theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>  <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Math</span> <span class="comment">// Uncaught TypeError: Right-hand side of 'instanceof' is not callable</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">2</span>) <span class="keyword">instanceof</span> <span class="built_in">Math</span> <span class="comment">// Uncaught TypeError: Right-hand side of 'instanceof' is not callable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f.prototype <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><br><br>### void<br><code>void (expression) 或者void expression</code><br>表明一个运算没有返回值。expression是javaScript表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。<br><br>你可以使用void运算符指明一个超文本链接。该表达式是有效的，但是并不会在当前文档中进行加载。<br><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span>&gt;</span>Click here to do nothing<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面的代码创建了一个超链接，当用户单击它时，提交一个表单。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(document.form.submit())"</span>&gt;</span>Click here to submit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>## 关系操作符<br>关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。<br>### in<br>in操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，<br>### instanceof<br>如果所判别的对象确实是所指定的类型，则返回true<br>当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">if</span> (theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">  <span class="comment">// statements to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 运算符优先级<br>member&gt; call / create instance&gt; …  logical-or&gt; conditional&gt;assignment&gt;comma<br>即：<code>. []&gt; () new &gt; ... &gt; &amp;&amp; &gt;|| &gt; ?: &gt; =,+=,*=,&lt;&lt;=,|=  &gt; ,</code><br><br><br><br># 表达式<br>每一个合法的表达式都能计算成某个值，但从概念上讲，有两种类型的表达式：有副作用的（比如赋值）和单纯计算求值的。<br><br>JavaScript有以下表达式类型：<br><em> 算数: 得出一个数字, 例如 3.14159. (通常使用 arithmetic operators.)
</em> 字符串: 得出一个字符串, 例如, “Fred” 或 “234”. (通常使用 string operators.)<br><em> 逻辑值: 得出true或者false. (经常涉及到 logical operators.)
</em> 基本表达式: javascript中基本的关键字和一般表达式。<br>* 左值表达式: 分配给左值。<br><br>## 基本表达式<br>### this<br>this关键字被用于指代当前的对象，通常，this指代的是方法中正在被调用的对象。<br><br><br>分组操作符<br>分组操作符（）控制了表达式中计算的优先级.<br><br>## 左值表达式<br>左值可以作为赋值的目标。<br>### new<br>创建一个自定义类型或者是预置类型的对象实例<br><br>super 关键字<br>可以用来调用一个对象父类的函数，它在用来调用一个类的父类的构造函数时非常有用，比如：<br><br>扩展语句<br>扩展语句符允许一个表达式在原地展开， 当需要多个参数 (比如函数调用时) 或者多个值(比如字面量数组) 。<br><br><br><p style="text-align:right">11:01</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js表达式和运算符</title>
    <url>/sum/js/new%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.12 星期五 17:15</p>

<!-- \# [javascript中，new操作符的工作原理是什么?](https://www.zhihu.com/question/36440948) -->
<h2 id="new操作符的工作原理"><a href="#new操作符的工作原理" class="headerlink" title="new操作符的工作原理"></a>new操作符的工作原理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//this指向谁，在定义时是不知道的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> F; <span class="comment">// $有无 () 都可以调用，有参和无参，和. 运算优先级不一样</span></span><br><span class="line"><span class="comment">// ## 1 代码说明</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.__proto__ = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br><span class="line"><span class="comment">// return *.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2.1 封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    o.__proto__ = Person.prototype;<span class="comment">//绑定Person的原型</span></span><br><span class="line">    Person.call(o, name);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1=newFunc(<span class="string">'person1'</span>)</span><br><span class="line">person1.name<span class="comment">// </span></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person <span class="comment">// false  不绑定Person的原型 ；绑定返回true  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2.2 扩展assign </span></span><br><span class="line"><span class="comment">// 如果再将这个函数抽象一下，可以传入构造函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">constructor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    o.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    <span class="keyword">constructor</span>.apply(o, Array.prototype.slice.call(arguments, 1));</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = newFunc(Person, 'MeloGuo', 21)</span><br></pre></td></tr></table></figure>
<p>用new调用一个函数发生了这些事：<br>（1）新建一个对象<code>instance=new Object()</code>;<br>（2）设置原型链<code>instance.__proto__=F.prototype</code>;<br>（3）让F中的this指向instance，执行F的函数体。<br>（4）判断F的返回值类型：<br>如果是值类型，就丢弃它，还是返回instance。<br>如果是引用类型，就返回这个引用类型的对象，替换掉instance。      </p>
<p>注：（1）如果没有写return，相当于return undefined，JavaScript中的函数都是这样。undefined是值类型的，因此丢弃它，返回instance。<br>（2）如果return this相当于返回一个引用类型的对象，它自己就是instance，无所谓替换不替换了。<br>（3）对instance并不需要设置它的constructor属性，这个属性在instance的原型中。<br>而且，任意一个新函数在创建时，原型的constructor就已经设置好了。<br>于是，这也要求我们在对prototype重新赋值的时候，重新指定constructor属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(!p.hasOwnProperty(<span class="string">'constructor'</span>));</span><br><span class="line"><span class="built_in">console</span>.assert(F.prototype.hasOwnProperty(<span class="string">'constructor'</span>));</span><br><span class="line"><span class="comment">// 而且 。。  </span></span><br><span class="line"><span class="keyword">var</span> G=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.assert(G.prototype.hasOwnProperty(<span class="string">'constructor'</span>));</span><br><span class="line"><span class="built_in">console</span>.assert(G.prototype.constructor===G);</span><br><span class="line"><span class="comment">// 重新指定constructor属性。</span></span><br><span class="line">F.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:F</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- $end -->
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new 、this、以及原型链相关问</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName();  <span class="comment">// 2  // Foo的静态方法（如果C#、java等后端语言来说）</span></span><br><span class="line">getName();  <span class="comment">// 4</span></span><br><span class="line">Foo().getName();   <span class="comment">//  1   // $PS:3,没有new即也就不会返回实例，return的this指window</span></span><br><span class="line">getName();  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();    <span class="comment">// 3 //  有new 返回实例;</span></span><br><span class="line">        <span class="comment">// 由于new是有参的，与.运算符同级，按照从左向右的执行顺序，先执行new Foo()。</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();    <span class="comment">// 3 </span></span><br><span class="line">    <span class="comment">// 原理：主要是运算符优先级的考查，实例开发中应该不会这样直接的用到。首先new有参，然后.getName(.运算符)（为什么是.运算符，这是因为new无参级别低一个档次）,再则new有参。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $PS: function的声明在var 前面</span></span><br><span class="line"><span class="comment">console.log(name) // f name()&#123;&#125; </span></span><br><span class="line"><span class="comment">var name;</span></span><br><span class="line"><span class="comment">function name()&#123;&#125; */</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-和new-Object"><a href="#Object-和new-Object" class="headerlink" title="Object()和new Object()"></a>Object()和new Object()</h2><p>当以非构造函数形式被调用时，Object 等同于 new Object()      </p>
<h2 id="与-运算优先级比较"><a href="#与-运算优先级比较" class="headerlink" title="与.运算优先级比较"></a>与.运算优先级比较</h2><p>new是有参的，与.运算符同级，按照从左向右的执行顺序，先执行new Foo()<br>new无参级别低一个档次，先进行.运算符    </p>
<p style="text-align:right">18:55</p>

]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端黑客技术揭秘</title>
    <url>/pdf/ex/Web%E5%89%8D%E7%AB%AF%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98/</url>
    <content><![CDATA[<p style="text-align:right">2018.10.10 星期三 17:24</p>

<p>前端安全主要有三类：XSS，CSRF，界面操作劫持     </p>
<h2 id="第1章-Web安全的关键点"><a href="#第1章-Web安全的关键点" class="headerlink" title="第1章 Web安全的关键点"></a>第1章 Web安全的关键点</h2><p>1.1 数据与指令<br>SQL注入攻击的发生，XSS跨站脚本攻击的发生<br>1.2 浏览器的同源策略<br>规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源<br>不同域或同域，客户端脚本(js,as,vb)，授权，读写权限，资源(HTTP消息头，整个DOM树，浏览器存储等)<br>1.3 信任与信任关系<br>1.4 社会工程学的作用<br>1.5 攻防不单一<br>1.6 场景很重要<br>1.7 小结      </p>
<h2 id="第2章-前端基础"><a href="#第2章-前端基础" class="headerlink" title="第2章 前端基础"></a>第2章 前端基础</h2><p>2.1 W3C的世界法则<br>web安全事件的角色：W3C，浏览器厂商，Web厂商，攻击者(黑客)，被攻击者(用户)<br>2.2 URL<br>三类编码方式：escape,encodeURI,encodeURIComponent(有差异，浏览器也不同)<br>2.3 HTTP协议<br>2.4 松散的HTML世界<br>DOM树，iframe内嵌出一个开放的世界，HTML内嵌脚本执行<br>2.5 跨站之魂——JavaScript<br>DOM树操作，AJAX风险，模拟用户发起浏览器请求，Cookie安全，本地存储风险，E4X带来的混乱世界，Javascript函数劫持<br>2.6 一个伪装出来的世界———CSS<br>css容错性，样式伪装，css伪类，css的属性选择符<br>2.7 另一个幽灵——ActionScript<br>Flash安全沙箱，HTML嵌入Flash的安全相关配置，跨站Flash，参数传递，Flash里的内嵌HTML，与Javascript通信，网络，通信，其他安全问题  </p>
<h2 id="第3章-前端黑客之XSS"><a href="#第3章-前端黑客之XSS" class="headerlink" title="第3章 前端黑客之XSS"></a>第3章 前端黑客之XSS</h2><p>Cross Site Scripting 跨站脚本<br>1.1 XSS概述<br>发生在目标网站中目标用户的浏览器层面上，当用户浏览器熏(xun)染整个HTML文档的过程中出现了不被预期的脚本指令并执行时，XSS就会发生<br>1.2 XSS类型<br>反射型(非持久型XSS)，XSS代码出现在URL中，作为输入提交到服务的，服务的解析后相应，在响应内容中出现这段XSS代码，最后浏览器解析齿形。这个过程就像一次反射，故。。。<br>存储型(持久型XSS)，提交的XSS代码会存储在服务的(不挂你是数据库，内存还是文件系统等)，下次请求目标页面时不用再提交XSS代码<br>DOM XSS: 并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情<br>1.3 哪里可以出现XSS攻击<br>1.4 危害    </p>
<h2 id="第4章-前端黑客之CSRF"><a href="#第4章-前端黑客之CSRF" class="headerlink" title="第4章 前端黑客之CSRF"></a>第4章 前端黑客之CSRF</h2><p>Cross Site Request Forgery 跨站请求伪造<br>比XSS简单，但是基础概念稍微难理解<br>4.1 概述<br>跨站点的请求(也可能来自本站)，请求是伪造的，一个场景<br>4.2 类型<br>请求方式：GET型和POST型<br>攻击方式：HTML CSRF攻击，JSON HiJacking攻击，Flash CSRF攻击<br>4.3 危害    </p>
<h2 id="第5章-前端黑客之界面操作劫持"><a href="#第5章-前端黑客之界面操作劫持" class="headerlink" title="第5章 前端黑客之界面操作劫持"></a>第5章 前端黑客之界面操作劫持</h2><p>5.1 概述<br>从技术发展阶段分析，分三类：点击，拖放，触屏<br>5.2 技术原理分析<br>透明层+iframe<br>点击劫持技术的实现<br>拖放劫持..<br>触屏劫持..<br>5.3 界面操作劫持实例<br>点击，拖放，触屏，<br>5.4 危害    </p>
<h2 id="第6章-漏洞挖掘"><a href="#第6章-漏洞挖掘" class="headerlink" title="第6章 漏洞挖掘"></a>第6章 漏洞挖掘</h2><p>6.1 普通XSS漏洞自动化挖掘思路<br>URL，HTML,请求 中的玄机， 关于存储型XSS挖掘<br>6.2 神奇的DOM渲染<br>HTML与Javascript的自解码机制，具备HtmlEncode功能的标签，URL编码差异，DOM修正式渲染，一种DOM fuzzing技巧<br>6.3 DOM XSS挖掘<br>静态，动态 方法<br>6.4 Flash XSS挖掘<br>6.5 字符集缺陷导致的XSS<br>宽字节编码带来的安全问题，UTF-7问题，浏览器处理字符集编码BUG带来的安全问题<br>6.6 绕过浏览器XSS Filter<br>6.7 混淆的代码<br>浏览器的进制常识，浏览器的编码常识，。。。<br>6.8 其他案例分享——Gmail-Cookie XSS       </p>
<h2 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h2><p>7.1 渗透前的准备<br>7.2 偷取隐私数据<br>7.3 内网渗透技术<br>7.4 基于CSRF的攻击技术<br>7.5 浏览器劫持技术<br>7.6 一些跨域操作技术<br>7.7 服务的WebSocket推送指令<br>7.8 只是案例剖析<br>7.9 关于XSS利用框架     </p>
<h2 id="第8章-HTML安全"><a href="#第8章-HTML安全" class="headerlink" title="第8章 HTML安全"></a>第8章 HTML安全</h2><p>8.1 新标签和新属性绕过<br>8.2 History API中的新方法<br>8.3 HTML5下的僵尸网络<br>8.4 地理定位暴露你的位置    </p>
<h2 id="第9章-Web蠕-ru-虫"><a href="#第9章-Web蠕-ru-虫" class="headerlink" title="第9章 Web蠕(ru)虫"></a>第9章 Web蠕(ru)虫</h2><p>9.1 Web蠕虫思想<br>9.2 XSS蠕虫<br>9.3 CSRF蠕虫<br>9.4 ClickJacking蠕虫    </p>
<h2 id="第10章-关于防御"><a href="#第10章-关于防御" class="headerlink" title="第10章 关于防御"></a>第10章 关于防御</h2><p>0.1 浏览器厂商的防御<br>0.2 Web 厂商的防御<br>0.3 用户的防御<br>0.4 邪恶的SNS社区   </p>
<p style="text-align:right">18:49</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>ex</category>
      </categories>
  </entry>
  <entry>
    <title>Js 数据类型</title>
    <url>/sum/js/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.29 星期六 14:43</p>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><!-- tarena javascript basic day01 -->
<p>javascript是一种运行于Javascript解释器/引擎中的解释型脚本语言<br>编译型语言：运行之前会编译检查，如果有错误，则不能运行。<br>解释型语言：运行之前不会检查语法结构，边执行边检查，出了错误就停止执行。    </p>
<p>弱类型语言： 由数据 决定 数据类型   </p>
<p>Javascript的组成：1、核心 (ECMAScript)，2、文档对象模型(DOM,Document Object Model)，3、浏览器对象模型(BOM,Browser Object Model)     </p>
<p>数据类型：保存在程序中的数据的类型<br>作用：规范了数据在内存中到底占多大的空间。<br>数据类型分类：原始类型(基本类型)，引用类型      </p>
<!-- \# [撸 js 基础之对象](https://juejin.im/entry/58f85f87b123db006235e938#_5)       -->
<h3 id="数据类型比较"><a href="#数据类型比较" class="headerlink" title="数据类型比较"></a>数据类型比较</h3><p>ECMAScript 不支持任何创建自定义类型的机制，而所有值最终都将是上述 7 种数据类型之一。    </p>
<p>基本类型的变量是存放在栈内存（Stack）里的。<br>栈内存中包括了变量的标识符和变量的值   </p>
<p>引用类型的值是保存在堆内存（Heap）中的对象（Object） 与其他编程语言不同，JavaScript 不能直接操作对象的内存空间（堆内存）。<br>栈内存中保存了变量标识符和指向堆内存中该对象的指针<br>堆内存中保存了对象的内容    </p>
<p>检测变量类型 typeof, toString, instanceof   </p>
<p>$BLOB: [js内存管理]<br>两中类型的特点：<br>（1）基本类型在内存中占据固定大小的空间，因此被保存在栈内存中。<br>（2）从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本     </p>
<p>（3）引用类型的值是对像，保存在堆内存中，引用类型的值是引用访问的<br>（4）包含引用类型的值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针<br>（5）从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。   </p>
<p>（6）用typeof操作符来确定是哪种基本类型，typeof是一个操作符，而不是一个函数，因此typeof后面的圆括号可有可无，用instanceof操作符来确定是哪种引用类型。   </p>
<p>栈的优势就是存取速度比堆要快，仅次于直接位于CPU中的寄存器，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。     </p>
<p>而对于js简单数据类型而言，他们占用内存比较小，如果放在堆中，查找会浪费很多时间，而把堆中的数据放入栈中也会影响栈的效率。比如对象和数组是可以无限拓展的，正好放在可以动态分配大小的堆中。    </p>
<h3 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h3><p>### 1 本地对象（native object）<br>ECMA-262把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。<br>Object， Function， Boolean， Symbol，          </p>
<p>### 2 内置对象（built-in object）<br>“ 由ECMAScript实现提供的，独立与宿主环境的所有对象，在ECMAScript程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已经被实例化了。ECMA只定义了两个内置对象，即Global和Math（它们也是本地对象，根据定义，所有内置对象都是本地对象）。<br>在 JavaScript 中，所有的本地对象、全局属性、全局函数都是 Global 对象的属性。ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。<br>Global，Math        </p>
<p>### 3 宿主对象（host object）<br>所有非本地对象都是宿主对象，即由ECMAScript实现的宿主环境提供的对象。<br>所有的 BOM 和 DOM 对象都是宿主对象。JavaScript 中常用的宿主对象主要包括以下：   </p>
<p>$PS: 插入<br><!-- \# [JavaScript 对象分类](https://blog.csdn.net/loganwong/article/details/22896667)       --><br>参考自W3School:JavaScript对象主要有三类。<br>一：JavaScript核心对象是ECMAScript标准定义好的一些对象与函数，在JavaScript语言中可以直接使用。<br>8: Array Boolean Date Math Number String RegExp Global<br>二：浏览器对象 BOM<br>5+:Window, Navigator, Screen, History, Location<br>三：HTML DOM 对象<br>Document Anchor Area Base Body Button Canvas Event Form Frame Frameset IFrame Image<br>Input- Button ,Checkbox ,File ,Hidden ,Password ,Radio ,Reset ,Submit ,<br>Text Link Meta Object Option SelectStyle Table TableCell TableRow Textarea<br><!-- $end --><br>### 4 用户自定义对象（user-defined object）<br>开发者通过 Js 代码创建的自己的对象。<br><!-- $end --></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><!-- \# [语法和数据类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types)   -->
<!-- \# [JavaScript 数据类型和数据结构](JavaScript 数据类型和数据结构)    -->
<p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：     </p>
<p>JavaScript语言可以识别下面 7 种不同类型的值：<br>六种 原型 数据类型:<br>Boolean.  布尔值，true 和 false.<br>null. 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。<br>undefined.  变量未定义时的属性。<br>Number.  表示数字，例如： 42 或者 3.14159。<br>String.  表示字符串，例如：”Howdy”<br>Symbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。<br>并且也可以用来作为Object的key的值(如下). 在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是C里面的枚举类型.      </p>
<p>以及 Object 对象    </p>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><p>ECMAScript定义的对象中有两种属性：数据属性和访问器属性。        </p>
<p>数据属性:数据属性是键值对，并且每个数据属性拥有下列特性:(数据属性的特性(Attributes of a data property))<br>[[Value]] (任何Javascript类型),[[Writable]],[[Enumerable]],[[Configurable]]   </p>
<p>访问器属性:访问器属性有一个或两个访问器函数 (get 和 set) 来存取数值，并且有以下特性:<br>[[Get]] (函数对象或者 undefined),[[Set]] (函数对象或者 undefined),[[Enumerable]],[[Configurable]]    </p>
<blockquote>
<p>注意：这些特性只有 JavaScript 引擎才用到，因此你不能直接访问它们。所以特性被放在两对方括号中，而不是一对。   </p>
</blockquote>
<p>“标准的” 对象, 和函数 : var obj={name:’zhangsan’},function fun(){}<br>日期: Date<br>有序集: 数组和类型数组 Array,Int8Array,Uint8Array<br>键控集: Maps, Sets, WeakMaps, WeakSets<br>结构化数据: JSON<br>标准库中更多的对象  </p>
<p>使用 typeof 操作符判断对象类型<br><!-- $end --></p>
<h2 id="标准内置对象（全局的对象）"><a href="#标准内置对象（全局的对象）" class="headerlink" title="标准内置对象（全局的对象）"></a>标准内置对象（全局的对象）</h2><!-- \# [JavaScript 标准库](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)     -->
<p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在全局作用域里的对象。   </p>
<p>“全局对象 （global object）” 是一个Global类的对象。可以在全局作用域里，用this访问（但只有在非严格模式下才可以，在严格模式下得到的是 undefined）。实际上，全局作用域包含了全局对象的属性，还有它可能继承来的属性。  </p>
<p>全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。浏览器作为最常见的宿主程序，其所提供的宿主对象的说明可以在这里找到：API 参考。  </p>
<p>标准内置对象的分类<br>### 1 值属性:这些 <strong>全局属性</strong>返回一个简单值，这些值没有自己的属性和方法。<br>Infinity,NaN,undefined,null 字面量,  </p>
<p>### 2 函数属性:<strong>全局函数</strong>可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。<br><!-- \# [javascript的全局函数](http://bijian1013.iteye.com/blog/1892299)  --><br>全局函数与内置对象的属性或方法不是一个概念。全局函数它不属于任何一个内置对象。JavaScript 中包含以下14个全局函数，用于完成一些常用的功能：escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )、decodeURI()、decodeURIComponent()、encodeURI()、encodeURIComponent()、getClass()、Number()、String()。<br>特别注意：setTimeout只是window对象的一个方法而已，setTimeout(code,millisec)，其中code必需，要调用的函数后要执行的 JavaScript 代码串；millisec必需，在执行代码前需等待的毫秒数。     </p>
<p>$PS: isNaN() 函数.下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。是原始的全局isNaN()的更强大的版本。<br><!-- $end --></p>
<p>### 3 基本对象:是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。<br>Object, Function, Boolean, Symbol, Error, EvalError, InternalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError    </p>
<p>### 4 数字和日期对象:用来表示数字、日期和执行数学计算的对象。<br>Number, Math, Date      </p>
<p>### 5 字符串:用来表示和操作字符串的对象。<br>String, RegExp      </p>
<p>### 6 可索引的集合对象:这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。<br>Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array       </p>
<p>### 7 使用键的集合对象:这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br>Map, Set, WeakMap, WeakSet      </p>
<p>### 8 矢量集合:SIMD 矢量集合中的数据会被组织为一个数据序列。   </p>
<p>### 9 反射:<br>Reflect,Proxy       </p>
<p>### 10 国际化:为了支持多语言处理而加入ECMAScript的对象。<br>Intl,   Intl.Collator,  Intl.DateTimeFormat,    Intl.NumberFormat,      </p>
<p>### 11 WebAssembly     </p>
<p>### 12 其他:arguments      </p>
<p style="text-align:right">17:03</p>



]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式30分钟入门教程</title>
    <url>/pdf/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F30%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.24 星期一 23:20 </p>

<!-- ![正则表达式快速入门.jpg](../../sum/assets/images/正则表达式快速入门.jpg) -->
<p>版本：v2.31 (2009-4-11)     </p>
<p>1 本文目标<br>2 如何使用本教程<br>3 正则表达式到底是什么东西？<br>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。     </p>
<p>4 入门<br>5 测试正则表达式<br>6 元字符<br><code>\b,\s,\d,\w,\W, ...,^,$</code><br>7 字符转义<br>8 重复<br><code>*,+,?,{n},{n,},{n,m}</code><br>9 字符类<br><code>[aeiou]</code>就匹配任何一个英文元音字母       </p>
<p>10 分枝条件<br>具体方法是用|把不同的规则分隔开;要注意各个条件的顺序<br>匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不<br>会去再管其它的条件了        </p>
<p>12 分组<br>(但如果想要重复多个字符又该怎么办？)你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作        </p>
<p>描述一个正确的IP地址：<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</code>   </p>
<p>11 反义<br><code>\W,\S,\D,\B,[^x]</code>匹配除了x以外的任意字符  $_PS:??[^x]<br><code>[âeiou]</code>匹配除了aeiou这几个字母以外的任意字符  </p>
<p>13 后向引用<br>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。      </p>
<p><code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像go go, 或者 kitty kitty。       </p>
<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：<code>(?&lt;Word&gt;\w+)</code>(或者把尖括号换成’也行：<code>(?&#39;Word&#39;\w+)</code>),这样就把\w+的组名指定为Word 了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：<code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>。     </word></p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：<br>分类 |代码/语法|说明<br>捕获<br><code>(exp</code>): 匹配exp,并捕获文本到自动命名的组里<br><code>(?&lt;name&gt;exp)</code> 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br><code>(?:exp)</code> 匹配exp,不捕获匹配的文本，也不给此分组分配组号<br>零宽断言<br><code>(?=exp)</code>匹配exp前面的位置   零宽度正预测先行断言<br><code>(?&lt;=exp)</code>匹配exp后面的位置  零宽度正回顾后发断言<br><code>(?!exp)</code>匹配后面跟的不是exp的位置    零宽度负预测先行断言<br><code>(?&lt;!exp)</code>匹配前面不是exp的位置       零宽度负回顾后发断言<br>注释<br><code>(?#comment)</code>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读   </p>
<p>14 零宽断言<br>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言 。       </p>
<p><code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing. 时，它会匹配sing 和danc。 </p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：<code>((?&lt;=\d)\d{3})+\b</code>，<br>15 负向零宽断言<br>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？<br>例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：     </p>
<p><code>\b((?!abc)\w)+\b</code> 匹配不包含连续字符串abc的单词<br><code>(?&lt;![a-z])\d{7}</code> 匹配前面不是小写字母的七位数字<br><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配 不包含属性的简单HTML标签内里的内容       </p>
<p>16 注释<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。       </p>
<p>17 贪婪与懒惰<br>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。<br>前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>     </p>
<p><code>a.*?b</code> 匹配 最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</p>
<p>18 处理选项<br>IgnoreCase(忽略大小写) ,<br>Multiline(多行模式)更改^和$ 的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) ,<br>Singleline(单行模式) :更改.的含义，使它与每一个字符匹配（包括换行符\n）<br>IgnorePatternWhitespace(忽略空白):忽略表达式中的非转义空白并启用由#标记的注释<br>ExplicitCapture(显式捕获):仅捕获已被显式命名的组。      </p>
<p>是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。  </p>
<p>19 平衡组/递归匹配<br>(?’group’)  把捕获的内容命名为group,并压入堆栈(Stack)<br>(?’-group’)  从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败<br>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分<br>(?!)  零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败  </p>
<p>如何把 <code>xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy</code>这样的字符串里，最长的配对的尖括号内的内容捕获出来？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;                         #最外层的左括号 </span><br><span class="line">    [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容 </span><br><span class="line">    ( </span><br><span class="line">        ( </span><br><span class="line">            (?&apos;Open&apos;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot; </span><br><span class="line">            [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容 </span><br><span class="line">        )+ </span><br><span class="line">        ( </span><br><span class="line">            (?&apos;-Open&apos;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot; </span><br><span class="line">            [^&lt;&gt;]*        #匹配右括号后面不是括号的内容 </span><br><span class="line">        )+ </span><br><span class="line">    )* </span><br><span class="line">    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；</span><br><span class="line"> </span><br><span class="line">&gt;                         #最外层的右括号</span><br></pre></td></tr></table></figure></p>
<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<code>&lt;div&gt;</code>标签：<code>&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&#39;Open&#39;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&#39;-Open&#39;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;</code>. </p>
<p>20 还有些什么东西没提到  </p>
<p>联系作者<br>最后,来点广告……<br>网上的资源及本文参考文献<br>更新纪录  </p>
<p style="text-align:right">2018.9.24 星期一 23:50 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Css像素</title>
    <url>/sum/css/cc%E5%83%8F%E7%B4%A0(003)/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.24 星期一 22:31 </p>

<!-- \# [003-bD 现在手机分辨率这么大，如何写响应式布局？] -->
<h2 id="像素和物理像素"><a href="#像素和物理像素" class="headerlink" title="像素和物理像素"></a>像素和物理像素</h2><p>一个显示屏的成像原理是通过一系列的小点排列成一个大的矩形，不同的小点通过显示不同的颜色来显示成图像。这每一个小点被叫做一个<strong>物理像素</strong>。    </p>
<p>另一个常见的数据叫每英寸像素取值（Pixel per inch，简称PPI），意思是每一英寸内的物理像素数量，计算公式是     (屏幕尺寸指的是屏幕对角线的长度)        </p>
<p>如果一个CSS像素占用n个物理像素，那么我们就说此时的dppx（dots per pixel）数为n。<br>dppx是一个单位。设备有多少dppx除了跟设备本身的PPI有关，也和当前的缩放状态有关，<br>因此在浏览器不缩放的情况下若一个CSS像素等于一个设备像素，那么因为页面尺寸过小，会影响我的浏览，所以火狐浏览器贴心地进行1.25dppx的设置，使得1CSS像素等于1.25物理像素（反观Chrome仍为1）  </p>
<p>是的，可以说dppx可以看作devicePixelRatio（设备像素比，简称DPR）的单位，尽管DPR本身并不需要单位。综上可以看出，DPR由浏览器厂商确定。dppx可以看作window.devicePixel的单位，同时也可看作媒体查询中device-pixel-ratio的单位。       </p>
<h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><!-- \# [0032-aD 屏幕完美适配方案]        -->
<p>通常所说的像素，就是CCD/CMOS上光电感应元件的数量<br>分辨率:手机在横向、纵向上的像素点数总和，一般描述成 宽*高<br>像素密度=像素/尺寸 （dpi=px/in）    $_PS:在不涉及打印机时和ppi一个概念<br>标准屏幕像素密度（mdpi）:每英寸长度上还有160个像素点<br>像素密度等级:<br>设备独立像素：<strong>设备独立像素，不同于设备像素（物理像素）</strong>，它是虚拟化的。比如说<strong>css像素</strong>，我们常说的10px其实指的就是它。需要注意的是，物理像素开发者是无法获取的，它是自然存在的一种东西，该是多少就是多少。     </p>
<p>位图像素:位图像素是栅格图像（如：png,jpg,gif等）最小的数据单元。<br>理论上来说，1个位图像素对应1个物理像素，图片才能等到完美清晰的展示。<br>但是上面说过，在retina屏幕上，会出现1个位图像素对应多个物理像素。   </p>
<p>媒体查询中，min-width、max-width的查询即是对布局视口宽度的查询。<br>在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。      </p>
<p>一般由设计师按照设备像素(device pixel)为单位制作设计稿。    </p>
<!-- \# [[CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport]](https://github.com/jawil/blog/issues/21) -->
<p>1、PX(CSS pixels)<br>1.3 那么PX到底是什么？<br>px实际是pixel（像素）的缩写，根据 维基百科的解释，它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚它的上下文！一定要清楚它的上下文！一定要清楚它的上下文！  </p>
<p>不同的设备，图像基本采样单元是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为ppi和dpi：<br>ppi：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。<br>dpi：每英寸多少点。<br>关于打印机的点距我们不去关心，只要知道 当用于描述显示器设备时ppi与dpi是同一个概念 。</p>
<p>从上面的例子可以看出，CSS像素从来都只是一个相对值。<br>2、DP(device pixels)<br><strong>设备像素（物理像素）</strong>:顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位pt。       </p>
<h2 id="3、DIP-Device-independent-Pixel"><a href="#3、DIP-Device-independent-Pixel" class="headerlink" title="3、DIP(Device independent Pixel)"></a>3、DIP(Device independent Pixel)</h2><p><strong>设备独立像素，也称为逻辑像素</strong>，简称dip。<br>根据上述设备像素与CSS像素之间的关系、及DPR的官方定义，我们可以推断出：<br><strong>CSS像素 =设备独立像素 = 逻辑像素</strong><br><strong>$_PS: 区分于物理像素=设备像素；dpr换算</strong>    </p>
<h2 id="5-3-ppi和dpr到底什么关系？"><a href="#5-3-ppi和dpr到底什么关系？" class="headerlink" title="5.3 ppi和dpr到底什么关系？"></a>5.3 ppi和dpr到底什么关系？</h2><p>毕竟这些参数是外国人先发明的，他们会优先选择自己熟悉的计量单位作为显示设备的工厂标准参数，因此ppi就用作显示设备的工业标准；     </p>
<p>告诉业界人士，ppi达到多少是高清屏，此时对应的dpr是多少，而不直接告诉你我现在的显示设备dpr是多少，毕竟人们直接听到像素分辨率会更加有反应。   </p>
<p>设备像素比与ppi相关，一般是ppi/160的整数倍：    </p>
<!--\# [003-aD 一篇真正教会你开发移动端页面的文章(一)] -->
<h2 id="像素-什么是像素"><a href="#像素-什么是像素" class="headerlink" title="像素 - 什么是像素"></a>像素 - 什么是像素</h2><p>CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于手机屏幕的特性和用户的缩放了       </p>
<p>web前端领域，像素分为设备像素和CSS像素(苹果设备 200css像素等于400个设备像素)<br>一个CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。    </p>
<p>如果用户缩小页面，那么一个CSS像素会明显小于一个设备像素     </p>
<h2 id="移动端的三个视口"><a href="#移动端的三个视口" class="headerlink" title="移动端的三个视口"></a>移动端的三个视口</h2><p>有没有想过html元素的宽度是基于谁的呢？这个时候，就要引出一个概念：初始包含块和视口了<br>记住一句话：视口是html的父元素，所以我们称视口为初始包含块。 这样你就明白了，html元素的百分比是基于视口的。 </p>
<h3 id="第一个视口：布局视口"><a href="#第一个视口：布局视口" class="headerlink" title="第一个视口：布局视口"></a>第一个视口：布局视口</h3><p>布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。</p>
<p>也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)<br>document.documentElement.clientHeight</p>
<h3 id="第二个视口：视觉视口"><a href="#第二个视口：视觉视口" class="headerlink" title="第二个视口：视觉视口"></a>第二个视口：视觉视口</h3><h3 id="第三个视口：理想视口"><a href="#第三个视口：理想视口" class="headerlink" title="第三个视口：理想视口"></a>第三个视口：理想视口</h3><p>我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。</p>
<p>但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，<br>下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：<br><code>&lt;meta name = &quot;viewport&quot; content = &quot;width=device-width&quot; /&gt;</code></p>
<p>$_PS: <!-- [0032-bD 前端移动端适配总结]  --><br>然而，这段代码其实也并不完美，在IE浏览器中，由于横屏竖屏的切换会对其造成影响，为了解决这个兼容性的问题，最后再加上一句，就有了现在的：<br><code>&lt;meta name = &quot;viewport&quot; content = &quot;width=device-width,initial-scale=1&quot; &gt;</code></p>
<h2 id="三、设备像素比-DPR"><a href="#三、设备像素比-DPR" class="headerlink" title="三、设备像素比(DPR)"></a>三、设备像素比(DPR)</h2><p><strong>设备像素比(DPR)</strong> = 设备像素个数 / 理想视口CSS像素个数(device-width)<br>（公式成立的大前提：缩放比例为1）<br>与理想视口一样，设备像素比对于不同的设备是不同的，<br>可知iPhone5的设备像素为 640*1136    </p>
<p style="text-align:right">23:14 </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档2-深入React</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A32-%E6%B7%B1%E5%85%A5react/</url>
    <content><![CDATA[<p>高级指南: <a href="http://react.css88.com/docs/optimizing-performance.html" target="_blank" rel="noopener">http://react.css88.com/docs/optimizing-performance.html</a>     </p>
<p style="text-align:right">2018.9.21 星期五 10:21</p>


<h1 id="8-与第三方库协作"><a href="#8-与第三方库协作" class="headerlink" title="8 与第三方库协作"></a>8 与第三方库协作</h1><p>本指南将列举一些更常见的用例，重点介绍与 jQuery 以及 Backbone 的集成，但同样的思路适用于将组件与任何现有代码集成。<br>## 与 DOM 操作类插件结合<br>## 在 React 中使用其他引擎加载页面<br>## 在 React 中使用其他数据层库和框架<br>一般来说，推荐大家使用符合单向数据流的框架和库，比如 React state、Flux 或 Redux。但 React 的组件也可以支持其他处理数据流的框架和库。    </p>
<h1 id="2-代码拆分-Code-Splitting"><a href="#2-代码拆分-Code-Splitting" class="headerlink" title="2 代码拆分(Code-Splitting)"></a>2 代码拆分(Code-Splitting)</h1><p>## 打包(Bundling)<br>大多数的 React 应用程序使用Webpack或 Browserify 等工具来 “打包” 文件。<br>如果你使用的是Create React App，Next.js，Gatsby 或类似的工具，您将拥有一个开箱即用的 Webpack 安装程序来打包你的应用程序。<br>## 代码拆分<br>### import()   </p>
<blockquote>
<p>动态 import() 语法是ECMAScript（JavaScript）提案，目前不是语言标准的一部分。预计在不远的将来会被接受。  </p>
</blockquote>
<p>当 Webpack 遇到这个语法时，它会自动启动 代码拆分 来拆分你的应用程序。 如果您正在使用 Create React App ，则已经为你配置好了<br>在使用 Babel 时，你需要确保 Babel 能够解析动态导入语法，但目前 Babel 还不能直接对其进行转换。<br>## 库(Libraries)<br>React Loadable<br>## 基于路由的代码拆分  </p>
<hr>
<hr>
<h1 id="14-一致性比较（Reconciliation）"><a href="#14-一致性比较（Reconciliation）" class="headerlink" title="14. 一致性比较（Reconciliation）"></a>14. 一致性比较（Reconciliation）</h1><p>React提供声明式API，因此在每次更新中你不需要关心具体的更改内容。<br>React 的 “diffing” 算法中我们所作出地决择，以使得组件的更新是可预测的并且可以适用于高性能应用。        </p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>当你使用 React ，在任何一个单点时刻你可以认为 render() 函数的作用是创建 React 元素树。在下一个 state 或props 更新时，render() 函数将会返回一个不同的 React 元素树。接下来 React 将会找出如何高效地更新 UI 来匹配最近时刻的 React 元素树。   </p>
<p>目前存在大量通用的方法能够以最少的操作步骤将一个树转化成另外一棵树。然而，这个算法是复杂度为O(n3)，其中n 为树中元素的个数。     </p>
<p>如果你在 React 中展示 1000 个元素，那么每次更新都需要10亿次的比较，这样的代价过于昂贵。然而，React 基于以下两个假设实现了时间复杂度为 O(n) 的算法:</p>
<ol>
<li>不同类型的两个元素将会产生不同的树。</li>
<li>开发人员可以使用一个 key prop 来指示在不同的渲染中那个那些元素可以保持稳定。<br>事实上，这些假设在几乎所有的用例中都是有效的。  </li>
</ol>
<h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><p>当比较不同的两个树，React 首先比较两个根元素。根据根跟的类型不同，它有不同的行为。  </p>
<p>### 元素类型不相同<br>### DOM元素类型相同<br>保留相同的底层 DOM 节点，只更新反生改变的属性（attributes）<br>### 相同类型的组件<br>当一个组件更新的时候，组件实例保持不变，以便在渲染中保持state。React会更新组件实例的属性来匹配新的元素，并在元素实例上调用 componentWillReceiveProps() 和 componentWillUpdate()。       </p>
<p>接下来， render() 方法会被调用并且diff算法对上一次的结果和新的结果进行递归。<br>### 子元素递归<br>默认情况下，当递归一个 DOM 节点的子节点时，React 只需同时遍历所有的孩子基点同时生成一个改变当它们不同时。<br>如果在开始处插入一个节点也是这样简单地实现，那么性能将会很差。<br>### Keys<br>当子节点有了 key ，React 使用这个 key 去比较原来的树的子节点和之后树的子节点。<br>这个key 需要在它的兄弟节点中是唯一的就可以了，不需要是全局唯一。    </p>
<p>$_索引做为key在排序中会有问题：<br>作为最后的手段，你可以将数组中的索引作为 key 。如果它们从不重新排序，它们工作也很好，但是如果存在重新排序，性能将会很差。       </p>
<p>当索引用作key时，组件状态在重新排序时也会有问题。组件实例基于key进行更新和重用。如果key是索引，则item的顺序变化会改变key值。这将导致受控组件的状态可能会以意想不到的方式混淆和更新。</p>
<h2 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h2><p>需要记住的是 reconciliation(协调) 算法仅仅只是一个实现细节。React 会在每个操作上重新渲染整个应用，最终的结果可能是相同的。我们经常细化启发式算法，以便优化性能。    </p>
<p>因为React 依赖这个启发式，如果它们背后的假设没有得到满足，性能将会受到影响。    </p>
<hr>
<hr>
<h1 id="12-React-中不使用-ES6"><a href="#12-React-中不使用-ES6" class="headerlink" title="12. React 中不使用 ES6"></a>12. React 中不使用 ES6</h1><p>通常情况下你可以用普通的 JavaScript 类定义一个组件:<br>如果你不使用 ES6 ，你可以使用 create-react-class 方法代替：<br>除了一些例外，ES6 classes(类) API 非常类似于函数 createReactClass()<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createReactClass = <span class="built_in">require</span>(<span class="string">'create-react-class'</span>);</span><br><span class="line"><span class="keyword">var</span> Greeting = createReactClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>## 声明默认 Props<br>## 设置初始化 State(状态)<br>## 自动绑定<br>在 createReactClass() 中，并不需要这么做，因为方法可以自动绑定。<br>## Mixins<br>$_MORE:     </p>
<blockquote>
<p>ES6 是不支持 mixin 的，因此，当你用 ES6 classes(类)编写 React 时是不支持 mixins 的。<br>我们也在使用 mixins 的情况下发现了部分问题，所以我们不推荐目前使用。</p>
</blockquote>
<p>有时不同的组件可能会共用部分方法，这些方法会被称为横切关注点(cross-cutting concerns)。createReactClass 可以允许你使用 mixins 。     </p>
<h1 id="13-React-中不使用-JSX"><a href="#13-React-中不使用-JSX" class="headerlink" title="13. React 中不使用 JSX"></a>13. React 中不使用 JSX</h1><p>JSX 对使用React 不是必须的。当你不想在你的构建环境中设置编译器，那么不使用 JSX 的 React 是非常方便的。  </p>
<p>每一个 JSX 元素都是调用 React.createElement(component, props, …children) 的语法糖，因此，任何你使用 JSX 来做事都可以通过纯 JavaScript 实现。  </p>
<p>如果你厌倦了使用 React.createElement ，另一个常见的模式是将其赋值给一个缩写     </p>
<h1 id="9-深入-JSX"><a href="#9-深入-JSX" class="headerlink" title="9 深入 JSX"></a>9 深入 JSX</h1><p>从本质上讲，JSX 只是为 React.createElement(component, props, …children) 函数提供的语法糖。JSX代码:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/MyButton&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 编译为  </span></span><br><span class="line"><span class="regexp">React.createElement(</span></span><br><span class="line"><span class="regexp">  MyButton,</span></span><br><span class="line"><span class="regexp">  &#123;color: 'blue', shadowSize: 2&#125;,</span></span><br><span class="line"><span class="regexp">  'Click Me'</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">React.createElement(</span></span><br><span class="line"><span class="regexp">  'div',</span></span><br><span class="line"><span class="regexp">  &#123;className: 'sidebar'&#125;,</span></span><br><span class="line"><span class="regexp">  null</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="指定-React-元素类型"><a href="#指定-React-元素类型" class="headerlink" title="指定 React 元素类型"></a>指定 React 元素类型</h2><p>一个 JSX 标签的开始部分决定了 React 元素的类型。    </p>
<p>首字母大写的标签指示 JSX 标签是一个 React 组件。这些标签会被编译成 命名变量 的直接引用。所以如果你使用 JSX <foo> 表达式，那么 Foo 必须在作用域中。    </foo></p>
<p>### React 必须在作用域中<br>### 对 JSX 类型使用点语法<br>### 用户定义组件必须以大写字母开头<br>### 在运行时选择类型   </p>
<h2 id="JSX-中的-props-属性"><a href="#JSX-中的-props-属性" class="headerlink" title="JSX 中的 props(属性)"></a>JSX 中的 props(属性)</h2><p>### JavaScript 表达式作为 props(属性)<br>在 JavaScript 中，if 语句和 for 循环不是表达式，因此不能在 JSX 中直接使用。但你可以将他们放在附近的代码块中<br>### 字符串字面量<br>### props(属性) 默认为 “true”<br>通常情况下，我们不建议使用这种类型，因为这会与ES6中的对象shorthand混淆 。<br>### 属性展开<br>你也可以挑选你的组件将使用的指定属性(props)，同时使用展开运算符传递所有其他属性(props)。<br>展开(Spread) 属性可能很有用，但它们还可以轻松地将不必要的属性(props)传递给不关心它们的组件,或将无效的HTML属性传递给DOM。我们建议谨慎使用此语法。    </p>
<h2 id="JSX-中的-Children"><a href="#JSX-中的-Children" class="headerlink" title="JSX 中的 Children"></a>JSX 中的 Children</h2><p>在 JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ： props.children，下面有好几种方式传递 children ：<br>### 字符串字面量<br>### JSX Children<br>所以你可以混用字符串字面量和 JSX children。这是 JSX 与 HTML 另一点相似的地方，<br>### JavaScript 表达式作为 Children(子元素)<br>### Functions(函数) 作为 Children(子元素)<br>然而， props.children 类似于其他的 props(属性) ，可以被传入任何数据，而不是仅仅只是 React 可以渲染的数据。<br>只要在渲染之前组件可以将其转化为 React 能够处理的东西即可。这种用法并不常见，但是如果你需要扩展 JSX 的话，则会非常有用。<br>### Booleans, Null, 和 Undefined 被忽略<br>false，null，undefined，和 true 都是有效的的 children(子元素) 。但是并不会被渲染，<br>需要注意的是“falsy”值，例如数值 0 ，仍然会被 React 渲染。   </p>
<h1 id="10-优化性能"><a href="#10-优化性能" class="headerlink" title="10 优化性能"></a>10 优化性能</h1><p>## 使用生产版本<br>chrome插件<br>## 使用 Chrome 性能分析工具 分析组件性能<br>## 虚拟化长列表:“windowing” (开窗口) 技术<br>## 避免重新渲染<br>在大多数情况下，您可以不用手写 shouldComponentUpdate() ，而是从 React.PureComponent 继承。 这相当于用当前和以前 props(属性) 和 state(状态) 的浅层比较来实现shouldComponentUpdate() 。   </p>
<p>## 应用 shouldComponentUpdate<br>## 例子<br>在这种情况下，shouldComponentUpdate 函数仅仅检查 props.color 或者 state.count 是否发生改变。如果这些值没有发生变化，则组件不会进行更新。如果你的组件更复杂，你可以使用类似于对 props 和 state 的所有属性进行”浅比较”这种模式来决定组件是否需要更新。这种模式非常普遍，因此 React 提供了一个 helper 实现上面的逻辑：继承 React.PureComponent 。因此，下面的代码是一种更简单的方式实现了相同的功能：<br>## 不可变数据的力量<br>concat 重写,ES6 对于数组支持展开语法,Object.assign 方法,JavaScript提案添加了对象展开符<br>## 使用 Immutable 数据结构     </p>
<p style="text-align:right">12:21</p>

]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档2-其它概念</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A32-%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>高级指南: <a href="http://react.css88.com/docs/optimizing-performance.html" target="_blank" rel="noopener">http://react.css88.com/docs/optimizing-performance.html</a>     </p>
<p style="text-align:right">2018.9.21 星期五 10:21</p>

<h1 id="1-Accessibility"><a href="#1-Accessibility" class="headerlink" title="1 Accessibility"></a>1 Accessibility</h1><p>。。。  </p>
<h1 id="3-上下文-Context"><a href="#3-上下文-Context" class="headerlink" title="3 上下文(Context)"></a>3 上下文(Context)</h1><p>上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop 。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function ThemedButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /</span>&gt;&#125;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ----------</span></span><br><span class="line"><span class="regexp">&lt;Provider value=&#123;/</span>* some value *<span class="regexp">/&#125;&gt; </span></span><br><span class="line"><span class="regexp">&lt;Consumer&gt;</span></span><br><span class="line"><span class="regexp">  &#123;value =&gt; /</span>* render something based on the context value *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Consumer&gt;</span><br></pre></td></tr></table></figure></p>
<p>## 何时使用 Context<br>## API<br>### React.createContext<br><code>const {Provider, Consumer} = React.createContext(defaultValue);</code><br>创建一个 { Provider, Consumer } 对。当 React 渲染 context Consumer 时，它将从组件树中匹配最接近的 Provider 中读取当前的 context 值。<br>### Provider<br>### Consumer<br>需要接收一个 函数作为子节点。 该函数接收当前 context 值并返回一个 React 节点。<br>## 示例<br>### 动态 Context<br>### 从嵌套组件更新 context<br>### 使用多个 context<br>### 在生命周期方法中访问 Context<br>是将 context 添加到每个生命周期方法中， 你只需将它作为 props ， 然后像使用 props 一样使用它即可。<br>### 高阶组件中的 Context<br>### 转发 Refs 给 context Consumer(使用者)<br>## 告诫        </p>
<h1 id="18-严格模式-Strict-Mode"><a href="#18-严格模式-Strict-Mode" class="headerlink" title="18. 严格模式(Strict Mode)"></a>18. 严格模式(Strict Mode)</h1><blockquote>
<p>注意: 严格模式检查只在开发模式下运行，不会与生产模式冲突。<br>你可以在应用的任何地方启用严格模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ComponentOne /&gt;</span><br><span class="line">          &lt;ComponentTwo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.StrictMode&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>StrictMode目前有助于：      </p>
<ul>
<li>识别具有不安全生命周期的组件</li>
<li>有关旧式字符串ref用法的警告</li>
<li>检测意外的副作用</li>
<li>检测遗留 context API<br>将来的React版本将添加其他</li>
</ul>
<h1 id="16-渲染属性-Render-Props"><a href="#16-渲染属性-Render-Props" class="headerlink" title="16. 渲染属性(Render Props)"></a>16. 渲染属性(Render Props)</h1><p>术语 “render prop” 是指一种简单的技术，用于使用一个值为函数的 prop 在 React 组件之间的代码共享。  </p>
<p>带有渲染属性(Render Props)的组件需要一个返回 React 元素并调用它的函数，而不是实现自己的渲染逻辑。<br>## 在交叉关注点（Cross-Cutting Concerns）使用 render props<br>组件在 React 是主要的代码复用单元，但如何共享状态或一个组件的行为封装到其他需要相同状态的组件中并不是很明了。<br>例如，下面的组件在 web 应用追踪鼠标位置：<br>这也是 render prop 的来历：我们可以提供一个带有函数 prop 的 <mouse> 组件，它能够动态决定什么需要渲染的，而不是将 <cat> 硬编码到 <mouse> 组件里，并有效地改变它的渲染结果。<br>更具体地说，render prop 是一个组件用来了解要渲染什么内容的函数 prop。<br>这一技术使得共享代码间变得相当便利。为了实现这一行为，渲染一个带有 render prop 的 <mouse> 组件能够告诉它当前鼠标坐标 (x, y) 要渲染什么。    </mouse></mouse></cat></mouse></p>
<p>关于 render props 一个有趣的事情是你可以使用一个带有 render props 的常规组件来实现大量的 高阶组件 (HOC)。   </p>
<p>## 使用 Props 而非 render<br>记住仅仅是因为这一模式被称为 “render props” 而你 不必为使用该模式而用一个名为 render 的 prop。实际上，组件能够知道什么需要渲染的任何函数 prop 在技术上都是 “render prop” 。   </p>
<p>## 警告<br>### 在 React.PureComponent 中使用 render props 要注意<br>如果你在 render 方法里创建函数，那么使用 render prop 会抵消使用 React.PureComponent 带来的优势。这是因为浅 prop 比较对于新 props 总会返回 false，并且在这种情况下每一个 render 对于 render prop 将会生成一个新的值。    </p>
<p>为了绕过这一问题，有时你可以定义一个 prop 作为实例方法，类似如下：    </p>
<h1 id="15-Refs-和-DOM"><a href="#15-Refs-和-DOM" class="headerlink" title="15. Refs 和 DOM"></a>15. Refs 和 DOM</h1><p>Refs 提供了一种访问在 render 方法中创建的 DOM 节点或 React 元素的方式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>## 何时使用 Refs<br>如果可以通过声明式实现，就尽量避免使用 refs 。<br>## 不要过度使用 Refs<br>在组件层中，通常较高级别的 state 更为清晰。有关示例，请参考状态提升。       </p>
<blockquote>
<p>下面的例子已经用 React v16.3 引入的 React.createRef() API 更新。<br>## 创建 Refs<br>使用 React.createRef() 创建 refs，通过 ref 属性来获得 React 元素。当构造组件时，refs 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们.<br>## 访问 Refs<br>当一个 ref 属性被传递给一个 render 函数中的元素时，可以使用 ref 中的 current 属性对节点的引用进行访问。<br>## 为 类(Class) 组件添加 Ref<br>## Refs 与 函数式组件<br>你不能在函数式组件上使用 ref 属性，因为它们没有实例:<br>如果你需要使用 ref ，你需要将组件转化成 类(class)组件，就像需要 生命周期方法 或者 state 一样。      </p>
</blockquote>
<p>然而你可以 在函数式组件内部使用 ref 来引用一个 DOM 元素或者 类(class)组件：<br>## 对父组件暴露 DOM 节点<br>如果你使用 React 16.3 或更高, 这种情况下我们推荐使用 ref 转发。<br>可能的话，我们不建议暴露 DOM 节点，<br>## 回调 Refs<br>React 也支持另一种设置 ref 的方式，称为“回调 ref”，更加细致地控制何时 ref 被设置和解除。    </p>
<p>React 将在组件挂载时将 DOM 元素传入ref 回调函数并调用，当卸载时传入 null 并调用它。ref 回调函数会在 componentDidMout 和 componentDidUpdate 生命周期函数前被调用     </p>
<p>你可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样。    </p>
<p>## 旧版API: String 类型的 Refs<br>我们不建议使用，因为string类型的 refs 存在问题。已经过时了，可能会在未来的版本是移除。  </p>
<h1 id="5-转发-Refs"><a href="#5-转发-Refs" class="headerlink" title="5 转发 Refs"></a>5 转发 Refs</h1><p>Ref 转发是一种自动将 ref 通过组件传递给子组件的技术。<br>## 转发 refs 给 DOM 组件<br>Ref 转发是一种选择性加入的功能，可让某些组件接收他们收到的 ref，并将其向下传递（换句话说，“转发”）给孩子。  </p>
<p>在下面的例子中， FancyButton 使用 React.forwardRef 来获取传递给它的 ref ， 然后将其转发给它渲染的的 DOM button：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    </span><br><span class="line">&#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ You can now get a ref directly to the DOM button:</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/</span>FancyButton&gt;;</span><br></pre></td></tr></table></figure></p>
<p>## 组件库维护者的注意事项<br>## 在高阶组件中转发 refs<br>## 在DevTools中显示一个自定义名称    </p>
<h1 id="6-片段-Fragments"><a href="#6-片段-Fragments" class="headerlink" title="6 片段(Fragments)"></a>6 片段(Fragments)</h1><p>React 中一个常见模式是为一个组件返回多个元素。 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM 中增加额外节点。<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt; <span class="comment">// 简写 &lt;&gt; </span></span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;/</span><span class="regexp">/ 简写 &lt;/</span>&gt; </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>## 简写语法<br>您可以像使用其他元素一样使用&lt;&gt;&lt;/&gt;，只是它不支持 键(keys) 或 属性(attributes)。<br>请注意， 目前许多工具都不支持这个简写语法 ， 所以你可能需要明确地使用<br>## 带 key 的 片段(fragments)<br>如果你需要一个带 key 的片段，你可以直接使用 &lt;React.Fragment /&gt; 。 一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：   </p>
<p>key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。    </p>
<h1 id="11-插槽-Portals"><a href="#11-插槽-Portals" class="headerlink" title="11. 插槽(Portals)"></a>11. 插槽(Portals)</h1><p>Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。<br><code>ReactDOM.createPortal(child, container)</code><br>## 用法<br>通常来说，当你从组件的 render 方法返回一个元素时，它将被作为子元素被装载到最近父节点 DOM 中：<br>然而，有时候将子元素插入到 DOM 节点的其他位置会有用的：<br><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。</span></span><br><span class="line">  <span class="comment">// `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。</span></span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">    <span class="keyword">this</span>.props.children,</span><br><span class="line">    domNode,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>## 通过 Portals 进行事件冒泡  </p>
<h1 id="4-错误边界-Error-Boundaries"><a href="#4-错误边界-Error-Boundaries" class="headerlink" title="4 错误边界(Error Boundaries)"></a>4 错误边界(Error Boundaries)</h1><p>部分 UI 中的 JavaScript 错误不应该破坏整个应用程序。 为了解决 React 用户的这个问题，React 16引入了一个 “错误边界(Error Boundaries)” 的新概念。      </p>
<p>错误边界是 React 组件，它可以 在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ，而不是使整个组件树崩溃。 错误边界(Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。</p>
<blockquote>
<p>错误边界 无法 捕获如下错误:</p>
<ul>
<li>事件处理 （了解更多）</li>
<li>异步代码 （例如 setTimeout 或 requestAnimationFrame 回调函数）</li>
<li>服务端渲染</li>
<li>错误边界自身抛出来的错误 （而不是其子组件）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 而后你可以像一个普通的组件一样使用：</span></span><br><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="20-不受控组件"><a href="#20-不受控组件" class="headerlink" title="20. 不受控组件"></a>20. 不受控组件</h1><p>在大多数情况下，我们推荐使用受控组件来实现表单。…<br>另外一个选择是不受控组件，其表单数据由 DOM 元素本身处理。   </p>
<p>要编写一个未控制组件，你可以使用一个 ref 来从 DOM 获得 表单值，而不是为每个状态更新编写一个事件处理程序。   </p>
<p>因为不受控组件的数据来源是 DOM 元素，当使用不受控组件时很容易实现 React 代码与非 React 代码的集成。如果你希望的是快速开发、不要求代码质量，不受控组件可以一定程度上减少代码量。否则。你应该使用受控组件。   </p>
<p>## 默认值<br>在不受控组件中，你可能希望 React 有初始值，但保留后续更新不受控制。<br>defaultValue,defaultChecked<br>## file input 标签<br>始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。      </p>
<h1 id="7-高阶组件-Higher-Order-Components"><a href="#7-高阶组件-Higher-Order-Components" class="headerlink" title="7 高阶组件(Higher-Order Components)"></a>7 高阶组件(Higher-Order Components)</h1><p>高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。<br>具体来说，高阶组件是一个函数，能够接受一个组件并返回一个新的组件。(组件是将 props 转化成 UI)<br>## 在横切关注点中使用高阶组件<br>## 不要改变原始组件，而是使用组合<br>高阶组件使用容器作为其实现的一部分。你可以将高阶组件视为定义参数化容器组件。<br>## 约定: 给包裹组件传递不相关的属性(Props)<br>## 约定: 最大化组合(Maximizing Composability)<br>## 约定:为了方便调试包装显示名称(display name)<br>## 警告<br>### 不要在render函数中使用高阶组件<br>### 静态方法必须复制<br>### Refs不会被传递  </p>
<h1 id="21-Web-组件-Web-Components"><a href="#21-Web-组件-Web-Components" class="headerlink" title="21. Web 组件(Web Components)"></a>21. Web 组件(Web Components)</h1><p>React 和 web组件 被用以解决不同问题。<br>Web组件为可重用组件提供了强大的封装能力，<br>而React则是提供了保持DOM和数据同步的声明式库。<br>二者目标互补。作为开发者，你可以随意地在Web组件里使用React，或者在React里使用Web组件，或都有。  </p>
<p>大部分使用 React 的开发者并不使用Web组件，但你可能想要，尤其若你正在使用那些用 Web组件编写的第三方UI组件。      </p>
<p style="text-align:right">12:21</p>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档2-类型检查</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A32-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>高级指南: <a href="http://react.css88.com/docs/optimizing-performance.html" target="_blank" rel="noopener">http://react.css88.com/docs/optimizing-performance.html</a>     </p>
<p style="text-align:right">2018.9.21 星期五 10:21</p>

<h1 id="17-静态类型检查"><a href="#17-静态类型检查" class="headerlink" title="17. 静态类型检查"></a>17. 静态类型检查</h1><p>像 Flow 和 TypeScript 这样的静态类型检查器可以在运行代码之前识别某些类型的问题。 他们还可以通过添加自动完成功能来改善开发人员的工作流程。 出于这个原因，对于更大的代码库我们建议使用 Flow 或者 TypeScript 来替代 PropTypes。        </p>
<h1 id="19-使用-PropTypes-进行类型检查"><a href="#19-使用-PropTypes-进行类型检查" class="headerlink" title="19. 使用 PropTypes 进行类型检查"></a>19. 使用 PropTypes 进行类型检查</h1><p>但即使你不使用这些（$指:Flow/TypeScript），React 内置了类型检测的功能。要在组件中进行类型检测，你可以赋值 propTypes 属性。     </p>
<blockquote>
<p>注意： 从 React v15.5 开始 ，React.PropTypes 助手函数已被弃用，我们建议使用 prop-types 库 来定义contextTypes。<br>## PropTypes<br>## 要求单独的 Child<br>## 默认的 prop 值<br>如果父组件没有为 this.props.name 传值，defaultProps 会给其一个默认值。propTypes 的类型检测是在defaultProps 解析之后发生的，因此也会对默认属性 defaultProps 进行类型检测。       </p>
</blockquote>
<p style="text-align:right">10:21</p>

]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
  </entry>
  <entry>
    <title>Vue和React比较</title>
    <url>/sum/jsplus/Vue%E5%92%8CReact%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>原文：<a href="https://github.com/lihongxun945/myblog/issues/21" target="_blank" rel="noopener">关于Vue和React区别的一些笔记</a></p>
<p>这篇文章记录我在使用Vue和React的时候，对他们的不同之处的一些思考，不仅局限于他们本身，也会包括比如 Vuex/Redux 等经常搭配使用的工具。因为涉及到的内容很多，可能下面的每一个点都能写成一篇文章，这次先简单做一个概要，等我有空做一个详细的专题出来。</p>
<h2 id="监听数据变化的实现原理不同"><a href="#监听数据变化的实现原理不同" class="headerlink" title="监听数据变化的实现原理不同"></a>监听数据变化的实现原理不同</h2><ul>
<li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的VDOM的重新渲染</li>
</ul>
<p>为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而React更强调数据的不可变。所以应该说没有好坏之分，Vue更加简单，而React构建大型应用的时候更加鲁棒。    </p>
<p>因为一般都会用一个数据层的框架比如 Vuex 和 Redux，所以这部分不作过多解释，在最后的 vuex 和 redux的区别 中也会讲到。</p>
<h2 id="数据流的不同"><a href="#数据流的不同" class="headerlink" title="数据流的不同"></a>数据流的不同</h2><p><img src="http://you img base url/https://raw.githubusercontent.com/lihongxun945/myblog/master/images/vue-vs-react-data-flow.png?e=1585218234&token=your qiniu access key:FAF9ejjgqxD43FlsO4Gn-49uBpw=" alt="vue和react数据流"></p>
<p>大家都知道Vue中默认是支持双向绑定的。在Vue1.0中我们可以实现两种双向绑定：</p>
<ol>
<li>父子组件之间，props 可以双向绑定</li>
<li>组件与DOM之间可以通过 v-model 双向绑定</li>
</ol>
<p>在 Vue2.x 中去掉了第一种，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过事件的方式修改），并且 Vue2.x 已经不鼓励组件对自己的 props 进行任何修改了。<br>所以现在我们只有 组件 <--> DOM 之间的双向绑定这一种。</--></p>
<p>然而 React 从诞生之初就不支持双向绑定，React一直提倡的是单向数据流，他称之为 onChange/setState() 模式。     </p>
<p>不过由于我们一般都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了。</p>
<h2 id="HoC-和-mixins"><a href="#HoC-和-mixins" class="headerlink" title="HoC 和 mixins"></a>HoC 和 mixins</h2><p>在 Vue 中我们组合不同功能的方式是通过 mixin，而在React中我们通过 HoC (高阶组件）。      </p>
<p>React 最早也是使用 mixins 的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了 mixinx 转而使用 HoC，关于mixin究竟哪里不好，可以参考React官方的这篇文章 <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>  </p>
<p>而 Vue 一直是使用 mixin 来实现的。<br>为什么 Vue 不采用 HoC 的方式来实现呢？<br>高阶组件本质就是高阶函数，React 的组件是一个纯粹的函数，所以高阶函数对React来说非常简单。<br>但是Vue就不行了，Vue中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的props怎么接收到的？这些都是vue创建组件实例的时候隐式干的事。由于vue默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个高阶组件，那么这个被包装的组件就无法正常工作了。   </p>
<p>推荐一篇很棒的文章讲的是vue中如何实现高阶组件 <a href="http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">探索Vue高阶组件</a></p>
<h2 id="组件通信的区别"><a href="#组件通信的区别" class="headerlink" title="组件通信的区别"></a>组件通信的区别</h2><p><img src="http://you img base url/https://raw.githubusercontent.com/lihongxun945/myblog/master/images/message.png?e=1585218234&token=your qiniu access key:Z1UWWE3nXVuVKBO1pLzzn1kf9Vo=" alt="vue和react组件通信">  </p>
<p>其实这部分两个比较相似。    </p>
<p>在Vue 中有三种方式可以实现组件通信：    </p>
<ul>
<li>父组件通过 props 向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据，而通过 事件的机制来处理子组件向父组件的通信</li>
<li>子组件通过 事件 向父组件发送消息</li>
<li>通过 V2.2.0 中新增的 provide/inject 来实现父组件向子组件注入数据，可以跨越多个层级。</li>
</ul>
<p>另外有一些比如访问 $parent/$children等比较dirty的方式这里就不讲了。</p>
<p>在 React 中，也有对应的三种方式：  </p>
<ul>
<li>父组件通过 props 可以向子组件传递数据或者回调</li>
<li>可以通过 context 进行跨层级的通信，这其实和 provide/inject 起到的作用差不多。</li>
</ul>
<p>可以看到，React 本身并不支持自定义事件，Vue中子组件向父组件传递消息有两种方式：事件和回调函数，而且Vue更倾向于使用事件。但是在 React 中我们都是使用回调函数的，这可能是他们二者最大的区别。</p>
<h2 id="模板渲染方式的不同"><a href="#模板渲染方式的不同" class="headerlink" title="模板渲染方式的不同"></a>模板渲染方式的不同</h2><p>在表层上， 模板的语法不同   </p>
<ul>
<li>React 是通过JSX渲染模板</li>
<li>而Vue是通过一种拓展的HTML语法进行渲染</li>
</ul>
<p>但其实这只是表面现象，毕竟React并不必须依赖JSX。<br>在深层上，模板的原理不同，这才是他们的本质区别：    </p>
<ul>
<li>React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的</li>
<li>Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现   </li>
</ul>
<p>对这一点，我个人比较喜欢React的做法，因为他更加纯粹更加原生，而Vue的做法显得有些独特，会把HTML弄得很乱。举个例子，说明React的好处：<br>react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。     </p>
<h2 id="Vuex-和-Redux-的区别"><a href="#Vuex-和-Redux-的区别" class="headerlink" title="Vuex 和 Redux 的区别"></a>Vuex 和 Redux 的区别</h2><p>从表面上来说，store 注入和使用方式有一些区别。      </p>
<p>在 Vuex 中，$store 被直接注入到了组件实例中，因此可以比较灵活的使用：</p>
<ul>
<li>使用 dispatch 和 commit 提交更新</li>
<li>通过 mapState 或者直接通过 this.$store 来读取数据</li>
</ul>
<p>在 Redux 中，我们每一个组件都需要显示的用 connect 把需要的 props 和 dispatch 连接起来。     </p>
<p>另外 Vuex 更加灵活一些，组件中既可以 dispatch action 也可以 commit updates，而 Redux 中只能进行 dispatch，并不能直接调用 reducer 进行修改。  </p>
<p>从实现原理上来说，最大的区别是两点：    </p>
<ul>
<li>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改</li>
<li>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的（如果看Vuex源码会知道，其实他内部直接创建一个Vue实例用来跟踪数据变化）  </li>
</ul>
<p>而这两点的区别，其实也是因为 React 和 Vue的设计理念上的区别。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用 Vue 的感觉。   </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>三大框架比较</title>
    <url>/sum/jsplus/%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.18 星期二 17:23</p>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p style="text-align:right">2018.11.02 星期五 17:23 #1</p>

<p>angular: ts,支持组件,其他不知道了;可能构建大的应用<br>angularjs:双向数据绑定–脏检测(被诟病);没有组件,而是model,通信可以$root,或者父子通信;     </p>
<p>vuejs: 灵活性,学习曲线,运行时性能,体积. 还有文档, 造就了大批信众<br>组件,单向数据流,只支持和dom的双向绑定了.和父组件取消了<br>虽然有render函数,但是更推荐vue模板,通过vue-loader来处理   </p>
<p>react: JSX语法, 生态系统强大,包括react native,<br>组件:更符合ES6 标准,纯函数,提供render函数<br>单向数据流,需要通过事件handler;<br>只是View层,基于数据通过JSX 展现了视图.区别于vue等MVVM, 把逻辑和视图都放到一起,并没有像vue,angularjs等MVVM框架明确区分开.   </p>
<p>模板和JSX: 如果不通过编译,new Vue的语法比react es5的写法容易一些.每个new vue都是一个新的实例,通过vue.component 共用组件<br>vue基于数据可变的,通过监听数据的变化 render<br>react通过setState触发生命周期,通过diff算法进行render<br>react强调数据不变(pureComponent可以做优化),所以更适合用HOC, 而vue一直是Mixin<br><!-- $end:#1 --></p>
<p>参考:<br><a href="https://github.com/lihongxun945/myblog/issues/21" target="_blank" rel="noopener">关于Vue和React区别的一些笔记</a><br><a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">对比其他框架</a>    </p>
<p>$BLOB:Vue和React比较],vuejs文档9-对比<br>以下内容略过     </p>
<p># vue和react</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><p>vue 模板语法：Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。<br>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。      </p>
<p>react jsx:  JavaScrip 的一种扩展语法。描述 UI 信息。<br>从本质上讲，JSX 只是为 React.createElement(component, props, …children) 函数提供的语法糖。JSX代码:    </p>
<p>### 事件处理<br>vue是有指令的，可以通过指令进行数据绑定，或者事件监听，模板语法等.<br>用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。     </p>
<p>react 没有指令,几乎都是定义在实例/组件中，<br>包括方法，而且方法需要在实例中绑定this(或者通过其它2中方式);   </p>
<p>#### 区别<br>vue的指令有简写，还有修饰符,可以在html的模板表达式中传入参数<br>react的事件需要将html的小写转化为驼峰进行监听；需要传入e(合成的事件) 阻止默认操作等，   </p>
<p>### 条件渲染：<br>vue 通过指令v-if/v-show,将html的模板 编译成 虚拟DOM渲染函数<br>react 是通过 render 函数，渲染的    </p>
<p>### class绑定：     </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vue html</span></span><br><span class="line"><span class="comment">&lt;div id="app"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> nv=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">'vue'</span>,</span><br><span class="line">        firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        great:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// event 是原生 DOM 事件</span></span><br><span class="line">            <span class="comment">// this 指向当前vue实例</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.message) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;<span class="comment">// 计算属性 vs 侦听属性</span></span><br><span class="line">        firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**********************/</span></span><br><span class="line"><span class="comment">// 从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖</span></span><br><span class="line"><span class="comment">// const element =&lt;div /&gt;</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span>; </span><br><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt; Click Me &lt;<span class="regexp">/MyButton&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 编译为</span></span><br><span class="line"><span class="regexp">React.createElement(</span></span><br><span class="line"><span class="regexp">  MyButton, /</span><span class="regexp">/ element  </span></span><br><span class="line"><span class="regexp">  &#123;color: 'blue', shadowSize: 2&#125;,</span></span><br><span class="line"><span class="regexp">  'Click Me'</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ## react：html写在js中，用render渲染；    </span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;Hello, world!&lt;/</span>h1&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>vue: beforeCreate,created,beforeMount,mounted,beforeDestory,destroyed;<br>beforeUpdate,updated</p>
<p>react:<br>Mounting(装载): constructor(),static getDerivedStateFromProps(),render(),componentDidMount()    </p>
<p>Updating(更新):static getDerivedStateFromProps(),shouldComponentUpdate(),render(),getSnapshotBeforeUpdate(),componentDidUpdate()    </p>
<p>Unmounting(卸载):componentWillUnmount()<br>错误处理:componentDidCatch()    </p>
<h2 id="state-props"><a href="#state-props" class="headerlink" title="state/props"></a>state/props</h2><p>都用state来表示实例的数据，都需要其他设置，或需要调用 setState()<br>props都描述了 组件的属性/特性：从父组件调用中传递下来的数据。不可变<br>表示的数据都属于实例，都可以通过props来传递     </p>
<p>### 区别<br>react: 一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：<br>state和props是 react实例的属性，要在construtor中通过this. 设置   </p>
<p>vue的state 是在 data 属性/函数返回的对象((组件) 中声明；props就是props     </p>
<p>需要注意vue有个计算属性，模板不再是简单的声明式逻辑。对于任何复杂逻辑，使用计算属性。计算属性和方法不同，也和侦听属性有差别       </p>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>子组件可以通过props获得父组件传递的数据<br>父获得子数据 通过 事件触发：<br>Vue 实例提供了一个自定义事件的系统来解决这个问题。调用内建的 $emit 方法并传入事件的名字，来向父级组件触发一个事件：<br>react 在子组件中绑定事件，在事件函数中 触发 父组件传递的 监听事件(props.onTemperatureChange，可以随意命名)，这个监听事件有一个函数，(参数)可以接收子组件传递的数据<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;input value=&#123;temperature&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">scale</span>: <span class="string">'c'</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> celsius = scale === <span class="string">'f'</span> ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput  scale=<span class="string">"c"</span> temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="双向数据绑定-和-单向数据流"><a href="#双向数据绑定-和-单向数据流" class="headerlink" title="双向数据绑定 和 单向数据流"></a>双向数据绑定 和 单向数据流</h2><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>vue:所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。<br>react: 从定义上来说， 组件就像JavaScript的函数。组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些组件是全局注册的。在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中   </span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span>,</span><br><span class="line">  props:[],<span class="comment">// &#123;&#125; </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 局部注册，然后使用       </span></span><br><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**************/</span></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">        <span class="comment">// this.props=;</span></span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<h3 id="受控组件-和-非受控组件"><a href="#受控组件-和-非受控组件" class="headerlink" title="受控组件 和 非受控组件"></a>受控组件 和 非受控组件</h3><h3 id="Mixin-和-HOC"><a href="#Mixin-和-HOC" class="headerlink" title="Mixin 和 HOC"></a>Mixin 和 HOC</h3><h2 id="视图更新-响应式"><a href="#视图更新-响应式" class="headerlink" title="视图更新(响应式)"></a>视图更新(响应式)</h2><p>react: 通过setState触发生命周期,进行diff算法,更新<br>vue:<br>1) 传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。<br>2) 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。<br>3) 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。     </p>
<p>都是异步更新,都会合并(比如vue,如果同一个 watcher 被多次触发，只会被推入到队列中一次),都有队列;<br>但是vue有实例方法<code>vm.$nextTick()</code> 直接触发更新      </p>
<p style="text-align:right">18:20</p>


<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>vue-loader: </p>
<h2 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h2><p>### react：<br>原生：直接 style Object；<br>库40+解决方式-css in js :<br>Css Modules,styled-components,JSS, Radium,styled-jsx, … </p>
<p>### vue<br>一旦加上 scoped 属性，css 就只作用于所在组件。简洁漂亮的解决。美中不足的是样式并不能直接访问组件状态，于是乎需要另外规定动态css的语法与此合并使用。     </p>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>vue-cli<br>create-react-app<br>$BLOB: vuejs文档9-对比    </p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>基本差不多    </p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p># angular  </p>
<h2 id="angular-js"><a href="#angular-js" class="headerlink" title="angular.js"></a>angular.js</h2><h2 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h2><h2 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h2>]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>setTimeout和setInterval</title>
    <url>/sum/js/setTimeout%E5%92%8CsetInterval/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.17 星期一 15：35</p>

<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>计时器：00:00:00 0  h:m:s hm(100ms)<br><a href="https://yalhu.github.io/forstudy/component/timer.html" target="_blank" rel="noopener">demo</a>   </p>
<h3 id="timer的count写法"><a href="#timer的count写法" class="headerlink" title="timer的count写法"></a>timer的count写法</h3><p>setTimeout递归跑时间长了要比setInterval慢一点<br>从api作用上来讲，该demo也是使用setInterval的：render中间的跳过可以不用处理，保证count+=.1 就ok了<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Timer=&#123;</span><br><span class="line">    <span class="comment">// paused:true,</span></span><br><span class="line">    el:<span class="literal">null</span>,</span><br><span class="line">    tid:<span class="literal">null</span>,</span><br><span class="line">    count:<span class="number">0</span>,</span><br><span class="line">    start:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// this.paused=false;</span></span><br><span class="line">        <span class="keyword">this</span>.tid=setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count=<span class="keyword">this</span>.count+<span class="number">0.1</span></span><br><span class="line">            <span class="keyword">this</span>.render(<span class="keyword">this</span>.count)</span><br><span class="line">        &#125;,<span class="number">100</span>)</span><br><span class="line">        <span class="comment">/* this.tid=setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">            this.count=this.count+0.1</span></span><br><span class="line"><span class="comment">            this.render(this.count)</span></span><br><span class="line"><span class="comment">            this.start()</span></span><br><span class="line"><span class="comment">        &#125;,100) */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render:<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.el.innerHTML=formatT(c);</span><br><span class="line">    &#125;,</span><br><span class="line">    pause:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// this.paused=true</span></span><br><span class="line"></span><br><span class="line">        clearTimeout(<span class="keyword">this</span>.tid)</span><br><span class="line">        <span class="keyword">this</span>.tid=<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// clear:()=&gt;&#123;  // error: this指向window,定义时所在的对象，而不是使用时所在的对象。</span></span><br><span class="line">    clear:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        clearTimeout(<span class="keyword">this</span>.tid)</span><br><span class="line">        <span class="keyword">this</span>.tid=<span class="literal">null</span></span><br><span class="line">        <span class="comment">// this.paused=false</span></span><br><span class="line">        <span class="keyword">this</span>.count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.render(<span class="keyword">this</span>.count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="timer-的其他方法"><a href="#timer-的其他方法" class="headerlink" title="timer 的其他方法"></a>timer 的其他方法</h3><p>用h/m/s ++ 的方法:<br>2.1 定义类的时候需要添加h/m/s的属性，本例使用一个count属性就可以了<br>    区别就是需要把count格式化，在使用setInterval的基础上影响可以不计<br>2.2 而且需要做判断 h/m/s&gt;60, 百毫秒的话 hm&gt;9  </p>
<h2 id="setTimeout和setInterval"><a href="#setTimeout和setInterval" class="headerlink" title="setTimeout和setInterval"></a>setTimeout和setInterval</h2><!-- \# <https://segmentfault.com/q/1010000005989491>     -->
<p>setInterval 是持续占有独立线程的一个定时触发函数！<br>嵌套setTimeout，实现的功能和前者一样！但是不会持续占有一个线程的资源，<br>执行完当前的方法，会释放当然的线程资源，等待下次触发，会重新申请资源！  </p>
<!-- \# <https://jixianqianduan.com/frontend-javascript/2014/08/25/js-settimeout-setinterval.html> -->
<p>实际的情况是javascript都是以单线程的方式运行于浏览器的javascript引擎中的,<br>settimeout和setinterval的作用只是把你要执行的代码在你设定的一个时间点插入js引擎维护的一个代码队列中,<br>插入代码队列并不意味着你的代码就会立马执行的,理解这一点很重要.<br>而且settimeout和setinterval还有点不一样。   </p>
<p>###  $_PS: setInterval 不能保证按照所给定的间隔时间执行，会跳过<br><!-- \# <https://jixianqianduan.com/frontend-javascript/2014/08/25/js-settimeout-setinterval.html> --><br>可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是,<br>由于代码队列中已经有了一份未执行的process代码, 所以605ms这个插入时间点将会被”无情”的跳过, 因为js引擎只允许有一份未执行的process代码 </p>
<p>用setTimeout递归就不会产生时间点被跳过的问题<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//processing </span></span><br><span class="line">    setTimeout(<span class="built_in">arguments</span>.callee, interval); </span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure></p>
<!-- <https://www.jianshu.com/p/839120a1d2e6> -->
<p>setInterval可能会出现调用时间间隔不准的问题，不能保证按照所给定的间隔时间执行。<br>比如调用的函数执行时间超过了间隔时间，那么在前一个调用还没有结束的时候后一个调用已经启动了。这里带来的问题是如果后一个调用需要以前一个调用为基础的话，就会出错。</p>
<p style="text-align:right">2018.9.17 星期一 15:53</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>React文档1-11_组合 vs 继承</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-11_%E7%BB%84%E5%90%88%20vs%20%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><a href="http://react.css88.com/docs/thinking-in-react.html" target="_blank" rel="noopener">http://react.css88.com/docs/thinking-in-react.html</a>  </p>
<p style="text-align:right">2018.9.14 星期六 11:45</p>

<p>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用。  </p>
<h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>一些组件在设计前无法获知自己要使用什么子组件，尤其在 Sidebar 和 Dialog 等通用 “容器” 中比较常见。<br>我们建议这种组件使用特别的 children prop 来直接传递 子元素到他们的输出中：  </p>
<p>然而这并不常见，有时候，在一个组件中你可能需要多个 “占位符” 。在这种情况下，你可以使用自定义的 prop(属性)，而不是使用 children ：   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">        &#123;props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;FancyBorder color="blue"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1 className="Dialog-title"&gt;</span></span><br><span class="line"><span class="regexp">          Welcome</span></span><br><span class="line"><span class="regexp">        &lt;/</span>h1&gt;</span><br><span class="line">        &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">          Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>FancyBorder&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// exam2 子定义 prop属性，非children</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Contacts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"Contacts"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"Chat"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">          &#123;props.left&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="SplitPane-right"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;SplitPane</span></span><br><span class="line"><span class="regexp">        left=&#123;</span></span><br><span class="line"><span class="regexp">          &lt;Contacts /</span>&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        right=&#123;</span><br><span class="line">          &lt;Chat /&gt;</span><br><span class="line">        &#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><p>有时候，我们考虑组件作为其它组件的“特殊情况”。例如，我们可能说一个 WelcomeDialog 是 Dialog 的一个特殊用例。<br>在React中，也可以使用组合来实现，一个偏“特殊”的组件渲染出一个偏“通用”的组件，通过 props(属性) 配置它：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Dialog</span></span><br><span class="line"><span class="regexp">      title="Welcome"</span></span><br><span class="line"><span class="regexp">      message="Thank you for visiting our spacecraft!" /</span>&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$_PS: 非继承：这里的<strong>包含</strong>不是继承，而是 组合</p>
<h2 id="如何看待继？"><a href="#如何看待继？" class="headerlink" title="如何看待继？"></a>如何看待继？</h2><p>在 Facebook ，我们在千万的组件中使用 React，我们还没有发现任何用例，值得我们建议你用继承层次结构来创建组件。    </p>
<p>使用 props(属性) 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数。   </p>
<p>如果要在组件之间重用非 U I功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。  </p>
<p style="text-align:right">11:54</p>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-12_react编程思想</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-12_react%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p><a href="http://react.css88.com/docs/thinking-in-react.html" target="_blank" rel="noopener">http://react.css88.com/docs/thinking-in-react.html</a>  </p>
<p style="text-align:right">2018.9.14 星期六 00:27</p>

<p>在我们看来，React 是 JavaScript 构建大型，高性能 Web 应用的首选。在 Facebook 和 Instagram 中都能很好的应用。    </p>
<p>React 中许多重要部分之一是思考如何构建应用程序。 在本文档中，我们将引导你完成用 React 构建一个可搜索的产品数据表的思考过程。    </p>
<h2 id="从一个线框图开始"><a href="#从一个线框图开始" class="headerlink" title="从一个线框图开始"></a>从一个线框图开始</h2><h2 id="步骤1：将-UI-拆解到组件层次结构中"><a href="#步骤1：将-UI-拆解到组件层次结构中" class="headerlink" title="步骤1：将 UI 拆解到组件层次结构中"></a>步骤1：将 UI 拆解到组件层次结构中</h2><p>如果你和设计师一起工作， 他们可能已经做了这些工作，所以去和他们交流一下！       </p>
<p>但是你该如何拆分组件呢？其实只需要像拆分一个新方法或新对象一样的方式即可。一个常用的技巧是单一职责原则，即一个组件理想情况下只处理一件事。如果一个组件持续膨胀，就应该将其拆分为多个更小的组件中。      </p>
<h2 id="步骤2：-用-React-构建一个静态版本"><a href="#步骤2：-用-React-构建一个静态版本" class="headerlink" title="步骤2： 用 React 构建一个静态版本"></a>步骤2： 用 React 构建一个静态版本</h2><p>目前为止你已经有了组件层次结构，现在是时候实现你的 app 了。最简单的方法是构建一个采用数据模型并渲染 UI 但没有交互性的版本。最好解耦这些处理，因为构建静态版本需要 大量的代码 和 少量的思考，而添加交互需要 大量思考 和 少量的代码。我们将看到原因。     </p>
<p>要构建你 app 的一个静态版本，用于渲染数据模型， 您将需要构建复用其他组件并使用 props 传递数据的组件。props 是将数据从 父级组件 传递到 子级 的一种方式。如果你熟悉 state 的概念，在构建静态版本时 不要使用 state 。state 只用于交互，也就是说，数据可以随时被改变。由于这是一个静态版本 app，所以你并不需要使用 state 。 </p>
<p>您可以 自上而下 或 自下而上 构建。也就是说，您可以从构建层次结构中顶端的组件开始（即从 FilterableProductTable 开始），也可以从构建层次结构中底层的组件开始（即 ProductRow ）。<br>在更简单的例子中，通常 自上而下 更容易，而在较大的项目中，自下而上，更有利于编写测试。    </p>
<p>### 小插曲: Props(属性) vs State(状态) </p>
<h2 id="步骤3：-确定-UI-state-状态-的最小（但完整）表示"><a href="#步骤3：-确定-UI-state-状态-的最小（但完整）表示" class="headerlink" title="步骤3： 确定 UI state(状态) 的最小（但完整）表示"></a>步骤3： 确定 UI state(状态) 的最小（但完整）表示</h2><p>这里的关键是：DRY: 不要重复你自己 。    </p>
<h2 id="步骤4：确定-state-状态-的位置"><a href="#步骤4：确定-state-状态-的位置" class="headerlink" title="步骤4：确定 state(状态) 的位置"></a>步骤4：确定 state(状态) 的位置</h2><p>记住：React 单向数据流在层级中自上而下进行。这样有可能不能立即判断出状态属于哪个组件。这常常是新手最难理解的一部分，试着按下面的步骤分析操作    </p>
<h2 id="步骤5：添加反向数据流"><a href="#步骤5：添加反向数据流" class="headerlink" title="步骤5：添加反向数据流"></a>步骤5：添加反向数据流</h2><p>目前，构建的应用已经具备了正确渲染 props(属性) 和 state(状态) 沿着层次结构向下传播的功能。现在是时候实现另一种数据流方式：层次结构中深层的 form(表单) 组件需要更新 FilterableProductTable 中的 state(状态) 。   </p>
<p>React 中明确的数据流向，使你容易理解程序如何运行。但是相比传统的数据双向绑定来说，的确需要多敲一些代码。    </p>
<h2 id="就这么简单"><a href="#就这么简单" class="headerlink" title="就这么简单"></a>就这么简单</h2><p style="text-align:right">2018.9.14 星期六 00:35</p>


]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactjs文档</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><a href="http://react.css88.com/docs/thinking-in-react.html" target="_blank" rel="noopener">http://react.css88.com/docs/thinking-in-react.html</a>  </p>
<!-- https://reactjs.org/tutorial/tutorial.html   -->
<!-- https://reactjs.org/docs/getting-started.html    -->
<!-- 优：http://react.css88.com/docs/getting-started.html     -->
<!-- 次：https://reactjs.org.cn/doc/hello-world.html     -->
<!--弃： http://react.yubolun.com/   -->
<!-- 网站选择说明
刚开始看的是站点是 reactjs.org.cn (resource.md中记录)   
晚上找到 css88和yubolun 两个站点，和官网(英文)类似   
css88 翻译更好一些，出错也少一些，还有渔人码头 批注    
yubolun侧边目录有的对不齐，说明不是严格翻译，虽然有一些翻译的比较“生动”     

org.cn文档中侧边栏目录 和官网不齐，第一大章中，还多了一个 安装 的章节      
测边栏目录也没有数字列表    
好像网站还不稳定，打开速度慢    
优点：内容/排版看着舒服，侧边栏是在左边的   
之前也是看的这个网站的教程，还有零基础、react-native    
 -->
<p>用于构建用户界面的 JavaScript 库<br>声明式,组件化,学习一次，到处使用    </p>
<p>一个简单的组件<br>一个有 state(状态) 的组件<br>一个应用:TODO<br>在组件中使用第三方库:remarkable( Markdown 库)     </p>
<p style="text-align:right">2018.9.14 星期五 16:32</p>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>入门<br>将 React 添加到网站<br>创建一个新的 React APP<br>CDN 链接    </p>
<h1 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h1><p>1 Hello World<br>2 JSX 简介<br>3 元素渲染<br>4 组件 &amp; Props<br>5 State &amp; 生命周期<br>6 事件处理<br>7 条件渲染<br>8 列表 &amp; Keys<br>9 表单<br>10 状态提升<br>11 组合 vs 继承<br>12 React 理念   </p>
<p style="text-align:right">17:28</p><br><p style="text-align:right">2018.9.21 星期五 10:21</p>

<h1 id="高级指南"><a href="#高级指南" class="headerlink" title="高级指南"></a>高级指南</h1><p>$PS: 网站是按英文字母顺序排序了，重新整理/归类了一下<br>$PS:2-深入react     </p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 8 与第三方库协作</li>
<li><p>[x] 2 代码拆分(Code-Splitting)</p>
</li>
<li><p>[x] 14 一致性比较（Reconciliation）</p>
</li>
<li><p>[x] 12 React 中不使用 ES6</p>
</li>
<li style="list-style: none"><input type="checkbox" checked> 13 React 中不使用 JSX</li>
<li style="list-style: none"><input type="checkbox" checked> 9 深入 JSX</li>
<li style="list-style: none"><input type="checkbox" checked> 10 优化性能</li>
</ul>
<p>$PS:2-类型检查和refs    </p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 17 静态类型检查</li>
<li style="list-style: none"><input type="checkbox" checked> 19 使用 PropTypes 进行类型检查</li>
<li style="list-style: none"><input type="checkbox" checked> 18 严格模式(Strict Mode)</li>
</ul>
<p>$PS:2-其它概念  </p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> <del>1 Accessibility</del></li>
<li style="list-style: none"><input type="checkbox" checked> 3 上下文(Context)</li>
<li style="list-style: none"><input type="checkbox" checked> 15 Refs 和 DOM</li>
<li style="list-style: none"><input type="checkbox" checked> 5 转发 Refs</li>
<li><p>[x] 16 渲染属性(Render Props)</p>
</li>
<li><p>[x] 6 片段(Fragments)</p>
</li>
<li style="list-style: none"><input type="checkbox" checked> 11 插槽(Portals)</li>
<li style="list-style: none"><input type="checkbox" checked> 4 错误边界(Error Boundaries)</li>
<li style="list-style: none"><input type="checkbox" checked> 20 不受控组件</li>
<li style="list-style: none"><input type="checkbox" checked> 7 高阶组件(Higher-Order Components)</li>
<li style="list-style: none"><input type="checkbox" checked> <del>21 Web 组件(Web Components)</del></li>
</ul>
<p style="text-align:right">12:18</p>


<!-- https://reactjs.org.cn/doc/jsx-in-depth.html
1 深入 JSX  
2 使用 PropTypes 检查类型   
3 Refs & DOM    
4 非受控组件    
5 性能优化  
6 不使用 ES6    
7 不使用 JSX    
8 Reconciliation    
9 Context   
10 Portals  
11 Web Components   
12 高阶组件 
13 与第三方库协同   
14 可访问性 
 -->
<h1 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h1><p>React<br>    React.Component<br>ReactDOM<br>ReactDOMServer<br>DOM Elements<br>SyntheticEvent<br>Test Utilities<br>Shallow Renderer<br>Test Renderer<br>JS Environment Requirements</p>
<h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><p>如何参与<br>源码总览<br>实现说明<br>设计理念        </p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p>AJAX 及 APIs<br>Babel, JSX, 及构建过程<br>在组件中使用事件处理函数<br>组件状态<br>样式及 CSS<br>项目文件结构<br>虚拟 DOM 及内核 </p>
<p style="text-align:right">2018.9.23 星期日 19:10</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档0_安装</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A30_%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 16:32</p>

<!-- # 安装 -->
<h2 id="体验React"><a href="#体验React" class="headerlink" title="体验React"></a>体验React</h2><p>Hello World 示例代码   </p>
<h2 id="创建新APP"><a href="#创建新APP" class="headerlink" title="创建新APP"></a>创建新APP</h2><p>构建一个新的 React 单页应用，Create React App 是您的最佳选择。<br>它可以帮助您配置开发环境，以便您可以使用最新的 JavaScript 特性，还能提供一个友好的开发体验，并为生产环境优化您的应用。<br>请注意：您开发机上的Node版本需要至少为6。   </p>
<p>Create React App 并不包含处理后端逻辑以及数据库。它只是一个前端的构建管道，所以您可以和任何后端技术搭配使用。它使用了 Babel 和 Webpack 这样的构建工具，但是在工作的时候，是零配置项的。     </p>
<h2 id="添加React技术到现有APP"><a href="#添加React技术到现有APP" class="headerlink" title="添加React技术到现有APP"></a>添加React技术到现有APP</h2><p>虽然 React 可以在没有构建管道的情况下使用 ，但是为了更高效的使用它，我们还是建议您使用：现代化的构建管道。这通常包括有:     </p>
<ul>
<li>包管理器，比如 Yarn 或 npm。它可以让您使用庞大的第三方软件包生态系统，还能很方便的对依赖包进行安装或升级。</li>
<li>构建工具，比如 webpack 或 Browserify。它允许您编写模块化代码，并把他们打包成为更小的文件文件，以优化加载时间。</li>
<li>编译工具 比如 Babel。利用它，您可以编写包含新特性的代码，同时稳定运行在旧版本浏览器上。<br>### 安装 React<br>### 开启 ES6 和 JSX<br>### 在 Hello World 中使用 ES6 和 JSX<br>### 开发版本和生产版本<br>### 使用 CDN</li>
</ul>
<p style="text-align:right">17:28</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-3_元素渲染</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-3_%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 16:32</p>

<h2 id="将元素渲染到-DOM-中"><a href="#将元素渲染到-DOM-中" class="headerlink" title="将元素渲染到 DOM 中"></a>将元素渲染到 DOM 中</h2><p>元素是构成 React 应用的最小单位。<br>元素用来描述你在屏幕上看到的内容：  </p>
<p>与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。    </p>
<p>我们用React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="更新元素渲染"><a href="#更新元素渲染" class="headerlink" title="更新元素渲染"></a>更新元素渲染</h2><p>React 元素都是immutable 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。    </p>
<h2 id="React-只会更新必要的部分"><a href="#React-只会更新必要的部分" class="headerlink" title="React 只会更新必要的部分"></a>React 只会更新必要的部分</h2><p>根据我们以往的经验，将界面视为一个个特定时刻的固定内容（就像一帧一帧的动画），而不是随时处于变化之中（而不是处于变化中的一整段动画）将会有利于我们理清开发思路，减少各种bugs.</p>
<p style="text-align:right">17:28</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-4_组件 &amp; Props</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-4_%E7%BB%84%E4%BB%B6%20&amp;%20Props/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 16:32</p>

<p>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。   </p>
<h2 id="函数定义-类定义组件"><a href="#函数定义-类定义组件" class="headerlink" title="函数定义/类定义组件"></a>函数定义/类定义组件</h2><p>该函数是一个有效的React组件，它接收一个单一的“props”对象并返回了一个React元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个JavaScript函数。<br>$_PS: 注意区别 React元素和Dom元素/标签<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// React元素都只是DOM标签：</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line"><span class="comment">// React元素也可以是用户自定义的组件</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件,这个对象称之为“props”。  </p>
<blockquote>
<p>组件名称必须以大写字母开头。<br>例如，<code>&lt;div /&gt;</code>表示一个DOM标签，但<code>&lt;Welcome /&gt;</code>表示一个组件并限定了它的可用范围。</p>
</blockquote>
<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><blockquote>
<p>组件的返回值只能有一个根元素。这也是我们要用一个<code>&lt;div&gt;</code>来包裹所有<code>&lt;Welcome /&gt;</code>元素的原因  </p>
</blockquote>
<h2 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h2><p>我们建议从组件自身的角度来命名props，而不是根据使用组件的上下文命名。</p>
<h2 id="Props的只读性"><a href="#Props的只读性" class="headerlink" title="Props的只读性"></a>Props的只读性</h2><p>无论是使用函数或是类来声明一个组件，它决不能修改它自己的props<br>所有的React组件必须像纯函数那样使用它们的props。    </p>
<p style="text-align:right">17:28</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-5_State &amp; 生命周期</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-5_State%20&amp;%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 16:32</p>


<p>到目前为止我们只学习了一种方法来更新UI:调用 <code>ReactDOM.render()</code>     </p>
<p>然而，它错过了一个关键的要求：Clock设置一个定时器并且每秒更新UI应该是Clock的实现细节。<br>理想情况下，我们写一次 Clock 然后它能更新自身：</p>
<h2 id="将函数转换为类"><a href="#将函数转换为类" class="headerlink" title="将函数转换为类"></a>将函数转换为类</h2><h2 id="为一个类添加局部状态"><a href="#为一个类添加局部状态" class="headerlink" title="为一个类添加局部状态"></a>为一个类添加局部状态</h2><h2 id="将生命周期方法添加到类中"><a href="#将生命周期方法添加到类中" class="headerlink" title="将生命周期方法添加到类中"></a>将生命周期方法添加到类中</h2><p>每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器，这在React中被称为<strong>挂载</strong><br>同样，每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器，这在React中被称为<strong>卸载</strong>。   </p>
<p>这些方法被称作生命周期钩子。    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">            () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">            <span class="number">1000</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">    &#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    this.timerID = setInterval(</span></span><br><span class="line"><span class="regexp">      () =&gt; this.tick(),</span></span><br><span class="line"><span class="regexp">      1000</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意我们如何在 this 中保存定时器ID。<br>虽然 this.props 由React本身设置以及this.state 具有特殊的含义，但如果需要存储不用于视觉输出的东西，则可以手动向类中添加其他字段。    </p>
<p>如果你不在 render() 中使用某些东西，它就不应该在状态中。<br>我们将在 componentWillUnmount（）生命周期钩子中卸载计时器   </p>
<p style="text-align:right">17:28</p>

<h2 id="正确地使用状态"><a href="#正确地使用状态" class="headerlink" title="正确地使用状态"></a>正确地使用状态</h2><p>### 不要直接更新状态   </p>
<p>### 状态更新可能是异步的   </p>
<p>### 状态更新合并   </p>
<h2 id="数据自顶向下流动"><a href="#数据自顶向下流动" class="headerlink" title="数据自顶向下流动"></a>数据自顶向下流动</h2><p>父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。<br>这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。     </p>
<p>组件可以选择将其状态作为属性传递给其子组件：  </p>
<p>这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。     </p>
<p>在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。      </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-7_条件渲染</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-7_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 22:32</p>

<p>在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后还可以根据应用的状态变化只渲染其中的一部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="元素变量"><a href="#元素变量" class="headerlink" title="元素变量"></a>元素变量</h2><p>你可以使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。  </p>
<p>在下面的例子中，我们将要创建一个名为 LoginControl 的有状态的组件。<br>它会根据当前的状态来渲染 <code>&lt;LoginButton /&gt;</code> 或 <code>&lt;LogoutButton&gt;</code>，它也将渲染前面例子中的 <code>&lt;Greeting /&gt;</code>。  </p>
<p>声明变量并使用 if 语句是条件渲染组件的不错的方式，但有时你也想使用更简洁的语法，在 JSX 中有如下几种方法。   </p>
<h2 id="与运算符-amp-amp"><a href="#与运算符-amp-amp" class="headerlink" title="与运算符 &amp;&amp;"></a>与运算符 &amp;&amp;</h2><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><h2 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h2><p>在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。  </p>
<p>在下面的例子中，<warningbanner> 根据属性 warn 的值条件渲染。如果 warn 的值是 false，则组件不会渲染：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></warningbanner></p>
<p>组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。</p>
<p style="text-align:right">22:39</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-6_事件处理</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-6_%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 22:39</p>

<p>React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同:     </p>
<ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。</li>
<li>如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)</li>
</ul>
<p>在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>e 是一个合成事件。React 根据 W3C spec 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题      </p>
<p>使用 React 的时候通常你不需要使用 addEventListener 为一个已创建的 DOM 元素添加监听器。你仅仅需要在这个元素初始渲染的时候提供一个监听器。<br>当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如，下面的 Toggle 组件渲染一个让用户切换开关状态的按钮：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $1 This binding is necessary to make `this` work in the callback</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $2 :使用实验性的属性初始化器语法</span></span><br><span class="line">  <span class="comment">// This syntax ensures `this` is bound within handleClick.</span></span><br><span class="line">  <span class="comment">// Warning: this is *experimental* syntax.</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $3: 回调函数中使用 箭头函数 </span></span><br><span class="line">  <span class="comment">// $3 This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。<br>$_PS: 注意这里是 回调函数 中,参见最后的$PS 。<br>这并不是 React 的特殊行为；它是<a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">函数如何在 JavaScript 中运行</a>的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this.  </p>
<p>如果使用 bind 让你很困惑，这里有两种方式可以解决。<br>$2: 如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：    </p>
<p>$3: 如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：<br>使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。   </p>
<h2 id="将参数传递给事件处理程序"><a href="#将参数传递给事件处理程序" class="headerlink" title="将参数传递给事件处理程序"></a>将参数传递给事件处理程序</h2><p>$_PS: org.cn 是没有该段落的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分别使用 arrow functions 和 Function.prototype.bind 。</span></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。<br>通过箭头函数的方式，事件对象必须显式的进行传递，<br>但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。  </p>
<h2 id="PS-函数如何在-JavaScript-中运行"><a href="#PS-函数如何在-JavaScript-中运行" class="headerlink" title="$_PS: 函数如何在 JavaScript 中运行"></a>$_PS: 函数如何在 JavaScript 中运行</h2><!-- What Problem Are We Actually Looking To Solve? -->
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    specialFunction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    anotherSpecialFunction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getAsyncData: <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.getAsyncData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            that.specialFunction();</span><br><span class="line">            that.anotherSpecialFunction();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObj.render();</span><br><span class="line"><span class="comment">// Uncaught TypeError: Object [object global] has no method 'specialFunction'</span></span><br><span class="line"><span class="comment">// rewrite  </span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getAsyncData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specialFunction();</span><br><span class="line">        <span class="keyword">this</span>.anotherSpecialFunction();</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-align:right">2018.9.14 星期五 23:11</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-8_列表 &amp; Keys</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-8_%E5%88%97%E8%A1%A8%20&amp;%20Keys/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.14 星期五 23:32</p>

<h2 id="多组件渲染"><a href="#多组件渲染" class="headerlink" title="多组件渲染"></a>多组件渲染</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="基本列表组件"><a href="#基本列表组件" class="headerlink" title="基本列表组件"></a>基本列表组件</h2><p>我们可以重构前面的例子到一个组件，它接受一个 numbers 数组，并输出一个元素的无序列表<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="键-Keys"><a href="#键-Keys" class="headerlink" title="键(Keys)"></a>键(Keys)</h2><p>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识：  </p>
<p>如果列表项的顺序可能改变，我们不建议使用索引作为 keys。这可能会对性能产生负面影响，并可能导致组件状态问题。  </p>
<p>$_TODO: 查阅 Robin Pokorny 的文章深入解释使用索引作为 键(key) 的负面影响 。 如果您选择不将明确的 键(key) 分配给列表项，那么 React 将默认使用索引作为键(key)。<br>$_TODO: 如果您有兴趣了解更多信息，请参阅 关于为什么必须输入 键(key) 的深入解释。    </p>
<h2 id="使用-keys-提取组件"><a href="#使用-keys-提取组件" class="headerlink" title="使用 keys 提取组件"></a>使用 keys 提取组件</h2><p>keys 只在数组的上下文中存在意义。</p>
<p>例如，如果你提取 一个 ListItem 组件，应该把 key 放置在数组处理的 <listitem> 元素中，不能放在 ListItem 组件自身中的 <code>&lt;li&gt;</code> 根元素上。</listitem></p>
<h2 id="keys-在同辈元素中必须是唯一的"><a href="#keys-在同辈元素中必须是唯一的" class="headerlink" title="keys 在同辈元素中必须是唯一的"></a>keys 在同辈元素中必须是唯一的</h2><p>在数组中使用的 keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一。我们可以在操作两个不同数组的时候使用相同的 keys ：  </p>
<h2 id="在-JSX-中嵌入-map"><a href="#在-JSX-中嵌入-map" class="headerlink" title="在 JSX 中嵌入 map()"></a>在 JSX 中嵌入 map()</h2><p>在上面的例子中，我们单独声明了一个 listItems 变量，并在 JSX 中引用了该变量：<br>JSX允许在大括号中嵌入任何表达式，因此可以 内联 map() 结果：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ JSX允许在大括号中嵌入任何表达式，因此可以 内联 map() 结果：</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &#123;numbers.map((number) =&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ListItem key=&#123;number.toString()&#125;</span></span><br><span class="line"><span class="regexp">                  value=&#123;number&#125; /</span>&gt;</span><br><span class="line"></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>有时这可以产生清晰的代码，但是这个风格也可能被滥用。<br>就像在 JavaScript 中，是否有必要提取一个变量以提高程序的可读性，这取决于你。但是记住，如果 map() 体中有太多嵌套，可能是提取组件的好时机。       </p>
<p style="text-align:right">23:51</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React文档1-Concepts</title>
    <url>/w3/jslib/react%E6%96%87%E6%A1%A3/react%E6%96%87%E6%A1%A31-concepts/</url>
    <content><![CDATA[<p><a href="http://react.css88.com/docs/thinking-in-react.html" target="_blank" rel="noopener">http://react.css88.com/docs/thinking-in-react.html</a>  </p>
<p style="text-align:right">2018.9.14 星期五 23:32</p>


<h1 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1 Hello World"></a>1 Hello World</h1><!-- # 2 安装 -->
<!-- $_PS: 官网/该网站中没有这节内容   -->
<!-- 官网/该网站中是在 主要概念 前面的位置 -->
<h1 id="2-JSX-简介"><a href="#2-JSX-简介" class="headerlink" title="2 JSX 简介"></a>2 JSX 简介</h1><h1 id="3-元素渲染"><a href="#3-元素渲染" class="headerlink" title="3 元素渲染"></a>3 元素渲染</h1><h1 id="4-组件-amp-Props"><a href="#4-组件-amp-Props" class="headerlink" title="4 组件 &amp; Props"></a>4 组件 &amp; Props</h1><h1 id="5-State-amp-生命周期"><a href="#5-State-amp-生命周期" class="headerlink" title="5 State &amp; 生命周期"></a>5 State &amp; 生命周期</h1><h1 id="6-事件处理"><a href="#6-事件处理" class="headerlink" title="6 事件处理"></a>6 事件处理</h1><h1 id="7-条件渲染"><a href="#7-条件渲染" class="headerlink" title="7 条件渲染"></a>7 条件渲染</h1><h1 id="8-列表-amp-Keys"><a href="#8-列表-amp-Keys" class="headerlink" title="8 列表 &amp; Keys"></a>8 列表 &amp; Keys</h1><p style="text-align:right">2018.9.14 星期六 00:45</p>

<h1 id="9-表单"><a href="#9-表单" class="headerlink" title="9 表单"></a>9 表单</h1><p>HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。  </p>
<h2 id="受控组件-Controlled-Components"><a href="#受控组件-Controlled-Components" class="headerlink" title="受控组件(Controlled Components)"></a>受控组件(Controlled Components)</h2><p>在 HTML 中，表单元素如 <code>&lt;input&gt;，&lt;textarea&gt; 和 &lt;select&gt;</code>表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过 setState() 更新。</p>
<p>我们可以通过使 React 的 state 成为 “单一数据源原则” 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。</p>
<h2 id="textare-标签"><a href="#textare-标签" class="headerlink" title="textare 标签"></a>textare 标签</h2><h2 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h2><p>注意，Coconut 选项是初始化选中的，因为它的 selected 属性。React 中，并不使用这个 selected 属性，而是在根 select 标签中使用了一个 value 属性。这使得受控组件使用更方便，因为你只需要更新一处即可。<br>您可以将一个数组传递给 value 属性，允许你在 select 标签中选择多个选项：   </p>
<h2 id="file-input-标签"><a href="#file-input-标签" class="headerlink" title="file input 标签"></a>file input 标签</h2><p>因为它的值是只读的，所以它是 Reac t中的 不受控 组件。 它与其他不受控制的组件一样，将在 稍后的文档中 一起讨论。  </p>
<h2 id="处理多个输入元素"><a href="#处理多个输入元素" class="headerlink" title="处理多个输入元素"></a>处理多个输入元素</h2><p>当您需要处理多个受控的 input 元素时，您可以为每个元素添加一个 name 属性，并且让处理函数根据 event.target.name 的值来选择要做什么。  </p>
<p>注意我们如何使用ES6 计算的属性名称语法来更新与给定输入名称相对应的 state(状态) 键：  </p>
<h2 id="受控-Input-组件的-null-值"><a href="#受控-Input-组件的-null-值" class="headerlink" title="受控 Input 组件的 null 值"></a>受控 Input 组件的 null 值</h2><p>在 受控组件 上指定值 prop 可防止用户更改输入，除非您希望如此。<br>如果你已经指定了一个 value ，但是输入仍然是可编辑的，你可能会意外地把 value 设置为undefined 或 null 。   </p>
<p>以下代码演示了这一点。 （输入首先被锁定，但在短暂的延迟后可以编辑。）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"hi"</span> /&gt;</span></span>, mountNode);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="受控组件的替代方案"><a href="#受控组件的替代方案" class="headerlink" title="受控组件的替代方案"></a>受控组件的替代方案</h2><p>有时使用受控组件有些乏味，因为你需要为每一个可更改的数据提供事件处理器，并通过 React 组件管理所有输入状态。<br>当你将已经存在的代码转换为 React 时，或将 React 应用程序与非 React 库集成时，这可能变得特别烦人。<br>在这些情况下，您可能需要使用不受控的组件，用于实现输入表单的替代技术。</p>
<h1 id="10-状态提升"><a href="#10-状态提升" class="headerlink" title="10 状态提升"></a>10 状态提升</h1><p>通常情况下，同一个数据的变化需要几个不同的组件来反映。我们建议提升共享的状态到它们最近的祖先组件中。我们看下这是如何运作的。    </p>
<p>我们知道 props(属性) 是只读的。 当 temperature 是 本地 state(状态)时， TemperatureInput 可以调用 this.setState() 来更改它。 然而，现在 temperature 来自父级作为 prop(属性) ，TemperatureInput 就无法控制它。    </p>
<h2 id="状态提升-Lifting-State-Up"><a href="#状态提升-Lifting-State-Up" class="headerlink" title="状态提升(Lifting State Up)"></a>状态提升(Lifting State Up)</h2><p>在 React 中，通常通过使组件“受控”的方式来解决。就像 DOM <code>&lt;input&gt;</code>一样接受一个 value 和一个 onChange prop(属性) ，所以可以定制 TemperatureInput 接受来自其父级 Calculator 的 temperature 和 onTemperatureChange 。   </p>
<p>##经验总结<br>在一个 React 应用中，对于任何可变的数据都应该循序“<strong>单一数据源</strong>”原则。通常情况下，state 首先被添加到需要它进行渲染的组件。然后，如果其它的组件也需要它，你可以提升状态到它们最近的祖先组件。你应该依赖 从上到下的数据流向 ，而不是试图在不同的组件中同步状态。         </p>
<p>### $_和双向数据绑定的对比<br>提升状态相对于双向绑定方法需要写更多的“模板”代码，<br>但是有一个好处，它可以更方便的找到和隔离 bugs。由于任何 state(状态) 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少 。<br>另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。</p>
<p>如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它可能不应该在 state(状态) 中比较常见。   </p>
<h1 id="11-组合-vs-继承"><a href="#11-组合-vs-继承" class="headerlink" title="11 组合 vs 继承"></a>11 组合 vs 继承</h1><h1 id="12-React-的编程思想"><a href="#12-React-的编程思想" class="headerlink" title="12 React 的编程思想"></a>12 React 的编程思想</h1><p style="text-align:right">01:07</p>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>react文档</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Web优化</title>
    <url>/sum/jsplus/web%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.11 星期四 14:25 </p>

<h1 id="编写高质量的代码"><a href="#编写高质量的代码" class="headerlink" title="编写高质量的代码"></a>编写高质量的代码</h1><p><a href="/pdf/opti/编写高质量代码--Web前端开发修炼之道/">编写高质量代码.pdf</a><br><a href="/pdf/opti/代码整洁之道/">代码整洁之道.pdf</a>   </p>
<p>## html    </p>
<p>## css<br>选择器选择/性能     </p>
<p>## JavaScript</p>
<h2 id="优雅注释"><a href="#优雅注释" class="headerlink" title="优雅注释"></a>优雅注释</h2><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="/pdf/opti/高性能网站建设指南/">高性能网站建设指南.pdf</a>        </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p># [021-D 如何提升页面渲染效率]:<br>Web页面背后的工作原理都是一样的：<br>用户输入网址<br>浏览器加载HTML/CSS/JS，图片资源等<br>浏览器将结果绘制成图形<br>用户通过鼠标，键盘等与页面交互  </p>
<p>宽带网速, DNS服务器的响应速度, 服务器的处理能力, 数据库性能, 路由转发, 浏览器处理能力<br><!-- $end --></p>
<p># [010-D 六个好方法缩短你的网页加载时间]:<br>图片优化, 尝试CDN加速.缓存, 压缩, 简洁的代码, 检查你的Web主机   </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><!-- \# [008-D 前端优化带来的思考，浅谈前端工程化] -->
<p>传输层面：减少请求数，降低请求量<br>执行层面：减少重绘&amp;回流     </p>
<p>## 减少请求数<br>① 合并样式、脚本文件<br>② 合并背景图片<br>③ CSS3图标、Icon Font   </p>
<p>## 降低请求量<br>① 开启GZip<br>② 优化静态资源，jQuery-&gt;Zepto、阉割IScroll、去除冗余代码<br>③ 图片无损压缩<br>④ 图片延迟加载<br>⑤ 减少Cookie携带    </p>
<p>## 很多时候，我们也会采用类似“时间换空间、空间换时间”的做法，比如：<br>① 缓存为王，对更新较缓慢的资源&amp;接口做缓存（浏览器缓存、localsorage、application cache这个坑多）<br>② 按需加载，先加载主要资源，其余资源延迟加载，对非首屏资源滚动加载<br>③ fake页技术，将页面最初需要显示Html&amp;Css内联，在页面所需资源加载结束前至少可看，理想情况是index.html下载结束即展示（2G 5S内）<br>④ CDN   </p>
<h2 id="资源缓存"><a href="#资源缓存" class="headerlink" title="资源缓存"></a>资源缓存</h2><p>资源缓存是为二次请求加速，比较常用的缓存技术有：<br>① 浏览器缓存<br>② localstorage缓存<br>③ application缓存<br>Hybrid载入<br>服务器资源合并<br>$_PS: 离线缓存  </p>
<p>### 浏览器缓存<br>只要服务器配置，浏览器本身便具有缓存机制，如果要使用浏览器机制作缓存，势必关心一个何时更新资源问题：<br>时间戳更新 ，MD5时代 ，seed.js时代  </p>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>① 页面滚动<br>② javascript交互<br>③ 动画<br>④ 内容变化<br>⑤ 属性计算（求元素的高宽）  </p>
<!-- $end -->
<p># [026-D 前端性能优化——桌面浏览器前端优化策略]:  </p>
<h2 id="一、-网络加载类"><a href="#一、-网络加载类" class="headerlink" title="一、 网络加载类"></a>一、 网络加载类</h2><p>1．减少HTTP资源请求次数<br>尽可能合并静态资源图片、JavaScript或CSS代码<br>2．减小HTTP请求大小<br>压缩优化，移除注释/无用代码<br>3．将CSS或JavaScript放到外部文件中，避免使用<code>&lt;style&gt;或&lt;script&gt;</code>标签直接引入<br>在HTML文件中引用外部资源可以有效利用浏览器的静态资源缓存，但有时候在移动端页面CSS或JavaScript比较简单的情况下为了减少请求，也会将CSS或JavaScript直接写到HTML里面<br>14．缩小favicon.ico并缓存<br>15．推荐使用异步JavaScript资源<br>16．消除阻塞渲染的CSS及JavaScript<br>17．避免使用CSS import引用加载CSS   </p>
<p>4．避免页面中空的href和src<br>仍会将href属性或src属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程       </p>
<p>5．为HTML指定Cache-Control或Expires<br>避免频繁向服务器端发送请求<br>6．合理设置Etag和Last-Modified<br>对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载。<br>7． 减少页面重定向<br>一次重定向大约需要600毫秒的时间开销     </p>
<p>13．减少Cookie的大小并进行Cookie隔离<br>对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离  </p>
<p>11．使用可缓存的AJAX<br>12．使用GET来完成AJAX请求<br>使用XMLHttpRequest时，浏览器中的POST方法发送请求首先发送文件头，然后发送HTTP正文数据。而使用GET时只发送头部，所以在拉取服务端数据时使用GET请求效率更高。    </p>
<p>8．使用静态资源分域存放来增加下载并行数<br>利用CDN网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间。<br>9．使用静态资源CDN来存储文件<br>浏览器在同一时刻向同一个域名请求文件的并行下载数是有限的，因此可以<br>10．使用CDN Combo下载传输内容<br>在CDN服务器端将多个文件请求打包成一个文件的形式来返回的技术     </p>
<h2 id="二、-页面渲染类"><a href="#二、-页面渲染类" class="headerlink" title="二、 页面渲染类"></a>二、 页面渲染类</h2><p>3．不要在HTML中直接缩放图片<br>会导致页面内容的重排重绘，此时可能会使页面中的其他操作产生卡顿  </p>
<p>5. 尽量避免使用<code>&lt;table&gt;、&lt;iframe&gt;</code>等慢元素<br>渲染树全部生成完并一次性绘制到页面上的<br>尽量使用异步的方式动态添加iframe，因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS及HTML DOM的解析。<br>7．避免使用CSS表达式或CSS滤镜<br>解析渲染速度是比较慢的  </p>
<p>1. 把CSS资源引用放到HTML文件顶部<br>浏览器可以优先下载CSS并尽早完成页面渲染<br>2．JavaScript资源引用放到HTML文件底部<br>可以防止JavaScript的加载和解析执行对页面渲染造成阻塞。由于JavaScript资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞HTML DOM解析和CSS渲染的过程。<br>4．减少DOM元素数量和深度<br>浏览器解析DOM并绘制到浏览器中所花的时间就越长<br>6．避免运行耗时的JavaScript<br>会阻塞浏览器构建DOM树、DOM渲染树、渲染页面<br><!-- $end --></p>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>### 资源预加载<br>### 资源懒加载<br>### 按需加载<br>### 缓存   </p>
<p>## CSS 方面<br>### CSS Sprite<br>### 图片格式选择/加载<br>### GPU加速<br>### 避免重排重绘    </p>
<p>## JS方面   </p>
<p>### DOM操作    </p>
<p style="text-align:right">15:08 </p>

]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>opti</tag>
      </tags>
  </entry>
  <entry>
    <title>Css不同布局方式</title>
    <url>/sum/css/css%E4%B8%8D%E5%90%8C%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F(012)/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.11 星期二 10:43 </p>

<p>前端布局方案主要有三种：传统布局方案（借助浮动、定位等手段）,flex布局,grid布局<br>主要比较传统布局中自适应，响应式，流式   </p>
<h2 id="自适应和响应式历史"><a href="#自适应和响应式历史" class="headerlink" title="自适应和响应式历史"></a>自适应和响应式历史</h2><p># <a href="https://juejin.im/entry/58b6414a128fe1006421bfa7" target="_blank" rel="noopener">响应式和自适应的区别</a><br>2017-03-01      </p>
<h3 id="缘起"><a href="#缘起" class="headerlink" title="$_缘起"></a>$_缘起</h3><p>#### $1<br>起初，网页设计者都会设计固定宽度的页面，最开始的电脑显示器分辨率种类不多<br>#### $2<br>后来随着显示器越来越多，以及笔记本的普及，这种方式的页面出现了问题。于是出现了一种新的布局方式宽度自适应布局。我们平时谈论的自适应布局，大多指的就是宽度自适应布局。<br>在这种布局下，出现了两派：<br>百分比宽度布局:宽度使用百分比，文字使用 em，现在也很多开始使用rem了，也就是所谓的高清方案<br>流式布局:iGoogle 为代表（已经停止）<br>#### $3<br>一开始没有响应式布局这个词语，但是慢慢出现了一个词——渐进增强，新词的出现总是伴随的旧词一起出现。<br>同理，渐进增强出现后，另一个词「优雅降级」也随之出现了。    </p>
<p>qqmail 就是 css hack 的完美体现，你用任何一个浏览器，几乎可以看到同一个样子的邮箱，腾讯的前端工程师们用各种 css hack 技术来展示邮箱页面，为的是统一的用户体验。<br>而 gmail 使用了渐进增强，你的浏览器越强，你看到的效果就越好，用户体验就越好。<br>#### $4<br>再后来，就是大家都熟知的 Google 发布了 android，于是互联网大战从 PC 打到了手机。还有 HTML5 标准的发布。   </p>
<p>最终的解决方案胜出者是响应式布局。  </p>
<p>响应式布局被大家熟知的一个重要原因就是 twitter 开源了 bootstrap。</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="$_响应式"></a>$_响应式</h3><p>自适应是为了解决如何才能在不同大小的设备上呈现同样的网页<br>很多网站的解决方法，是为不同的设备提供不同的网页，   </p>
<p>响应式的概念应该覆盖了自适应，而且涵盖的内容更多。      </p>
<p>自适应还是暴露出一个问题，如果屏幕太小，即使网页能够根据屏幕大小进行适配，但是会感觉在小屏幕上查看，内容过于拥挤，响应式正是为了解决这个问题而衍生出来的概念。它可以自动识别屏幕宽度、并做出相应调整的网页设计，布局和展示的内容可能会有所变动。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="$_实现方式"></a>$_实现方式</h3><p>1、允许网页宽度自动调整<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code><br>viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。    </p>
<p>所有主流浏览器都支持这个设置，包括IE9。对于那些老式浏览器（主要是IE6、7、8），需要使用css3-mediaqueries.js。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">　　<span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">　　　　&lt;script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">　　&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2、尽量少使用绝对宽度<br>3、相对大小的字体<br>4、流动布局（fluid grid）<br>“<a href="https://alistapart.com/article/fluidgrids" target="_blank" rel="noopener">流动布局</a>“的含义是，各个区块的位置都是浮动的，不是固定不变的。<br>$_PS: 理解是错误的，不是浮动，而是百分比<br>5、选择加载CSS<br>“自适应网页设计”的核心，就是CSS3引入的Media Query模块。<br>6、CSS的@media规则<br>同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。<br>7、图片/视频的自适应（fluid image）</p>
<p>不过，有条件的话，最好还是根据不同大小的屏幕，加载不同分辨率的图片。有很多方法可以做到这一条，服务器端和客户端都可以实现。<br><!-- #end --></p>
<p># <a href="https://www.cnblogs.com/zhuzhenwei918/p/7147303.html" target="_blank" rel="noopener">布局的几种方式（静态布局、自适应布局、流式布局、响应式布局、弹性布局）</a><br>参考：<a href="http://www.cnblogs.com/yanayana/p/7066948.html" target="_blank" rel="noopener">静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别</a>        </p>
<h2 id="一、静态布局（static-layout）"><a href="#一、静态布局（static-layout）" class="headerlink" title="一、静态布局（static layout）"></a>一、静态布局（static layout）</h2><p>即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。<br>1、布局特点<br>　　不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于pc端。<br>2、设计方法<br>PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；<br>移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如wap.或m.。        </p>
<p>优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。<br>缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。<br>但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。</p>
<h2 id="二、流式布局（Liquid-Layout）"><a href="#二、流式布局（Liquid-Layout）" class="headerlink" title="二、流式布局（Liquid Layout）"></a>二、流式布局（Liquid Layout）</h2><p>流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。     </p>
<p>网页中主要的划分区域的尺寸使用百分数（搭配min-<em>、max-</em>属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。    </p>
<p>1、 布局特点<br>屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。<br>2、 设计方法<br>使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。      </p>
<p>这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，<br>但缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调</p>
<h2 id="三、自适应布局（Adaptive-Layout）"><a href="#三、自适应布局（Adaptive-Layout）" class="headerlink" title="三、自适应布局（Adaptive Layout）"></a>三、自适应布局（Adaptive Layout）</h2><p>自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。      </p>
<p>1、布局特点<br>　　屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。<br>2、设计方法<br>　　使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。</p>
<h2 id="自见"><a href="#自见" class="headerlink" title="$_自见"></a>$_自见</h2><p>这里的自适应 是一种全新的概念 和上文 缘起 提到不一样。<br>上文缘起提到的自适应，应该是本文的 流式布局和弹性布局；但是上文也没有对流式做进一步解释   </p>
<blockquote>
<p>于是出现了一种新的布局方式宽度自适应布局。我们平时谈论的自适应布局，大多指的就是宽度自适应布局。<br>在这种布局下，出现了两派：百分比宽度布局,流式布局<br>百分比宽度布局:宽度使用百分比，文字使用 em，现在也很多开始使用rem了，也就是所谓的高清方案  </p>
</blockquote>
<p>$_PS: 现在的弹性布局不应该是flex吗。而不是下文的百分比？    </p>
<p>没有人做规范，都是圈内 自产。而且复制严重。<br>ruan <a href="http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html" target="_blank" rel="noopener">自适应网页设计（Responsive Web Design）</a>博文介绍的 应该是响应式。<br>$_PS: 该死的应该和可能    </p>
<p>随着技术手段的变化，可能最初的一些概念发生了变化/进化。比如自适应，流式，响应式；弹性    </p>
<p>现代的自适应应该是本文提到的概念，根据不同设备/分辨率 适应一份不同css样式(一个设备对应一份样式，多设备可能就是一套(多份)样式；而响应式始终是一份)，方法包括百分比，媒体查询，设备选择等；<br>而不是 前文提到的简单的宽度百分比。概念没有变，定义更加明确了，前文提到的百分比可能是受到当时技术水平限制而使用的 一种单一的手段/方式。现代概念把流式的百分比当作一种手段包含进来了。    </p>
<p>而响应式的中心思想是不变，一套css可以适用多种设备/分辨率，主要手段是媒体查询，其他包括百分比等。发展过程中可能会有把自适应和响应式混谈的时候，比如ruan    </p>
<p>流式布局的概念：元素的宽度按照屏幕进行适配调整，也就是宽度百分比。Fluid的不应该理解成float，float是width百分比布局的附属物：宽度定义后，块级元素需要浮动才可以按行内快显示，而不是单独占据一行。<br>所以流式布局和自适应是两个不同的概念。      </p>
<p>栅格系统：以规则的网格阵列来指导和规范版面排布以及信息分布。包含：container，rows，columns，gutters。有960gs 、不固定宽（bootstrap）等，有4、6、8、10、12，24，16列等，没有强调列的宽度是百分比，只需等分就可以了。自适应网页布局中container宽度100%，列的宽度当然百分比合适了；列与列挨靠，对于div可以选择：<a href="https://juejin.im/entry/58c3d8bdda2f6056096b2b40" title="跟着写一个 CSS 栅格布局" target="_blank" rel="noopener">Floats, inline-blocks, display-table, display-flex. 他们都可以实现栅格布局中，列的定位。我个人推荐使用“float”</a>      </p>
<p>Bootstrap的栅格系统定义：提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。<br>bootstrap列结合媒体查询定义为col-sm/md/lg-*, 所以可以说是响应式。其中“流式栅格系统”中流式应该是宽度百分比了。      </p>
<p>### 前端的应用(Css Grid)<br>早期HTML5规范没有定稿之前，大部分应用基于自己设计的百分比or固定宽式的方式来约定了一套class，开发者调用不同的class来完成栅格化布局。960GS/ bootstrap的栅格系统/等等都是这类思路来实现。</p>
<p>在16年，HTML5规范已经被各大浏览器实现，基本上flexbox已经落地到业务中，也出现了很多模块来提供栅格布局<a href="http://bulma.io/。" target="_blank" rel="noopener">http://bulma.io/。</a></p>
<!-- 参考：[栅格系统，以及为什么需要栅格系统](https://www.jianshu.com/p/cb0ecb763373)  -->
<h2 id="四、响应式布局（Responsive-Layout）"><a href="#四、响应式布局（Responsive-Layout）" class="headerlink" title="四、响应式布局（Responsive Layout）"></a>四、响应式布局（Responsive Layout）</h2><p>随着CSS3出现了媒体查询技术，又出现了响应式设计的概念。<br>响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。</p>
<p>响应式几乎已经成为优秀页面布局的标准。      </p>
<p>1、 布局特点<br>　　每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。<br>2、 设计方法<br>　　媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。  </p>
<p>优点：适应pc和移动端，如果足够耐心，效果完美。<br>缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。        </p>
<p>响应式页面在头部会加上这一段代码：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta name="applicable-device" content="pc,mobile"&gt;</span><br><span class="line">&lt;meta http-equiv="Cache-Control" content="no-transform "&gt;</span><br></pre></td></tr></table></figure></p>
<p>## 五、弹性布局（rem/em布局）<br>$_PS: 这不是我理解的弹性布局，应该是flex布局<br><!-- end --></p>
<p>前端布局方案主要有三种：传统布局方案（借助浮动、定位等手段）,flex布局,grid布局</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><h2 id="自适应布局和响应式布局区别"><a href="#自适应布局和响应式布局区别" class="headerlink" title="自适应布局和响应式布局区别"></a>自适应布局和响应式布局区别</h2><p># <a href="https://rawbin-.github.io/web开发/前端开发/2017/08/08/css-layout/" target="_blank" rel="noopener">页面布局 固定布局 流式布局 响应式布局 自适应布局</a><br>## 1 布局方式<br>1.1 静态/固定布局<br>站点使用固定的宽度（通常是像素宽度），改变浏览器的宽度或者用不同的设备上查看站点的展示效果一样，这会在小屏设备上引入横向滚动条，对移动设备体验不友好。<br>1.2 流式布局<br>站点使用百分比宽度（或者其他相对宽度，某些内容也可以固定宽度），页面相对于不同的浏览器或者不同设备的宽度，流式适应。<br>1.3 自适应布局<br>针对特定的设备尺寸进行断点划分，或者针对特定的设备有不同的设计，需要针对新设备进行设计。<br>1.4 响应式布局<br>在流式布局的基础上，针对不同宽度的设备进行不同的设计，不需要针对新设备进行设计。    </p>
<p>## 2 自适应布局和响应式布局区别    </p>
<table>
<thead>
<tr>
<th>—-</th>
<th>自适应</th>
<th>响应式</th>
</tr>
</thead>
<tbody>
<tr>
<td>设备识别</td>
<td>使用服务端或者客户端代码来检测设备</td>
<td>使用媒体查询来检测设备</td>
</tr>
<tr>
<td>实现方式</td>
<td>提供单独的HTML或页面，使用CSS根据屏幕大小来改变内容展现</td>
<td>使用弹性图片和流式网格来适配图片</td>
</tr>
<tr>
<td>内容优化</td>
<td>内容预先选择，只有针对设备的需要的内容才会被下载</td>
<td>不管什么设备都会下载所有内容，不管是否需要</td>
</tr>
<tr>
<td>设备优化</td>
<td>使用不同的模板，针对不同的设备进行优化</td>
<td>对所有设备使用同一个模板</td>
</tr>
<tr>
<td>特性</td>
<td>使用脚本来支撑不同的设备和屏幕尺寸，检测不同的设备类型来改变站点的展现行为</td>
<td>包含所有的移动端和桌面浏览器支持的特性</td>
</tr>
<tr>
<td>性能</td>
<td>只加载用户设备需要的资源，加载较快；图片针对特定的设备分辨率优化，减少文件尺寸和加载时间</td>
<td>加载针对所有设备的资源，加载较慢；加载全尺寸的图片通过压缩来适配用户设备</td>
</tr>
<tr>
<td>开发</td>
<td>对已经存在的站点来使用可适应的模板</td>
<td>整个站点重建</td>
</tr>
<tr>
<td>部署</td>
<td>门槛较高，开发者需要扎实的JavaScript;设计和实现曲线陡峭，用户体验需要根据不同的设备定制;不需要站点重建；需要扎实的JavaScript和CSS知识；不同的设备性能表现良好</td>
<td>对新站点更容易实现；需要站点重建；不同设备上性能表现较差</td>
</tr>
</tbody>
</table>
<!-- #end -->
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p># <a href="http://blog.sina.com.cn/s/blog_75afbf420102x3e0.html" target="_blank" rel="noopener">静态、自适应、流式、响应式四种网页布局有什么区别</a><br>(2016-12-21 11:29:52)<br>响应式与自适应的原理是相似的，都是检测设备，根据不同的设备采用不同的css，而且css都是采用的百分比的，而不是固定的宽度，<br>不同点是响应式的模板在不同的设备上看上去是不一样的，会随着设备的改变而改变展示样式，<br>而自适应不会，所有的设备看起来都是一套的模板，不过是长度或者图片变小了，不会根据设备采用不同的展示样式，<br>流式就是采用了一些设置，当宽度大于多少时怎么展示，小于多少时怎么展示，而且展示的方式向水流一样，一部分一部分的加载，<br>静态的就是采用固定宽度的了。  </p>
<p>静态布局（Static Layout）<br>即传统Web设计，对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；<br>对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。</p>
<p>自适应布局（Adaptive Layout）<br>自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。<br>你可以把自适应布局看作是静态布局的一个系列。    </p>
<p>流式布局（Liquid Layout）<br>流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。</p>
<p>响应式布局（Responsive Layout）<br>分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。<br>可以把响应式布局看作是流式布局和自适应布局设计理念的融合。<br>恩恩大概就是这样。</p>
<p>其他：<br><a href="http://techbrood.com/zh/news/html5/html%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%EF%BC%9A%E9%9D%99%E6%80%81%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E3%80%81%E6%B5%81%E5%BC%8F%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F.html" target="_blank" rel="noopener">HTML网页布局：静态、自适应、流式、响应式</a><br>效果展示：<a href="http://wow.techbrood.com/fiddle/1753" target="_blank" rel="noopener">HTML 主流布局区别差异动态</a>        </p>
<p style="text-align:right">14:32 </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuejs文档-深入响应式原理</title>
    <url>/w3/jslib/vuejs%E6%96%87%E6%A1%A3/vuejs%E6%96%87%E6%A1%A37-%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.11 星期二 16:20 </p>

<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><p>1. 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。<br>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。</p>
<p>2. 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>3. 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><p>受现代 JavaScript 的限制 (以及废弃 Object.observe)，<br>### Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：      </p>
<p>### Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：   </p>
<p>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</p>
<p>### 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：<br>// 代替 <code>Object.assign(this.someObject, { a: 1, b: 2 })</code><br><code>this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code></p>
<p>### 也有一些数组相关的问题，之前已经在列表渲染中讲过。 </p>
<h2 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h2><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值：   </p>
<p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。而且在代码可维护性方面也有一点重要的考虑：data 对象就像组件状态的概要，提前声明所有的响应式属性，可以让组件代码在以后重新阅读或其他开发人员阅读时更易于被理解。</p>
<h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。<br>如果同一个 watcher 被多次触发，只会被推入到队列中一次。  </p>
<p>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p>
<p>### 例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。<br>虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。例如：</p>
<p>### 在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：</p>
<p style="text-align:right">2018.9.11 星期二 16:25 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>vuejs文档</category>
      </categories>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/sum/js/fibonnacii(091)/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.10 星期一 14:23</p>

<p>Fibonacci数列的数学表达式就是：<br>F(n) = F(n-1) + F(n-2)<br>F(1) = 1<br>F(2) = 1<br>0,1,1,2,3,5,8,13,21,34,55,89,144,233,…<br>0,1,2,3,4,5,6, 7, 8, 9,10,11, 12, 13,…   </p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>### 1<br>1202年，义大利数学家斐波那契出版了他的“算盘全书”。他在书中提出了一个关于兔子繁殖的问题： 如果一对兔子每月能生一对小兔（一雄一雌），而每对小兔在它出生后的第三个月里，又能开始生一对小兔，假定在不发生死亡的情况下，由一对出生的小兔开始，50个月后会有多少对兔子？<br>### 2<br>假设你现在正在爬楼梯，楼梯有n级。每次你只能爬1级或者2级，那么你有多少种方法爬到楼梯的顶部？  </p>
<p>15/n级楼梯，一步最多三级，爬上楼梯可以有多少种走法实现（js递归实现）<br>f(15) = f(14) + f(13) + f(12);<br><!-- 链接：<https://blog.csdn.net/gohike/article/details/54867371> --><br><!-- 链接：<http://www.bkjia.com/ASPjc/988723.html> --></p>
<p>### 3<br>数列中相邻两项的前项比后项的极限是多少，就是问，当n趋于无穷大时，F(n)/F(n+1)的极限是多少？<br>答：这个可由它的通项公式直接得到，极限是(-1+√5)/2，这个就是所谓的黄金分割点，也是代表大自然的和谐的一个数字。</p>
<h2 id="逻辑推理"><a href="#逻辑推理" class="headerlink" title="逻辑推理"></a>逻辑推理</h2><p>### 兔子问题<br>根据 繁殖二叉树 可以直观的看到f(n)是f(n-1),f(n-2)两项的和<br>第n代 等于 (n-1)代的数量加上(n-1)代新生的数量；而新生兔的数量 是有生育能力的兔子的数量，也就是(n-2)代的兔子数量(需要生长/隔一个月 才可以生育)，(n-1)代并不是都有生育能力。</p>
<p>### 爬楼梯<br>爬n层楼梯的时候，可以考虑先前已经爬完的楼梯(n-1),(n-2),(n-3),…<br>最后一步 共有两种走法：1步 或者 2步；1步的走法f(n-1), 2步的走法f(n-2),即最后一步是确认的<br>同理 一步最多三级 的情况    </p>
<p>1 1: 1<br>2 2: 11 2<br>3 3: 111  121  211<br>4 5: 1111 112 121 211 221<br>5 8: 11111 1112 1121 1211 122 2111 212 221<br>6 13:111111 …    </p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p># <a href="https://www.jianshu.com/p/6c8a876e7aba" target="_blank" rel="noopener">【算法】爬楼梯(JavaScript实现)</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接用不作处理的递归求解</span></span><br><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">3</span> ? n : climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>) </span><br><span class="line"><span class="comment">// 递推求解。</span></span><br><span class="line"><span class="keyword">const</span> climbStairs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用一个数组保存每一次的结果</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      arr[i - <span class="number">1</span>] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 逐一递推得到结果</span></span><br><span class="line">      arr[i - <span class="number">1</span>] = arr[i - <span class="number">2</span>] + arr[i - <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">0</span> ? <span class="number">0</span> : arr[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $_迭代：用下面的改写:交换大小数/重新赋值数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x1=x2=<span class="number">1</span>;<span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        x2=x1+x2;</span><br><span class="line">        x1=x2-x1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p># <a href="https://www.cnblogs.com/CCBB/archive/2009/04/25/1443441.html" target="_blank" rel="noopener">斐波那契数列算法分析</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 递归程序1：很直观的二叉递归程序  O（(3/2)^N）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fib1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">return</span> fib1(n<span class="number">-1</span>) + fib1(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 递归程序2：用一叉递归程序就可以得到近似线性的效率</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (count == n)</span><br><span class="line">         <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">return</span> fib(n, b, a+b, ++count);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">fib2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fib(n, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 迭代解法：O（N）</span></span><br><span class="line">    <span class="comment">// 也可以用数组将每次计算的f(n)存储下来，用来下次计算用（空间换时间）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fib3</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">long</span> x = <span class="number">0</span>, y = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         y = x + y;</span><br><span class="line">         x = y - x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 矩阵乘法：O（log(N)）</span></span><br><span class="line">    <span class="comment">// 显然用二分法来求，结合一些面向对象的概念，C++代码如下：</span></span><br><span class="line"><span class="comment">// 5 公式解法：</span></span><br><span class="line">F(n)=</span><br></pre></td></tr></table></figure></p>
<h2 id="黄金分割比"><a href="#黄金分割比" class="headerlink" title="黄金分割比"></a>黄金分割比</h2><p>黄金比率是源于神奇数字/菲波纳奇比率（Fibonnacci Number Sequence）。<br>黄金比率是由十三世纪末出生的义大利著名数学家斐波那契(Leonardo Fibonacci)发现的，比率由一组神奇数字计算而成。这串神奇数列，是任何相列的两个数字之和都等于后一个数字。即：1，1，2，3，5，8，13，21，34，55，89，144……如此类推。即1＋1＝2，1＋2＝3，2＋3＝5，3＋5＝8等。</p>
<p>(√5 – 1) / 2 ，一个约为 0.618 的无限不循环小数<br># <a href="http://www.matrix67.com/blog/archives/5221" target="_blank" rel="noopener">为什么Fibonacci数列相邻两项之比会趋于0.618？</a><br>一个简单的解释就是，假设相邻两项之比存在一个极限，那么到了无穷远的时候，连续的三个数 a, b, a + b 将会满足 a / b = b / (a + b) ，这正好就是黄金比例的定义。</p>
<p>因而，不管数列的最初两个数是什么（比如说 2 和 7 ），只要今后每一个数都是前两个数之和，相邻两项之比总是会越来越接近 0.618 。这可以很好地解释一个我很喜欢的<a href="https://www.guokr.com/article/1858/" target="_blank" rel="noopener">数学小魔术</a>。    </p>
<p>两杯浓度不同的盐水混合在一起，<br>a/b，另一杯盐水的浓度是 c/d，那么 (a+c)/(b+d) 一定介于 a/b 和 c/d 之间。<br>因此，(21a+34b)/(34a+55b) 就一定介于 21a/34a 和 34b/55b 之间。而 21a/34a = 21/34 ≈ 0.6176，34b/55b = 34/55 ≈ 0.6182，可见不管 a 和 b 是多少，(21a+34b)/(34a+55b) 都被夹在了 0.6176 和 0.6182 之间。如果 a 和 b 都不大，用 21a+34b 的值除以 0.618 来推测 34a+55b 是相当靠谱的。  </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://open.163.com/movie/2014/2/N/O/M9HKRT25D_M9HNA0UNO.html" target="_blank" rel="noopener">神奇的斐波那契数列</a><br><a href="https://www.zhihu.com/question/28062458" target="_blank" rel="noopener">斐波那契数列为什么那么重要，所有关于数学的书几乎都会提到？</a>       </p>
<p style="text-align:right">15:09 </p>

<h2 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h2><p>[<a href="https://blog.csdn.net/laoyang360/article/details/7855860" target="_blank" rel="noopener">深究递归和迭代的区别、联系、优缺点及实例对比]</a></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归的基本概念:程序调用自身的编程技巧称为递归,是函数自己调用自己.   </p>
<p>使用递归要注意的有两点:<br>1)递归就是在过程或函数里面调用自身;<br>2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口.   </p>
<p>利用递归可以解决很多问题:如背包问题,汉诺塔问题,斐波那契数列…等.       </p>
<p>由于递归引起一系列的函数调用,并且有可能会有一系列的重复计算,递归算法的执行效率相对较低.     </p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代:利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B.        </p>
<p>递归空间消耗要比非递归代码要大很多，而且，如果递归深度太大，可能系统资源会不够用。  </p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>二者关系<br>1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。<br>2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出./<em>相对</em>/        </p>
<p>往往有这样的观点：能不用递归就不用递归，递归都可以用迭代来代替。<br>万物的存在是需要时间的检验的，递归没有被历史所埋没，即有存在的理由。    </p>
<p>从理论上说，所有的递归函数都可以转换为迭代函数，反之亦然，然而代价通常都是比较高的。但从算法结构来说，递归声明的结构并不总能够转换为迭代结构，<br>一个极典型的例子类似于链表，使用递归定义及其简单<br>采用递归算法需要的前提条件是，当且仅当一个存在预期的收敛时，才可采用递归算法，否则，就不能使用递归算法。    </p>
<p>递归其实是方便了程序员难为了机器，递归可以通过数学公式很方便的转换为程序。其优点就是易理解，容易编程。<br>但递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。    </p>
<p>而迭代虽然效率高，运行时间只因循环次数增加而增加，没什么额外开销，空间上也没有什么增加，但缺点就是不容易理解，编写复杂问题时困难    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//迭代实现斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fab_iteration</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">long</span> f1 = <span class="number">1L</span>;</span><br><span class="line">		<span class="keyword">long</span> f2 = <span class="number">1L</span>;</span><br><span class="line">		<span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index<span class="number">-2</span>; i++)</span><br><span class="line">		&#123;   </span><br><span class="line">			f3 = f1 + f2; <span class="comment">//利用变量的原值推算出变量的一个新值</span></span><br><span class="line">			f1 = f2;</span><br><span class="line">			f2 = f3;</span><br><span class="line">		&#125;</span><br><span class="line">		 <span class="keyword">return</span> f3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//递归实现斐波那契数列</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">fab_recursion</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"> </span>&#123;    </span><br><span class="line">	<span class="keyword">if</span>(index == <span class="number">1</span> || index == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> fab_recursion(index<span class="number">-1</span>)+fab_recursion(index<span class="number">-2</span>);    <span class="comment">//递归求值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fab_recursion(<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fab_iteration(<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-枚举-等概念"><a href="#遍历-枚举-等概念" class="headerlink" title="遍历/枚举 等概念"></a>遍历/枚举 等概念</h3><!-- \# [递归、循环、迭代、遍历和枚举的简单概念描述](https://www.cnblogs.com/anychem/archive/2011/05/26/Basic_Concept.html)   -->
<p>递归(recursion)在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。</p>
<p>循环(loop)：指的是在满足条件的情况下，重复执行同一段代码。一般语言都会有三种类型的循环语句:for语句、while语句和do While语句。<br>可以理解为：循环就是迭代(重复)一些命令的代码块, 如果循环控制条件不满足的话, 就结束循环.</p>
<p>迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项<br>可以理解为：遍历一个集合，把集合里的每个元素都遍历一边。有时候，迭代也会指循环执行，反复执行的意思。(这个迭是高潮迭起的迭！对迭代的理解有限，如果想详细了解，自己search！)</p>
<p>遍历（traversal），是树形结构的一种重要运算，指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。<br>可以理解为：遍历，是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。或者理解为按一定的次序系统地访问结构中的所有结点，使每个结点只被访问一次。</p>
<p>枚举(enumeration)，在数学和计算机科学理论中，一个集的枚举是列出某些有穷序列集的所有成员的程序，或者是一种特定类型对象的计数。这两种类型经常（但不总是）重叠。枚举是一个被命名的整型常数的集合！</p>
<p># <a href="https://segmentfault.com/a/1190000009263950" target="_blank" rel="noopener">leetcode50 Pow(x, n)自定义实现指数运算</a><br><a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="noopener">此处为题目链接</a>     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路一：二分法计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    x = n&gt;<span class="number">0</span> ? x : <span class="number">1</span>/x;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x*myPow(x, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line">    <span class="keyword">while</span>(n &gt;= (temp+temp))&#123;</span><br><span class="line">        temp += temp;</span><br><span class="line">        result *= result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result*myPow(x, n-(<span class="keyword">int</span>)temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路二：递归</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>/x * myPow(<span class="number">1</span>/x, -(n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> x*x;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> myPow( myPow(x, n/<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x*myPow( myPow(x, n/<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Async 函数</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/19-async%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.9 星期日 22:53 </p>

<p>1. 含义<br>2. 基本用法<br>3. 语法<br>4. async 函数的实现原理<br>5. 与其他异步处理方法的比较<br>6. 实例：按顺序完成异步操作<br>7. 异步遍历器</p>
<a id="more"></a>
<h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1 含义"></a>1 含义</h2><p>它就是 Generator 函数的语法糖。<br>体现在以下四点。<br>（1）内置执行器。<br>（2）更好的语义。<br>（3）更广的适用性。<br>（4）返回值是 Promise:Generator 函数的返回值是 Iterator 对象方便多了     </p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h2><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);<span class="comment">// 50 毫秒以后，输出hello world。</span></span><br></pre></td></tr></table></figure></p>
<p>由于async函数返回的是 Promise 对象，可以作为await命令的参数     </p>
<p>async 函数有多种使用形式:<br>// 函数声明<br>// 函数表达式<br>// 对象的方法<br>// Class 的方法<br>// 箭头函数</p>
<h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h2><p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p>async函数返回一个 Promise 对象。<br>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。   </p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，await命令后面是一个 Promise 对象。<br>如果不是，会被转成一个立即resolve的 Promise 对象。    </p>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。<br>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。<br>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时..</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>防止出错的方法，也是将其放在try…catch代码块之中。     </p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。<br>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。<br>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 如果确实希望多个请求并发执行，除了Promise.all</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。<br>如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前，esm模块加载器支持顶层await，即await命令可以不放在 async 函数里面，直接使用。<br>第二种写法的脚本必须使用esm加载器，才会生效。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 函数的写法</span></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'google.com'</span>);</span><br><span class="line">  <span class="keyword">return</span> res.text();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start().then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层 await 的写法</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'google.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> res.text());</span><br></pre></td></tr></table></figure></p>
<h2 id="4-async-函数的实现原理"><a href="#4-async-函数的实现原理" class="headerlink" title="4 async 函数的实现原理"></a>4 async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。<br>下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 </p>
<h2 id="5-与其他异步处理方法的比较"><a href="#5-与其他异步处理方法的比较" class="headerlink" title="5 与其他异步处理方法的比较"></a>5 与其他异步处理方法的比较</h2><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是 Promise 的写法。<br>接着是 Generator 函数的写法。<br>最后是 async 函数的写法。   </p>
<h2 id="6-实例：按顺序完成异步操作"><a href="#6-实例：按顺序完成异步操作" class="headerlink" title="6 实例：按顺序完成异步操作"></a>6 实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。    </p>
<p>Promise 的写法如下。<br>这种写法不太直观，可读性比较差。下面是 async 函数实现。<br>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并发发出远程请求。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。</p>
<p style="text-align:right">23:37</p>


<h2 id="7-异步遍历器"><a href="#7-异步遍历器" class="headerlink" title="7 异步遍历器"></a>7 异步遍历器</h2><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。<br>这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值。也就是  </p>
<p>ES2018 引入了”异步遍历器“（Async Iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。  </p>
<p>###　异步遍历的接口<br>异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。</p>
<h3 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h3><h3 id="异步-Generator-函数"><a href="#异步-Generator-函数" class="headerlink" title="异步 Generator 函数"></a>异步 Generator 函数</h3><h3 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h3>]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 对象</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/14-Promise%20%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.9 星期日 23:51 </p>

<p>1. Promise 的含义<br>2. 基本用法<br>3. Promise.prototype.then()<br>4. Promise.prototype.catch()<br>5. Promise.prototype.finally()<br>6. Promise.all()<br>7. Promise.race()<br>8. Promise.resolve()<br>9. Promise.reject()<br>10. 应用<br>11. Promise.try()</p>
<a id="more"></a>
<h2 id="1-Promise-的含义"><a href="#1-Promise-的含义" class="headerlink" title="1 Promise 的含义"></a>1 Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。    </p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。     </p>
<p>Promise对象有以下两个特点。<br>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。   </p>
<p>优缺点：…  </p>
<p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。   </p>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h2><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。<br>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<br>then方法可以接受两个回调函数作为参数。<br>第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。<br>Promise 新建后就会立即执行。    </p>
<p>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例  </p>
<p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。<br>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。  </p>
<h2 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3 Promise.prototype.then()"></a>3 Promise.prototype.then()</h2><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。        </p>
<h2 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4 Promise.prototype.catch()"></a>4 Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。   </p>
<p>如果 Promise 状态已经变成resolved，再抛出错误是无效的。     </p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br>上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。   </p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。       </p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。      </p>
<p>catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。<br>此时，要是then方法里面报错，就与前面的catch无关了。     </p>
<p>catch方法之中，还能再抛出错误。     </p>
<h2 id="5-Promise-prototype-finally"><a href="#5-Promise-prototype-finally" class="headerlink" title="5 Promise.prototype.finally()"></a>5 Promise.prototype.finally()</h2><p>该方法是 ES2018 引入标准的。<br>finally本质上是then方法的特例。   </p>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6 Promise.all()"></a>6 Promise.all()</h2><p>Promise.all方法接受一个数组作为参数，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）    </p>
<p>p的状态由p1、p2、p3决定，分成两种情况。     </p>
<p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7 Promise.race()"></a>7 Promise.race()</h2><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。     </p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure></p>
<h2 id="8-Promise-resolve"><a href="#8-Promise-resolve" class="headerlink" title="8 Promise.resolve()"></a>8 Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。        </p>
<p>Promise.resolve方法的参数分成四种情况。<br>（1）参数是一个 Promise 实例<br>（2）参数是一个thenable对象<br>（3）参数不是具有then方法的对象，或根本就不是对象<br>（4）不带有任何参数     </p>
<p>需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure></p>
<h2 id="9-Promise-reject"><a href="#9-Promise-reject" class="headerlink" title="9 Promise.reject()"></a>9 Promise.reject()</h2><p>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。     </p>
<p>上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</p>
<h2 id="10-应用"><a href="#10-应用" class="headerlink" title="10 应用"></a>10 应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><h2 id="11-Promise-try"><a href="#11-Promise-try" class="headerlink" title="11 Promise.try()"></a>11 Promise.try()</h2><p>提案：chrome也没有通过      </p>
<p>下面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure></p>
<p>回答是可以的，并且还有两种写法。第一种写法是用async函数来写。<br>第二种写法是使用new Promise()。<br><figure class="highlight plain"><figcaption><span>f </span></figcaption><table><tr><td class="code"><pre><span class="line">Promise.try(f);</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure></p>
<p>事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。<br>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。  </p>
<p>但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try…catch去捕获。<br>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try(database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">00:30</p>

]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的扩展</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.7 星期五 9:46 </p>

<p>1. 属性的简洁表示法<br>2. 属性名表达式<br>3. 方法的 name 属性<br>4. Object.is()<br>5. Object.assign()<br>6. 属性的可枚举性和遍历<br>7. Object.getOwnPropertyDescriptors()<br>8. <strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()<br>9. super 关键字<br>10. Object.keys()，Object.values()，Object.entries()<br>11. 对象的扩展运算符</p>
<a id="more"></a>
<h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。<br>除了属性简写，方法也可以简写。  </p>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。<br>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。      </p>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。<br>如果某个方法的值是一个 Generator 函数，前面需要加上星号。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">'2000/01/01'</span>;</span><br><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  birth,</span><br><span class="line">  hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总是字符串</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。<br>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。<br>表达式还可以用于定义方法名。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span>,</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。<br>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ### 是对象</span></span><br><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">'valueA'</span>,</span><br><span class="line">  [keyB]: <span class="string">'valueB'</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: "valueB"&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-方法的-name-属性"><a href="#3-方法的-name-属性" class="headerlink" title="3. 方法的 name 属性"></a>3. 方法的 name 属性</h2><p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。        </p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；<br>Function构造函数创造的函数，name属性返回anonymous。  </p>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line">descriptor.get.name <span class="comment">// "get foo"</span></span><br><span class="line">descriptor.set.name <span class="comment">// "set foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></span><br></pre></td></tr></table></figure>
<h2 id="4-Object-is"><a href="#4-Object-is" class="headerlink" title="4. Object.is()"></a>4. Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。<br>它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。    </p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。   </p>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-Object-assign"><a href="#5-Object-assign" class="headerlink" title="5. Object.assign()"></a>5. Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Object.assign方法用于对象的合并，将源对象（source）的<strong>所有可枚举属性</strong>，复制到目标对象（target）。<br>只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。<br>属性名为 Symbol 值的属性，也会被Object.assign拷贝。     </p>
<p>####<br>如果只有一个参数，Object.assign会直接返回该参数。<br>如果该参数不是对象，则会先转成对象，然后返回。<br>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。<br>####<br>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。   </p>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br>这是因为只有字符串的包装对象，会产生可枚举属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="comment">// ### </span></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br><span class="line"><span class="comment">// ### </span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">'c'</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'hello'</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: 'c' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line">funciton f()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）浅拷贝<br>（2）同名属性的替换<br>（3）数组的处理:Object.assign可以用来处理数组，但是会把数组视为对象。<br>（4）取值函数的处理:Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [4, 5, 3]</span></span><br><span class="line"><span class="comment">// #### 取值函数    </span></span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)<span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p>（1）为对象添加属性<br>（2）为对象添加方法<br>（3）克隆对象<br>（4）合并多个对象<br>（5）为属性指定默认值：存在浅拷贝的问题，最好都是简单类型，   </p>
<h2 id="6-属性的可枚举性和遍历"><a href="#6-属性的可枚举性和遍历" class="headerlink" title="6. 属性的可枚举性和遍历"></a>6. 属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。   </p>
<p>目前，有四个操作会忽略enumerable为false的属性。     </p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>
<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3>ES6 一共有 5 种方法可以遍历对象的属性。<br>（1）for…in<br>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li>
</ul>
<p>（2）Object.keys(obj)<br>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 </p>
<p>（3）Object.getOwnPropertyNames(obj)<br>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p>（4）Object.getOwnPropertySymbols(obj)<br>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p>（5）Reflect.ownKeys(obj)<br>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。<br>首先遍历所有数值键，按照数值升序排列。<br>其次遍历所有字符串键，按照加入时间升序排列。<br>最后遍历所有 Symbol 键，按照加入时间升序排列。  </p>
<h2 id="7-Object-getOwnPropertyDescriptors"><a href="#7-Object-getOwnPropertyDescriptors" class="headerlink" title="7. Object.getOwnPropertyDescriptors()"></a>7. Object.getOwnPropertyDescriptors()</h2><p>前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象<br>ES2017 引入了   </p>
<p>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。<br>方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。<br>可以实现一个对象继承另一个对象。<br>也可以用来实现 Mixin（混入）模式。  </p>
<h2 id="8-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#8-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="8. proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>8. <strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><h3 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h3><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。<br>该属性没有写入 ES6 的正文，而是写入了附录，原因<br>标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。<br>因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p>
<p>实现上，<strong>proto</strong>调用的是Object.prototype.<strong>proto</strong>，具体实现如下。</p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。  </p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。<br>由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。    </p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>如果参数不是对象，会被自动转为对象。<br>如果参数是undefined或null，它们无法转为对象，所以会报错。   </p>
<h2 id="9-super-关键字"><a href="#9-super-关键字" class="headerlink" title="9. super 关键字"></a>9. super 关键字</h2><p>ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。   </p>
<p>注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。<br>目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。  </p>
<p>上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。  </p>
<h2 id="10-Object-keys-，Object-values-，Object-entries"><a href="#10-Object-keys-，Object-values-，Object-entries" class="headerlink" title="10. Object.keys()，Object.values()，Object.entries()"></a>10. Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了Object.keys方法，<br>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的 键名/键值/键值对<br>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。     </p>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。<br>Object.values会过滤属性名为 Symbol 值的属性。<br>Object.values会过滤属性名为 Symbol 值的属性。符串会先转成一个类似数组的对象<br>如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。    </p>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p>行为与Object.values基本一致。<br>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。    </p>
<p>Object.entries的基本用途是遍历对象的属性。<br>Object.entries方法的另一个用处是，将对象转为真正的Map结构。     </p>
<h2 id="11-对象的扩展运算符"><a href="#11-对象的扩展运算符" class="headerlink" title="11. 对象的扩展运算符"></a>11. 对象的扩展运算符</h2><p>ES2018 将这个运算符引入了对象。     </p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。<br>解构赋值必须是最后一个参数，否则会报错。        </p>
<p>注意，解构赋值的拷贝是浅拷贝<br>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。<br>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。    </p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>$_LUE: </p>
<p style="text-align:right">11:13 </p>

]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6入门</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 10：56 </p>

<p>ECMAScript 6 入门:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a>  </p>
<p>全书已由电子工业出版社出版，2017年9月推出了第三版，书名为《ES6 标准入门》</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="ECMAScript-6简介"><a href="#ECMAScript-6简介" class="headerlink" title="ECMAScript 6简介"></a>ECMAScript 6简介</h2><h3 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h3><p>1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<h3 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h3><p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。<br>2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。<br>根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h3 id="语法提案的批准流程"><a href="#语法提案的批准流程" class="headerlink" title="语法提案的批准流程"></a>语法提案的批准流程</h3><p>Stage 0 - Strawman（展示阶段）<br>Stage 1 - Proposal（征求意见阶段）<br>Stage 2 - Draft（草案阶段）<br>Stage 3 - Candidate（候选人阶段）<br>Stage 4 - Finished（定案阶段）</p>
<h3 id="ECMAScript-的历史"><a href="#ECMAScript-的历史" class="headerlink" title="ECMAScript 的历史"></a>ECMAScript 的历史</h3><h3 id="部署进度"><a href="#部署进度" class="headerlink" title="部署进度"></a>部署进度</h3><h3 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h3><h3 id="Traceur-转码器"><a href="#Traceur-转码器" class="headerlink" title="Traceur 转码器"></a>Traceur 转码器</h3><h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h2><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><h2 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h2><h2 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h2><h2 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h2><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><h2 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h2><h2 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h2><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><h2 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h2><h2 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h2><h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><h2 id="读懂规格"><a href="#读懂规格" class="headerlink" title="读懂规格"></a>读懂规格</h2><h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><h2 id="最新提案"><a href="#最新提案" class="headerlink" title="最新提案"></a>最新提案</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
      </categories>
  </entry>
  <entry>
    <title>Let 和 Const 命令</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/2-let%20%E5%92%8C%20const%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 10：56 </p>


<p>let 命令<br>块级作用域<br>const 命令<br>顶层对象的属性<br>global 对象</p>
<a id="more"></a>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<p>for循环的计数器，就很合适使用let命令。<br>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。   </p>
<p>你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。    </p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。<br>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。<br>因此，不能在函数内部重新声明参数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>第一种场景，内层变量可能会覆盖外层变量。<br>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。   </p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。      </p>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。     </p>
<p>const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br>如果真的想将对象冻结，应该使用Object.freeze方法。<br>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。  </p>
<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>var,function;<br>let,const;<br>import,class        </p>
<h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<br>$_PS: window===top/self/this  </p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。….      </p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h2 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h2><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。  </p>
<pre><code>* 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
* 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
* Node 里面，顶层对象是global，但其他环境都不支持。
</code></pre><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p>
<pre><code>* 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。
* 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
* 不管是严格模式，还是普通模式，new Function(&apos;return this&apos;)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。
</code></pre><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<p style="text-align:right">11:35 </p>

]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Class 的基本语法</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/20-Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 17:40 </p>

<p>1. 简介<br>2. 严格模式<br>3. constructor 方法<br>4. 类的实例对象<br>5. Class 表达式<br>6. 不存在变量提升<br>7. 私有方法和私有属性<br>8. this 的指向<br>9. name 属性<br>10. Class 的取值函数（getter）和存值函数（setter）<br>11. Class 的 Generator 方法<br>12. Class 的静态方法<br>13. Class 的静态属性和实例属性<br>14. new.target 属性 </p>
<a id="more"></a>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。    </p>
<p>另外，方法之间不需要逗号分隔，加了会报错。<br>ES6 的类，完全可以看作构造函数的另一种写法。<br>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。     </p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。       </p>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。<br>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与 ES5 的行为不一致。<br>类的属性名，可以采用表达式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2. 严格模式"></a>2. 严格模式</h2><p>..</p>
<h2 id="3-constructor-方法"><a href="#3-constructor-方法" class="headerlink" title="3. constructor 方法"></a>3. constructor 方法</h2><p>上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。  </p>
<h2 id="4-类的实例对象"><a href="#4-类的实例对象" class="headerlink" title="4. 类的实例对象"></a>4. 类的实例对象</h2><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。  </p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。     </p>
<p>这也意味着，可以通过实例的<strong>proto</strong>属性为“类”添加方法。<br><code>__proto__</code>并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。  </p>
<h2 id="5-Class-表达式"><a href="#5-Class-表达式" class="headerlink" title="5. Class 表达式"></a>5. Class 表达式</h2><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。<br>采用 Class 表达式，可以写出立即执行的 Class<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-不存在变量提升"><a href="#6-不存在变量提升" class="headerlink" title="6. 不存在变量提升"></a>6. 不存在变量提升</h2><p>这一点与 ES5 完全不同。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。<br>但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。    </p>
<h2 id="7-私有方法和私有属性"><a href="#7-私有方法和私有属性" class="headerlink" title="7. 私有方法和私有属性"></a>7. 私有方法和私有属性</h2><h3 id="现有的方法"><a href="#现有的方法" class="headerlink" title="现有的方法"></a>现有的方法</h3><p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。   </p>
<p>一种做法是在命名上加以区别。 下划线<br>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。<br>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 ：$_QUE:不是很懂，为什么就私有了；两个都需要用Symbol吗   </span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="私有属性的提案"><a href="#私有属性的提案" class="headerlink" title="私有属性的提案"></a>私有属性的提案</h3><p>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。<br>$_LUE:</p>
<h2 id="8-this-的指向"><a href="#8-this-的指向" class="headerlink" title="8. this 的指向"></a>8. this 的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。      </p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。<br>另一种解决方法是使用箭头函数。<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。<br>$_LUE:Proxy<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法：绑定this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 解决方法 箭头函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-name-属性"><a href="#9-name-属性" class="headerlink" title="9. name 属性"></a>9. name 属性</h2><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<h2 id="10-Class-的取值函数（getter）和存值函数（setter）"><a href="#10-Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="10. Class 的取值函数（getter）和存值函数（setter）"></a>10. Class 的取值函数（getter）和存值函数（setter）</h2><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。<br>这与 ES5 完全一致。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="11-Class-的-Generator-方法"><a href="#11-Class-的-Generator-方法" class="headerlink" title="11. Class 的 Generator 方法"></a>11. Class 的 Generator 方法</h2><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<h2 id="12-Class-的静态方法"><a href="#12-Class-的静态方法" class="headerlink" title="12. Class 的静态方法"></a>12. Class 的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。    </p>
<p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。    </p>
<p>父类的静态方法，可以被子类继承。<br>静态方法也是可以从super对象上调用的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()<span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></p>
<h2 id="13-Class-的静态属性和实例属性"><a href="#13-Class-的静态属性和实例属性" class="headerlink" title="13. Class 的静态属性和实例属性"></a>13. Class 的静态属性和实例属性</h2><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种写法都无效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写法一</span></span><br><span class="line">  prop: <span class="number">2</span></span><br><span class="line">  <span class="comment">// 写法二</span></span><br><span class="line">  <span class="keyword">static</span> prop: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。<br>（1）类的实例属性<br>类的实例属性可以用等式，写入类的定义之中。<br>（2）类的静态属性<br>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。    </p>
<h2 id="14-new-target-属性"><a href="#14-new-target-属性" class="headerlink" title="14. new.target 属性"></a>14. new.target 属性</h2><p>new是从构造函数生成实例对象的命令。<br>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。     </p>
<p>上面代码确保构造函数只能通过new命令调用。<br>Class 内部调用new.target，返回当前 Class。  </p>
<p>需要注意的是，子类继承父类时，new.target会返回子类。<br>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<p>注意，在函数外部，使用new.target会报错。    </p>
<p style="text-align:right">18:12 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Class 的继承</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/21-Class%20%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 19:06 </p>

<p>1. 简介<br>2. Object.getPrototypeOf()<br>3. super 关键字<br>4. 类的 prototype 属性和<strong>proto</strong>属性<br>5. 原生构造函数的继承<br>6. Mixin 模式的实现 </p>
<a id="more"></a>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。     </p>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。        </p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。  </p>
<p>最后，父类的静态方法，也会被子类继承。  </p>
<h2 id="2-Object-getPrototypeOf"><a href="#2-Object-getPrototypeOf" class="headerlink" title="2. Object.getPrototypeOf()"></a>2. Object.getPrototypeOf()</h2><p>Object.getPrototypeOf方法可以用来从子类上获取父类。     </p>
<h2 id="3-super-关键字"><a href="#3-super-关键字" class="headerlink" title="3. super 关键字"></a>3. super 关键字</h2><p>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。     </p>
<p>###<br>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。<br>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure></p>
<p>###<br>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。<br>####<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。    </p>
<p>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。  </p>
<p>####<br>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。<br>另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。     </p>
<p>###<br>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<br>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。   </p>
<h2 id="4-类的-prototype-属性和proto属性"><a href="#4-类的-prototype-属性和proto属性" class="headerlink" title="4. 类的 prototype 属性和proto属性"></a>4. 类的 prototype 属性和<strong>proto</strong>属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h3><p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5. 原生构造函数的继承"></a>5. 原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。<br>Boolean(),Number(),String(),Array(),Date(),Function(),RegExp(),Error(),Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。     </p>
<p>ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。  </p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></span><br><span class="line"><span class="comment">// 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。     </p>
<p>下面是一个自定义Error子类的例子，可以用来定制报错时的行为。<br>注意，继承Object的子类，有一个行为差异。    </p>
<h2 id="6-Mixin-模式的实现"><a href="#6-Mixin-模式的实现" class="headerlink" title="6. Mixin 模式的实现"></a>6. Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: 'a', b: 'b'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。    </p>
<p style="text-align:right">19:38 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>变量的解构赋值</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 11：56 </p>

<p>数组的解构赋值<br>对象的解构赋值<br>字符串的解构赋值<br>数值和布尔值的解构赋值<br>函数参数的解构赋值<br>圆括号问题<br>用途</p>
<a id="more"></a>
<h2 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1. 数组的解构赋值"></a>1. 数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。<code>let [a, b, c] = [1, 2, 3];</code><br>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>如果解构不成功，变量的值就等于undefined。<br>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。    </p>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。      </p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。<br>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>]; <span class="comment">//因为x能取到值，所以函数f根本不会执行。</span></span><br></pre></td></tr></table></figure></p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。    </p>
<h2 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2. 对象的解构赋值"></a>2. 对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;    </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</span></span><br><span class="line">    <span class="comment">// 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br><span class="line"><span class="comment">//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</span></span><br></pre></td></tr></table></figure></p>
<p>#### 与数组一样，解构也可以用于嵌套结构的对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</span></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure></p>
<p>#### 对象的解构也可以指定默认值。<br>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</span><br><span class="line">x // 3</span><br><span class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></p>
<p>#### 如果解构失败，变量的值等于undefined。<br><code>let {foo} = {bar: &#39;baz&#39;}; foo // undefined</code></p>
<p>#### 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。<br><code>let {foo: {bar}} = {baz: &#39;baz&#39;};// 报错</code></p>
<p>#### 如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误``的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line">上面代码的写法会报错，因为 JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>#### 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure></p>
<p>#### 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3. 字符串的解构赋值"></a>3. 字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4. 数值和布尔值的解构赋值"></a>4. 数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5. 函数参数的解构赋值"></a>5. 函数参数的解构赋值</h2><p>函数参数的解构也可以使用默认值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);<span class="comment">// [ 3, 7 ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);<span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6. 圆括号问题"></a>6. 圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>（1）变量声明语句<br>（2）函数参数：函数参数也属于变量声明<br>（3）赋值语句的模式     </p>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-用途"><a href="#7-用途" class="headerlink" title="7. 用途"></a>7. 用途</h2><p>（1）交换变量的值<br>（2）从函数返回多个值<br>（3）函数参数的定义：一组有/无次序的值<br>（4）提取 JSON 数据<br>（5）函数参数的默认值<br>（6）遍历 Map 结构<br>（7）输入模块的指定方法     </p>
<p style="text-align:right">12:21 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Module 的加载实现</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/24-Module%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 17:13 </p>

<p>1. 浏览器加载<br>2. ES6 模块与 CommonJS 模块的差异<br>3. Node 加载<br>4. 循环加载 $_LUE<br>5. ES6 模块的转码</p>
<a id="more"></a>
<h2 id="1-浏览器加载"><a href="#1-浏览器加载" class="headerlink" title="1. 浏览器加载"></a>1. 浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。      </p>
<p>上面代码中，<code>&lt;script&gt;</code>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p>defer与async的区别是：<br>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<br>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。<br>一句话，defer是“渲染完再执行”，async是“下载完就执行”。<br>另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。    </p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=”module”属性。<br>所以浏览器知道这是一个 ES6 模块。   </p>
<p>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。    </p>
<p><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<p>一旦使用了async属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。     </p>
<h2 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="2. ES6 模块与 CommonJS 模块的差异"></a>2. ES6 模块与 CommonJS 模块的差异</h2><p>它们有两个重大差异。    </p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ul>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<br>下面重点解释第一个差异。<br>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。  </p>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。     </p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。  </p>
<p>最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。    </p>
<h2 id="3-Node-加载"><a href="#3-Node-加载" class="headerlink" title="3. Node 加载"></a>3. Node 加载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。     </p>
<p>Node 要求 ES6 模块采用.mjs后缀文件名。也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。<br>require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。      </p>
<p>#### 目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用–experimental-modules参数才能打开该功能。<br><code>$ node --experimental-modules my-app.mjs</code>  </p>
<p>#### 为了与浏览器的import加载规则相同，Node 的.mjs文件支持 URL 路径。<br><code>import &#39;./foo?query=1&#39;; // 加载 ./foo 传入参数 ?query=1</code><br>上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。    </p>
<p>目前，Node 的import命令只支持加载本地模块（file:协议），不支持加载远程模块。  </p>
<p>如果模块名不含路径，那么import命令会去node_modules目录寻找这个模块。<br>如果模块名包含路径，那么import命令会按照路径去寻找这个名字的脚本文件。<br>如果脚本文件省略了后缀名，比如import ‘./foo’，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json的main字段指定的脚本。如果./foo/package.json不存在或者没有main字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。</p>
<p>最后，Node 的import命令是异步加载，这一点与浏览器的处理方法相同。</p>
<h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。    </p>
<p>首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。      </p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。<br>arguments ,require ,module ,exports ,<strong>filename ,</strong>dirname      </p>
<p>如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// expose.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;__dirname&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use.mjs</span></span><br><span class="line"><span class="keyword">import</span> expose <span class="keyword">from</span> <span class="string">'./expose.js'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;__dirname&#125; = expose;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，expose.js是一个 CommonJS 模块，输出变量<strong>dirname，该变量在 ES6 模块之中不存在。ES6 模块加载expose.js，就可以得到</strong>dirname。     </p>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。<br>下面是一个 CommonJS 模块。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span>,</span><br><span class="line">  bar: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>import命令加载上面的模块，module.exports会被视为默认输出，即import命令实际上输入的是这样一个对象<code>{ default: module.exports }</code>。     </p>
<p>所以，一共有三种写法，可以拿到 CommonJS 模块的module.exports。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;;</span></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> baz&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: 'hello', bar: 'world'&#125;;</span></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> baz <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="comment">// baz = &#123;</span></span><br><span class="line"><span class="comment">//   get default() &#123;return module.exports;&#125;,</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return this.default.foo&#125;.bind(baz),</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return this.default.bar&#125;.bind(baz)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports。     </p>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es.mjs</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">bar</span>: <span class="string">'my-default'</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./es.mjs'</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get default() &#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(es_namespace.default);</span><br><span class="line"><span class="comment">// &#123; bar:'my-default' &#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-ES6-模块的转码"><a href="#5-ES6-模块的转码" class="headerlink" title="5. ES6 模块的转码"></a>5. ES6 模块的转码</h2><p>浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码。<br>### ES6 module transpiler<br>### SystemJS       </p>
<p style="text-align:right">17:32 </p>

<h2 id="4-循环加载"><a href="#4-循环加载" class="headerlink" title="4. 循环加载"></a>4. 循环加载</h2><p>$_LUE:     </p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。    </p>
<h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。     </p>
<p>以后需要用到这个模块的时候，就会到exports属性上面取值。<br>即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。<br>也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。   </p>
<h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3>]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的扩展</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 12:56 </p>


<p>1. 字符的 Unicode 表示法<br>2. codePointAt()<br>3. String.fromCodePoint()<br>4. 字符串的遍历器接口<br>5. normalize()<br>6. includes(), startsWith(), endsWith()<br>7. repeat()<br>8. padStart()，padEnd()<br>9. matchAll()<br>10. 模板字符串<br>11. 实例：模板编译<br>12. 标签模板<br>13. String.raw()<br>14. 模板字符串的限制 </p>
<a id="more"></a>
<h2 id="1-字符的-Unicode-表示法"><a href="#1-字符的-Unicode-表示法" class="headerlink" title="1. 字符的 Unicode 表示法"></a>1. 字符的 Unicode 表示法</h2><p>但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。<br>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<br>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="string">"\u20BB7"</span><span class="comment">// " 7"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span><span class="comment">// "𠮷"       </span></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 6 中方法</span></span><br><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-codePointAt"><a href="#2-codePointAt" class="headerlink" title="2. codePointAt()"></a>2. codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。<br>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = &quot;𠮷&quot;;</span><br><span class="line"></span><br><span class="line">s.length // 2</span><br><span class="line">s.charAt(0) // &apos;&apos;</span><br><span class="line">s.charAt(1) // &apos;&apos;</span><br><span class="line">s.charCodeAt(0) // 55362</span><br><span class="line">s.charCodeAt(1) // 57271</span><br><span class="line"></span><br><span class="line">let s = &apos;𠮷a&apos;;</span><br><span class="line">s.codePointAt(0) // 134071</span><br><span class="line">s.codePointAt(1) // 57271</span><br><span class="line">s.codePointAt(2) // 97</span><br></pre></td></tr></table></figure></p>
<p>总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。</p>
<p>#### codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// "20bb7"</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// "61"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure></p>
<p>你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。    </p>
<p>#### codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function is32Bit(c) &#123;</span><br><span class="line">  return c.codePointAt(0) &gt; 0xFFFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-String-fromCodePoint"><a href="#3-String-fromCodePoint" class="headerlink" title="3. String.fromCodePoint()"></a>3. String.fromCodePoint()</h2><p>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。        </p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。  </p>
<h2 id="4-字符串的遍历器接口"><a href="#4-字符串的遍历器接口" class="headerlink" title="4. 字符串的遍历器接口"></a>4. 字符串的遍历器接口</h2><p>使得字符串可以被for…of循环遍历。      </p>
<p>除了遍历字符串，<br>这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-normalize"><a href="#5-normalize" class="headerlink" title="5. normalize()"></a>5. normalize()</h2><h2 id="6-includes-startsWith-endsWith"><a href="#6-includes-startsWith-endsWith" class="headerlink" title="6. includes(), startsWith(), endsWith()"></a>6. includes(), startsWith(), endsWith()</h2><h2 id="7-repeat"><a href="#7-repeat" class="headerlink" title="7. repeat()"></a>7. repeat()</h2><h2 id="8-padStart-，padEnd"><a href="#8-padStart-，padEnd" class="headerlink" title="8. padStart()，padEnd()"></a>8. padStart()，padEnd()</h2><h2 id="9-matchAll"><a href="#9-matchAll" class="headerlink" title="9. matchAll()"></a>9. matchAll()</h2><h2 id="10-模板字符串"><a href="#10-模板字符串" class="headerlink" title="10. 模板字符串"></a>10. 模板字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。<br>模板字符串之中还能调用函数。<br>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。<br>如果模板字符串中的变量没有声明，将报错。<br>模板字符串甚至还能嵌套。    </p>
<h2 id="11-实例：模板编译"><a href="#11-实例：模板编译" class="headerlink" title="11. 实例：模板编译"></a>11. 实例：模板编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let template = `</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<h2 id="12-标签模板"><a href="#12-标签模板" class="headerlink" title="12. 标签模板"></a>12. 标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。     </p>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。<br>标签模板的另一个应用，就是多语言转换（国际化处理）。    </p>
<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。<br>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。      </p>
<h2 id="13-String-raw"><a href="#13-String-raw" class="headerlink" title="13. String.raw()"></a>13. String.raw()</h2><p>往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。        </p>
<h2 id="14-模板字符串的限制"><a href="#14-模板字符串的限制" class="headerlink" title="14. 模板字符串的限制"></a>14. 模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p style="text-align:right">13:01 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的扩展</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/6-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 12:21 </p>


<p>1. 二进制和八进制表<br>2. Number.isFinite(), Number.isNaN()<br>3. Number.parseInt(), Number.parseFloat()<br>4. Number.isInteger()<br>5. Number.EPSILON<br>6. 安全整数和 Number.isSafeInteger()<br>7. Math 对象的扩展<br>8. 指数运算符</p>
<h2 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1. 二进制和八进制表示法"></a>1. 二进制和八进制表示法</h2><p>二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。<br>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。    </p>
<h2 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2. Number.isFinite(), Number.isNaN()"></a>2. Number.isFinite(), Number.isNaN()</h2><p>注意，如果参数类型不是数值，Number.isFinite一律返回false。<br>如果参数类型不是NaN，Number.isNaN一律返回false。        </p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，<br>而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p>
<h2 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3. Number.parseInt(), Number.parseFloat()"></a>3. Number.parseInt(), Number.parseFloat()</h2><h2 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4. Number.isInteger()"></a>4. Number.isInteger()</h2><p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。<br>如果参数不是数值，Number.isInteger返回false。       </p>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。<br>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324）      </p>
<p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。    </p>
<h2 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5. Number.EPSILON"></a>5. Number.EPSILON</h2><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。      </p>
<h2 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6. 安全整数和 Number.isSafeInteger()"></a>6. 安全整数和 Number.isSafeInteger()</h2><h2 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7. Math 对象的扩展"></a>7. Math 对象的扩展</h2><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<p>Math.trunc(),Math.sign(), Math.cbrt(),Math.clz32()<br>Math.fround(),Math.hypot() </p>
<p>### 对数方法 4个<br> Math.expm1(),Math.log1p(),Math.log10(),Math.log2()<br>### 双曲函数方法 6个       </p>
<h2 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8. 指数运算符"></a>8. 指数运算符</h2><p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。<br>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。       </p>
<p>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">99</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment">// 3.697296376497263e+197</span></span><br><span class="line"></span><br><span class="line"><span class="number">99</span> ** <span class="number">99</span></span><br><span class="line"><span class="comment">// 3.697296376497268e+197</span></span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">12:32 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的扩展</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/8-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 15:31 </p>


<p>1. 扩展运算符<br>2. Array.from()<br>3. Array.of()<br>4. 数组实例的 copyWithin()<br>5. 数组实例的 find() 和 findIndex()<br>6. 数组实例的 fill()<br>7. 数组实例的 entries()，keys() 和 values()<br>8. 数组实例的 includes()<br>9. 数组实例的 flat()，flatMap()<br>10. 数组的空位 </p>
<a id="more"></a>
<h2 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1. 扩展运算符"></a>1. 扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。<br>该运算符主要用于函数调用。  </p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。<br>扩展运算符后面还可以放置表达式。<br>如果扩展运算符后面是一个空数组，则不产生任何效果。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  ...(x &gt; <span class="number">0</span> ? [<span class="string">'a'</span>] : []),</span><br><span class="line">  <span class="string">'b'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">[...[], <span class="number">1</span>] <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法 VS ES6 的写法</span></span><br><span class="line"><span class="comment">// #### 1 简化求出一个数组最大元素的写法。</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 2 通过push函数，将一个数组添加到另一个数组的尾部。</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"><span class="comment">// #### 3 </span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p>（1）复制数组<br>（2）合并数组:不过，这两种方法都是浅拷贝，使用的时候需要注意。<br>（3）与解构赋值结合:用于生成数组<br>    如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<br>（4）字符串:转为真正的数组。<br>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。<br>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。<br>（5）实现了 Iterator 接口的对象<br>（6）Map 和 Set 结构，Generator 函数<br>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #### 1</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 2 </span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">arr1.concat(arr2, arr3);<span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line">[...arr1, ...arr2, ...arr3] <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 3</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line">[a, ...rest] = list</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 4</span></span><br><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// #### 6</span></span><br><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h2><p>用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。     </p>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。<br>Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure></p>
<p>###<br>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。   </p>
<p>###<br>Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。     </p>
<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。  </p>
<h2 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3. Array.of()"></a>3. Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。<br>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。    </p>
<h2 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4. 数组实例的 copyWithin()"></a>4. 数组实例的 copyWithin()</h2><p>会修改当前数组。<br><code>Array.prototype.copyWithin(target,[ start = 0, end = this.length])</code><br>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<h2 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5. 数组实例的 find() 和 findIndex()"></a>5. 数组实例的 find() 和 findIndex()</h2><p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。<br>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。<br>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)<span class="comment">// -1</span></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6. 数组实例的 fill()"></a>6. 数组实例的 fill()</h2><p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line">arr[<span class="number">0</span>].push(<span class="number">5</span>);</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7. 数组实例的 entries()，keys() 和 values()"></a>7. 数组实例的 entries()，keys() 和 values()</h2><p>用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，<br>唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8. 数组实例的 includes()"></a>8. 数组实例的 includes()</h2><p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。     </p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。<br><code>[NaN].includes(NaN) // true</code>   </p>
<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。<br>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</p>
<h2 id="9-数组实例的-flat-，flatMap"><a href="#9-数组实例的-flat-，flatMap" class="headerlink" title="9. 数组实例的 flat()，flatMap()"></a>9. 数组实例的 flat()，flatMap()</h2><p>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。<br>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。<br>如果原数组有空位，flat()方法会跳过空位。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat() <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。<br>flatMap()只能展开一层数组。<br>flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。<br>flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])  <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])  <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure></p>
<h2 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10. 数组的空位"></a>10. 数组的空位</h2><p>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。  </p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
<p>ES6 则是明确将空位转为undefined。<br>Array.from方法会将数组的空位，转为undefined<br>扩展运算符（…）也会将空位转为undefined。<br>copyWithin()会连空位一起拷贝。<br>fill()会将空位视为正常的数组位置。<br>for…of循环也会遍历空位。      </p>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。   </p>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。    </p>
<p style="text-align:right">16:17 </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的扩展</title>
    <url>/w3/es/ECMAScript6%E5%85%A5%E9%97%A8/7-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.9.6 星期四 14:15 </p>

<p>1. 函数参数的默认值<br>2. rest 参数<br>3. 严格模式<br>4. name 属性<br>5. 箭头函数<br>6. 双冒号运算符<br>7. 尾调用优化<br>8. 函数参数的尾逗号 </p>
<a id="more"></a>
<h2 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1. 函数参数的默认值"></a>1. 函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">'World'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>参数变量是默认声明的，所以不能用let或const再次声明。<br>使用参数默认值时，函数不能有同名参数。<br>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br><span class="line">x =<span class="number">200</span>;</span><br><span class="line">foo() <span class="comment">// 201</span></span><br></pre></td></tr></table></figure></p>
<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">'http://example.com'</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line">fetch(<span class="string">'http://example.com'</span>) <span class="comment">// "GET"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为练习，请问下面两种写法有什么差别？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。    </p>
<h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。    </p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。<br>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。     </p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'outer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = (</span>) =&gt; <span class="title">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'inner'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。        </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。</span></span><br><span class="line"><span class="comment">    这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。</span></span><br><span class="line"><span class="comment">    函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进:如果将var x = 3的var去除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。<br>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">// Error: Missing parameter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = undefined</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2. rest 参数"></a>2. rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。<br>rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<br>函数的length属性，不包括 rest 参数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure></p>
<h2 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。<br>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。     </p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。<br>第二种是把函数包在一个无参数的立即执行函数里面。    </p>
<h2 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4. name 属性"></a>4. name 属性</h2><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。<br>需要注意的是，ES6 对这个属性的行为做出了一些修改。  </p>
<p>#### 1 如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。<br>#### 2 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。<br>#### 3 Function构造函数返回的函数实例，name属性的值为anonymous。<br>#### 4 bind返回的函数，name属性值会加上bound前缀。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #### 1</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f.name <span class="comment">// "" // ES5</span></span><br><span class="line">f.name <span class="comment">// "f" // ES6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 2</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">bar.name <span class="comment">// "baz" // ES5</span></span><br><span class="line">bar.name <span class="comment">// "baz" // ES6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 3</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。<br>1) 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。<br>2) 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。<br>3) 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<br>$PS: 如果只有一条语句,没有大括号,默认是返回该语句 的值,比如上面返回一个对象<br>4) 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。<br>5) 箭头函数可以与变量解构结合使用。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">// ## 1 </span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// ## 2 </span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line"><span class="comment">// ## 3</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"><span class="comment">// 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。      </span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。</span></span><br><span class="line"><span class="comment">// ## 4 </span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br><span class="line"><span class="comment">// ## 5 </span></span><br><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数使得表达更加简洁。<br>箭头函数的一个用处是简化回调函数。<br>下面是 rest 参数与箭头函数结合的例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;  </span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;  </span><br><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>箭头函数有几个使用注意点。<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。  </p>
<p>1) 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。<br>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。<br>2) 正是因为它没有this，所以也就不能用作构造函数。<br>3) 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。(bind方法无效，内部的this指向外部的this。)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## $PS1 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;  <span class="comment">// window</span></span><br><span class="line">    <span class="keyword">const</span> goo=<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// window</span></span><br><span class="line">    bar(); <span class="comment">// 非箭头函数,调用对象window.foo(), 指向window</span></span><br><span class="line">    goo()  <span class="comment">// 箭头函数 定义时所在的对象: window</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// ## $PS2 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = <span class="number">0</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// setTimeout(function () &#123;console.log(this)&#125;, 1000);  // 始终是window</span></span><br><span class="line">&#125;</span><br><span class="line">Timer();  <span class="comment">// window,window   // 箭头函数 定义时所在的对象: window</span></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();  <span class="comment">// Timer, window  // 箭头函数 就是定义时所在的对象: new 操作符,this指当前对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 4  请问下面的代码之中有几个this？: 只有一个this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// $PS: f()()() // id: 1 // 需要 三次 调用,即() ,才可以执行到最内层的函数. foo执行了一次</span></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure></p>
<p>$PS: 箭头函数没有this,但是指向固定:就是定义时所在的对象，而不是使用时所在的对象。结合下面    </p>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。<br>第一个场合是定义函数的方法，且该方法内部包括this。<br>第二个场合是需要动态this的时候，也不应使用箭头函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;, <span class="comment">// window : 箭头函数指向固定:就是定义时所在的对象:定义cat时的对象window</span></span><br><span class="line">  jumps:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;  <span class="comment">// cat  使用时所在的对象cat</span></span><br><span class="line">&#125;</span><br><span class="line">cat.jumps(); <span class="comment">// </span></span><br><span class="line"><span class="comment">// ## 2 </span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'press'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $PS: react的事件处理, 用箭头函数绑定 this:始终指向定义时的对象</span></span><br><span class="line"><span class="comment">//  ### 1 这里使用箭头绑定方法.   警告：这个语法是实验性的！</span></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.state.message);</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;input </span><br><span class="line">            <span class="comment">// ### 2</span></span><br><span class="line">            onChange=&#123;(e)=&gt;&#123;<span class="keyword">this</span>.handleChange(e)&#125;&#125;</span><br><span class="line">            <span class="comment">// ### 3 </span></span><br><span class="line">            onChange=&#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.changTextValue() &#125;.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。<br>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。     </p>
<h2 id="6-双冒号运算符"><a href="#6-双冒号运算符" class="headerlink" title="6. 双冒号运算符"></a>6. 双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。    </p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。<br>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。      </p>
<h2 id="8-函数参数的尾逗号"><a href="#8-函数参数的尾逗号" class="headerlink" title="8. 函数参数的尾逗号"></a>8. 函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。<br>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。      </p>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。    </p>
<p style="text-align:right">15:05 </p>

<h2 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7. 尾调用优化"></a>7. 尾调用优化</h2><h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h3><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h3>]]></content>
      <categories>
        <category>w3</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue文档</title>
    <url>/w3/jslib/vuejs%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p></p><p style="text-align:right">2018.9.3 星期</p>
<h1 id="Ⅰ-基础"><a href="#Ⅰ-基础" class="headerlink" title="Ⅰ 基础"></a>Ⅰ 基础</h1><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><h2 id="二-介绍"><a href="#二-介绍" class="headerlink" title="二 介绍"></a>二 介绍</h2><p>1. Vue.js 是什么<br>1. 起步<br>1. 声明式渲染<br>1. 条件与循环<br>1. 处理用户输入<br>1. 组件化应用构建<br>1. 与自定义元素的关系<br>1. 准备好了吗？</p>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h2 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h2><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h1 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h1><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h2><h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h1 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h1><h2 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h2><h2 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h2><h1 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h1><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h2 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h2><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h2><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="TypeScript-支持"><a href="#TypeScript-支持" class="headerlink" title="TypeScript 支持"></a>TypeScript 支持</h2><h1 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><h1 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h1><h2 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h2><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><h2 id="从-Vue-1-x-迁移"><a href="#从-Vue-1-x-迁移" class="headerlink" title="从 Vue 1.x 迁移"></a>从 Vue 1.x 迁移</h2><h2 id="从-Vue-Router-0-7-x-迁移"><a href="#从-Vue-Router-0-7-x-迁移" class="headerlink" title="从 Vue Router 0.7.x 迁移"></a>从 Vue Router 0.7.x 迁移</h2><h2 id="从-Vuex-0-6-x-迁移到-1-0"><a href="#从-Vuex-0-6-x-迁移到-1-0" class="headerlink" title="从 Vuex 0.6.x 迁移到 1.0"></a>从 Vuex 0.6.x 迁移到 1.0</h2><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架"></a>对比其他框架</h2><h2 id="加入-Vue-js-社区"><a href="#加入-Vue-js-社区" class="headerlink" title="加入 Vue.js 社区"></a>加入 Vue.js 社区</h2><h2 id="认识团队"><a href="#认识团队" class="headerlink" title="认识团队"></a>认识团队</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
      </categories>
  </entry>
  <entry>
    <title>Vue文档-基础</title>
    <url>/w3/jslib/vuejs%E6%96%87%E6%A1%A3/vuejs%E6%96%87%E6%A1%A31-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p># B 深入了解组件</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 组件注册</li>
<li style="list-style: none"><input type="checkbox" checked> Prop</li>
<li style="list-style: none"><input type="checkbox"> 自定义事件</li>
<li style="list-style: none"><input type="checkbox"> 插槽: 作用域插槽</li>
<li style="list-style: none"><input type="checkbox"> 动态组件 &amp; 异步组件</li>
<li style="list-style: none"><input type="checkbox"> 处理边界情况<br># C 过渡 &amp; 动画</li>
<li style="list-style: none"><input type="checkbox"> 进入/离开 &amp; 列表过渡</li>
<li style="list-style: none"><input type="checkbox"> 状态过渡<br># D 可复用性 &amp; 组合</li>
<li style="list-style: none"><input type="checkbox"> 混入</li>
<li style="list-style: none"><input type="checkbox" checked> 自定义指令</li>
<li style="list-style: none"><input type="checkbox"> 渲染函数 &amp; JSX</li>
<li style="list-style: none"><input type="checkbox" checked> <del>插件</del></li>
<li><p>[x] 过滤器</p>
</li>
<li><p>[ ] <a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>    </p>
</li>
</ul>
<p style="text-align:right">2018.9.3 星期一</p><br><p style="text-align:right">2018.11.2 星期五 10:28 2nd</p>


<h1 id="A-基础"><a href="#A-基础" class="headerlink" title="A 基础"></a>A 基础</h1><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><h2 id="二-介绍"><a href="#二-介绍" class="headerlink" title="二 介绍"></a>二 介绍</h2><p>1. Vue.js 是什么<br>1. 起步<br>1. 声明式渲染<br>1. 条件与循环<br>1. 处理用户输入<br>1. 组件化应用构建<br>1. 与自定义元素的关系<br>1. 准备好了吗？    </p>
<h2 id="三-Vue-实例"><a href="#三-Vue-实例" class="headerlink" title="三 Vue 实例"></a>三 Vue 实例</h2><p>创建一个 Vue 实例<br>数据与方法<br>实例生命周期钩子<br>生命周期钩子的 this 上下文指向调用它的 Vue 实例。   </p>
<blockquote>
<p>不要在选项属性或回调上使用箭头函数，因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，<br><!-- 
$PS: react使用ES6 class定义,this指向当前实例. vue通过new Vue()创建一个vue实例.单文件组件中this指当前组件. react事件绑定中要通过箭头函数让this指向定义时上下文即实例,否则值向当前react元素/dom    
$PS: vue的组件和react的组件有什么区别: vue.component('',{}); extends React.Component{},还有vue的单文件组件. react每个组件都有一个render函数,最后通过根 ReactDOM.render(<App/>,id)挂载;    
$PS: vue 是 new Vue({el:id,data,..}). 可以有创建多个vue实例  
 --><br><img src="http://you img base url/https://cn.vuejs.org/images/lifecycle.png?e=1585218234&token=your qiniu access key:f1n1h_XW5cURHYO9Vqx3TZzzWS0=" alt="生命周期图示"><br>beforeCreate,created,  beforeMount,mounted,   beforeDestroy,destroyed<br>beforeUpdate,updated     </p>
</blockquote>
<p>$PS_react生命周期: constructor,getDerivedStateFromProps,render,componentDidMount,componentWillUnmount,  shouldComponentUpdate,getSnapsBeforeUpdate,componentDidUpdate   </p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h2 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h2><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><p>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。        </p>
<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的：        </p>
<p>0 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：<br>1 通过 Prop 向子组件传递数据<br>2 通过事件向父级组件发送消息<br>Vue 实例提供了一个自定义事件的系统来解决这个问题。我们可以调用内建的 $emit 方法并传入事件的名字，来向父级组件触发一个事件：<br>$emit 的第二个参数来提供这个值,在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">"post in posts"</span></span><br><span class="line">  v-bind:key=<span class="string">"post.id"</span></span><br><span class="line">  v-bind:post=<span class="string">"post"</span></span><br><span class="line">  v-on:enlarge-text=<span class="string">"postFontSize += 0.1"</span></span><br><span class="line">  v-on:enlarge-text=<span class="string">"onEnlargeText"</span> <span class="comment">// ### 传递值</span></span><br><span class="line">&gt;&lt;<span class="regexp">/blog-post&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ### 传递值</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  onEnlargeText: function (enlargeAmount) &#123;</span></span><br><span class="line"><span class="regexp">    this.postFontSize += enlargeAmount</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局定义</span></span><br><span class="line"><span class="regexp">Vue.component('blog-post', &#123;</span></span><br><span class="line"><span class="regexp">  props: ['post'],</span></span><br><span class="line"><span class="regexp">  template: `</span></span><br><span class="line"><span class="regexp">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/</span>h3&gt;</span><br><span class="line">      &lt;div v-html=<span class="string">"post.content"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button v-on:click="$emit('enlarge-text,0.1')"&gt; Enlarge text &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  `</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p>### 在组件上使用 v-model<br>### 通过插槽分发内容<br>### 动态组件 is  <code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</code><br>### 解析 DOM 模板时的注意事项<br>幸好这个特殊的 is 特性给了我们一个变通的办法：<br>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：    </p>
<ul>
<li>字符串 (例如：template: ‘…’)</li>
<li>单文件组件 (.vue)</li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>   </li>
</ul>
<h1 id="B-深入了解组件"><a href="#B-深入了解组件" class="headerlink" title="B 深入了解组件"></a>B 深入了解组件</h1><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>全局注册Vue.component   在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。<br>局部注册 然后在 components 选项中定义你想要使用的组件  注意局部注册的组件在其子组件中不可用,也需要在components选项中定义要使用的组件($PS:全局注册的不需要)   </p>
<p>### 模块系统<br>通过 import/require 使用一个模块系统，<br>局部注册:然后你需要在局部注册之前导入每个你想使用的组件。<br>基础组件的自动化全局注册:幸好如果你使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。    </p>
<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><p>### 单向数据流<br>###<br>### Prop 验证<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        propA:<span class="built_in">Number</span>,/[<span class="built_in">String</span>, <span class="built_in">Number</span>],/&#123;<span class="attr">type</span>:<span class="number">7</span>类型/自定义构造函数,<span class="built_in">require</span>,<span class="attr">default</span>:type/funciton,validator,&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>### 非 Prop 的特性<br>一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性。<br>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。<br>### 替换/合并已有的特性<br>对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值。庆幸的是，class 和 style 特性会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<br>### 禁用特性继承<br>如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false   </p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>### 事件名<br>同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。  </p>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)  </p>
<p>因此，我们推荐你始终使用 kebab-case 的事件名。<br>### 自定义组件的 v-model<br>### 将原生事件绑定到组件<br>### .sync 修饰符  </p>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>具名插槽: 有些时候我们需要多个插槽。    </p>
<p><slot> 元素有一个特殊的特性：name。这个特性可以用来定义额外的插槽：<br>在一个父组件的 <template> 元素上使用 slot 特性：<br>另一种 slot 特性的用法是直接用在一个普通的元素上：<br>我们还是可以保留一个未命名插槽，这个插槽是默认插槽，也就是说它会作为所有未匹配到插槽的内容的统一出口。    </template></slot></p>
<p>### 插槽的默认内容: 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。<br>### 编译作用域: 该插槽可以访问跟这个模板的其它地方相同的实例属性  </p>
<blockquote>
<p>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译<br>### 作用域插槽  </p>
</blockquote>
<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h2><h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h1 id="C-过渡-amp-动画"><a href="#C-过渡-amp-动画" class="headerlink" title="C 过渡 &amp; 动画"></a>C 过渡 &amp; 动画</h1><h2 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h2><h2 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h2><h1 id="D-可复用性-amp-组合"><a href="#D-可复用性-amp-组合" class="headerlink" title="D 可复用性 &amp; 组合"></a>D 可复用性 &amp; 组合</h1><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind,inserted,update,componentUpdated,unbind.<br>指令钩子函数会被传入以下参数：el,binding:{name,value,oldvalue,expression,arg,modifiers},vnode,oldvalue  </p>
<blockquote>
<p>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。<br>### 函数简写:你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子<br>### 对象字面量<br>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 1 全局 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ## 2 如果想注册局部指令，组件中也接受一个 directives 的选项：</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h2><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>$LUE   </p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ## 2 你可以在一个组件的选项中定义本地的过滤器：  </span></span><br><span class="line">filters: &#123;</span><br><span class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 1 或者在创建 Vue 实例之前全局定义过滤器：     </span></span><br><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="E-工具"><a href="#E-工具" class="headerlink" title="E 工具"></a>E 工具</h1><h2 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h2><p>### 不使用构建工具<br>### 使用构建工具: webpack 或 Browserify 类似的构建工具时，Vue 源码会根据 process.env.NODE_ENV ;Rollup 使用 rollup-plugin-replace：<br>### 模板预编译<br>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>### 提取组件的 CSS<br>当使用单文件组件时，组件内的 CSS 会以 <code>&lt;style&gt;</code> 标签的方式通过 JavaScript 动态注入。<br>将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。  webpack + vue-loader,其他..<br>### 跟踪运行时错误  </p>
<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>我们使用 Vue.component 来定义全局组件，紧接着用 <code>new Vue({ el: &#39;#container &#39;})</code> 在每个页面内指定一个容器元素。    </p>
<ol>
<li>全局定义 (Global definitions) </li>
<li>字符串模板 (String templates) 缺乏语法高亮，</li>
<li>不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>
<li>没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel </li>
</ol>
<p>单文件组件:  完整语法高亮,CommonJS 模块,组件作用域的 CSS<br>可以使用预处理器来构建简洁和功能更丰富的组件        </p>
<p>### 怎么看待关注点分离？<br>关注点分离不等于文件类型分离。<br>在一个组件里，其模板、逻辑和样式是内部耦合的，并且把他们搭配在一起实际上使得组件更加内聚且更可维护。    </p>
<p>即便你不喜欢单文件组件，你仍然可以把 JavaScript、CSS 分离成独立的文件然后做到热重载和预编译。   </p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><del>单元测试</del></h2><h2 id="TypeScript-支持"><a href="#TypeScript-支持" class="headerlink" title="TypeScript 支持"></a><del>TypeScript 支持</del></h2><h1 id="F-规模化"><a href="#F-规模化" class="headerlink" title="F 规模化"></a>F 规模化</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>官方 vue-router, 整合第三方如 Page.js 或者 Director   </p>
<p>$TODO: vue-router   </p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>类 Flux 状态管理的官方实现:vuex<br>Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 Vue 一起使用。Vuex 区别在于它是一个专门为 Vue 应用所设计。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改善过的开发体验。     </p>
<p>1) vue 应用中原始数据对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享<br>2) 为了解决这个问题，我们采用一个简单的 store 模式：<br>此外，每个实例/组件仍然可以拥有和管理自己的私有状态：   </p>
<p>2) 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们<strong>最终达成了 Flux 架构</strong>。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。</p>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a><del>服务端渲染</del></h2><h1 id="G-内在"><a href="#G-内在" class="headerlink" title="G 内在"></a>G 内在</h1><h2 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h2><p>$BLOB: vuejs文档-深入响应式原理<br><img src="http://you img base url/https://cn.vuejs.org/images/data.png?e=1585218234&token=your qiniu access key:O9Hcs1kKCTXF0SH8xaNph_IoauQ=" alt="如何追踪变化.png">   </p>
<p>### 检测变化的注意事项<br>受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。<br>### 声明响应式属性<br>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值：<br>### 异步更新队列<br>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。<br>Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p>
<p>1) 全局 $PS: 不采用<br>2) 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上：<br>$PS: angularjs: <code>$scope.$apply(function(){$scope.data=newData})</code><br>3) 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'没有更新'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123; <span class="comment">// 2 this.$nextTick(callback)</span></span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'更新完成'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '没有更新'</span></span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '更新完成'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123; <span class="comment">// 3 async/await  </span></span><br><span class="line">    <span class="keyword">async</span> updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">'updated'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '未更新'</span></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">this</span>.$nextTick()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '已更新'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="H-迁移"><a href="#H-迁移" class="headerlink" title="H 迁移"></a>H 迁移</h1><h2 id="从-Vue-1-x-迁移"><a href="#从-Vue-1-x-迁移" class="headerlink" title="从 Vue 1.x 迁移"></a>从 Vue 1.x 迁移</h2><h2 id="从-Vue-Router-0-7-x-迁移"><a href="#从-Vue-Router-0-7-x-迁移" class="headerlink" title="从 Vue Router 0.7.x 迁移"></a>从 Vue Router 0.7.x 迁移</h2><h2 id="从-Vuex-0-6-x-迁移到-1-0"><a href="#从-Vuex-0-6-x-迁移到-1-0" class="headerlink" title="从 Vuex 0.6.x 迁移到 1.0"></a>从 Vuex 0.6.x 迁移到 1.0</h2><h1 id="I-更多"><a href="#I-更多" class="headerlink" title="I 更多"></a>I 更多</h1><h2 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架"></a>对比其他框架</h2><h2 id="加入-Vue-js-社区"><a href="#加入-Vue-js-社区" class="headerlink" title="加入 Vue.js 社区"></a>加入 Vue.js 社区</h2><h2 id="认识团队"><a href="#认识团队" class="headerlink" title="认识团队"></a>认识团队</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
        <category>vuejs文档</category>
      </categories>
  </entry>
  <entry>
    <title>WebRTC研究</title>
    <url>/sum/others/WebRTC%E7%A0%94%E7%A9%B6(015)/</url>
    <content><![CDATA[<!-- 2017年底，研究了webrtc；没有用到 -->
<p style="text-align:right">2018.8.27 星期一 10:11</p>

<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>Real time communication with WebRTC:<a href="https://codelabs.developers.google.com/codelabs/webrtc-web/" target="_blank" rel="noopener">https://codelabs.developers.google.com/codelabs/webrtc-web/</a><br>WebRTC samples: <a href="https://webrtc.github.io/samples/" target="_blank" rel="noopener">https://webrtc.github.io/samples/</a>  </p>
<p><img src="http://you img base url/../assets/images/WebRTC架构图.jpg?e=1585218234&token=your qiniu access key:PqhYTzZfWaB_F9tpQKksrOMHepw=" alt="WebRTC架构图">     </p>
<p># <a href="https://blog.coding.net/blog/getting-started-with-webrtc" target="_blank" rel="noopener">[WebRTC 的前世今生]</a>    </p>
<p>换一句话说，WebRTC 需要四中服务类型的信息。<br><em>用户发现和通信。
</em>Signaling。<br><em>NAT/防火墙穿透。
</em>当端到端通信失败时，采用 Relay 服务通信。</p>
<p>NAT 穿透、端到端连接、用户发现和建立信令服务器超过了本文范畴。我想说的是，STUN 协议和它的延伸 ICE 冰框架可以使用 RTCPeerConnection 处理 NAT 和其他网络变化。</p>
<p>ICE 是一个连接端到端的框架，例如视频客户端。最初，ICE 尝试直接连接，通过采用 UDP 实现更少延迟，在这个过程中，STUN 服务有一个简单的任务：使一个在防火墙后面的设备找出公网 IP 和端口。Google 有两个 STUN 服务器，其中一个在 apprtc.appspot.com 个例子中就使用了。</p>
<p># <a href="https://segmentfault.com/a/1190000000436544" target="_blank" rel="noopener">[使用WebRTC搭建前端视频聊天室——入门篇]</a><br>三个接口<br>WebRTC实现了三个API，分别是:   </p>
<ul>
<li>MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流</li>
<li>RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件</li>
<li>RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据</li>
</ul>
<p><code>var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia ||navigator.msGetUserMedia);</code> </p>
<p>约束对象（Constraints）<br>RTCPeerConnection<br>信令  </p>
<ul>
<li>session的信息：用来初始化通信还有报错</li>
<li>网络配置：比如IP地址和端口啥的</li>
<li>媒体适配：发送方和接收方的浏览器能够接受什么样的编码器和分辨率</li>
</ul>
<p>通过服务器建立信道      </p>
<p>NAT/防火墙穿越技术<br>建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越</p>
<p>ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。</p>
<h2 id="WebRTC通信流程"><a href="#WebRTC通信流程" class="headerlink" title="WebRTC通信流程"></a>WebRTC通信流程</h2><p># <a href="https://www.bbsmax.com/A/amd0Dxqdge/" target="_blank" rel="noopener">WebRTC通信流程</a><br><img src="http://you img base url/../assets/images/WebRTC通信流程.png?e=1585218234&token=your qiniu access key:IqrdggqMGHo3Oo9shCRzO3oST5s=" alt="WebRTC通信流程"><br><!-- ![Alt text](/path/to/img.jpg "Optional title") --><br>上述序列中，WebRTC并不提供Stun服务器和Signal服务器，服务器端需要自己实现。Stun服务器可以用google提供的实现stun协议的测试服务器（stun:stun.l.google.com:19302），Signal服务器则完全需要自己实现了，它需要在ClientA和ClientB之间传送彼此的SDP信息和candidate信息，ClientA和ClientB通过这些信息建立P2P连接来传送音视频数据。由于网络环境的复杂性，并不是所有的客户端之间都能够建立P2P连接，这种情况下就需要有个relay服务器做音视频数据的中转，本文本着源码剖析的态度，这种情况就不考虑了。这里说明一下， stun/turn、relay服务器的实现在WebRTC源码中都有示例，真是个名副其实的大宝库。</p>
<p>上述序列中，标注的场景是ClientA向ClientB发起对聊请求，调用描述如下：    </p>
<ol>
<li>ClientA首先创建PeerConnection对象，然后打开本地音视频设备，将音视频数据封装成MediaStream添加到PeerConnection中。</li>
<li>ClientA调用PeerConnection的CreateOffer方法创建一个用于offer的SDP对象，SDP对象中保存当前音视频的相关参数。ClientA通过PeerConnection的SetLocalDescription方法将该SDP对象保存起来，并通过Signal服务器发送给ClientB。</li>
<li>ClientB接收到ClientA发送过的offer SDP对象，通过PeerConnection的SetRemoteDescription方法将其保存起来，并调用PeerConnection的CreateAnswer方法创建一个应答的SDP对象，通过PeerConnection的SetLocalDescription的方法保存该应答SDP对象并将它通过Signal服务器发送给ClientA。</li>
<li>ClientA接收到ClientB发送过来的应答SDP对象，将其通过PeerConnection的SetRemoteDescription方法保存起来。</li>
<li>在SDP信息的offer/answer流程中，ClientA和ClientB已经根据SDP信息创建好相应的音频Channel和视频Channel并开启Candidate数据的收集，Candidate数据可以简单地理解成Client端的IP地址信息（本地IP地址、公网IP地址、Relay服务端分配的地址）。</li>
<li>当ClientA收集到Candidate信息后，PeerConnection会通过OnIceCandidate接口给ClientA发送通知，ClientA将收到的Candidate信息通过Signal服务器发送给ClientB，ClientB通过PeerConnection的AddIceCandidate方法保存起来。同样的操作ClientB对ClientA再来一次。</li>
<li>这样ClientA和ClientB就已经建立了音视频传输的P2P通道，ClientB接收到ClientA传送过来的音视频流，会通过PeerConnection的OnAddStream回调接口返回一个标识ClientA端音视频流的MediaStream对象，在ClientB端渲染出来即可。同样操作也适应ClientB到ClientA的音视频流的传输。</li>
</ol>
<p># <a href="http://www.voidcn.com/article/p-ywdhlyyo-bqs.html" target="_blank" rel="noopener">webRTC——浏览器里的音视频通话</a>  </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如图，浏览器之间媒体流的传输是 P2P 的，但是这并不意味着 webRTC 不需要服务器支持。<br>建立 P2P 视频连接需要的信息，如用来初始化通信的 session 信息，双方的 ip、端口，视频分辨率，编解码格式等等，还是需要通过服务器来传输的。<br>webRTC 没有规定这些信息传输的机制，XHR、webSocket、Socket.io 等都是可以的，因为 Socket.io 自带了房间的概念，便于双向视频的撮合，所以我在 demo 里选择了 Socket.io。      </p>
<p>当然，连接建立的过程不会这么简单。首先，提到 P2P 就绕不开 NAT(Network Address Translation)，webRTC 使用 ICE(Interactive Connectivity Establishment) 框架，ICE 是一种综合性的 NAT 穿越技术，它整合了 STUN、TURN。当穿越网络时，ICE 会先尝试 STUN，查出自己位于哪种类型的 NAT 之后以及 NAT 为某一个本地端口所绑定的 Internet 端端口从而建立 UDP 连接，如果失败了 ICE 就会再尝试 TCP(先尝试 HTTP，再尝试 HTTPS)，如果仍然失败就使用中继的 TURN 服务器。    </p>
<p>再来看看建立连接过程中的具体步骤：<br>1. 调用 getUserMedia 获取本地的 MediaStreams；<br>2. 从 STUN 获取自己的外网 IP 及端口，通过 Signaling Server 向对方发送 Offer(SDP 协议)，并收到 Answer；<br>3. 同时 webRTC 会生成一些包含自己的内网、外网 IP 等信息的 candidate，同样通过 Signaling Server 相互传输；<br>4. 建立 P2P 连接，传输媒体信息。   </p>
<h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><p>### 兼容性<br>IOS: 只有最新的 ios11 支持 webRTC，且仅限 safari 浏览器，微信内置浏览器尚不支持 getUserMedia, 不支持 DataChannel，视频编解码格式为 H.264；<br>Android: 安卓 4.4 以上 (不含 4.4)，经测试各大手机厂商自带浏览器均不支持 getUserMedia，但微信内置浏览器可以正常运行，另外 61 版本以上的 Chrome for Android 也都支持；<br>PC: Chrome49 以上，Firefox55 以上，Edge 支持，Safari 只有 11 支持，IE 不支持。  </p>
<p>### 性能<br>诚然 webRTC 在回声消除，图像编解码等方面已经做得十分出色，但它在性能上的问题还是不可忽视的：<br>由于需要进行视频编解码，所以 CPU 占用率非常高，尤其是在移动设备上；<br>在移动设备上获取的视频分辨率有限，最高只能达到 640 * 480；<br>带宽有限时，音视频质量较差，延时明显；      </p>
<p>综上所述，虽然 webRTC 具有不需安装插件或者客户端，开源免费，强大的网络穿透能力，出色的音视频处理技术等等优点，但由于兼容性及性能上的问题，要投入到生产中还需要时间，主要是 IOS11 的普及以及 CPU 占用率和延时的问题。</p>
<p># WebRTC - Kevin - aculearn<br>WebRTC is future    </p>
<ul>
<li>It is the best implementation of A/V transfer over Internet     </li>
<li>Audio is fantastic, Video is OK, transmission a little bit old fashion. SDP is not beautiful    </li>
<li>WebRTC’s bandwidth adaptation is amazing, but only with its own stacks  </li>
</ul>
<p>Problems    </p>
<ul>
<li>It is designed for P2P, when move to video conference or webcast, you will need a good media server. </li>
<li>So far no Opensource SFU proved to be scalable and stable, need more test run on product env. (we will see a lot victim)</li>
</ul>
<p>Opensource SFU<br>Janus, mediasoup, licode, jitsi, kurento, and more<br>Can RTC clould service be a solution?   </p>
<p>Cost<br>Bandwidth and disk space is expansive, so unless you co-op with Telco or your application is very high  value, otherwise</p>
<p>hard to run a service by your own.<br>Cost: VOD &gt; webcast &gt; Conferencing<br>Tech: VOD &lt; webcast &lt; Conferencing (1 magnitudes)   </p>
<h2 id="SFU"><a href="#SFU" class="headerlink" title="SFU"></a>SFU</h2><p>Signaling Server<br>SFU,MCF,*<br><img src="http://you img base url/../assets/images/WebRTC_SFU比较.jpg?e=1585218234&token=your qiniu access key:nN1qKrp4x8tsdkRcYd3z2HE0iTQ=" alt="WebRTC SFU比较">   </p>
<p>Intel® Collaboration Suite for WebRTC version 4.0.1:<a href="https://software.intel.com/sites/products/documentation/webrtc/js/index.html" target="_blank" rel="noopener">https://software.intel.com/sites/products/documentation/webrtc/js/index.html</a><br>Licode: <a href="https://chotis2.dit.upm.es/" target="_blank" rel="noopener">https://chotis2.dit.upm.es/</a><br>mediasoup:<a href="https://mediasoup.org/documentation/" target="_blank" rel="noopener">https://mediasoup.org/documentation/</a>   </p>
<!-- 
## 其他:   
WebRTC-ruan: <http://javascript.ruanyifeng.com/htmlapi/webrtc.html>

[WebRTC学习之一：开篇](https://blog.csdn.net/caoshangpa/article/details/53306992)   
[使用WebRTC搭建前端视频聊天室——信令篇](https://blog.csdn.net/dragonrxl/article/details/38928511)    

[WebRTC实时通信系列教程1 介绍](https://blog.csdn.net/Leytton/article/details/76696372?fps=1&locationNum=2)  
[敬我岁月无波澜](https://blog.csdn.net/gupar/article/category/5629961)  
[二刀流的博客](https://blog.csdn.net/SanBaDao/article/category/6413127)     
 -->
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>浏览器实现不一样需要兼容;有兼容api的库<br>ff可能读不到label;如果有多个设备会让用户选择<br>chrome会打开一个默认(是不是指定不确认),保存在浏览器摄像头设置中   </p>
<p>也有录制的插件/库,录制摄像头和本机都可以    </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>webRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>微博数据爬取</title>
    <url>/sum/others/%E5%BE%AE%E5%8D%9A%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<script src=/js/crypto-js.js></script>
<script>
function doDecrypt (pwd, onError) {
	console.log('in doDecrypt');
	const txt = document.getElementById('enc_content').innerHTML;
	let plantext;
	try {
		const bytes = CryptoJS.AES.decrypt(txt, pwd);
		var plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {
			onError(err);
		}
		return;
	}
	document.getElementById('enc_content').innerHTML = plaintext;
	document.getElementById('enc_content').style.display = 'block';
	document.getElementById('enc_passwd').style.display = 'none';
	if(typeof MathJax !== 'undefined') {
		MathJax.Hub.Queue(
			['resetEquationNumbers', MathJax.InputJax.TeX],
			['PreProcess', MathJax.Hub],
			['Reprocess', MathJax.Hub]
		);
	}
}
</script>
<div id="enc_content" style="display:none">U2FsdGVkX18suhW8K5kbpHF2o+CPASFN/ltnifPAKQE8Hs3GSwx+BKqmXnVEnJxKdCgjYz7Ow6fVXrUD45mlP7HQvrNN+XU2DFn3J5CTPcZPHvOh4ys/sGF1kbRiKupgvTAGHHGzUxge2CGDTj59IB+vmYsVk4bh13qgNR9f777RiW3igxUWVg02iRILsj6vqyO40LQbm0hVtlBNSodbeJD7OYiy0lbMVOsg5E0MQhoa6S2pnyUks/5tmPSrgqwge0ate2Q8wpVKglHSjDeRpmMl0c4bk8N7Y4wUiZ0nGK6kQmTOuwEKUsCFNbNx9wx5KBH1aFuVRWGG96m9lher3Gzfb8LhTLycnTYN5wpzMm5ubxCHeyExZKUYUIYm7/7cFxa5q9S415XBbYMrORMlXYosZ+csnXldlUdeQgTIrKRFcZ8OmOJNcHOZ3ckEdTwwON7DUCJ3AfgHteQOqzyf1JA1Zi5yE2/z4OpGzbV1ApoKTyteXvlX85xe9zlWAQoGD5RikNmwkdc+bX1hy3J0wEkJwjU64seUBaUO6FOJmg5WkbvzZWuXmY8tAy8qYac7kC47IKGIGrSeAY80SxZjkk3JBddgBVj1X0jFC/qQEzimrzyF734dFIrulr+0bCB6+Q3iN/tOkkp8Vv2OHkSgCfcMsdTqOAahypxMuv8PQQhsKinCjpQ9/w09QnDG7qzZhIt3PkaF+PFlNBN9rHDlz8Gdr2PjdLk/lB+WITfQSZeL/rZlzBZtTdhDExekhgHPL/f9uqkTuyhyVif2Em+dzCSt6A77RP1/vGjBKb2pvSTdCFWE3559d3Sqk5m3SWKc0aWUauvppscpgDtDv/cuCqlTk11BLv2sMMn84b8RciFbBwz3M40urcz1P2lVBWMq7n7Kb6rvlRtDJmWY5XTxZ2PSY+WCIEMaDq4NoluVZrS217T0RkkcUViqkRljNar4z9D1q86GruJ1ZMpYa3je/LBCOd/365oSs79NTFHGRnqPRXPcmC63Hzk5mOGXqHmbBQOtlpGkU2gs9tlGQhcNj6LCkZ1BB9G8arNUTnLvJ9tqDYA7/ntYn9dc5Yu90OpjUKsEJMvmLEAe4yFBk8rKICM1s98wJtlfFhRdOXRptzVDvGSyfUxvMR9Cyk7K0mP5pvPe2eCNQObAVJdnh0l08Tc18g+QC5CwUaQ4nJe902IwOholwQY9zfgbANqTgEC6heGkcDDzKe0T1GctLj46RMqZXOdAmDb8EVSYc8xSvbDKMFHU1p/+AK2mEo2ozEeriMT6JwE3FFPofWhgNomdQW2pJjD2Hp3VeSUQBglZGCCl8QPs8MUdB9pkD4QdUM2DuPuEt0aub1ci+hE8d3yjEYzDz3ir7iuLh5rlakSfNx9wGQwzfRtYMQtJramdUbgUYl9ZQkMJO2Gh3Nq5oOpJVL/EvLjozmaCk8oC22vaftk1pax3EzKySr+t744bV8oQ00A5TAS3hyTKBD3M/3XWG19Zvg2wLVE5Avp6c6sPna9AYi06NID/iAvCk21fPdDaX/GytfBKmRggHai20eXqa+C+aJvHLfB2EvSl4d2rlsQNyOSOQgrsrTdbKv3cKQlgYmjQPDNhsUAtz3vlu4IS0U6sk8lBmXADGdIOApmhM4AtPY8QiRHS5NIN6RetEekUKM73DjKpxKse3mNVjo2D0B+VsrEo9FNn9xWbRQf/GwPdRJCk7Wa5scP2aKjmjovnokil2ZbdnxD0JEWPaJvs9Tz0wkqcDTgfKUy4+u4kihCWX3wgD/++doYFxvRhXQnvRZv64eZ9S2UWutGZK4fqEhlLD1Z1de5PNL8o7Z/ZVZMDl35EXeigqzNB5JbV6qaLPnWU2HkpnQJ9MeXXdHnn2YniGLIQTeYRvmSlIoK8MmSM8HxcjsGkoJhaBq28N9TP8WTPXH7nbYEG7MQNo9sxSLwwHbAWHllZLKo7OH87M00ead2VEow9LtelHcQImgH/sfN95QHTQRc3ys+0M2UfTLaPbhWcLPZPF1hA+APvVOkOnei2OQUY6K7iRSXdKnZVhtyTB+JLRGG9fApjwV37p7axLgHpBIvr6g5ctR9ctFo1P7whxzPONSrCns91Qw+bopG/EGEpypE5nKYl8kYArLfJZ35/SBM9w5KqLS8BWAdbYPVtAn7FsgqGvP1cImYQjGSZIesTeys93JhmZEvOROi3OfEYmKxMMPHeTh6+Y1R7JP7HwaelB5At1JDuG1ri3HQrpyEhHpN16tqTUFw9CI7Qvp1v30qAmQhIOSr5Y95A84lp8DlMoICk7eHO/RnWR+igWR6H11ZYI/QIYnhcJ7lilPqXph5/wPy8toMQcmthjSy7IK2/jQq4ZllWIOAznziqSIHkG2OMB0XBAgTCb0BXOcMnD4e57/aoOnR9krVIXNs8N1KYfSR9X7PNxuzpazqXnn/9Rh91e8lH2YRtOUItvxCvQKnOZmTkpwMgNL2Nto6+Ly6uzuT3Z1C3YN+UpYtARfe0iRWN60BQ42PU6dQPUi2SXtMv+vGjVxCiI5uuQ7EEgNOAf6PBAyyMy4BaHEDqerp4qFm4Io/hFMZRHbVpVecDlJqDIYfJ6r1UnI58zFFSt/PXAvSpbXOLPJI6f/ng6VctlsYuxPFeEOigs1qpS0Q2YnS7AFJmgSJP8tVUQxkgp/IVtA7UZcTvBNK7ZevUNej36Bp8bslq4HDPXJljfIRsiY8I7bQU6D5fo0Oakl8ao3RPj4qYQhV8fb1Gg+UYvh2FGcD1tYr9T067mWSOnvKidw0efgIQpBF9NVQqlseWJpBAp8GQQ1zk+65ZBCnrLTYZPVP3qitqTymgLm9rlRX2hLC9w6U3kr6hBRumGX5kI1nhRaI2BH2aUOhnkT3ogfLg/8e7RUfEqdoQiGEi66No4soTNZ/RmlWkaXlzMRwn6EinLEI5TaDGoBtycLKEdV0rvsfZN30xsexr/r7ULXmllcEgmqumI1idt4RU7hNixHp81/teEmkxG6sUvmX6mvjsS1ZxPPWf4ux0c8ee+Vjhca87nZPUY5gHLRr/Ti6L2cqlkq95ocNZd12RLx00LTDkLm+KbWYVxh+CWIBvhyXGWYOtFUvT0Pb2SSN2Iat+8DXasQz+9MgLPksz9oobZ40g2+mxhD+cvu0lzDxFyzqNNAZZ04hehrnINyDmwG0NzyhWP6rymqdyEaThgep1UATX+EWJflebZ6NIGLySnH3xDfYG3SAhAdi4m1fgedxMerDR268x8wCg1XzxqoFO3jAORDS1qKG9r4g9cZ6Ss49yiNQgWJKI/+FIGsEUikZeeG3izftVzXtwa37Il0OOoWqbIE/Ebeg1ay3gcRRfO8XOfeKIHELbTef1UpOBmcn8xQ2BvL9R/oRBw5RYiW//Mw+O4MUiypI0ewqWy3+WvV5a+UMI+T0klP7wk/oAthu8KmNdmgLCDbYXG90S0nI/H8B9+gzijztxD9iEpuY+M0plRkXaXCCqxCQ59ikrsduievIxEaB2I6UreUmS8DmvS2oiT5rrL6SgVyKE+EU4isTFnTizrxB7pV0cBYOfMpeVqnbK266ArsuVlU3AeG8FOk3PQ4hUv2XzL8TmjL79tk8KpT5+hInJDstUZfHNdt1acLIDUVSebRpCQnS/X8iGQYG49RSXZDmOiRQeYoiwakFl1h9cHiz5VBXOUMpzfyR/JKJT1r0fsnkVwH5anq3hzP4CTjTGyzsOyXT2rLlDLknqyxnl7CBE0l/cLWtLyOyAi79e+8aAEu80DGd6PRMyyvpSaOWrbEBB/ih4z1dq3CwWJ6Ox9ufL69dn5tujP3wbl8ELkrJV+KwlqV5DSdw0OY2vrxXluEopoFgYFckRW6+qhxsG412dsuq/4xcOAtkRxXk/ZhBcvD0OVQUvJ7mrS9crLXgQDx7DTzxlo349PsXIl9tMa9EXLibqrGAI8P9RReciwVkHvRH6JwJzfDAq6aXVg1ULR65CA29X5T5QMYymFUUWEGQLTp0JvghVOHR9G+gsZ024vcdVO/amDAzA4Ge7aiciQgzcrJo656qPZ9VugYblod6Gb4l6ykSqTJ7pben1JpOASRVumF4pHA8wrtrg0WQhnkN8f88Wv2eOkLSYYxHZyhPyJQfy6Xb1MNQbrbQx/U80oDSzgqy8m62BJGtX6my6JFc7bb+wPw78xvJh2GaA4wS170sEkn52rWLFluLyoIDnhw0JiYPZFTKwhOWSybqTexqg7H6BeTJVU+O1Fr17b6dQzsZcIvcjNI2l8+41U7Hmev9NIc+D3/AE+xX2LZrDx2L1o88paN14n7XRmVGkQEliF9SyVujGKpKRXd9ilJonJsEPWzZinsh/29SESDRy5Egu97PAvsFoasS98lj3QNkS/yHIhVLuJxM/h9P4+QoMlOpnm7AarWk6hY2D2R/o52PpxL7WKHCYcHjZQdJNqGHgdQLkMXJQLlm/8MYYtFZ5/FY1yE7gLn8Z3y8eAgU3iJCm2lUpFA4b6RB9oXQHZfYrP0XB3pthDt+JgYX0chGrDDCMNNSWR6AcXbjufJya+zMBHVBIt51kAjoJGIot1SnZ4MsZ+EskFmvgRm2HFKIPNZst9kqQsGlIPZqBB1vbhNILCyzaP48Q/u9g6z4x0PAQlcv+GeI7hKf/y4wcfGCY2+RCzlbjnnITrkrPzFqGaAFNCoKAxCVitnbctIXaKAjRoTsxtrHO0V/EAl90CgcIrQph7UN6B6BGtjLthfnjdBJWfQ1quxASq9WYR3i6XhvrAdGhf8yDgQOOKqkZvSKkgGsI2VaHaJfhEX64eV/NJqmmRpLcGjX1I/48S8HTNrgAEScGHNE9vLW2dDGGCTdbcGkog7AatOSLs1LMj4fN/POfuX1bvoVwqMEA71uhrpd5gTIHb3QONZe4NUo03NTXNOShSuCawLQzCqgZ3sdKKG8RsYIcXl2+ZRob75Yl7jijrn3MlTFZv+G+obBWQ9gPpYx2yHCinzJHQaaas0OPEpRDQuZnhntLoVXdCzi2Y5KgKwoFCOFVEHgm173ZDUzFPhfs+RvBshXcj/msynVtowwD8Tyf6cQsLY4aTox++J+jcY+nhjSN1QkuGVWucMcp/oIe0gi3SCiir9ngRJdHvVpxuI83goczLmMCFtEDILKOjch/cePSCgEOolM6lEVUb+XSg2l4i1VfOVOgr6OsDL0v7EViREQsuEoKYoBSbqFOl4zXeMAZ9OvyZNijcfbZK9kblz4jJ8iNhavRV2lbjfZHlme+L+9H6r7V4TjNSFKb6yPJJ7f+tZRIhp/tqySiDAWC7q4A6p7O2v+j4C/XMOzq3KK1NcROcv1nA1mvV+P4I+EUMves4YXLMxMuuS54UufnlR6uZ8QGZ+LpkBNbYPi+pDBvhh/VXKpwDCnp/CKVFwyl2Wy1NMfMc/jnLSD8Cjzwo9lMJf3S/t+vOL6F8BG8uD/PO/JaHxjegaPtQDXNTJXkTOz4QdZcEsdHGiPYUfxySbGmdWT4sgRORzQDtVHeq/BPQVAO1Taajm5LbW5LDlax/laQCmUOVc3u0euR6juwi2EPURinf1beCfc5M8zAQHGb8FeiRx3JJ9Z+4mzepXu6nazsHf0545AqC4AJyYGSbl//PyaclXgrI05nlHVqv0jBxQuZVB3HMC3PP90IrLczfPjVfd5jzUCFQNf+vAbUJR0GfkELaVxvdJdbFVTMj160pu5LtKTD1cjEUXOIiU4MnG+zDD5W8bo++nv0ug2hBkl3ugOJHoKqMnbgzj1LkXu9wAr0+Q1jmHTbOr8PVRg8Q3ULEX2hT1INwM0PPjlES2EceAJ6QKssKD5Sc3VlyZPwsa+McKqs3Npl4LReo+l4En3TTj80gjJx14FejZB6UGBbC6bWkoGPHaR19EVHq2be0YGIvmdUVWI8BdF0Asn4+GyT/uxTzjzFjWenoUM0MN7I2jx4FuHtikZlEpWAvh+WhzGJGIo9edpBSo+p5RfSed4cAkmhsTG/QfsxnyfVqysAX1/rYmfGAcHPs5IoYrELho5Q2SYOWw58xzHX3OcdJoKhE4njMN8VDeWjhpcS/9Gsxkkz8L+yPZmdUthsbrxO2uXg4Y0wE3/s+YCccaLmb4JtxyGKD1g9FUxu3PNnJOH092avi03cCprZDwsXSC5OpMZrCH4SEa1caRTBryYUt/IcpVcjwOrBue46eaDPS9GoIL+FjPJ5FfdCAzs9cdRiyNn20aQAITY9IZItmOm8trZ1MEL64/dlFLD0S30FDYQKKfnQd6I1F1P/ln+VufTs9c2LngwXXZ9ovUYcqf3dvE/VLGFBOVxjrZDs0T4znWkTfBJn1OXiM0mI/0rUymR3rR5cQ+kFK0cnVtCB5FxyRo+wnMZg9Hecps0mscz3a6MxFi4azBr+fziBSfrINngoUwlTXYqk5C5jj/Ey2od+0GlXywqs4U/hiBYn/rTGEo/tzeLYNWm8JTILaWCl6vaHmE0QW7VpiyrceE9Uc2hdwptL9IHRX8371Vn3pmt3Ckr5Q/bCuzQwSIMtPUlqNEDnQm5VJ3IsdsZ8F3Fh9ugO6X6dI03tMlKBa5ATuP5YpQl2drsvSFxureXNz2qX7pFUKnjKaAzzkmK3PsnuTuR/iBgFozX8i/JGpRfd1+vIhH/g6VCcPzomlIQNyyCAWd6OLf7N2i95tWe97wmDB9zjDvfiDWvMgdQ7zi6fI5ajEeTJ/KFOdySGUOlQSPdHBqw304CJ+FKeHALwZSoUrvofJgVdc6AB5xWJDkCHNQWuuAOgn8Odwen9vjjrDziovObAaIOJYrJuO4Mh9UqdEOw+8MBnYdkX3tc3fpqjgQP0RG1mptCciXQUHRrGeUNcoP/GZP5e2Fr1P/E2JD39WVVKg6j9r7QdrHh5VyLm13FDuREdCMpoKUEUp/SLYFC7MCC5sGuvDFyrJzGZ4eh1gB3rUQ16bGj9/6X6OM/+HMTuF+jX0j3llySptg8ZFvVTySr8UwNhedjZ1I9LhawO4UoRrySftdfnD+Ct2s8OoVPrTQ5UplkPTJ1l3ls5E+v3WXfMjXVnOayEkFNgLF8LgvvtWf9WDkxhlGQuBFKSiAtsNP2vdSrT20XjHWqm/xlWtFGmz8kELsv4JGuK01YP/izohx3fFADa2DTHBu2IJexmsZiSdG+7W0nisl0ogY132Bl7L4p+d0H7RBZBJJdTn9QYE3OZr61u7qDj9kFFJZAZJweh0qhKV+EMZS4uAskvdKChDDZocPRQXpaEfh3a06reUIS/2D3I3OmuDH4KDWTq0H2hzniGLNnH6R3vXMUzycuor4leqRREfDZu6zzMEJ0hPgX1k1MkTT8wl1bOs3Aa45hAGotveHff5lLYrM6jdsKvvGpAQIwRHcB341qyFSd3e1wzKvCIKOvrXr3fdkwZ8EvI8L12xVmHpoW1HfK1kyUPrWM1BtHl8xeWx5QdbgABrF96BpPrvQOoCwpQW3dqXqBHJdpECLE3n2TlNHOHJ0JOmgpcrN4t1y50oOEIrdBaxvjPuU5dkPicqnifGlRJGlGvEPkyydr+8B4j9KwUbc+eHujjkjkQ5r50esZQoLoWQLkzQYtJEDcHc0j2HIsTeylIuoFU3Wc8oE5Y/e6Tu3kHiWluVNaGjAbzRWKy5r+1Zlxh9EdhEdT+V2KZLbrgaeNm7ltZnD5pPYP86/XXbiukBe30z4WqAyO9LeqGaAy6EKbyqfBKFCceVTUTcoxMudE8rh9ypNnPAzMongOqiF+vv1OSdrttP0F892y1M7CvrH8UW2QMSrV/1mq6oQFXDzdkwFb8sRQt0NwtA6lt+HVoYM1qqwMVMvWgH8pfz8KF1JrMAGfhMCXDqlxrFqB+QJBzHZv7RgTQqREE7oVXZfYr14JMyFJb2jmrKkFnMmrPjpoa6hLug1wna4/XCmHoPfCBALOMIKaIeaSJlu3e4INcdfRDWOynF0WvcDi4OycuoTx/Wl8X+63/GDe+dIiuG0+S1/aD/qatZxBfNEcPZnEUUxosEdZDMXwBAP8XmfInXBKWueTlel+PZ/0OXViyAkxfNBsNLx/ygHxnthvKJsi6s2pQF6/5QhQaGX3tQvAd6aspoq2znKvi8VE2s9YvpV9PA9quzUxcnWz90OwKKDryHd91xI79Eo6Oc4OnYyopHdAipAyNvTHv8NHmlC1z7kXAzGUpWHDG7kbU9uVfNyOwqEFkW7injRUlT+bWfzc0Hu3FBKZBvpt8TSA4EmBShtZF+fBS1W/KNOr7Saq5F92ir3jTExouBwyUvw+PBtdPaA3EtVMwcqDiWOFo6vp2NvPN/3MgwD3Xb944zoBia2CvBKDuEfGHhI0L2RqS/w8ZyywoAHfs0PS3M/tCY8sy7USj/fecJhh46ca1gNj0Pz0ede4QXONcnqWTKtJo+wK02Ma63JceL0ooRT19VagxRLZIBIfsEnTlfxVhqQwaHgeDtQFFfZW6FNO8CS+OuwUOE0bDO2iAi19BX4WAVVMqJ3zy3w6JsgT1Jb9yBtZjUT4MsMmSaJ5T2HJJAT+ejnUAMXL7b0yHdwObqfpEqg0KUEDVX22iCR4KNNDnZZioUjCsmKIG3oJ1bMlZXVpHKfM8WGeqI3IIqdCz87lPFQsWSFCvtkH6/8BWR/HyB82vHnqwuhKyc0j/bmwhludT1Abn3MFJ7SONJEVyGZZthkYaU4XneJp227qObJCMm2JhAftXBDg/2ibQE805asK/RRbkfACHAeKbNFlHTxR2Jqa6hEKVL0LVrVHWWzWVSKEQwb2rLecmd7gpL9GueOBEaD4ltlelN438/QBRqot1A7VEJJFi4+yhuXjvAT/h3IceSojZDC0MizTjIzsq4XnbP8xo/vGI3pyX0ePzn+273uhavhYhOrpq5OCXUPt91fsqCZlIT1CoqwVwcgbGO4kUSrCW9AUhuUtCkYVPn+6bl9lhrozaDiH9MX4h3vHIBLIxWnDwCiKI71ZAYtsSOmlXRlt0sUNql0fNjqLiDEyos/3MmtSL55WpNlyXyViPFjgj+Lqd0hpIZHo8e368MYWh/hP9nCvGlwU4BaHr1cVnP3Csk5sHlsvVPzpgjQ8zZxYd1oTCUQamZ9Kukwq9XtC6WUqX98fG06Vmr6jqQYoa3yZQbXDgf0I3yQe9WUaHhp6kTTgJD5nqm6tDYcZBjce6shPDfXpw5/qOSo5rxnTav8g0WmwLsuG6Ee5bhPtRW17k/IJLH79R3/6hBvTBF7kAswE4pT2Zg5wiGf5cpCAS6mbd/z09/spr8Sz9cnRFfuHIO2xS/4E37xGkVKKNcid5Mew40Gg9QbQP2vmmW5JfPHmT/H3Dd5STHC041yKqYMqi/vLDkogQMPhfvRCOw4f+FlwFS5Y8FPc+H/iWyF+h2lVy/E+CoWtF7fnuvbONKW9EUQi/xlAad8mLbkJCbfhLnXKh5dR+zfiXYHtZSTymJjq36UFfu7ZuXSunjDy49WVplO658TGM6HKHispKLqCgEQPD4RcfYGHtOqxDNg3uJBiW6nTpxU/L9n4nXdfcFm+WkcApwMFFJegGOqcAVc9AahID6edXrA7xcbyDSQS5XoNwIwwqqbEIYj3ryxPcfHYGYVAN6X3ooXZWA4CBLBFObKjQj+EZLDOCBzVeyJYRJG08Pjnc169toCjYLwhywKH435nyP8cNG6NqyBnWV4izupyM0qKZV5u2xQzwIJPMbclbTwgP8NBMxX0fvummFBEsYKT+pwHJ/lj1QPmw5yNWfqfrtR5Ggy7oGg20ZRCpd5zpNpLcRVcq8i/hxnFTjBxqHrd+lNvmpcaoZFlo4MJcXFzkbN3xz2Df9r/wT3ayM+4JDBIUnW5g/zh9ksN0iFuHGEdw83bpIKTix3nOtIs38avTvT46Rdy9o9p6uBfOjv0luQQgPLrSvCbZO1CS8wzZMXLBouOgT7izyTcETRsdKt6IRbb/aMR2wPrO6c59x+6BX0WNbNS9YzOHOWGblDH710nSlkL0IevejZjlXNBuVk3+dhwXbTDbwnjut9m9HktuV5+kRQKotE+dYyhwrr9vYJziz8PwbUgn8lHqgpP/wYLmYvkJiJQu8TtHJIdCOb54Cdf/0EERnHk98j9sHeQssblgku5HPritoB53wPBhSlK3mCyQykNqcqO5ZOSQMEO2Q86LL4irp0N6SDQo3jvpNa/fENQVx4vqwfaUJEOpl9g/5vRDGf7QkV/j2b/kATJArAHI2gdirjdjH9pFRwOoA/ZuZYhca/BY/PZ2kdXdyZK0qsiiOCw0pcJc+hC+5X9GdXYtopO/GEJY8iTCFd8sYTCwu5WEm2YRZTC8akfw7gpK2qjJkOUzse1rNbxw0XYvnMWGGXuqS4BFYqZIH/n6r9Fit4/Ur+Vm+/Rr44aCq4KUHew2RoE2AgUDYltczAQDbySNGJMmysGgaD+6DyygSbahVyN9xQyhMP764n0LK3YfF7st6Hc3FBU0SLKKUIIrM/rabCdUzgkMD7h4FpJtDhKJriZt8UpTdCiyx13GFGYoBPlXxtuUyL8BFgwPkX0JwGqUxLMxqziBlaygSxXAPrcDZUTPrKhkQ90SPJd3IFLArjJawqMViL316oTO4chKef2BIKIMhi1wnTm6EE0bqyEHACKjB1xDN8Ij0Fy7HjgmQcc7nve5XoMNCWzDQlt8rxGMFdkJZnNOCojA4aRvu2GWjal1xB481Z2pdIysNRUOIFErF6n6Y5fgVFm3diDNnprllijnERvKqnAbfpfDIiK++LVacggJrs/By216kkqVSyvwHGN0Hpm6j3vS25uOtbuc4r9i+hIc3oDZaa7cbqg7WFG5JzKe4DfIV/wPUaHra2PGdRIc1ki5UIfazTb7UfGX7982SBQL7wjsGkXmjNJaiq034nCgo0cnePwPYUHWGV+cg33HhmnqeUY38RAxFNW6hrCR8ZcLdCozT8vJVzrLg+PXxFrFcKpc+Tx+K7kgAe82TWlqMycXFZvfmRX39TyZkvo9/NsVLqz054f5npDvKRn/imf84/isMctEiMeEfGoRGxqLJbPnRlxxYZE7vpMJoLn/mirh15xQTZfE32OTS7207KSoaSwTmdC5DlXe1xGnHD+pCwqRNdKnzTKDPHgjysSFdxbQQ8iKwLjz7poX/UwKMXSCpLq7QTImVw/pWU7Izm4AGoGdP07v12yHstcZ3XzLCGFSux/hSp1qxYUZfLEUbX9lwFyGXbstrmCVtK0kvzDTsrReaKEf3SOPH3iRSa1PVLXzYmLsPKz9F3+5Pt+i5S+/bQQvT/fuoepIFUn2saPC9OJVARJNTHSNY554xOl4rVTJ5ttJPh6fXDs0ejKkRP5p8RHG77gvFVeB+6D3YVr0NbmD5gIT9t/hmkCSP8dNHAp/F9s5zM4ypRtcXtsDrqRghS5D7Ne4ekhNBi8TyryLS7cxhrhbHR+XPKsdxxdagvql99XDCF9eMsPQ7uDy6uVJhsm0j3pLGxnzmlRBa01xhuKKW1WQ7e2L9rEY/+xLA5Sn5TJQgFzEvWAkqvqvVtcKlxP84vzlf/P7RgXKMW/WVf7OVIAaaAMmPeYNNwefQjO4h3MIULZg2TDeUgmfYz/FIRMoA/q6jt4BSP7yVNw6w5BMKHr4uOpisU6301Swj7M/PKkAdCJmqB8Z1YhmmqLTkx8NBJPViWKbQ9tnDOhttPkGJT0Zsj+uCvZ7cb4SegOIraz8zzq6lYUc1Ir9yyrvOmFRgt2Lq9RetQDJx2jsbT+Tr8NnV3br3PtdzrH1+dee419+l9jJOdqrfW4mUm8egmhWczebvHNhvTiF02P1XkZ3klaoyPzElKKusXQh7IF66hCVuyyM+Q6ERsTA8fEteIqXoS86yyLfnpe3zYWAhCx6Ghrh1JmK8QPhAbQVuv851mSjXJt2jVERRu+H3mSCtZ+tjtk4NEhWCjn6Ywm+BtyLDn9QPKRHz2OP5Oex25ppkQPY7LTYK8+C5VE7FjSCXrTQXgkUKs1iZM7dJWLg6S8KK2BlZIiZaBb+zVk2TbvFmRs27lc8dAGUoXU2h+N7kE6uu0WSRFfWr6ocHM8KxTU34JJjnsn5GXsUpC8Fw+Pl46gPi6r+lo4XYVU+iRlhRPju/7CSJw68FeHB5na6FCG5of8VVgQKJbapNj3libTddro81k+dw90QeCmYwOCLiUMVi1a1rxRcMRddDobPNQU8nLX3fTFROHX12nBuwWShI0MB9W3t9ki1g6oMSQegANY3RT0VFgYoyNsaTKImXCLLbdz4T45f/mpGo+D4Z1Q25P72DQVpsoLsk2ug9wftvkVDDnn+P0L1GeHPxF2ZM7Pvcw+jUNcH+UX+</div>
<div id="enc_passwd"> <input type="text" style=" border-radius: 5px; border-style: groove; height: 30px; width: 50%; cursor: auto; font-size: 102%; color: currentColor; outline: none; text-overflow: initial; padding-left: 5px;">   <input type="submit" value="decrypt" onclick="decrypt()" style=" width: 58px; height: 34px; border-radius: 5px; background-color: white; border-style: solid; color: currentColor; ">  <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script>  var onError = function(error) {  $("#enc_error")[0].innerHTML = "password error!";  };  function decrypt() {  var passwd = $("#enc_passwd input")[0].value;  console.log(passwd);  doDecrypt(passwd, onError);  }  </script></div>]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node使用</title>
    <url>/sum/ser/node%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p style="text-align:right">2018.8.9 </p>


<h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>npm config list<br>npm config ls -l # 全部信息<br>其他指令：<br>npm config set proxy <a href="http://proxy.company.com:8080" target="_blank" rel="noopener">http://proxy.company.com:8080</a><br>npm config set https-proxy <a href="http://proxy.company.com:8080" target="_blank" rel="noopener">http://proxy.company.com:8080</a><br>npm config set http-proxy <a href="http://proxy.company.com:8080" target="_blank" rel="noopener">http://proxy.company.com:8080</a></p>
<p>npm config delete proxy<br>npm config delete http-proxy<br>npm config delete https-proxy</p>
<h2 id="npm-安装-管理-升级包"><a href="#npm-安装-管理-升级包" class="headerlink" title="npm 安装/管理/升级包"></a>npm 安装/管理/升级包</h2><p>npm -g install <a href="mailto:npm@4.0.2" target="_blank" rel="noopener">npm@4.0.2</a><br>npm install npm@latest -g<br>npm install npm -g<br>npm update [-g] [<pkg>…]<br>npm install npm@latest -g</pkg></p>
<p>npm i element-ui -S</p>
<h2 id="node多版本控制"><a href="#node多版本控制" class="headerlink" title="node多版本控制"></a>node多版本控制</h2><h2 id="改变全局模块-缓存路劲"><a href="#改变全局模块-缓存路劲" class="headerlink" title="改变全局模块/缓存路劲"></a>改变全局模块/缓存路劲</h2><p># <a href="https://blog.csdn.net/Candy_mi/article/details/80764319" target="_blank" rel="noopener">安装npm cnpm踩坑记录</a><br>## 3. 改变原有的环境变量（配置npm的全局模块的存放路径以及cache的路径）<br>(1)先在C:\Program Files\nodejs目录下新建”global”和”cache”两个文件夹<br>(2)输入以下命令改变npm配置<br>npm config set prefix “C:\Program Files\nodejs\global”<br>npm config set cache “C:\Program Files\nodejs\cache”</p>
<p>## 4.配置环境变量<br>(1）我的电脑右键点击属性进入该页面—点击高级系统设置—点击环境变量进入该页面<br>(2)修改用户变量PATH：把”C:\Program Files\nodejs\global”加到后面，用分号隔开。<br>(3)新增系统变量NODE_PATH：设置成“C:\Program Files\nodejs\node_global\node_modules”。<br>tip:由于前面已经更改了原有的环境变量，所以安装cnmp时会自己安装到C:\Program Files\nodejs\global\node_modules目录下面,所以cnpm的环境变量也许要更改（如下步骤很重要）<br>(4)修改系统变量path:把“C:\Program Files\nodejs\global\node_modules\cnpm“加到后面</p>
<p>## 5.安装cnmp<br>安装命令：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>## 6.cmd检测是否安装成功（cnmp -v），如下就算成功</p>
<h2 id="设置cnpm"><a href="#设置cnpm" class="headerlink" title="设置cnpm"></a>设置cnpm</h2><p>$_PS: 装axios的时候镜像也没有用，用yarn就ojbk了     </p>
<p># <a href="https://www.jianshu.com/p/2c0df2c25b29" target="_blank" rel="noopener">npm的设置cnpm</a><br>淘宝 npm 地址： <a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a><br>如何使用<br>有很多方法来配置npm的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝npm镜像安装express举例：<br>## 1.临时使用<br>npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> install express</p>
<p>## 2.持久使用<br>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>// 配置后可通过下面方式来验证是否成功<br>npm config get registry<br>// 或<br>npm info express</p>
<p>## 3.通过cnpm使用<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>// 使用<br>cnpm install express</p>
<p>## 4.关闭npm的https<br>npm config set strict-ssl false</p>
<h2 id="node支持import"><a href="#node支持import" class="headerlink" title="node支持import"></a>node支持import</h2><p>### .1<br><!-- \# [Node中没搞明白require和import，你会被坑的很惨] --></p>
<blockquote>
<p>因为目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require。这也是为什么在模块导出时使用module.exports，在引入模块时使用import仍然起效，因为本质上，import会被转码为require去执行。</p>
</blockquote>
<p>### .2<br><!-- \# [如何让Node.js支持ES6的语法](https://www.jianshu.com/p/af32b6417e4c) --><br>检测ES6: npm install -g es-checker  -&gt;  es-checker<br>添加ES6支持: npm install babel-cli -g (全局)<br>    npm install babel-preset-es2015 –save<br>    .babelrc文件:<br>    {<br>        “presets”: [<br>            “es2015”<br>        ],<br>        “plugins”: []<br>    }<br>测试ES6： babel-node index.js 或者scripts: “babel”:”babel-node index.js”  </p>
<p>### .3<br><!-- \# [JavaScript笔记-JavaScript Modules](http://imushan.com/2018/01/14/js/javascript/JavaScript%E7%AC%94%E8%AE%B0-JavaScript-Modules/) --><br>Node.js默认使用的是CommonJS模块。在8.5.0版本后，Node.js支持了JavaScript Modules标准。但是需要添加参数–experimental-modules来开启。默认支持估计要到Node.js 10 LTS了。   </p>
<p>同时为了区分使用CommonJS的代码和ES modules的代码，Node.js要求使用ES modules的代码使用.mjs作为后缀名。<br>详细信息可以参考：<a href="http://2ality.com/2017/09/native-esm-node.html" target="_blank" rel="noopener">Using ES modules natively in Node.js</a>    </p>
<p>那有没有办法在Node.js 8.5.0前的版本中使用JavaScript Modules呢？有的，可以使用<a href="https://github.com/standard-things/esm" target="_blank" rel="noopener">standard-things/esm: ES modules in Node today!</a>项目。     </p>
<h2 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h2><p># <a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank" rel="noopener">使用npm安装一些包失败了的看过来（npm国内镜像介绍）</a>        </p>
<p>这个也是网上搜的，亲自试过，非常好用！<br>镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p>
<p>## 1.通过config命令<br>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>npm info underscore （如果上面配置正确这个命令会有字符串response）</p>
<p>## 2.命令行指定<br>npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> info underscore </p>
<p>## 3.编辑 ~/.npmrc 加入下面内容<br>registry = <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>搜索镜像: <a href="https://npm.taobao.org" target="_blank" rel="noopener">https://npm.taobao.org</a><br>建立或使用镜像,参考: <a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="noopener">https://github.com/cnpm/cnpmjs.org</a></p>
<p># <a href="https://www.cnblogs.com/mingc/p/8714472.html" target="_blank" rel="noopener">npm 安装 electron 超时</a><br>在用户目录的 .npmrc 文件里添加一行<br>electron_mirror=<a href="https://npm.taobao.org/mirrors/electron/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/electron/</a><br>指定 Electron 二进制文件的国内镜像（上面路径里最后一个正斜杠 “/“ 别丢了）。</p>
<h2 id="为Npm设代理"><a href="#为Npm设代理" class="headerlink" title="为Npm设代理"></a>为Npm设代理</h2><p># <a href="http://geek100.com/2574.html" target="_blank" rel="noopener">Node.js安装npm包出现网络错误的2种解决方案</a>     </p>
<p>为npm更换镜像后，我在公司安装npm包还是链接超时。后来在同事的提醒下，知道公司所有的网络链接都要通过公司代理服务器的。所以尝试着为npm设置了下proxy，设置方法如下：</p>
<p>第一个是http，第二个是https<br>npm config set proxy <a href="http://proxy.company.com" target="_blank" rel="noopener">http://proxy.company.com</a><br>npm config set https-proxy <a href="http://proxy.company.com" target="_blank" rel="noopener">http://proxy.company.com</a></p>
<p>上面proxy代理地址可根据你公司电脑ie里默认设置的代理服务器来填写。如ie里没有设置代理服务器，那么就需要知道公司的代理服务器地址。</p>
<p>通过为npm设置公司代理服务器的方式，npm终于能顺利连接了。</p>
<h2 id="npm安装出错"><a href="#npm安装出错" class="headerlink" title="npm安装出错"></a>npm安装出错</h2><h3 id="SSL-Error-CERT-UNTRUSTED-while-using-npm-command"><a href="#SSL-Error-CERT-UNTRUSTED-while-using-npm-command" class="headerlink" title="SSL Error: CERT_UNTRUSTED while using npm command"></a>SSL Error: CERT_UNTRUSTED while using npm command</h3><p># 实际<br>通过安装n包，更新node成功了。之后出现问题是退出当前工作目录，重新进入就好了。（服务端同学，把工作目录全量更新了，然后npm命令就不可以执行了，不知道他全量更新做了什么）<br># <a href="https://sre.ink/node-npm-install-error-cert_untrusted/" target="_blank" rel="noopener">node npm install Error: CERT_UNTRUSTED</a><br>ssl验证问题，使用下面的命令取消ssl验证即可解决<br>npm config set strict-ssl false</p>
<p>错误error-code-ELIFECYCLE，执行如下命令<br>npm cache clear –force<br>npm install -g npm</p>
<p># <a href="https://stackoverflow.com/questions/21855035/ssl-error-cert-untrusted-while-using-npm-command" target="_blank" rel="noopener">SSL Error: CERT_UNTRUSTED while using npm command</a><br>### 1<br>You can bypass https using below commands:<br><code>npm config set strict-ssl false</code><br>or set the registry URL from https or http like below:<br><code>npm config set registry=&quot;http://registry.npmjs.org/&quot;</code></p>
<p>### 2<br>Update your node.js installation.The following commands should do it (from here):<br>sudo npm cache clean -f<br>sudo npm install -g n<br>sudo n stable</p>
<h2 id="ngix-node"><a href="#ngix-node" class="headerlink" title="ngix-node"></a>ngix-node</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://blog.csdn.net/xiejunna/article/details/69229369" target="_blank" rel="noopener">linux下安装node.js</a>   </p>
<p>下载后，得到这样一个文件  node-v6.10.1-linux-x64.tar.xz<br>解压下载文件，分两步。先把xz后缀解压为tar文件，再解压tar文件。<br>xz -d xxx.tar.xz<br>tar -xvf xxx.tar</p>
<p>4.此时进入到cd node-v6.10.1-linux-x64/bin目录下，有 node npm<br>执行 ./node -v 可查看node.js版本号，这时是局部的，需要把node设为全局的</p>
<p>5.把node设置为全局的ln -s 源文件 目标文件 ，意思是为某一个文件或目录在另外一个位置建立一个同步的链接，类似Windows下的超级链接。<br>ln -s /home/dk/h5server/h5server_dev/.well-known/node-v6.10.1-linux-x64/bin/node /usr/local/bin/node</p>
<p>把npm设为全局的：<br>ln -s /home/dk/h5server/h5server_dev/.well-known/node-v6.10.1-linux-x64/bin/npm /usr/local/bin/npm</p>
<h3 id="环境变量配置-Linux"><a href="#环境变量配置-Linux" class="headerlink" title="环境变量配置(Linux)"></a>环境变量配置(Linux)</h3><p><a href="https://blog.csdn.net/m0_37263637/article/details/81942435" target="_blank" rel="noopener">npm install全局安装找不到命令</a><br>Linux环境变量配置有三种：</p>
<ul>
<li>当前用户当前shell有效。（临时环境变量,关闭即失效）  </li>
<li>当前用户有效    </li>
<li>所有用户均有效  </li>
</ul>
<p>3.1 临时环境变量<br>在shell中运行下列命令，$PATH:后跟想要加入环境变量的目录<br>export PATH=$PATH:/home/xx.xx/node-v8.11.3-linux-x64/bin</p>
<p>3.2 对当前用户有效<br>修改用户目录下的.bashrc文件<br>vi ~/.bashrc<br>在文件最后添加该语句. 重新登录即生效<br>PATH=$PATH:/home/xx.xx/node-v8.11.3-linux-x64/bin</p>
<p>3.3 所有账户均有效<br>修改/etc/profile文件<br>sudo vi /etc/profile<br>在末尾添加以下内容</p>
<p>export PATH=”$PATH:/home/xx.xx/node-v8.11.3-linux-x64/bin”</p>
<p>退出当前shell再重新登录即可生效或执行source /etc/profile该命令</p>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><p><a href="https://blog.csdn.net/EDDYCJY/article/details/77892446" target="_blank" rel="noopener">bash: vue: command not found</a><br>npm 全局路径不对或 node_modules 的路径未设置<br>三、查看npm全局路径：<br>npm root -g<br>得出/usr/local/node/lib/node_modules，检查是否正确的路径。<br>若存在问题可重新指定：</p>
<p>npm config set prefix /usr/local   </p>
<p># linux系统node 升级<br><a href="https://blog.csdn.net/tlbaba/article/details/79412433" target="_blank" rel="noopener">node升级的正确方法</a><br>1.查看node版本，没安装的请先安装；没有安装的可能会提示命令未找到之类的信息。<br> $  node -v</p>
<p>2.清楚node缓存；<br>$  sudo npm cache clean -f  </p>
<p>3.安装node版本管理工具’n’;<br>$  sudo npm install n -g</p>
<p>4.使用版本管理工具安装指定node或者升级到最新node版本；<br>$  sudo n stable  （安装node最新版本）</p>
<p>$  sudo n 8.9.4 （安装node指定版本8.9.4）</p>
<p>5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功。<br>若版本号未改变则还需配置node环境变量</p>
<p>1.查看通过n安装的node的位置；<br>$  which node  (如：/usr/local/n/versions/node/6.12.3）</p>
<p>2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile;<br>$  vim /etc/profile</p>
<p>3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾；<br><code>#set node path</code><br>export NODE_HOME=/usr/local/n/versions/node/8.9.4<br>export PATH=$NODE_HOME/bin:$PATH</p>
<p>4.wq退出保存文件，编译/etc/profile;<br>$  source /etc/profile</p>
<p>5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>程序签名</title>
    <url>/sum/others/%E7%A8%8B%E5%BA%8F%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p style="text-align:right">2018.8.16 星期四 16:03</p>

<p>sign.bat<br><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">.\tools\signtool3.exe sign /a /s MY /n "Aculearn Pte Ltd" /fd sha256 -d "studioserveredit" -du http://www.aculearn.com -tr http://sha256timestamp.ws.symantec.com/sha256/timestamp .\studioserveredit.exe</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure></p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/signtool-exe" target="_blank" rel="noopener">SignTool.exe（签名工具）</a><br><a href="https://docs.microsoft.com/zh-cn/previous-versions/dotnet/netframework-4.0/8s9b9yaz(v=vs.100" target="_blank" rel="noopener">SignTool.exe（签名工具）</a>)</p>
<p>signtool [command] [options] [file_name | …]  </p>
<h3 id="参考一"><a href="#参考一" class="headerlink" title="参考一"></a>参考一</h3><p># <a href="https://blog.csdn.net/zhangbinsijifeng/article/details/51543707" target="_blank" rel="noopener">signtool.exe 对exe程序进行数字签名</a>   </p>
<p>signtool.exe是微软的数字签名制作工具，只能制作windows平台的签名，</p>
<p>本使用指南演示如何使用 WoSign微软代码签名证书 来给Windows平台代码签名，签名工具为WDK自带的签名工具软件 SignTool.exe,此签名工具软件仅支持DOS命令符方式签名。如果您希望使用图形化界面签名您的代码，则建议使用老版本的签名工具 SignCode.exe，并请参考 SignCode微软代码签名指南。</p>
<p>1. 获取代码签名证书：<br>成功在沃通申请代码签名证书后，会得到一个有密码的压缩包文件，输入证书密码后解压得到两个文件： pfx+MS、 pvk+spc，这个是证书的两种种格式，签名普通代码需要用到 pfx 格式的证书:<br>2. 解压证书文件：<br>打开 pfx+MS 文件可以看到3个文件。我们要用到pfx格式的文件，如图<br>3. 用SignTool签名工具签名(方法一)：<br>现在，就可以使用WDK的 SignTool 签名你的文件了,点这里 下载 Signtool签名工具。请先将您的证书XXX.pfx文件放到签名signtool工具所在目录签名命令行为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XP,Win7用户：</span><br><span class="line">signtool sign /v /f xxx.pfx /p 密码 /t http://timestamp.wosign.com/timestamp test.cab      </span><br><span class="line">Win7,Win8用户：</span><br><span class="line">signtool sign /v /f xxx.pfx /p 密码 /tr http://timestamp.wosign.com/rfc3161 test.cab</span><br></pre></td></tr></table></figure></p>
<p>其中：<br>(1) /v：显示详细的签名结果；<br>(2) /f xx.pfx：加载代码签名证书。请把颁发给你的用户证书放到signtool目录下，或者指定文件路径；<br>(3) /p 密码：申请证书时候设置的密码；<br>(4) /t,/tr：为代码加上WoSign免费时间戳，确保签名后的代码永不过期；<br>(5) test.cab: 就是您要签名的Windows文件，如：.cab, .dll, .exe 等文件；<br>(6) 如果您需要批量签名: 请<a href="https://bbs.wosign.com/thread-47-1-1.html" target="_blank" rel="noopener">点击这里</a>      </p>
<p>请注意：签名时，一定要保证能连上互联网，否则由于无法访问时间戳服务器而失败。</p>
<p>签名完成后，如果显示“Successfully signed and timestamped”(成功签名与加上时间戳)，如下图所示，这表明签名已经成功：</p>
<h2 id="参考二"><a href="#参考二" class="headerlink" title="参考二"></a>参考二</h2><p># <a href="https://www.trustauth.cn/coding-signing/19618.html" target="_blank" rel="noopener">如何对EXE程序进行数字签名</a><br>一、首先获取代码GDCA代码签名证书<br>成功申请恒信企业（EV）或者速信个人代码签名证书后，会收到一个包含证书文件的USB-key，如下图：<br>二、使用代码签名证书对代码进行签名<br>1.先请下载USBkey驱动—下载<br>2.下载Signtool签名软件，选择一个盘符进行保存，进入cmd命令，cd到这个目录；<br>3.使用以下签名命令对代码进行签名，签名过程需要输入设置的PIN码；</p>
<p>signtool sign /v /fd sha256 /i “GDCA TrustAUTH R4 EV CodeSigning CA” /tr <a href="http://timestamp.gdca.com.cn/tsa" target="_blank" rel="noopener">http://timestamp.gdca.com.cn/tsa</a> test.exe<br>signtool sign /v /fd sha256 /i “GDCA TrustAUTH R4 CodeSigning CA” /tr <a href="http://timestamp.gdca.com.cn/tsa" target="_blank" rel="noopener">http://timestamp.gdca.com.cn/tsa</a> test.exe<br><!--
参数说明：  
(1) /v：显示详细的签名结果；     
(2) /fd sha256：指定使用sha256算法进行hash摘要的技术方法；   
(3) /i：指定证书进行签名，EV证书请用/i “GDCA TrustAUTH R4 EV CodeSigning CA”；   
(4) //tr：为代码加上GDCA免费时间戳，确保签名后的代码永不过期；   
(5) test.exe: 就是您要签名的Windows文件，如：.cab, .dll, .exe 等文件；      
---></p>
<p># <a href="http://www.cnblogs.com/1-2-3/archive/2007/11/27/colloquialism-digital-certificate-part4.html" target="_blank" rel="noopener">白话数字签名（番外篇）——签名EXE文件（上）</a><br>Step1: 登录<a href="http://www.ca365.com，在“免费证书”栏中点击“用表格申请证书”链接。" target="_blank" rel="noopener">www.ca365.com，在“免费证书”栏中点击“用表格申请证书”链接。</a></p>
<p># <a href="https://blog.csdn.net/guangboo/article/details/8887063" target="_blank" rel="noopener">对exe文件进行数字签名</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signtool</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> subprocess</span><br><span class="line">    signtool_exe = <span class="string">r'C:\Program Files\Microsoft SDKs\Windows\v7.0A\bin\signtool.exe'</span></span><br><span class="line">    pfx_file = <span class="string">'c:\\mycert.pfx'</span></span><br><span class="line">    cmd = <span class="string">'%s sign /f %s /p password /v %s'</span> % (signtool_exe, pfx_file, filename)</span><br><span class="line">    <span class="keyword">print</span> cmd</span><br><span class="line">    proc = subprocess.Popen(cmd)</span><br><span class="line">    proc.wait()</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">10:28</p><br><p style="text-align:right">2018.8.9 星期四 10:03</p>


<h2 id="Visual-Studio-编译和打包"><a href="#Visual-Studio-编译和打包" class="headerlink" title="Visual Studio 编译和打包"></a>Visual Studio 编译和打包</h2><h3 id="生成解决方案-重新生成解决方案"><a href="#生成解决方案-重新生成解决方案" class="headerlink" title="生成解决方案/重新生成解决方案"></a>生成解决方案/重新生成解决方案</h3><p># <a href="https://bbs.csdn.net/topics/310029018" target="_blank" rel="noopener">介绍解决方案、项目和项</a><br>Visual Studio 提供了两类容器，帮助您有效地管理开发工作所需的项，如引用、数据连接、文件夹和文件。这两类容器分别叫做解决方案和项目。<br>此外，Visual Studio 还提供解决方案文件夹，用于将相关的项目组织成项目组，然后对这些项目组执行操作。<br>作为查看和管理这些容器及其关联项的界面，“解决方案资源管理器”是集成开发环境 (IDE) 的一部分。     </p>
<p># <a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/solutions-and-projects-in-visual-studio" target="_blank" rel="noopener">Visual Studio 中的解决方案和项目</a><br>## 项目<br>## 解决方案<br>项目包含在解决方案中。 解决方案可能包含一个或多个相关项目，以及生成信息、Visual Studio 窗口设置和不与特定项目关联的任何杂项文件。 解决方案由格式唯一的文本文件（扩展名 .sln）描述；不应对其进行手动编辑。<br>Visual Studio 采用两种文件类型（.sln 和 .suo）来存储解决方案设置：<br>.sln    Visual Studio 解决方案    将项目、项目项和解决方案项组织到解决方案中。<br>.suo    解决方案用户选项    存储用户级别设置和自定义项，如断点。        </p>
<h3 id="打包安装程序"><a href="#打包安装程序" class="headerlink" title="打包安装程序"></a>打包安装程序</h3><p>首先在官网下载VS2015的Visual Studio Installer<br>安装打包插件：Microsoft Visual Studio 2017 Installer Projects<br>下载打包工具InstallShield2013LimitedEdition      </p>
<p>以前使用该方式，后来就改为脚本了：<br>1. 好像要收费<br>1. 有些东西仍然需要脚本/插件 自己写，比如安装过程中的一些提示信息      </p>
<p style="text-align:right">10:28</p>   


<h2 id="不同平台工具"><a href="#不同平台工具" class="headerlink" title="不同平台工具"></a>不同平台工具</h2><p>资源管理器——文件夹，命令行工具都不一样<br>win: svn(乌龟),sourcetree, nodepad++, visualstudio, Venis IX, Poedit ; <em>.bat,</em>.vbs<br>mac: cornercode, 章鱼,     sublime,   xcode; dropdmg *.sh<br>ubantu:     </p>
<h2 id="nsis打包"><a href="#nsis打包" class="headerlink" title="nsis打包"></a>nsis打包</h2><p>参考：[NSIS实用]    </p>
<p><a href="/sum/others/NSIS实用">NSIS实用</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>画板练习</title>
    <url>/sum/jsplus/sketchpad/</url>
    <content><![CDATA[<p style="text-align:right">2018.8.2 星期四</p>

<p>~2018.5  画板需求，已经有很多了，都不是完美贴合，<br>同时也是学习，自己造轮子，且初见成效。<br>半成品，非成品：<br>1. 自定义画笔（圆角矩形/箭头/星形等）没有完成<br>2. undo/redo 没有完成，<br>3. 同时可以发送当前画板/画笔 共享，以展示或共同完成;同时可以携带作者信息  </p>
<p><a href="https://yalhu.github.io/forstudy/boardjs/board.html" target="_blank" rel="noopener">demo</a><br><a href="https://github.com/yalhu/forstudy/boardjs" target="_blank" rel="noopener">源码</a></p>
<h2 id="一-crysyan"><a href="#一-crysyan" class="headerlink" title="一 crysyan"></a>一 crysyan</h2><p>github:<a href="https://github.com/BPing/crysyan" target="_blank" rel="noopener">https://github.com/BPing/crysyan</a><br>demo:<a href="https://home.cbping.vip/crysyan/demo-index.html" target="_blank" rel="noopener">https://home.cbping.vip/crysyan/demo-index.html</a></p>
<p>a web drawing board with canvas.<br>样式简洁，功能齐全。<br>单个组件的API   </p>
<p>record：可以记录成video，并播放（webrtc相关）<br>界面简洁，封装成组件的项目，样式改动困难<br>封装成 选区/铅笔/形状/橡皮/字体等组件，每一个组件可以单独进行设置<br>上传图片<br>还有redo/undo<br>清空画布   </p>
<h2 id="一二-whiteBoard"><a href="#一二-whiteBoard" class="headerlink" title="一二 whiteBoard"></a>一二 whiteBoard</h2><p>github:<a href="https://github.com/Qbian61/whiteBoard" target="_blank" rel="noopener">https://github.com/Qbian61/whiteBoard</a><br>demo:<a href="http://qbian.me:8082/" target="_blank" rel="noopener">http://qbian.me:8082/</a></p>
<p>橡皮擦除整个形状<br>和第一个相似，黑白样式，没有形状   </p>
<h2 id="二-drawingboard-js"><a href="#二-drawingboard-js" class="headerlink" title="二 drawingboard.js"></a>二 drawingboard.js</h2><p>github:<a href="https://github.com/Leimi/drawingboard.js" target="_blank" rel="noopener">https://github.com/Leimi/drawingboard.js</a><br>demo:<a href="http://leimi.github.io/drawingboard.js/" target="_blank" rel="noopener">http://leimi.github.io/drawingboard.js/</a>   </p>
<p>有api和事件回调   </p>
<p>填充功能<br>简单绘制，只有画笔，可以设置颜色大小<br>有redo/undo，清空  </p>
<h2 id="三-wPaint"><a href="#三-wPaint" class="headerlink" title="三 wPaint"></a>三 wPaint</h2><p>github:<a href="https://github.com/websanova/wPaint#wpaintjs" target="_blank" rel="noopener">https://github.com/websanova/wPaint#wpaintjs</a><br>demo:<a href="http://wpaint.websanova.com/" target="_blank" rel="noopener">http://wpaint.websanova.com/</a></p>
<p>有api   </p>
<p>保存图片<br>加载背景图片<br>填充<br>形状可选<br>redo/undo,clear,size,color,   </p>
<h2 id="四-sketchpad"><a href="#四-sketchpad" class="headerlink" title="四 sketchpad"></a>四 sketchpad</h2><p>github:<a href="https://github.com/yiom/sketchpad" target="_blank" rel="noopener">https://github.com/yiom/sketchpad</a><br>demo:<a href="http://www.htmleaf.com/Demo/201604023292.html" target="_blank" rel="noopener">http://www.htmleaf.com/Demo/201604023292.html</a>   </p>
<p>有api，npm包  </p>
<p>animate<br>单一画笔，颜色/大小，<br>redo/undo   </p>
<h2 id="五-literallycanvas"><a href="#五-literallycanvas" class="headerlink" title="五 literallycanvas"></a>五 literallycanvas</h2><p>github:<a href="https://github.com/literallycanvas/literallycanvas" target="_blank" rel="noopener">https://github.com/literallycanvas/literallycanvas</a><br>demo:<a href="http://literallycanvas.com/index.html" target="_blank" rel="noopener">http://literallycanvas.com/index.html</a>    </p>
<p>功能全，有api   </p>
<h2 id="二-仿windows画图工具的html5画图工具"><a href="#二-仿windows画图工具的html5画图工具" class="headerlink" title="-二 仿windows画图工具的html5画图工具"></a>-二 仿windows画图工具的html5画图工具</h2><p>home:<a href="http://www.htmleaf.com/html5/html5-canvas/201801224943.html" target="_blank" rel="noopener">http://www.htmleaf.com/html5/html5-canvas/201801224943.html</a><br>demo: <a href="http://www.htmleaf.com/Demo/201801224944.html" target="_blank" rel="noopener">http://www.htmleaf.com/Demo/201801224944.html</a>   </p>
<p>仿的真全，还包括菜单栏，调整画布大小   </p>
<h2 id="一-Canvas-Tattle"><a href="#一-Canvas-Tattle" class="headerlink" title="-一 Canvas-Tattle"></a>-一 Canvas-Tattle</h2><p>github:<a href="https://github.com/hongru/Canvas-Tattle" target="_blank" rel="noopener">https://github.com/hongru/Canvas-Tattle</a>    </p>
<p>【Canvas杂谈：第一季】RAF/FPS/dt干嘛用？<br>【Canvas杂谈：第一季】我只画了一条线，为什么我越来越慢？<br>【Canvas杂谈：第一季】别告诉我你只能贴矩形的图<br>【Canvas杂谈：第一季】啊啊啊！为什么我画不出1像素的线！！<br>【Canvas杂谈：第一季】我有菱角，请让我变得圆滑<br>【Canvas杂谈：第一季】我是画笔，也是橡皮擦<br>【Canvas杂谈：第一季】我的身后，拖着一条长长的尾巴<br>【Canvas杂谈：第一季】画了一个圆，帮我长出事件<br>【Canvas杂谈：第一季】scale不仅仅只是缩放<br>第一季更多：<a href="https://github.com/hongru/Canvas-Tattle/issues" target="_blank" rel="noopener">https://github.com/hongru/Canvas-Tattle/issues</a>?    </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫及SA和分词</title>
    <url>/sum/others/%E7%88%AC%E8%99%AB%E5%8F%8ASA%E5%92%8C%E5%88%86%E8%AF%8D(012)/</url>
    <content><![CDATA[<p style="text-align:right">2018.8.2 星期四 11:34</p>

<p>python简单爬图片，查看了爬去微博/招聘/微信 数据，及情感分析；<br>也用脚本-插件批量下载文本-小说   </p>
<p>爬虫 不只python，node和php等也可以   </p>
<h1 id="Ⅰ-爬虫选择"><a href="#Ⅰ-爬虫选择" class="headerlink" title="Ⅰ 爬虫选择"></a>Ⅰ 爬虫选择</h1><p>比较后，并没有多大选择，也查了 情感分析和中文分词，选择node：<br>1. 没有那么多需求。只是爬个数据玩，自己需要的数据，可以的话简单分析。不会去爬各大网站内容，自己再做一个内容系统，或者提供什么服务<br>2. js语法——ES 比较熟悉，最基本/简单的需求node都可以满足。python毕竟也是一门语言，需要仔细学习。选node不光写了js，也加强了node。<br>3. node也可以查找一些资料及库   </p>
<h1 id="Ⅱ-情感分析"><a href="#Ⅱ-情感分析" class="headerlink" title="Ⅱ 情感分析"></a>Ⅱ 情感分析</h1><!-- 包括中文情感分析     -->
<p># A [Twitter是怎么做情感分析的？长文解读！]<br><a href="https://yq.aliyun.com/articles/65239" target="_blank" rel="noopener">https://yq.aliyun.com/articles/65239</a>    </p>
<p>1 引言<br>1.1 情感分析的应用<br>情感分析可应用于众多领域。;A. 电子商务 ;B. 市场呼声（Voice of the Market，VOM）;C. 消费者呼声（Voice of the Customer，VOC）;D. 品牌声誉管理;E. 政府<br>1.2 推文的特症<br>从情感分析的角度，我们讨论Twitter的以下几点特征：推文长度、使用的语言、数据可用性、话题范围、       </p>
<p>2 相关工作<br>3 方法<br>我们使用了不同的特征集和机器学习分类器来确定适用于Twitter情感分析的最佳组合。 我们还尝试了各种预处理操作，处理文本中的标点符号、表情符号、Twitter特定术语以及词干。我们对以下特征进行了研究——一元词串、二元词串、三元词串、否定检测。最后，我们使用不同机器学习算法——朴素贝叶斯、决策树和最大熵模型，来训练我们的分类器。<br>3.1 数据集<br>Twitter情感分析面临的主要挑战之一便是标记数据的采集。研究者们公开了以下数据集用于分类器的训练和测试。<br>3.1.1 Twitter情感语料库     3.1.2 斯坦福Twitter语料库       </p>
<p>3.2 预处理<br>3.2.1 话题标签  3.2.2 用户句柄    3.2.3 链接  3.2.4 表情符号    3.2.5 标点符号  3.2.6 重复字符      </p>
<p>3.3 词干提取算法<br>所有的词干提取算法都属于以下几种主要类型——基于词缀去除的、基于统计的以及混合型的。<br>第一种类型，即词缀去除算法，是最基本一种词干提取算法。这些词干提取算法应用一组转换规则，试图剥离每个词的前缀和/或后缀[8]。普通的词干提取算法在单词的第N个字符处进行截断。但这很明显在实际场景下并不适用。   </p>
<p>另一种广泛使用的著名词干分析器将在下一节介绍。<br>3.3.1 Porter词干提取算法    3.3.2 词形还原算法      </p>
<p>3.4 特征<br>3.4.1 一元词串      3.4.2 n元词串   3.4.3 否定处理      </p>
<p>4 实验<br>4.1 朴素贝叶斯      4.2 最大熵分类器        </p>
<p>5 未来展望<br>研究支持向量机，为印地语推文构造分类器，使用语义分析改进结果    </p>
<p>6 结论<br>我们使用标注数据集，为Twitter构建了一个情感分类器。同时，为了进行情感分析，我们还探讨了使用两步分类器与否定检测间的相关性。     </p>
<p>我们的基准分类器仅使用一元词串特征，达到了约80.00%的准确率。如果使用否定检测或引入二元词串和三元词串，准确率会有所增长。因此，我们可以得出结论，否定检测和高阶n元词串都可用于文本分类。然而，如果我们同时使用否定检测和n元词串，准确率会略微下降。我们还注意到，单步分类器相比两步分类器效果更为突出。而且，一般来说，朴素贝叶斯分类器的性能优于最大熵分类器。</p>
<p>以一元词串+二元词串+三元词串为特征并使用朴素贝叶斯分类器进行训练，我们达到了最佳的分类效果，准确率为86.68%。</p>
<p># B [自然语言处理]<br><a href="http://www.cnblogs.com/en-heng/category/882183.html" target="_blank" rel="noopener">http://www.cnblogs.com/en-heng/category/882183.html</a>   </p>
<p># C [利用深度学习方法进行情感分析以及在海航舆情云平台的实践]<br><a href="https://blog.csdn.net/javastart/article/details/56292109" target="_blank" rel="noopener">https://blog.csdn.net/javastart/article/details/56292109</a><br>原理解析<br>1.文本的预处理<br>由网络爬虫爬取到的原始语料，通常都会带有我们不需要的信息，比如额外的Html标签，所以需要对语料进行预处理。这里的预处理工作主要是为了提取完整的句子，去掉一些多余的标记符号。处理之后我们需要对原始语料进行情感标注，我们可以用-1标记消极情感评论，1标记积极情感评论。</p>
<p>2.分词<br>为了判断句子中是否存在情感词典中相应的词语，我们需要把句子准确切割为一个个词语，即分词。现有可选择的分词工具有很多，我们可以研读各分词工具的测试报告，根据自己的需求选择合适的分词工具。</p>
<p>3.构建情感词典<br>情感词典可分为四个部分：积极情感词典、消极情感词典、否定词典以及程度副词词典。为了得到更加完整的情感词典，我们可以收集多个情感词典，对它们进行整合去重，同时需要对部分词语进行调整，以达到尽可能高的准确率。</p>
<p>此外，我们需要根据需求加入某些行业词汇，以增加分类中的命中率。不同行业某些词语的词频会有比较大的差别，而这些词有可能是情感分类的关键词之一。比如手机行业，“耐摔”和“防水”就是在这个领域有积极情绪的词。因此，有必要将这些因素考虑进模型之中。</p>
<p>4.分类<br>为了简单起见，我们将每个积极情感词语赋予权重1，将每个消极情感词语赋予权重-1，并且假设情感值满足线性叠加原理；我们已经将句子进行分词，如果分词后的词语向量包含相应的词语，就加上其对应的权值，其中，否定词和程度副词会有特殊的判别规则，否定词会导致权值取反，而程度副词则让权值加倍。最后，根据总权值的正负性来判断句子的情感。基本的规则如图所示。</p>
<h1 id="Ⅱ-Ⅱ-中文情感分析"><a href="#Ⅱ-Ⅱ-中文情感分析" class="headerlink" title="Ⅱ-Ⅱ 中文情感分析"></a>Ⅱ-Ⅱ 中文情感分析</h1><p># A [中文情感分类方法简介]<br><a href="http://ir.hit.edu.cn/~zkli/report/Brief%20Intro%20to%20Sentiment%20Analysis(share).pdf" target="_blank" rel="noopener">http://ir.hit.edu.cn/~zkli/report/Brief%20Intro%20to%20Sentiment%20Analysis(share).pdf</a>    </p>
<p>1. 情感分类有什么用<br>1. 情感分类的任务有哪些<br>1. 情感分类的主要方法<br>1. 使用分词&amp;朴素贝叶斯做实验<br>1. 几点思考    </p>
<p># B 中文情感分析 (Sentiment Analysis) 的难点在哪？现在做得比较好的有哪几家？<br><a href="https://www.zhihu.com/question/20700012" target="_blank" rel="noopener">https://www.zhihu.com/question/20700012</a>    </p>
<p># C 中文文本情感分析：基于机器学习方法的思路<br><a href="https://blog.csdn.net/u013737526/article/details/73201572" target="_blank" rel="noopener">https://blog.csdn.net/u013737526/article/details/73201572</a><br>1.常用步骤  </p>
<p>2.中文分词<br>1）这是相对于英文文本情感分析，中文独有的预处理。<br>2）常用方法：基于词典、基于规则、基于统计、基于字标注、基于人工智能。<br>3）常用工具：哈工大—语言云、东北大学NiuTrans统计机器翻译系统、中科院张华平博士ICTCLAS、波森科技、结巴分词、Ansj分词，HanLP。    </p>
<p>3.特征提取<br>1）文本中拿什么作为特征。<br>2）常用方法：根据词性（adj、adv、v）、单词进行组合（unigram、bigram）、位置。<br>3）使用词的组合表示文本，两种方式：词出现与否、词出现的次数。   </p>
<p>4.特征选择<br>1）选择哪些特征，如果把所有的特征都作为特征计算，那计算量非常大，高维稀疏矩阵。<br>2）常用方法：去停用词，卡方，互信息。<br>3）常用工具：word2vector ，doc2vec      </p>
<p>5.分类模型<br>1）训练、测试。<br>1) 常用方法：朴素贝叶斯、最大熵、svm。      </p>
<p>6.评价指标<br>1）准确率<br>Accuracy = (TP + TN)/(TP + FN + FP + TN) 反映了分类器统对整个样本的判定能力——能将正的判定为正，负的判定为负 。<br>2）精确率<br>Precision = TP/(TP+FP) 反映了被分类器判定的正例中真正的正例样本的比重<br>3）召回率<br>Recall = TP/(TP+FN) 反映了被正确判定的正例占总的正例的比重      </p>
<p># D sentiment, 基于AFINN的node.js 情感分析<br><a href="https://www.helplib.com/GitHub/article_135674" target="_blank" rel="noopener">https://www.helplib.com/GitHub/article_135674</a><br><a href="https://github.com/thisandagain/sentiment" target="_blank" rel="noopener">https://github.com/thisandagain/sentiment</a>   </p>
<p>工作原理<br>AFINN<br>AFINN是一个单词列表，它的价格为整数，减五( 负片) 和五( 正) 。 情绪分析是通过交叉检查 string tokens(words, emojis) 和AFINN列表并获得它们各自的分数来执行的。 比较评分是简单的： sum of each token/number of tokens 例如让我们执行以下操作：</p>
<p>返回的对象<br>得分: 通过添加recongnized单词的情绪值来计算得分。<br>比较: 输入字符串的比较分数。<br>标记: 输入字符串中的单词或者符号等所有符号。<br>单词: 从AFINN列表中找到的输入字符串中的单词列表。<br>正数: AFINN列表中找到的输入字符串中肯定单词的列表。<br>负: 在AFINN列表中找到的输入字符串中的否定单词列表。<br>在这种情况下，爱值值为 3，敏感度为 -2，它的余标记为中性值为 0. 因为字符串有 9个标记，因此结果比较得分如下所示： (3 + -2)/9 = 0.111111111</p>
<p>这种方法使你具有 0个中点，上下界约束为正和负 5 ( 与每个标记相同) 。   </p>
<p>$_PS: sentiment-zh_cn :<a href="https://github.com/omegacoleman/sentiment-zh_cn" target="_blank" rel="noopener">https://github.com/omegacoleman/sentiment-zh_cn</a>   </p>
<p># E Popular NPM sentiment analysis Projects - Libraries.io<br><a href="https://libraries.io/search?keywords=sentiment+analysis&amp;platforms=NPM" target="_blank" rel="noopener">https://libraries.io/search?keywords=sentiment+analysis&amp;platforms=NPM</a>   </p>
<h1 id="Ⅲ-分词-中文分词"><a href="#Ⅲ-分词-中文分词" class="headerlink" title="Ⅲ 分词/中文分词"></a>Ⅲ 分词/中文分词</h1><!-- 主要是中文分词    -->
<p># A [中文分词十年又回顾: 2007-2017]<br><a href="http://bcmi.sjtu.edu.cn/~zhaohai/pubs/CWS-10Year-Review-2.pdf" target="_blank" rel="noopener">http://bcmi.sjtu.edu.cn/~zhaohai/pubs/CWS-10Year-Review-2.pdf</a>   </p>
<p># B [中文分词算法总结]<br><a href="https://www.jianshu.com/p/e978053b0b95" target="_blank" rel="noopener">https://www.jianshu.com/p/e978053b0b95</a>    </p>
<p>中文分词和搜索引擎<br>中文分词技术<br>现有的分词算法可分为三大类：基于字符串匹配的分词方法、基于理解的分词方法和基于统计的分词方法。</p>
<p># C [有哪些比较好的中文分词方案？]<br><a href="https://www.zhihu.com/question/19578687" target="_blank" rel="noopener">https://www.zhihu.com/question/19578687</a>   </p>
<p># D 专栏 | 中文分词工具测评<br><a href="http://www.sohu.com/a/120375125_465975" target="_blank" rel="noopener">http://www.sohu.com/a/120375125_465975</a><br>## 中文分词工具<br>本文选择了4个常见的分词工具，分别是：哈工大LTP、中科院计算所NLPIR、清华大学THULAC和jieba，为了对比分词速度，选择了这四个工具的c++版本进行评测。     </p>
<p>1、LTP<br>2、NLPIR<br>3、THULAC<br>4、jieba<br>## 测试数据集<br>1、SIGHAN Bakeoff 2005 MSR, 560KB<br>2、SIGHAN Bakeoff 2005 PKU, 510KB<br>3、人民日报 2014, 65MB  </p>
<p>前两个数据集是SIGHAN于2005年组织的中文分词比赛所用的数据集，也是学术界测试分词工具的标准数据集，本文用于测试各大分词工具的准确性，而最后一个数据集规模较大，用于测试分词速度。  </p>
<p>$_PS: jieba python<br>友情链接<br><a href="https://github.com/baidu/lac" target="_blank" rel="noopener">https://github.com/baidu/lac</a> 百度中文词法分析（分词+词性+专名）系统<br><a href="https://github.com/baidu/AnyQ" target="_blank" rel="noopener">https://github.com/baidu/AnyQ</a> 百度FAQ自动问答系统<br><a href="https://github.com/baidu/Senta" target="_blank" rel="noopener">https://github.com/baidu/Senta</a> 百度情感识别系统<br>$_PS: end   </p>
<h3 id="nodejs中文分词"><a href="#nodejs中文分词" class="headerlink" title="nodejs中文分词"></a>nodejs中文分词</h3><p># A 3大Node.js中文分词模块对比<br><a href="http://geek100.com/2945.html" target="_blank" rel="noopener">http://geek100.com/2945.html</a><br>node-segment<br>nodejieba<br>node-analyzer   </p>
<p># B Node.JS 中文分词模块<br>## 1 mmseg-node<br>一个基于 libmmseg 的 NodeJS 驱动。<br>Github：<a href="https://github.com/zzdhidden/mmseg-node" target="_blank" rel="noopener">https://github.com/zzdhidden/mmseg-node</a>   </p>
<p>## 2 nseg<br>基于 MMSG 中文分词算法。<br>GitHub：<a href="https://github.com/mountain/nseg" target="_blank" rel="noopener">https://github.com/mountain/nseg</a>   </p>
<p>## 3 node-segment<br>node-segment 模块以盘古分词组件中的词库为基础，算法设计也部分参考了盘古分词组件中的算法。<br>Github：<a href="https://github.com/leizongmin/node-segment" target="_blank" rel="noopener">https://github.com/leizongmin/node-segment</a>   </p>
<p># C natural 用 node.js 进行自然语言处理<br>我们曾经介绍过用Python的TextBlob模块对文本进行情感分析，node.js同样可以进行自然预言处理。natural模块已经支持词法分析、词干分析、分类、语音、反比文档频数权重评价、WordNet、字符串相似度等处理。     </p>
<p>目前为止，大多数算法还仅限于英文，以后会逐渐增加多语言支持。现在已支持俄语和西班牙语的词干分析。  </p>
<h3 id="python-中文分词"><a href="#python-中文分词" class="headerlink" title="python 中文分词"></a>python 中文分词</h3><p># [中文分词原理及工具]<br><a href="https://cuiqingcai.com/5844.html" target="_blank" rel="noopener">https://cuiqingcai.com/5844.html</a>   </p>
<p>基于规则的分词方法<br>基于统计的分词方法<br>基于语义的分词方法<br>基于理解的分词方法  </p>
<p>分词工具<br>在这里介绍几个比较有代表性的支持分词的 Python 库，主要有：  </p>
<ol>
<li>jieba<br>专用于分词的 Python 库，GitHub：<a href="https://github.com/fxsjy/jieba，分词效果较好。" target="_blank" rel="noopener">https://github.com/fxsjy/jieba，分词效果较好。</a>  </li>
<li>SnowNLP<br>SnowNLP: Simplified Chinese Text Processing，可以方便的处理中文文本内容，是受到了 TextBlob 的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和 TextBlob 不同的是，这里没有用 NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。GitHub地址：<a href="https://github.com/isnowfy/snownlp。" target="_blank" rel="noopener">https://github.com/isnowfy/snownlp。</a></li>
<li>THULAC<br>THULAC（THU Lexical Analyzer for Chinese）由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，GitHub 链接：<a href="https://github.com/thunlp/THULAC-Python，具有中文分词和词性标注功能。THULAC具有如下几个特点：" target="_blank" rel="noopener">https://github.com/thunlp/THULAC-Python，具有中文分词和词性标注功能。THULAC具有如下几个特点：</a></li>
<li>NLPIR<br>NLPIR 分词系统，前身为2000年发布的 ICTCLAS 词法分析系统，GitHub 链接：<a href="https://github.com/NLPIR-team/NLPIR，是由北京理工大学张华平博士研发的中文分词系统，经过十余年的不断完善，拥有丰富的功能和强大的性能。NLPIR是一整套对原始文本集进行处理和加工的软件，提供了中间件处理效果的可视化展示，也可以作为小规模数据的处理加工工具。主要功能包括：中文分词，词性标注，命名实体识别，用户词典、新词发现与关键词提取等功能。另外对于分词功能，它有" target="_blank" rel="noopener">https://github.com/NLPIR-team/NLPIR，是由北京理工大学张华平博士研发的中文分词系统，经过十余年的不断完善，拥有丰富的功能和强大的性能。NLPIR是一整套对原始文本集进行处理和加工的软件，提供了中间件处理效果的可视化展示，也可以作为小规模数据的处理加工工具。主要功能包括：中文分词，词性标注，命名实体识别，用户词典、新词发现与关键词提取等功能。另外对于分词功能，它有</a> Python 实现的版本，GitHub 链接：<a href="https://github.com/tsroten/pynlpir。" target="_blank" rel="noopener">https://github.com/tsroten/pynlpir。</a></li>
</ol>
<p>$_PS:<a href="http://www.52nlp.cn/category/word-segmentation" target="_blank" rel="noopener">推荐NLPIR大数据语义智能分析平台</a>     </p>
<ol start="5">
<li>NLTK<br>NLTK，Natural Language Toolkit，是一个自然语言处理的包工具，各种多种 NLP 处理相关功能，GitHub 链接：<a href="https://github.com/nltk/nltk。" target="_blank" rel="noopener">https://github.com/nltk/nltk。</a>  </li>
</ol>
<p>但是 NLTK 对于中文分词是不支持的，    </p>
<ol start="6">
<li>LTP<br>语言技术平台（Language Technology Platform，LTP）是哈工大社会计算与信息检索研究中心历时十年开发的一整套中文语言处理系统。LTP制定了基于XML的语言处理结果表示，并在此基础上提供了一整套自底向上的丰富而且高效的中文语言处理模块（包括词法、句法、语义等6项中文处理核心技术），以及基于动态链接库（Dynamic Link Library, DLL）的应用程序接口、可视化工具，并且能够以网络服务（Web Service）的形式进行使用。    </li>
</ol>
<p>LTP 有 Python 版本，GitHub地址：<a href="https://github.com/HIT-SCIR/pyltp，另外运行的时候需要下载模型，模型还比较大，下载地址：http://ltp.ai/download.html。" target="_blank" rel="noopener">https://github.com/HIT-SCIR/pyltp，另外运行的时候需要下载模型，模型还比较大，下载地址：http://ltp.ai/download.html。</a>    </p>
<h1 id="Ⅳ-词云图"><a href="#Ⅳ-词云图" class="headerlink" title="Ⅳ 词云图"></a>Ⅳ 词云图</h1><p>基于前端：js2wordcloud,d3.js    </p>
<p>python还有其他的分析/可视化工具/库       </p>
<h1 id="爬虫选择"><a href="#爬虫选择" class="headerlink" title="爬虫选择"></a>爬虫选择</h1><p style="text-align:right">2019.2.18 星期二 10:48</p>

<!-- [PHP, Python, Node.js 哪个比较适合写爬虫](https://www.zhihu.com/question/23643061)    -->
<!-- [哪种语言合适写爬虫程序](https://blog.csdn.net/wakice/article/details/50668359)  -->
<p>主要看你定义的“爬虫”干什么用。<br>1、如果是定向爬取几个页面，做一些简单的页面解析，爬取效率不是核心要求，那么用什么语言差异不大。<br>当然要是页面结构复杂，正则表达式写得巨复杂，尤其是用过那些支持xpath的类库/爬虫库后，就会发现此种方式虽然入门门槛低，但扩展性、可维护性等都奇差。因此此种情况下还是推荐采用一些现成的爬虫库，诸如xpath、多线程支持还是必须考虑的因素。</p>
<p>2、如果是定向爬取，且主要目标是解析js动态生成的内容   此时候，页面内容是有js/ajax动态生成的，用普通的请求页面-&gt;解析的方法就不管用了，需要借助一个类似firefox、chrome浏览器的js引擎来对页面的js代码做动态解析。   此种情况下，推荐考虑casperJS+phantomjs或slimerJS+phantomjs ，当然诸如selenium之类的也可以考虑。</p>
<p>3、如果爬虫是涉及大规模网站爬取，效率、扩展性、可维护性等是必须考虑的因素时候    大规模爬虫爬取涉及诸多问题：多线程并发、I/O机制、分布式爬取、消息通讯、判重机制、任务调度等等，此时候语言和所用框架的选取就具有极大意义了。     </p>
<p>PHP对多线程、异步支持较差，不建议采用。    </p>
<p>NodeJS：对一些垂直网站爬取倒可以，但由于分布式爬取、消息通讯等支持较弱，根据自己情况判断。     </p>
<p>Python：强烈建议，对以上问题都有较好支持。尤其是Scrapy框架值得作为第一选择。<br>优点诸多：支持xpath；基于twisted，性能不错；有较好的调试工具；<br>此种情况下，如果还需要做js动态内容的解析，casperjs就不适合了，只有基于诸如chrome V8引擎之类自己做js引擎。     </p>
<p>至于C、C++虽然性能不错，但不推荐，尤其是考虑到成本等诸多因素；对于大部分公司还是建议基于一些开源的框架来做，不要自己发明轮子，做一个简单的爬虫容易，但要做一个完备的爬虫挺难的。    </p>
<p>像我搭建的微信公众号内容聚合的网站<a href="http://lewuxian.com就是基于Scrapy做的，当然还涉及消息队列等。可以参考下图：" target="_blank" rel="noopener">http://lewuxian.com就是基于Scrapy做的，当然还涉及消息队列等。可以参考下图：</a></p>
<!-- $end -->
<p>scrapy中文网：<a href="http://www.scrapyd.cn/doc/147.html" target="_blank" rel="noopener">http://www.scrapyd.cn/doc/147.html</a><br>CasperJS:<a href="http://casperjs.org/" target="_blank" rel="noopener">http://casperjs.org/</a>   </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Hybris开发</title>
    <url>/sum/jsplus/hybris%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p style="text-align:right">$1 2019.2.15 星期五 14:21</p>

<p># [JSBridge的原理]<br>4.1.1 JavaScript 调用 Native<br>JavaScript 调用 Native 的方式，主要有两种：注入 API 和 拦截 URL SCHEME。   </p>
<p>4.1.2 Native 调用 JavaScript<br>不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。<br>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）   </p>
<p># [什么是 Native、Web App、Hybrid、React Native 和 Weex]   </p>
<p># [Hybrid App技术解析 – 原理篇]<br>现有混合方案<br>Hybrid App，俗称混合应用，即混合了 Native技术 与 Web技术 进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在UI渲染机制上的不同：<br>1) 基于 WebView UI 的基础方案，市面上大部分主流 App 都有采用，例如微信JS-SDK，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予H5一定程度的原生能力。<br>2) 基于 Native UI 的方案，例如 React-Native、Weex。在赋予 H5 原生API能力的基础上，进一步通过 JSBridge 将js解析成的虚拟节点树(Virtual DOM)传递到 Native 并使用原生渲染。<br>3) 另外还有近期比较流行的小程序方案，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了JS逻辑与UI渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。      </p>
<p>最核心的点就是 Native端 与 H5端 之间的双向通讯层<br>这个方案就是我们所说的 JSBridge，而实现的关键，便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。  </p>
<p>(一) JavaScript 通知 Native<br>基于 WebView 的机制和开放的 API, 实现这个功能有三种常见的方案：  </p>
<ol>
<li>API注入，原理其实就是 Native 获取 JavaScript环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式</li>
<li>WebView 中的 prompt/console/alert 拦截，通常使用 prompt，因为这个方法在前端中使用频率低，比较不会出现冲突</li>
<li>WebView URL Scheme 跳转拦截    </li>
</ol>
<p>(二) Native 通知 Javascript<br>由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了 Native 可以通过 WebView API直接执行 Js 代码。</p>
<p style="text-align:right">$1  15:02 </p><br><p style="text-align:right">2018.7.31 星期二 </p>


<h2 id="三端共适"><a href="#三端共适" class="headerlink" title="三端共适"></a>三端共适</h2><p>都需要注意编码问题<br>ios白屏问题android也更换的布局方式<br>android webview不支持 filter，需要添加前缀 -webkit-filter   </p>
<h3 id="页面加载方式"><a href="#页面加载方式" class="headerlink" title="页面加载方式"></a>页面加载方式</h3><p>本地加载页面-html（沙箱），所以不能向网络发起请求获得数据；需要中间件访问网络后，通过api传递给本地页面<br>本地快？为什么是本地加载html，不用服务器http(s)加载页面   </p>
<p>#### icon-font图标在android闪烁<br>如果是本地都应该是 file:///D:/dev/../html/ 的加载方式，所以icon-font不需要添加crossorigin了<br>但是android中不论加不加，都会先看到细长的空图标占位然后变圆<br>不确定是否是由于android版本低造成fetch不兼容。<code>*font-display:swap</code>估计也不行    </p>
<p>#### 多语言<br>lang.js为ajax，而不是类似jquery/ng的i18n，所以需要exe提供服务：调用lang.js的api    </p>
<h3 id="定义log函数"><a href="#定义log函数" class="headerlink" title="定义log函数"></a>定义log函数</h3><p>如果是alert移动端需要做相应的设置；cef不确定<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log;</span><br><span class="line"><span class="keyword">if</span>(IsAndroid)&#123;</span><br><span class="line">    log=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line">        [...arguments].forEach(<span class="function"><span class="params">v</span>=&gt;</span>str+=(<span class="built_in">JSON</span>.stringify(v)+<span class="string">';'</span>))</span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Error</span>().stack;</span><br><span class="line">        <span class="keyword">var</span> arr=stack.split(<span class="string">"\n"</span>)[<span class="number">2</span>].split(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">var</span> line = arr[arr.length<span class="number">-2</span>];</span><br><span class="line">        <span class="built_in">window</span>.androidCallback[<span class="string">'h5Debug'</span>](<span class="string">'h5Debug('</span>+line+<span class="string">')|'</span>+str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>log定义<code>log=console.log.bind(this,&#39;h5Debug|&#39;)</code>在ios中没有报错，但在android中会出错，阻止后面代码的执行   </li>
<li>ios<code>var arr=stack.split(&quot;\n&quot;)[2].split(&quot;:&quot;);</code>会出错，好像是stack是未定义的，没有仔细研究，直接取消行号/或者取消ios的log    </li>
<li>android还没有核查  </li>
</ol>
<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>传递json字符串，可能有的不支持传递数组或对象<br>注意把<code>/r,/r,/t</code>等影响JSON.parse()的字符串替换/转义    </p>
<p>android不知道怎么做的，传了几次都不对-_-。提供一个链接（不知道对不对）：<br><a href="https://blog.csdn.net/qfikh/article/details/52712025" target="_blank" rel="noopener">JAVA中使用JSON进行数据传递</a>   </p>
<h2 id="一-CEF"><a href="#一-CEF" class="headerlink" title="一 CEF"></a>一 CEF</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IsCEF=!!<span class="built_in">window</span>.cefQuery;</span><br><span class="line"><span class="keyword">var</span> log;</span><br><span class="line"><span class="keyword">if</span>(IsCEF)&#123;</span><br><span class="line">    <span class="comment">// log=console.log.bind(this,'h5Debug|') // if not need string info,but right num</span></span><br><span class="line">    log=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// if need string info and right line num</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line">        [...arguments].forEach(<span class="function"><span class="params">v</span>=&gt;</span>str+=(<span class="built_in">JSON</span>.stringify(v)+<span class="string">';'</span>))</span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Error</span>().stack;</span><br><span class="line">        <span class="keyword">var</span> arr=stack.split(<span class="string">"\n"</span>)[<span class="number">2</span>].split(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">var</span> line = arr[arr.length<span class="number">-2</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'h5Debug('</span>+line+<span class="string">')|'</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgCef</span>(<span class="params">cmd,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// log('msg cef cmd/data',cmd,data)</span></span><br><span class="line">    <span class="keyword">if</span>(!IsCEF) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">window</span>.cefQuery(&#123;</span><br><span class="line">        request: <span class="built_in">JSON</span>.stringify(&#123;cmd,data&#125;),</span><br><span class="line">        <span class="comment">// onSuccess:res=&gt;log('msg cef success:',res), //DEBUG</span></span><br><span class="line">        <span class="comment">// onFailure:res=&gt;log('msg cef error:',res) //DEBUG</span></span><br><span class="line">        <span class="comment">// ## 2.0 switch   </span></span><br><span class="line">        <span class="comment">// onSuccess:onCef</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ## 2.1 callback</span></span><br><span class="line"><span class="comment">// ## 2 Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgCef</span>(<span class="params">cmd,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// log('msg cef cmd/data',cmd,data)</span></span><br><span class="line">    <span class="keyword">if</span>(!IsCEF) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(res,<span class="number">1500</span>,&#123;<span class="attr">code</span>:<span class="number">0</span>&#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.cefQuery(&#123;</span><br><span class="line">            request: <span class="built_in">JSON</span>.stringify(&#123;cmd,data&#125;),</span><br><span class="line">            onSuccess:<span class="function"><span class="params">response</span>=&gt;</span>res(response),</span><br><span class="line">            onFailure:<span class="function"><span class="params">response</span>=&gt;</span>rej(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.0 switch  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCef</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="built_in">JSON</span>.parse(res)</span><br><span class="line">    <span class="keyword">const</span> &#123;cmd,data&#125;=res;</span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-WKWebView"><a href="#二-WKWebView" class="headerlink" title="二 WKWebView"></a>二 WKWebView</h2><p>非UIWebView<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log=<span class="built_in">console</span>.log.bing(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">const</span> IsWKWV=!!<span class="built_in">window</span>.webkit;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgMob</span>(<span class="params">method,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// log('msg cef cmd/data',cmd,data)</span></span><br><span class="line">    <span class="keyword">if</span>(!IsWKWV) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">window</span>.webkit.messageHandlers[method].postMessage(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">    <span class="comment">// window.webkit.messageHandlers.method.postMessage(JSON.stringify(data))//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="白屏-只有IOS"><a href="#白屏-只有IOS" class="headerlink" title="白屏(只有IOS)"></a>白屏(只有IOS)</h3><p>非内存，初步判定为滚动：只有出现定位，且内容过多（50条的时候还ok）的时候会白屏；<br>不要问怎么找到是css定位的问题。常理上css即使出错也不会有影响<br>#### 过程重现<br>1. 没有切换布局（每行显示4个-&gt;单行显示）前，同样的数据是ok的<br>1. 换布局后，<code>.stuList ul li &gt; div.speaker</code> 出现定位<code>position:absolute/relative</code> 就会白屏<br>去掉定位后就是ok的<br>#### 解决方案<br>1. width: 把li下两个div inline-block，第一个设置宽度百分比<br>缺点：1) 右边的内容不会右对齐；2) 不同宽度下右边空离距离不同<br>2. headerFixed: 把<code>.main{overflow-y:;}</code>取消掉，<code>.header{position:fixed}</code><br>缺点：实际滚动的是body，滚动条会从header开始滚动<br>3. flex: <code>li{display:flex;justify-content:space-between;}</code>    </p>
<p>滚动渲染机制可能是对的，解决方案(参考)在本case中没有作用<br>所以，干脆采用了新的布局方案flex，第一个div给定宽度(也不需要改display)，也可以设置text-overflow    </p>
<p>参考：<br><a href="http://www.poorren.com/ios-webview-white-screen-bug-fixes" target="_blank" rel="noopener">iOS WebView加载网页触摸白屏bug排查及修复</a><br>其他：<br><a href="https://www.jianshu.com/p/1d739e2e7ed2" target="_blank" rel="noopener">WKWebView刷新机制小探</a><br><a href="https://juejin.im/post/5aa2405551882555784d8d4b" target="_blank" rel="noopener">http://www.poorren.com/ios-webview-white-screen-bug-fixes</a>    </p>
<h2 id="三-Android-Webkit"><a href="#三-Android-Webkit" class="headerlink" title="三 Android Webkit"></a>三 Android Webkit</h2><p>window.jsInterfaceName.methodName(parameterValues)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IsWKWV=!!<span class="built_in">window</span>.webkit;<span class="comment">// ios WKWebView</span></span><br><span class="line"><span class="keyword">const</span> IsAndroid=!!<span class="built_in">window</span>.androidCallback;<span class="comment">// android point definded   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgMob</span>(<span class="params">method,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// log('msg cef cmd/data',cmd,data)</span></span><br><span class="line">    <span class="comment">//if(!IsWKWV) return;</span></span><br><span class="line">    <span class="keyword">if</span>(IsWKWV)&#123;</span><br><span class="line">        <span class="built_in">window</span>.webkit.messageHandlers[method].postMessage(<span class="built_in">JSON</span>.stringify(data));<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(IsAndroid)&#123;<span class="comment">// android webkit   </span></span><br><span class="line">        <span class="built_in">window</span>.androidCallback[method](<span class="built_in">JSON</span>.stringify(data));<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="零-IE-Interface"><a href="#零-IE-Interface" class="headerlink" title="零 IE Interface"></a>零 IE Interface</h2><p>IE7,当时可是吃了亏，做的ie8      </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _gbDebug = <span class="literal">false</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DebugMsg</span>(<span class="params">sInfo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( _gbDebug ) &#123;</span><br><span class="line">        alert(sInfo);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>._callFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!PreventRepeatedClick())	<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> fun;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> &amp;&amp; <span class="built_in">window</span>.external &amp;&amp; <span class="built_in">window</span>.external.CB_CustomFunction ) &#123;</span><br><span class="line">            fun = <span class="string">"window.external.CB_CustomFunction("</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                    fun = fun+<span class="string">","</span>;</span><br><span class="line">                fun = fun+<span class="string">"\""</span>+<span class="built_in">arguments</span>[i]+<span class="string">"\""</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            fun = fun+<span class="string">")"</span>;</span><br><span class="line">            <span class="comment">//alert(fun);</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">eval</span>(fun));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          fun = <span class="string">""</span>;</span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                fun = fun+<span class="string">","</span>;</span><br><span class="line">            fun = fun + <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _gaCMDToControl[_gaCMDToControl.length] = fun;</span><br><span class="line">        <span class="built_in">document</span>.title = GetJSCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网页调用exe"><a href="#网页调用exe" class="headerlink" title="网页调用exe"></a>网页调用exe</h2><p>自定义协议，而且可以传第参数，比如<br>sutdent.bat<code>cloudclass.exe &quot;cloudclass://mhjnhpjenfhpmmfioljfjcfephkgdfkm...jbpbgmkailkigc&quot;</code></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>Python初学</title>
    <url>/sum/ser/python%E5%88%9D%E5%AD%A6/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.25 星期六</p>


<h2 id="一-简单安装及语法"><a href="#一-简单安装及语法" class="headerlink" title="一 简单安装及语法"></a>一 简单安装及语法</h2><p>python2和python3<br>pip在scripts目录下，运行easy_install或者easy_install-2.7（不确定，不过不重要了）<br>注意设置环境变量   </p>
<p>ruboon-python3:<a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-tutorial.html</a>   </p>
<p>python是通过缩进来进行语法控制的，所以把制表符都换成空格<br>（编辑器里可以显示缩进：制表符/空格）   </p>
<h2 id="二-Python2和Python3-共存，包括pip"><a href="#二-Python2和Python3-共存，包括pip" class="headerlink" title="二 Python2和Python3 共存，包括pip"></a>二 Python2和Python3 共存，包括pip</h2><p>链接：<a href="https://www.zhihu.com/question/21653286/answer/95532074" target="_blank" rel="noopener">https://www.zhihu.com/question/21653286/answer/95532074</a></p>
<p>想学习Python3，但是暂时又离不开Python2。在Windows上如何让它们共存呢？<br>目前国内网站经常会让大家把其中一个python.exe改个名字（嗯，我也这样讲过，在此纠正一下），这样区分开两个可执行文件的名字，<br>但是这样做有一个重大的隐患，就是修改了名字的那个python对应的pip将无法使用。     </p>
<h3 id="官方的解法是什么？"><a href="#官方的解法是什么？" class="headerlink" title="官方的解法是什么？"></a>官方的解法是什么？</h3><p>事实上这个问题几年以前Python社区就给出了官方解决方案，只不过国内一直没有注意到罢了。<br>我们在安装Python3（&gt;=3.3）时，Python的安装包实际上在系统中安装了一个启动器py.exe，默认放置在文件夹C:\Windows\下面。这个启动器允许我们指定使用Python2还是Python3来运行代码（当然前提是你已经成功安装了Python2和Python3）。   </p>
<blockquote>
<p>有关Python2和3的安装，可以参见Python部落(<a href="http://python.freelycode.com)--&gt;影音学堂--&gt;《0基础1小时,Python入门》的第一节。" target="_blank" rel="noopener">http://python.freelycode.com)--&gt;影音学堂--&gt;《0基础1小时,Python入门》的第一节。</a>   </p>
</blockquote>
<p>如果你有一个Python文件叫 hello.py，<br>那么你可以这样用Python2运行它py -2 hello.py<br>类似的，如果你想用Python3运行它，就这样py -3 hello.py   </p>
<h3 id="去掉参数-2-3"><a href="#去掉参数-2-3" class="headerlink" title="去掉参数 -2/-3"></a>去掉参数 -2/-3</h3><p>每次运行都要加入参数-2/-3还是比较麻烦，<br>所以py.exe这个启动器允许你在代码中加入说明，表明这个文件应该是由python2解释运行，还是由python3解释运行。说明的方法是在代码文件的最开始加入一行<br><code>#! python2或者#! python3</code>分别表示该代码文件使用Python2或者Python3解释运行。<br>这样，运行的时候你的命令就可以简化为py hello.py</p>
<h3 id="使用pip"><a href="#使用pip" class="headerlink" title="使用pip"></a>使用pip</h3><p>当Python2和Python3同时存在于windows上时，它们对应的pip都叫pip.exe，所以不能够直接使用 pip install 命令来安装软件包。而是要使用启动器py.exe来指定pip的版本。命令如下：<br>py -2 -m pip install XXXX-2   还是表示使用 Python2，-m pip 表示运行 pip 模块，也就是运行pip命令了。<br>如果是为Python3安装软件，那么命令类似的变成py -3 -m pip install XXXX</p>
<h3 id="python2-和-coding-utf-8-哪个写在前面？"><a href="#python2-和-coding-utf-8-哪个写在前面？" class="headerlink" title="#! python2 和 # coding: utf-8 哪个写在前面？"></a>#! python2 和 # coding: utf-8 哪个写在前面？</h3><p>对于Python2用户还有另外一个困惑，Python2要在代码文件顶部增加一行说明，才能够在代码中使用中文。如果指明使用的Python版本也需要在文件顶部增加一行，那哪一行应该放在第一行呢？</p>
<p>#! python2 需要放在第一行，编码说明可以放在第二行。所以文件开头应该类似于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! python2</span><br><span class="line"># coding: utf-8</span><br></pre></td></tr></table></figure></p>
<p>有了这些技巧，Python2和Python3就可以愉快地在一起玩耍了～</p>
<p>其它：<br><a href="https://blog.csdn.net/qiang12qiang12/article/details/53239866" target="_blank" rel="noopener">Windows10下python3和python2同时安装（二）python2.exe、python3.exe和pip2、pip3设置</a><br><code>python3 -m pip install --upgrade pip --force-install</code>无效，还是一个</p>
<h3 id="node-gyp"><a href="#node-gyp" class="headerlink" title="node-gyp"></a>node-gyp</h3><p># <a href="http://blog.mojijs.com/post/156.html" target="_blank" rel="noopener">MSBUILD : error MSB3428: 未能加载 Visual C++ 组件“VCBuild.exe”..</a><br>If you have multiple Python versions installed, you can identify which Python version node-gyp uses by setting the ‘–python’ variable:<br><code>$ node-gyp --python /path/to/python2.7</code>    </p>
<p>If node-gyp is called by way of npm and you have multiple versions of Python installed, then you can set npm’s ‘python’ config key to the appropriate value:<br><code>$ npm config set python /path/to/executable/python2.7</code></p>
<h2 id="第三方库安装"><a href="#第三方库安装" class="headerlink" title="第三方库安装"></a>第三方库安装</h2><p>### lxml 安装失败<br>根据提示，通过安装需要的两个依赖（libxml2 libxslt）,或者easy_install也并不能解决。<br>通过lxml.whl可以成功   </p>
<p>参考：<br><a href="https://blog.csdn.net/seven_zhao/article/details/72896163" target="_blank" rel="noopener">在windows系统中实现python3安装lxml</a>:lxml.whl<br><a href="https://blog.csdn.net/qq_32131499/article/details/52210099" target="_blank" rel="noopener">window下python无法安装lxml问题解决</a>    </p>
<h2 id="实例：爬取图片"><a href="#实例：爬取图片" class="headerlink" title="实例：爬取图片"></a>实例：爬取图片</h2><h2 id="实例：爬取微博数据-及情感分析"><a href="#实例：爬取微博数据-及情感分析" class="headerlink" title="实例：爬取微博数据(及情感分析)"></a>实例：爬取微博数据(及情感分析)</h2><h2 id="实例：爬取微信数据-及情感分析"><a href="#实例：爬取微信数据-及情感分析" class="headerlink" title="实例：爬取微信数据(及情感分析)"></a>实例：爬取微信数据(及情感分析)</h2><h2 id="实例：爬取招聘信息"><a href="#实例：爬取招聘信息" class="headerlink" title="实例：爬取招聘信息"></a>实例：爬取招聘信息</h2><p>爬文章-简书等</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3-Runoob</title>
    <url>/w3/ser/python3-runoob/</url>
    <content><![CDATA[<p>toc only.   </p>
<p><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-tutorial.html</a>   </p>
<p style="text-align:right">2018.7.23 星期四</p>

<p>Python3 中有六个标准的数据类型：<br>Number（数字）<br>String（字符串）<br>List（列表）<br>Tuple（元组）<br>Set（集合）<br>Dictionary（字典）   </p>
<p>Python3 的六个标准数据类型中：<br>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；<br>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。    </p>
<p># A Python3 教程   </p>
<h2 id="Python3-环境搭建"><a href="#Python3-环境搭建" class="headerlink" title="Python3 环境搭建"></a>Python3 环境搭建</h2><h2 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h2><h2 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h2><h2 id="Python3-解释器"><a href="#Python3-解释器" class="headerlink" title="Python3 解释器"></a>Python3 解释器</h2><h2 id="Python3-注释"><a href="#Python3-注释" class="headerlink" title="Python3 注释"></a>Python3 注释</h2><h2 id="Python3-运算符"><a href="#Python3-运算符" class="headerlink" title="Python3 运算符"></a>Python3 运算符</h2><h2 id="Python3-数字-Number"><a href="#Python3-数字-Number" class="headerlink" title="Python3 数字(Number)"></a>Python3 数字(Number)</h2><h2 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h2><h2 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h2><h2 id="Python3-元组"><a href="#Python3-元组" class="headerlink" title="Python3 元组"></a>Python3 元组</h2><h2 id="Python3-字典"><a href="#Python3-字典" class="headerlink" title="Python3 字典"></a>Python3 字典</h2><h2 id="Python3-集合"><a href="#Python3-集合" class="headerlink" title="Python3 集合"></a>Python3 集合</h2><h2 id="Python3-编程第一步"><a href="#Python3-编程第一步" class="headerlink" title="Python3 编程第一步"></a>Python3 编程第一步</h2><h2 id="Python3-条件控制"><a href="#Python3-条件控制" class="headerlink" title="Python3 条件控制"></a>Python3 条件控制</h2><h2 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h2><h2 id="Python3-迭代器与生成器"><a href="#Python3-迭代器与生成器" class="headerlink" title="Python3 迭代器与生成器"></a>Python3 迭代器与生成器</h2><h2 id="Python3-函数"><a href="#Python3-函数" class="headerlink" title="Python3 函数"></a>Python3 函数</h2><h2 id="Python3-数据结构"><a href="#Python3-数据结构" class="headerlink" title="Python3 数据结构"></a>Python3 数据结构</h2><h2 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h2><h2 id="Python3-输入和输出"><a href="#Python3-输入和输出" class="headerlink" title="Python3 输入和输出"></a>Python3 输入和输出</h2><h2 id="Python3-File"><a href="#Python3-File" class="headerlink" title="Python3 File"></a>Python3 File</h2><h2 id="Python3-OS"><a href="#Python3-OS" class="headerlink" title="Python3 OS"></a>Python3 OS</h2><h2 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h2><h2 id="Python3-面向对象"><a href="#Python3-面向对象" class="headerlink" title="Python3 面向对象"></a>Python3 面向对象</h2><h2 id="Python3-标准库概览"><a href="#Python3-标准库概览" class="headerlink" title="Python3 标准库概览"></a>Python3 标准库概览</h2><h2 id="Python3-实例"><a href="#Python3-实例" class="headerlink" title="Python3 实例"></a>Python3 实例</h2><p># BPython3 高级教程       </p>
<h2 id="Python3-正则表达式"><a href="#Python3-正则表达式" class="headerlink" title="Python3 正则表达式"></a>Python3 正则表达式</h2><h2 id="Python3-CGI编程"><a href="#Python3-CGI编程" class="headerlink" title="Python3 CGI编程"></a>Python3 CGI编程</h2><h2 id="Python3-MySQL"><a href="#Python3-MySQL" class="headerlink" title="Python3 MySQL"></a>Python3 MySQL</h2><h2 id="Python3-网络编程"><a href="#Python3-网络编程" class="headerlink" title="Python3 网络编程"></a>Python3 网络编程</h2><h2 id="Python3-SMTP发送邮件"><a href="#Python3-SMTP发送邮件" class="headerlink" title="Python3 SMTP发送邮件"></a>Python3 SMTP发送邮件</h2><h2 id="Python3-多线程"><a href="#Python3-多线程" class="headerlink" title="Python3 多线程"></a>Python3 多线程</h2><h2 id="Python3-XML解析"><a href="#Python3-XML解析" class="headerlink" title="Python3 XML解析"></a>Python3 XML解析</h2><h2 id="Python3-JSON"><a href="#Python3-JSON" class="headerlink" title="Python3 JSON"></a>Python3 JSON</h2><h2 id="Python3-日期和时间"><a href="#Python3-日期和时间" class="headerlink" title="Python3 日期和时间"></a>Python3 日期和时间</h2><h2 id="Python3-内置函数"><a href="#Python3-内置函数" class="headerlink" title="Python3 内置函数"></a>Python3 内置函数</h2><h2 id="Python-Mongodb"><a href="#Python-Mongodb" class="headerlink" title="Python Mongodb"></a>Python Mongodb</h2><h2 id="Python-uwsgi-安装配置"><a href="#Python-uwsgi-安装配置" class="headerlink" title="Python uwsgi 安装配置"></a>Python uwsgi 安装配置</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>Git操作</title>
    <url>/sum/jsplus/git%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.18 星期三 17:30</p>

<p>git –version<br>git init    </p>
<p>github Page好像还区分大小写 </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git config –list （全局，本地）<br>git config  user.name user （修改本地/当前项目）<br>git config user.email <a href="mailto:user@fenhao.doulou" target="_blank" rel="noopener">user@fenhao.doulou</a><br>git config  –global user.name user<br>git config –global –unset user.name</p>
<p>cat .git/config     </p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>git add .<br>git add -A<br>git add –all   </p>
<p>git commit -m ‘mssd’<br>git am -m ‘sdfsf’s    </p>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>On branch master<br>### “Changes not staged for commit:”<br>git 分为工作区和版本库，工作区是你的代码，版本库就是git记录了。<br>在修改进入版本库前有一个暂存区也叫索引，就是做git add 操作后记录的区域。<br>当commit的时候是将暂存区的记录添加到版本数据库。    </p>
<p>你的提示说staged没有内容，也就是说你没有执行过add操作   </p>
<p>### Untracked files:<br>no changes added to commit  </p>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>一堆参数<br>git log –pretty=oneline<br>git show HEAD^:path/to/file  </p>
<h2 id="查找删除文件"><a href="#查找删除文件" class="headerlink" title="查找删除文件"></a>查找删除文件</h2><p>git log -p filename (相对路径)<br>git log – [file_path]<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> see the changes of a file, works even </span><br><span class="line"><span class="meta">#</span> if the file was deleted</span><br><span class="line">git log -- [file_path]  	</span><br><span class="line"><span class="meta">#</span> include stat parameter to see</span><br><span class="line"><span class="meta">#</span> some statics, e.g., how many files were </span><br><span class="line"><span class="meta">#</span> deleted</span><br><span class="line">git log -1 --stat -- [file_path]</span><br></pre></td></tr></table></figure></p>
<p>(上面只是看到的commit，不好使，下面的好用)<br>大多数我们是不知道在何时删除了某个文件，通过下面这个命令我们可以查看在哪个 commit 中删除了哪些文件。<br>git log –diff-filter=D –summary<br>比如我想恢复 ic_selected.png 这个文件，我们可以看到删除该文件对应的 commit id<br>这个命令会检出该 commit 的上一个提交中的文件，因为我们是在该 commit 中删除的文件，所以需要在上一个 commit 才能恢复出文件。<br>git checkout $commit~1 filename   </p>
<p>最后的处理方式：通过git-history(vscode插件)查到历史提交大概删除日期，从该commit中创建并切换分支，找到文件复制出来恢复的。     </p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>git remote<br>git remote -v<br>git remote add origin git://192.145.1.4:12/cloudclass.git<br>git remote set-url origin <a href="http://user@192.134.2:1001/r/cloudclass.git" target="_blank" rel="noopener">http://user@192.134.2:1001/r/cloudclass.git</a>     </p>
<p>新项目第一次添加远程报错:Not a git repository (or any of the parent directories): .git<br>需要执行命令 git init   </p>
<h2 id="clone两种方式-ssh和http"><a href="#clone两种方式-ssh和http" class="headerlink" title="clone两种方式:ssh和http"></a>clone两种方式:ssh和http</h2><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。<br><!-- 参考：[git远程操作](https://www.jianshu.com/p/e78b28081a44)    --></p>
<p>### git Blit<br>git clone ssh:<a href="mailto://user@192.168.1.5" target="_blank" rel="noopener">//user@192.168.1.5</a>:29418/cloudclass.git<br>git clone <a href="http://user@192.168.1.5:10001/r/cloudclass.git" target="_blank" rel="noopener">http://user@192.168.1.5:10001/r/cloudclass.git</a><br>git clone git://192.168.1.5/cloudclass.git      </p>
<p>### github<br>ssh:    <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:videojs/video.js.git<br>https:  <a href="https://github.com/videojs/video.js.git" target="_blank" rel="noopener">https://github.com/videojs/video.js.git</a>     </p>
<p>### ssh(YX:006)<br>SSH是一种网络协议，用于计算机之间的加密登录。采用了公钥加密。<br>github配置ssh后，每次提交代码可以不用输入密码/或者新设置的密码——非账户密码；</p>
<p>如果clone的是https协议，每次都需要登陆github账户<br>### 保存用户名密码（不用每次push都输入）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## git保存用户名密码。主要是后面这两行，如果不想保存，则删除即可</span><br><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure></p>
<p>## git push fatal:HttpRequestException encountered<br>clone完后，在bash中git push 出错‘fatal:HttpRequestException encountered.’<br>原因： github禁用了TLS1.0/1.1协议</p>
<p>截至2018年2月22日，GitHub禁用了对弱加密的支持，这意味着许多用户会突然发现自己无法使用Git for Windows进行身份验证（影响版本低于v2.16.0）。不要恐慌，有一个修复。将Git for Windows更新到最新版本（或至少v2.16.0）。<br>参考：<a href="https://www.cnblogs.com/xuey/p/8474071.html" target="_blank" rel="noopener">git push fatal: HttpRequestException encountered</a></p>
<p>$_PS: 又切换ssh了:git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:user/hello.git</p>
<h2 id="pull-push"><a href="#pull-push" class="headerlink" title="pull/push"></a>pull/push</h2><p>根据remote origin url提及的方式也不一样：ssh/http(clone时会添加，不是通过clone/本地建的项目需要先添加远程仓库)<br>别人提交过，要先pull:远程代码和本地不一致了，需要先pull更新，然后才能提交<br>本地仓库不同通过clone方式建立的/新建的，pull的时候出错：没有关系的仓库;需要添加参数pull<br>建立关系后，以后可以不用指明分支/主机，直接 pull/push</p>
<p>git pull<br>git pull origin master –allow-unrelated-histories<br>git push -u origin master<br>    第一次提交.记得第一次push前commit,否则报错:error: src refspec master does not match any<br>    上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。<br>git push    </p>
<p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>-u: 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。<br>参考：<a href="https://www.cnblogs.com/ederwin/articles/6666614.html" target="_blank" rel="noopener">[git push参数]</a>       </p>
<h2 id="cache相关-gitignore"><a href="#cache相关-gitignore" class="headerlink" title="cache相关/.gitignore"></a>cache相关/.gitignore</h2><p>git rm –cache ./bin/client/release/html/_faker.min.js<br>(add不成功时，也可能是进入到cache中了，此方式也有效)<br>其它，add –all /add -A /add dir/faker.min.js 都没有用  </p>
<p>### lock文件删除失败<br>rm -f xx/.git/index.lock   </p>
<h2 id="git-push-origin-master"><a href="#git-push-origin-master" class="headerlink" title="git push origin master"></a>git push origin master</h2><p># <a href="http://lishicongli.blog.163.com/blog/static/1468259020132125247302/" target="_blank" rel="noopener">Git 的origin和master分析</a></p>
<p>在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git/config可以看到origin的含义），并下载其中所有的数据，建立一个指向它的master 分支的指针，我们用(远程仓库名)/(分支名) 这样的形式表示远程分支，所以origin/master指向的是一个remote branch（从那个branch我们clone数据到本地），但你无法在本地更改其数据。</p>
<p>同时，Git 会建立一个属于你自己的本地master 分支，它指向的是你刚刚从remote server传到你本地的副本。随着你不断的改动文件，git add, git commit，master的指向会自动移动，你也可以通过merge（fast forward）来移动master的指向。<br>……<br>origin指定了你要push到哪个remote</p>
<p>master其实是一个“refspec”，正常的“refspec”的形式为”+<code>&lt;src&gt;:&lt;dst&gt;</code>”，冒号前表示local branch的名字，冒号后表示remote repository下 branch的名字。注意，如果你省略了<code>&lt;dst&gt;</code>，git就认为你想push到remote repository下和local branch相同名字的branch。听起来有点拗口，再解释下，push是怎么个push法，就是把本地branch指向的commit push到remote repository下的branch，比如</p>
<p>$git push origin master:master (在local repository中找到名字为master的branch，使用它去更新remote repository下名字为master的branch，如果remote repository下不存在名字是master的branch，那么新建一个)</p>
<p>$git push origin master （省略了<code>&lt;dst&gt;</code>，等价于“git push origin master:master”）</p>
<p>$git push origin master:refs/for/mybranch (在local repository中找到名字为master的branch，用他去更新remote repository下面名字为mybranch的branch)</p>
<p>$git push origin HEAD:refs/for/mybranch （HEAD指向当前工作的branch，master不一定指向当前工作的branch，所以我觉得用HEAD还比master好些）</p>
<p>$git push origin :mybranch （再origin repository里面查找mybranch，删除它。用一个空的去更新它，就相当于删除了）</p>
<p># <a href="https://www.zhihu.com/question/27712995/answer/39946123" target="_blank" rel="noopener">Git 里面的 origin 到底代表啥意思?</a><br>…<br>这个时候，如果user2想加一个远程指向你的代码库，他可以在控制台输入<br>    git remote add upstream <a href="https://github.com/user1/repository.git" target="_blank" rel="noopener">https://github.com/user1/repository.git</a><br>然后再输入一遍 git remote -v输出结果就会变为:<br>origin <a href="https://github.com/user2/repository.git" target="_blank" rel="noopener">https://github.com/user2/repository.git</a> (fetch)<br>origin <a href="https://github.com/user2/repository.git" target="_blank" rel="noopener">https://github.com/user2/repository.git</a> (push)<br>upstream <a href="https://github.com/user1/repository.git" target="_blank" rel="noopener">https://github.com/user1/repository.git</a> (push)<br>upstream <a href="https://github.com/user1/repository.git" target="_blank" rel="noopener">https://github.com/user1/repository.git</a> (push)</p>
<p>增加了指向user1代码库的upstream，也就是之前对指向位置的命名。总结来讲，顾名思义，origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签， @陈肖恩的答案并不准确，origin指向的是repository，master只是这个repository中默认创建的第一个branch。当你git push的时候因为origin和master都是默认创建的，所以可以这样省略，但是这个是bad practice，因为当你换一个branch再git push的时候，有时候就纠结了</p>
<!-- 
\# [git远程操作](https://www.jianshu.com/p/e78b28081a44)   
## git clone
git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。  
在clone完成之后，... 和上面[Git 的origin和master分析] 差不多
## git fetch
...     
git fetch origin branch1:branch2
首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支), 如果本地不存在branch2分支, 则会自动创建一个新的branch2分支, 如果本地存在branch2分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作.

git fetch origin :branch2
等价于: git fetch origin master:branch2
## git push
git  push  origin  本地分支A : 远程分支B 
回答和上面  [Git 的origin和master分析] 差不多
--->
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>git checkout -b 本地分支名x origin/远程分支名x<br>    采用此种方法建立的本地分支会和远程分支建立映射关系。<br>git fetch origin 远程分支名x:本地分支名x<br>    需要手动checkout;不会和远程分支建立映射关系。    </p>
<p>git branch –set-upstream-to origin/远程分支名  本地分支名</p>
<h2 id="fetch和pull的区别-001"><a href="#fetch和pull的区别-001" class="headerlink" title="[fetch和pull的区别 001]"></a>[fetch和pull的区别 001]</h2><p>要讲清楚git fetch，git pull的区别必须要附加讲清楚git remote，git merge 、远程repo， branch 、 commit-id 以及 FETCH_HEAD。   </p>
<ol>
<li>【git remote】首先， git是一个分布式的结构，这意味着本地和远程是一个相对的名称。<br>本地的repo仓库要与远程的repo配合完成版本对应必须要有 git remote子命令，通过git remote add来添加当前本地长度的远程repo， 有了这个动作本地的repo就知道了当遇到git push 的时候应该往哪里提交代码。</li>
<li>【git branch】其次，git天生就是为了多版本分支管理而创造的，因此分支一说，不得不提， 分支就相当于是为了单独记录软件的某一个发布版本而存在的，既然git是分布式的，便有了本地分支和远程分支一说，git branch 可以查看本地分支， git branch -r 可以用来查看远程分支。 本地分支和远程分支在git push 的时候可以随意指定，交错对应，只要不出现版本从图即可。</li>
<li>【git merge】再者，git的分布式结构也非常适合多人合作开发不同的功能模块，此时如果每个人都在其各自的分支上开发一个相对独立的模块的话，在每次release制作时都需先将各成员的模块做一个合并操作，用于合并各成员的工作成果，完成集成。 此时需要的就是git merge.<br>4.【git push 和 commit-id】在每次本地工作完成后，都会做一个git commit 操作来保存当前工作到本地的repo， 此时会产生一个commit-id，这是一个能唯一标识一个版本的序列号。 在使用git push后，这个序列号还会同步到远程repo。</li>
</ol>
<p>在理解了以上git要素之后，分析git fetch 和 git pull 就不再困难了。<br>首先，git fetch 有四种基本用法      </p>
<ol>
<li>git fetch →→ 这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</li>
<li>git fetch remote_repo →→ 这将更新名称为remote_repo 的远程repo上的所有branch的最新commit-id，将其记录。 </li>
<li>git fetch remote_repo remote_branch_name →→ 这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name</li>
<li>git fetch remote_repo remote_branch_name:local_branch_name →→ 这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。</li>
</ol>
<p>FETCH_HEAD： 是一个版本链接，记录在本地的一个文件中，指向着目前已经从远程仓库取下来的分支的末端版本。</p>
<p>git pull 的运行过程：<br>git pull : 首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。</p>
<h2 id="撤销和回滚-版本回退"><a href="#撤销和回滚-版本回退" class="headerlink" title="撤销和回滚/版本回退"></a>撤销和回滚/版本回退</h2><!-- \# [Git - 暂存区及撤销修改](https://blog.csdn.net/kikajack/article/details/79846098)   -->
<p>通过 git checkout – 文件名 命令可以撤销文件在工作区的修改。<br>通过 git reset 文件名 命令可以撤销指定文件的 git add 操作，即这个文件在暂存区的修改。<br>通过 git reset 命令可以撤销之前的所有 git add 操作，即在暂存区的修改。</p>
<blockquote>
<p>git checkout – 文件名 命令中的 – 表示命令行在 – 之后没有更多的选项。这样的好处是，如果碰巧有一个分支与文件名重名，仍然可以恢复该文件，而不是切换到同名的分支。</p>
</blockquote>
<p>没有放入暂存区（即文件一直在工作区）: git checkout<br>放入暂存区，且文件没有再次修改（即文件已经进入暂存区）: git reset; git checkout<br>放入暂存区，且文件再次修改：分三步 git checkout(撤销工作区的改动);git reset;git checkout</p>
<!-- \# [版本回退](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000)        -->
<p>### 0<br>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。<br>### 1<br>现在，我们要把当前版本回退到上一个版本就可以使用git reset命令：<br>$ git reset –hard HEAD^<br>### 2<br>然我们用git log再看看现在版本库的状态：<br>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？    </p>
<p>1) 只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：<code>$ git reset --hard 1094a</code><br>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。<br>2) Git提供了一个命令git reflog用来记录你的每一次命令：      </p>
<p>### 3<br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：<br>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。      </p>
<p>### 小结<br>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。<br>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。        </p>
<h2 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a>git revert 和 git reset 的区别</h2><!-- \# [Git 回滚代码的正确姿势](https://www.jianshu.com/p/f7451177476a)        -->
<p>sourceTree 中 revert 译为提交回滚，作用为忽略你指定的版本，然后提交一个新的版本。新的版本中已近删除了你所指定的版本。   </p>
<p>reset 为 重置到这次提交，将内容重置到指定的版本。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。   </p>
<p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用git status 命令可以在缓冲区中看到这些修改。而如果加上-–hard参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。可以使用 git push origin HEAD –force 强制将分区内容推送到远程服务器。</p>
<p>默认参数 -soft,所有commit的修改都会退回到git缓冲区<br>参数–hard，所有commit的修改直接丢弃<br>推送到远程 <code>$ git push origin HEAD --force</code>  </p>
<!--
其它:  
[Git撤销&回滚操作](https://blog.csdn.net/ligang2585116/article/details/71094887)
--->
<h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><p><a href="https://git-scm.com/book/zh/v2/Git-工具-储藏与清理" target="_blank" rel="noopener">7.3 Git 工具 - 储藏与清理</a>  </p>
<p>现在想要切换分支，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 <code>git stash 或 git stash save</code>   </p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><h3 id="修改标签名"><a href="#修改标签名" class="headerlink" title="修改标签名"></a>修改标签名</h3><p><a href="https://www.iisns.com/p/1097" target="_blank" rel="noopener">Git 修改 tag 名称</a><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag new old</span><br><span class="line">git tag -d old</span><br><span class="line">git push origin :refs/tags/old</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure></p>
<h2 id="merge操作"><a href="#merge操作" class="headerlink" title="merge操作"></a>merge操作</h2><ol>
<li>不希望合并进去,公开 给 其他人的 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.xml merge=ours</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>git config --global merge.ours.driver true</code>        </p>
<blockquote>
<p>只有先修改的往后来修改的合并的时候才会生效。        </p>
</blockquote>
<h2 id="（Git代码冲突）"><a href="#（Git代码冲突）" class="headerlink" title="（Git代码冲突）"></a>（Git代码冲突）</h2><p>Git出现error: Your local changes to the following files would be overwritten by merge: … Please, commit your changes or stash them before you can merge.  </p>
<p>If you want remove all local changes from your working copy, simply stash them:<br>1、如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:<br>git stash    |git stash save –keep-index<br>git pull<br>git stash pop   |git stash drop<br>然后可以使用Git diff -w +文件名来确认代码自动合并的情况。   </p>
<p>2、如果要直接使用服务器上最新版本，那么可以选择直接覆盖<br>git reset –hard<br>git pull<br>其中git reset是针对版本。,如果想针对文件回退本地修改,使用<br>git checkout HEAD file/to/overwrite<br>git pull    </p>
<p>If you want to overwrite only specific parts of your local changes, there are two possibilities:<br>1. Commit everything you don’t want to overwrite and use the method above for the rest.<br>2. Use <code>git checkout path/to/file/to/revert</code> for the changes you wish to overwrite. Make sure that file is not staged via <code>git reset HEAD path/to/file/to/revert</code>.</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>git clean  -d  -fx “”<br>其中<br>x  —–删除忽略文件已经对git来说不识别的文件<br>d  —–删除未被添加到git的路径中的文件<br>f  —–强制运行</p>
<h2 id="添加多个远程仓库"><a href="#添加多个远程仓库" class="headerlink" title="添加多个远程仓库"></a>添加多个远程仓库</h2><p># <a href="https://blog.csdn.net/mengzuchao/article/details/80489864" target="_blank" rel="noopener">git 本地项目添加多个远程仓库</a><br>第一种方式：</p>
<ol>
<li>添加一个远程库 名字不能是origin<br>git remote add 17MOX  <a href="http://git.17byh.com/17MOX/mxhy.git" target="_blank" rel="noopener">http://git.17byh.com/17MOX/mxhy.git</a>   </li>
<li>拉，推<br>git pull 17MOX    远程分支名：本地分支名<br>git push 17MOx   本地分支名：远程分支名</li>
</ol>
<p>第二种方式：（好处时，推送时，可以同时推送到另外一个库）</p>
<ol>
<li>添加另外一个远程库<br>git remote set-url –add origin <a href="mailto:git@gitlab.com" target="_blank" rel="noopener">git@gitlab.com</a>:mzc/DIVIDE_PKG.git<br>git push origin master:master  </li>
</ol>
<p># <a href="https://segmentfault.com/q/1010000008366409" target="_blank" rel="noopener">Git 怎么添加多个远程仓库呢？</a><br>可以通过-all一次提交多个仓库<br>配置远程仓库<br>git remote add origin <a href="https://url" target="_blank" rel="noopener">https://url</a><br>再添加一个远程仓库<br>git remote set-url –add origin <a href="https://url" target="_blank" rel="noopener">https://url</a>    </p>
<p>注意这里多次添加需要用<br>git remote set-url –add<br>不然会报错：fatal: remote origin already exists.<br>$PS: 这里是上文提到的第二种方式，同时提交<br>或者改名<br>git remote add otherOrigin <a href="https://url" target="_blank" rel="noopener">https://url</a></p>
<p>一次提交到所有远程仓库<br>git push –all</p>
<p>注意<br>git pull 是 git pull (from) origin (to) master<br>git push 是 git push (to) origin (from) master</p>
<h3 id="配置多个仓库，想提交不同的gitignore"><a href="#配置多个仓库，想提交不同的gitignore" class="headerlink" title="配置多个仓库，想提交不同的gitignore"></a>配置多个仓库，想提交不同的gitignore</h3><p>1) 新建分支，修改.gitignore, 删除文件等其他修改。 缺点： 每次都要修改许多文件，然后才可以提交，有些繁琐。<br>2） git rm -r –cached<br>将.setting文件夹从版本库中删除<br>git rm -r –cached  .setting #–cached不会把本地的.setting删除<br>git commit -m ‘delete .setting dir’<br>git push -u origin master</p>
<p>将被.gitignore文件所忽略的文件从版本库中删除<br>git rm -r –cached .<br>git add .<br>git commit<br>git push  -u origin master</p>
<p>用 git rm 来删除文件，同时还会将这个删除操作记录下来；<br>用 rm 来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。</p>
<p>直观的来讲，git rm 删除过的文件，执行 git commit -m “abc” 提交时，会自动将删除该文件的操作提交上去。</p>
<p>而用 rm 命令直接删除的文件，单纯执行 git commit -m “abc” 提交时，则不会将删除该文件的操作提交上去，需要在执行commit的时候，多加一个-a参数，<br>即rm删除后，需要使用git commit -am “abc”提交才会将删除文件的操作提交上去。</p>
<h2 id="git-remote-HTTP-Basic-Access-denied"><a href="#git-remote-HTTP-Basic-Access-denied" class="headerlink" title="git remote: HTTP Basic: Access denied"></a>git remote: HTTP Basic: Access denied</h2><p>原因：远程服务端的用户名和密码与当前系统中git保存的用户名和密码有冲突<br>git config –system –unset credential.helper命令，作用就是清空本地保存的用户名和密码<br>但后面发现每次操作远程仓库都需要重新输入用户名和密码，这个命令清空gitconfig里的自动保存用户名和密码配置，找到本地的gitconfig文件，写入：<br>如果不想保存，则删除即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure></p>
<p>\=====================================\<br># <a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">Connecting to GitHub with SSH</a>    </p>
<h2 id="SSH-key与公钥"><a href="#SSH-key与公钥" class="headerlink" title="SSH key与公钥"></a>SSH key与公钥</h2><p>## 一 About SSH<br>## 二 Checking for existing SSH keys<br>$ ls -al ~/.ssh      </p>
<p>$ ssh-add -l  // 可以通过 ssh-add -l 来确私钥列表<br>可以通过 ssh-add -D 来清空私钥列表<br>$ ssh-add -D<br>## 三 Generating a new SSH key and adding it to the ssh-agent<br>### 3.1 Generating a new SSH key<br>$ ssh-keygen -t rsa -b 4096 -C “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“     </p>
<p>Generating public/private rsa key pair.<br>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]<br>Enter passphrase (empty for no passphrase): [Type a passphrase]<br>Enter same passphrase again: [Type passphrase again]   </p>
<p>默认在 /c/users/administartor/.ssh/…<br>id_rsa:<br>id_rsa.pub: ssh-rsa AAAAB3NzaC1yc2E…<br>known_hosts:github添加成功后会写入：github.com,13.229.188.59 ssh-rsa AAAAB3NzaC1yc…<br>### 3.2 Adding your SSH key to the ssh-agent<br>$ eval $(ssh-agent -s)<br>$ ssh-add ~/.ssh/id_rsa     </p>
<p>$PS: 如果多添加了没关系，反正关掉之后都没有了。需要重新启动ssh-agent, 执行ssh-add ~/.ssh/*/id_rsa</p>
<p>## 四 Adding a new SSH key to your GitHub account<br>$ clip &lt; ~/.ssh/id_rsa.pub<br>然后去github/gitblit等git服务器添加SSH key      </p>
<p>## 五 Testing your SSH connection<br>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>   </p>
<p>The authenticity of host ‘github.com (IP ADDRESS)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes/no)?   </p>
<p>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>## 六 Working with SSH key passphrases    </p>
<p style="text-align:right">18:52</p>

<p>## $PS ssh-keygen删除旧密钥<br>linux 系统上使用ssh工具远程登录设备时，如果之前保存过该设备的密钥，之后该设备密钥更新，此时需执行以下命令才能后续的ssh正常登录。<br>ssh-keygen -f  “/root/.ssh/known_hosts” -R 192.168.0.1<br>其中 -f filename     指定密钥文件名。<br>     -R hostname   从 known_hosts 文件中删除所有属于 hostname 的密钥。</p>
<h2 id="配置多个ssh"><a href="#配置多个ssh" class="headerlink" title="配置多个ssh"></a>配置多个ssh</h2><p>新建config文件,指定HostName对应的IdentityFile<br>$PS: github的Host 和 HostName 必须都是github.com; 上面那个不一样也没事<br>或者都在C:/Users/Administrator/.ssh/下,命名不同的id_rsa文件名, id_work1/work2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 该文件用于配置私钥对应的服务器</span><br><span class="line"># Default github user(first@mail.com)</span><br><span class="line">Host aculearn</span><br><span class="line">HostName 192.168.1.5</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User yalong</span><br><span class="line">IdentityFile C:/Users/Administrator/.ssh/aculearn/id_rsa</span><br><span class="line"># Port 443</span><br><span class="line"># UserKnownHostsFile /dev/null</span><br><span class="line"># StrictHostKeyChecking no/ask/yes</span><br><span class="line"></span><br><span class="line"># second user(second@mail.com)</span><br><span class="line"># 建一个github别名，新建的帐号使用这个别名做克隆和更新</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com  </span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User yalhu</span><br><span class="line">IdentityFile D:/ablob/.ssh/github/id_rsa</span><br><span class="line"># UserKnownHostsFile /dev/null</span><br><span class="line"># StrictHostKeyChecking no</span><br></pre></td></tr></table></figure></p>
<p>Host 表示来源地址匹配字段<br>HostName表示源地址<br>IdentityFile 则为私匙文件地址<br>PreferredAuthentications 权限<br>User 配置私匙的用户名称<br>多个账号可以写相同的Host User不要一样</p>
<p>$PS: dangd的gitlib配置了config没有成功，发现是没有开启ssh，并不是配置失败（换成http， clone可以成功，如果是ssh就不可以）<br>$PS: dangd的gitlib 换了http 提交(强制)也没有成功，把项目(pazhihu) 删除，重新建立就正常了。（也不是私有权限的原因，新建仓库切换成私有也可以提交成功）  </p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>#### 1 下面几种写法都可以<br>C:\Users\huyalong\.ssh\github\id_rsa<br>C:/Users/huyalong/.ssh/reader/id_rsa<br>C:\Users\huyalong.ssh\dangdang\id_rsa    </p>
<p>$_abolish: 因为config id_rsa文件路径不对(没有到id_rsa)。所以每次都需要重新指定位置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~ \#### 2 `ssh-keygen; ssh-add` 需要在当前项目中执行。如果在其他目录执行，并不会配置成功   ~~</span><br><span class="line">~~ \#### 3 每次都要ssh-add 添加id_rsa 到ssh-agent   ~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#11 [是否必须每次添加ssh-add](https://segmentfault.com/q/1010000000835302)   </span><br><span class="line">我的repo 分别推送到github，gitcafe。 正确添加了两个公钥私钥之后，并命名为id_github和id_gitcafe，发现每次push 代码 都必须重新ssh-add 上私钥。将id_github 名改回默认的id_rsa，就可以直接push了。但是gitcafe 被拒绝。有没有办法可以一次都设置上，不需要每次 ssh-add 私钥的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你首先得了解一件事：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了。</span><br><span class="line"></span><br><span class="line">如果是为了永久记住对应的私钥是哪个，我们不能依赖 ssh-agent 服务。能依赖什么则取决于以下哪些方案适合你的使用场景。</span><br><span class="line"></span><br><span class="line">\## 有没有简单点的办法？	</span><br><span class="line">有。如果 ssh-add 已经可以满足你的要求（除了启动以后还要再来一遍以外），那么你完全可以用脚本自动化这件事。简单地把你输入的 ssh-add 命令的内容写进 .bashrc 或 .bash_profile（或其他任何你使用的 shell 环境配置文件）中去，这样只要你打开终端，就等于自动做了这件事情。</span><br><span class="line"></span><br><span class="line">不过如我之前所说，这个机制是依赖 ssh-agent 服务的，并且只能在终端下有效。而用 Keychain 机制的话，是整个系统内都有效的（包括不依赖终端的应用程序）并且无需开启 ssh-agent 服务。</span><br><span class="line"></span><br><span class="line">最后 Keychain 服务不是只有 Mac 才有的，我刚才搜索了一下，Windows 和 各种 Linux 都有对应的机制，不过我没用过，只能以 Mac 为例了。了解了这些概念，相信你可以自己查得到具体的方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 Host 和 Hostname 的对应关系，如果 Hostname 是域名则最好保持一致。但是这里有两个诀窍：	</span><br><span class="line">1. 如果同一域名下有两个不同的配置怎么办？Host 后面对应的是 Github 的两个用户名，</span><br><span class="line">2. 如果域名是数字 IP，是否可以简化呢？ Host 可以帮助你把对应的 IP 变成好记的名字。</span><br><span class="line">$PS: 即host为Hostname（可以是ip）的域名；如果不是ip，最好保持一致  </span><br><span class="line"></span><br><span class="line">\#11 end  ***************************</span><br><span class="line">````````abolish</span><br><span class="line"></span><br><span class="line">### vscode 配置git/ssh</span><br><span class="line">直接点击push不能提交,报deny,权限不足,即使remote的url是git@git.hub.com:user/repository   </span><br><span class="line">而且此时, c:\..user\administartor\.ssh  下已经有config配置了(当前是两个rsa:gitlib,github);   </span><br><span class="line">用Git Bash的时候可以提交, 而且是根据config的配置 弹窗 输入密码后 提交    </span><br><span class="line">$Question:如果github配置的ssh没有密码,是否可以直接提交    </span><br><span class="line">\#### 修正   </span><br><span class="line">[Support git with private key password](https://github.com/Microsoft/vscode/issues/13680#issuecomment-414841885)   </span><br><span class="line">`git config --global core.sshCommand &quot;C:/Windows/System32/OpenSSH/ssh.exe&quot;`   </span><br><span class="line">```markdown</span><br><span class="line">1. Make Git use the OpenSSH that comes with Windows instead of the one that comes with Git.</span><br><span class="line">git config --global core.sshCommand &quot;C:/Windows/System32/OpenSSH/ssh.exe&quot;</span><br><span class="line">2. Set the ssh-agent service (not the one that comes with git) to run automatically.</span><br><span class="line">Open Task Manager, Services tab, click Open Services.</span><br><span class="line">Find OpenSSH Authentication Agent, open properties, set Startup Type to Automatic, hit OK.</span><br><span class="line">Also start the service or restart your computer.</span><br><span class="line">3. Add your password protected key to the agent.</span><br><span class="line">ssh-add</span><br><span class="line">It should automatically pick up keys stored in C:\Users\%USERNAME%\.ssh which is where ssh-keygen creates them.</span><br><span class="line">Enter your password(s) at the prompt.</span><br></pre></td></tr></table></figure></p>
<p>是可以通过push提交<br>问题:<br><!-- <https://github.com/Microsoft/vscode/issues/13680#issuecomment-440524500> --></p>
<ol>
<li>提交的时候不需要密码   </li>
<li>只有新建的ssh有用,如果用之前配过的,比如: ablob.ssh\id_rsa 就会报错<br><code>ssh-add .ssh/id_rsa</code> (从ablob复制过来)    </li>
<li>貌似设置新的ssh后原先的(ablob)也没有输入密码就提交了    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">Permissions for &apos;D:/ablob/.ssh/id_rsa&apos; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;D:/ablob/.ssh/id_rsa&quot;: bad permissions</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#### git-credential-store - Helper<br>git-credential-store:<a href="https://git-scm.com/docs/git-credential-store" target="_blank" rel="noopener">https://git-scm.com/docs/git-credential-store</a><br>git-credential-store - Helper to store credentials on disk<br>保存密码在文件中,可以不用设置ssh,https的远程仓库也可以提交.<br>不足:保存密码的文件权限需要专门设置权限,来保证安全性        </p>
<p>$PS: 余下都是一些设置ssh的教程,没有设置密码.可能不设置密码可以push成功<br><!-- 其它:   
[vsCode 使用git问题](https://segmentfault.com/q/1010000013809777)
 --></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="sourceTree"><a href="#sourceTree" class="headerlink" title="sourceTree"></a>sourceTree</h2><p>破解: 需要认证时退出，修改以下文件后，重新启动。<br>C:\Users\huyalong\AppData\Local\Atlassian\SourceTree\account.json<br>C:\Users\huyalong\AppData\Local\Atlassian\SourceTree.exe_Url_1kidzh22pwslluf1rgjympiqlohmf5ps\3.1.3.3158\user.config<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;setting name=&quot;DiffContext&quot; serializeAs=&quot;String&quot;&gt;</span><br><span class="line">	&lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;</span><br><span class="line">&lt;setting name=&quot;DiffWhiteSpaceIgnored&quot; serializeAs=&quot;String&quot;&gt;</span><br><span class="line">	&lt;value&gt;False&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;,</span><br><span class="line">    &quot;Authenticate&quot;: true,</span><br><span class="line">    &quot;HostInstance&quot;: &#123;</span><br><span class="line">      &quot;$id&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;,</span><br><span class="line">      &quot;Host&quot;: &#123;</span><br><span class="line">        &quot;$id&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;atlassian account&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Credentials&quot;: &#123;</span><br><span class="line">      &quot;$id&quot;: &quot;4&quot;,</span><br><span class="line">      &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;,</span><br><span class="line">      &quot;Username&quot;: &quot;&quot;,</span><br><span class="line">      &quot;Email&quot;: null</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;IsDefault&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git文件忽略</title>
    <url>/sum/jsplus/git%E6%96%87%E4%BB%B6%E5%BF%BD%E7%95%A5/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.18 星期四 17:03</p>

<p># </p>
<h3 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h3><ol>
<li>本地项目  .git/info/exclude<br>全局项目  .gitignore<br>全局忽略    不需要在每一个仓库中添加 .gitignore 文件或者修改 exclude文件(毕竟在.git文件里乱动可能项目就没了), 只需要在用户账户文件夹下建立.gitignore_global文件就可以忽略我们想忽略的内容, 步骤如下:</li>
</ol>
<p>在git bash下执行命令 git config –global core.excludesfile ~/.gitignore_global, 然后你会发现, ~/.gitconfig 文件里多了一行<br>git_config里的变化<br>创建 .gitignore_global 文件, 在里面写上规则就好了</p>
<h1 id="git-文件忽略"><a href="#git-文件忽略" class="headerlink" title="git 文件忽略"></a>git 文件忽略</h1><p>原文：<a href="https://segmentfault.com/a/1190000013776387" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013776387</a><br>$_PS: YX一直同步失败</p>
<p>在使用git进行版本管理时，有一些不需要提交到版本库里的文件和文件夹，或者在管理一个实际应用的开源项目的时候，不可以把带有数据库信息的文件上传到开源平台当中，此时就需要让git自动忽略掉一下文件。文件忽略有几种方式：</p>
<h2 id="一-没有被track的文件"><a href="#一-没有被track的文件" class="headerlink" title="一 没有被track的文件"></a>一 没有被track的文件</h2><p>我们需要在项目的根目录当中创建.gitignore文件。 .gitignore 的格式规范如下：</p>
<p>1. 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略;<br>1. 匹配模式最后跟反斜杠（/）说明要忽略的是目录;<br>1. 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反;<br>1. 可以使用标准的 glob 模式匹配;　<br>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*星 　 匹配零个或多个任意字符；</span><br><span class="line">?　 　 只匹配一个任意字符；</span><br><span class="line">[abc]　匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；</span><br><span class="line">[0-9]　表示匹配所有 0 到 9 的数字；</span><br><span class="line">*？    代表任意的一个字符</span><br><span class="line">**    代表任意数目的字符</span><br><span class="line">*&#123;!ab&#125;    必须不是此类型</span><br><span class="line">*&#123;ab,bb,cx&#125;    代表ab,bb,cx中任一类型即可</span><br><span class="line">*[ ^abc]    代表必须不是a,b,c中任一字符</span><br><span class="line"></span><br><span class="line">由于git不会加入空目录，所以下面做法会导致tmp不会存在</span><br><span class="line">tmp/* //忽略tmp文件夹所有文件</span><br><span class="line">改下方法，在tmp下也加一个.gitignore,内容为</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line">!.gitignore</span><br><span class="line">注意：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的</span><br></pre></td></tr></table></figure></p>
<h2 id="二-另外-git-还提供了另一种-exclude-的方式来做同样的事情。"><a href="#二-另外-git-还提供了另一种-exclude-的方式来做同样的事情。" class="headerlink" title="二 另外 git 还提供了另一种 exclude 的方式来做同样的事情。"></a>二 另外 git 还提供了另一种 exclude 的方式来做同样的事情。</h2><p>不同的是 .gitignore 这个文件本身会提交到版本库中去，用来保存的是公共的需要排除的文件。<br>而 .git/info/exclude 这里设置的则是你自己本地需要排除的文件,不会提交到版本库，只对本地副本有效， 他不会影响到其他人。</p>
<p>exclude 文件所在位置.git/info/exclude , 每个项目下都有自己的exclude<br>vim .git/info/exclude</p>
<p>全局ignore方法，唯一，本地所有git repo有效。~/.gitconfig/core.excludesfile<br>1.账户文件夹下新建一个.gitignore_global文件<br>2.直接修改.gitconfig的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = c:/Users/你的账户文件夹/.gitignore_global</span><br><span class="line">或者，在Git的命令行里输入：</span><br><span class="line"></span><br><span class="line">$ git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line">注意：exclude 忽略的也是未tract的文件。</span><br></pre></td></tr></table></figure></p>
<h2 id="三-文件已被track"><a href="#三-文件已被track" class="headerlink" title="三 文件已被track"></a>三 文件已被track</h2><p>即远程仓库中已经包含或者已经commit/add了，这时再在.gitignore中添加规则忽略已经无法生效了，正确的做法是：<br>1. 首先，删除暂存区或分支上的文件，<code>$ git rm --cached config.xml</code><br>2. 然后，更新.gitignore文件忽略掉config.xml<br>3. 最后，<code>$ git commit -m &quot;&quot;</code> </p>
<p>按照上面的方法，当你push之后，服务器的config.xml文件将被删除。本地存在可使用, 只是文件不被版本控制（如果没有更新 .gitignore, 会提示有untrack文件）。<br>有一点需要注意的，git rm –cached 不会删除本地的物理文件；如果你真的是彻底不想要了，你也可以直接 rm＋忽略＋提交,即不要 –cached 参数。</p>
<h2 id="四-只是想在本地忽略某文件的修改，但是服务器保存一份副本。"><a href="#四-只是想在本地忽略某文件的修改，但是服务器保存一份副本。" class="headerlink" title="四 只是想在本地忽略某文件的修改，但是服务器保存一份副本。"></a>四 只是想在本地忽略某文件的修改，但是服务器保存一份副本。</h2><p>正确的做法是在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。 </p>
<p>对于所有协同开发人员以及任何新加入的开发人员执行：</p>
<p>$ git update-index –assume-unchanged FILE 在FILE处输入要忽略的文件. 假设未更改<br>查看忽略的文件列表</p>
<p>$ git ls-files -v|grep h\ // \后面有空格<br>如果要还原的话，使用命令：</p>
<p>$ git update-index –no-assume-unchanged FILE<br>这样就可以在本地版本库中忽略FILE文件的修改。但是，切记一点，这样做必须保证协同开发的所有人都执行此命令，但凡有一个人不执行，则FILE文件的更改等到commit和push的时候便会更新到服务器而导致不愿发生的情形出现。 亲手实验结果：如果本地执行假设未更改的命令，其他人修改了文件并推送后，本地git pull提示：error: Your local changes to the following files would be overwritten by merge: FILE。git status，nothing to commit, working tree clean。如果没有更改，可以正常git pull合并，但会失去忽略状态。</p>
<h2 id="五-gitignore-还有个有意思的小功能"><a href="#五-gitignore-还有个有意思的小功能" class="headerlink" title="五 .gitignore 还有个有意思的小功能"></a>五 .gitignore 还有个有意思的小功能</h2><p>一个空的 .gitignore 文件 可以当作是一个 placeholder 。当你需要为项目创建一个空的 log 目录时， 这就变的很有用。 你可以创建一个 log 目录 在里面放置一个空的 .gitignore 文件。这样当你 clone 这个 repo 的时候 git 会自动的创建好一个空的 log 目录了。</p>
<p style="text-align:right">17:17</p>


<h1 id="排除忽略"><a href="#排除忽略" class="headerlink" title="排除忽略"></a>排除忽略</h1><p>如果你排除了application/，那么它下的所有东西都会被排除在外(即使一些后来的否定排除模式(“unignore”)可能与下面的内容相匹配)。application/).</p>
<p>要想做您想做的事情，您必须“unignore”您想要“unignore”的任何东西的每个父目录。通常情况下，您会成对地编写规则：忽略目录中的所有内容，而不是某些特定的子目录。</p>
<h1 id="you-can-skip-this-first-one-if-it-is-not-already-excluded-by-prior-patterns-application"><a href="#you-can-skip-this-first-one-if-it-is-not-already-excluded-by-prior-patterns-application" class="headerlink" title="you can skip this first one if it is not already excluded by prior patterns !application/"></a>you can skip this first one if it is not already excluded by prior patterns <code>!application/</code></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application/*</span><br><span class="line">!application/language/</span><br><span class="line"></span><br><span class="line">application/language/*</span><br><span class="line">!application/language/gr/</span><br></pre></td></tr></table></figure>
<p><strong>注: 尾随/*意义重大：</strong></p>
<p>模式  dir/</p>
<p>不包括名为 dir, 以及(隐式地)它下面的一切。</p>
<p>带着<br>dir/</p>
<p>，Git永远不会看下面的任何东西<br>dir</p>
<p>，因此永远不会将任何“不排除”模式应用于下面的任何内容。<br>dir.</p>
<p>模式<br>dir/*</p>
<p>什么都没说<br>dir</p>
<p>它本身；它只是排除了下面的一切<br>dir</p>
<p>..带着<br>dir/*</p>
<p>，git将处理<br>dir</p>
<p>，使其他模式有机会“不排除”一些内容(<br>!dir/sub/).</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Onclick参数传递</title>
    <url>/sum/js/onclick%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>onclick参数传递,包括this，event    </p>
<h2 id="onclick参数"><a href="#onclick参数" class="headerlink" title="onclick参数"></a>onclick参数</h2><p>onclick调用参数必须有意义，比如this，event,3,’22’等<br>参数可以写在任意位置,包括this，event<br>实质：onclick中定义的直接是js语句，所以类似this/this.value,event/evnet.preventDefault()等是合法的；</p>
<h2 id="event对象及参数传递："><a href="#event对象及参数传递：" class="headerlink" title="event对象及参数传递："></a>event对象及参数传递：</h2><ol>
<li><p>e只是个形参，并没有e，会error；<br>而event如果直接输出，在chrome,ie11中是undefined;ff中是error;<br>如果是在事件句柄中，无论chrome，还是ff，此时就会得到一个event对象</p>
</li>
<li><p>浏览器兼容<br>在ff中，调用的时候需要以参数 <code>event</code>的形式传入；函数声明时，形参可以是e。<br>chrome和ie，需要用window.event<br>通用的兼容写法 var e=e||window.event;</p>
</li>
<li><p>事件句柄函数中也可以传递参数；默认第一个参数是event。<br>onclick调用时，不用传递event参数，函数声明时默认第一个就是event对象，可以直接调用    </p>
</li>
<li><p>addEventListener回调函数中event对象要以第一个参数传递   </p>
</li>
<li>jQuery中on/click/bind…，应该是和addEventListener是相同的，需要event对象的时候，需要以第一个参数传递  </li>
</ol>
<pre><code class="html"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"test(3)"</span> <span class="attr">value</span>=<span class="string">"button"</span>&gt;</span>btn<span class="tag">&lt;/<span class="name">button</span>&gt;</span>
<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"test(this.value)"</span> <span class="attr">value</span>=<span class="string">"btn2"</span>&gt;</span>btn2<span class="tag">&lt;/<span class="name">button</span>&gt;</span>
<span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"testE(this,23)"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>test e<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
<span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"testE(23,this)"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>test参数顺序<span class="tag">&lt;/<span class="name">a</span>&gt;</span>
<span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"event.preventDefault()"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>test evnet对象<span class="tag">&lt;/<span class="name">a</span>&gt;</span>

<span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"taga"</span>  <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>test jquery<span class="tag">&lt;/<span class="name">a</span>&gt;</span>


<span class="tag">&lt;<span class="name">script</span>&gt;</span>
<span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v</span>)</span>{</span>
<span class="javascript">        <span class="built_in">console</span>.log(v)</span>
    }
<span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">testE</span>(<span class="params">node,v,e</span>)</span>{</span>
<span class="javascript">        <span class="built_in">console</span>.log(node)</span>
<span class="javascript">        <span class="built_in">console</span>.log(v)</span>
<span class="javascript">        <span class="built_in">console</span>.log(e);</span>
<span class="javascript">        <span class="comment">//var e=e||window.event;</span></span>
<span class="javascript">        <span class="keyword">var</span> e=<span class="built_in">window</span>.event;</span>
        e.preventDefault();
<span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'test evnet'</span>,e);</span>
    }

<span class="javascript">    taga.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a,e</span>)</span>{</span>
<span class="javascript">        <span class="built_in">console</span>.log(e);</span>
<span class="javascript">        <span class="built_in">console</span>.log(a);</span>
        a.preventDefault();
    });


<span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">ev</span>)</span>{<span class="comment">// 测试第三条   </span></span>
<span class="javascript">        <span class="built_in">console</span>.log(ev)</span>
    }
<span class="javascript">    fn1(<span class="number">1</span>)<span class="comment">// 1</span></span>
<span class="javascript">    <span class="built_in">document</span>.onclick=fn1 <span class="comment">// event对象</span></span>
<span class="tag">&lt;/<span class="name">script</span>&gt;</span>
</code></pre>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本语言</title>
    <url>/sum/os/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80(023)/</url>
    <content><![CDATA[<p>cmd，bat/sh<br>.ini,   .vbs,    .nsi,   </p>
<h1 id="A-命令行-脚本"><a href="#A-命令行-脚本" class="headerlink" title="A 命令行/脚本"></a>A 命令行/脚本</h1><p>批处理<br>.bat      .sh     </p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>cd,mv,cp,ls,rm,cat,vi,echo   </p>
<p>bat：start,call,    </p>
<p>bat中代码可以多行复制到命令行直接执行，但是好像到 <code>timeout 3 &gt; NUL</code>就停了    </p>
<h2 id="win和linus指令对比"><a href="#win和linus指令对比" class="headerlink" title="win和linus指令对比"></a>win和linus指令对比</h2><!-- [附录 C. DOS 和 Linux 常用命令的对比](http://www.huihoo.org/gnu_linux/ch-doslinux.html)       -->
<p>### 相同<br>cd,exit,echo,mkdir<br>tree,    </p>
<p>copy      cp<br>move       mv<br>ren      mv (重命名)<br>del    rm<br>dir   ls  </p>
<pre><code>touch(新建)    
</code></pre><p>type     cat<br>cls     clear  </p>
<p>time  date      </p>
<p>### tree<br>windows: tree /f &gt; list.txt<br>    两个参数 /f  /a    </p>
<p>linus 需要安装，且参数更多</p>
<h2 id="linux-查看进程"><a href="#linux-查看进程" class="headerlink" title="linux 查看进程"></a>linux 查看进程</h2><p>这里以常用的80端口为例，进行查找<br>执行 netstat -nlp|grep 80</p>
<p>通过记录信息， 6697/httpd 表示进程号和进程名称，如果不需要它，可以将该进程停止，执行<br>kill -9 6697</p>
<p>如果是某些服务进程，kill掉后，又会重新产生一个进程，继续占用这个端口<br>从上图中，80端口继续占用着，可以采用停服务的办法,本例中由httpd服务占用，<br>执行service httpd stop<br>再次执行 netstat -nlp|grep 80   </p>
<h2 id="编辑模式-vim"><a href="#编辑模式-vim" class="headerlink" title="编辑模式 vim"></a>编辑模式 vim</h2><p>### 进入<br>命令行(需要bash-linus)：vi test.txt  / vim test.txt  </p>
<p>### 退出<br>如果是输出状态，首先按Esc键退出输入状态，然后按Shift+“;”，<br>再输入q!或wq!（不保存改动，wq!是保存文件的写入修改）退出。  </p>
<p>补充：<br>只要按住shift键盘，下面的这些命令都可以用：<br>1、如果你想编辑某个文档，可以直接编辑的如：你有文档AA，可以用vi AA 【注意：必须在AA所在的目录下】。<br>2、如果没有文档，而且你又想编辑就可以直接编辑vi aa【名字你可以随便命名】。<br>3、也可以先建立一个文档touch aa ，然后再编辑vi aa。     </p>
<p>编辑器有三种模式：1、命令行模式 2、末行模式 3、输入模式。<br>5、按Esc 就可以进入命令行模式，也是系统默认模式。<br>6、输入模式可以按 o i a 都可以进入，退出可以进入末行和命令行模式。<br>7、末行模式可以按ctrl+；它的主要功能是退出编辑器，也可以保存退出文档。      </p>
<p>8、q! 【强制退出不保存】，q【退出不保存】，wq【退出并保存后面也可以加个！】。   </p>
<p>9、在输入模式和命令行模式命令很多。<br>10、如复制（yy）、粘贴（p)、删除（d）等等   </p>
<h1 id="bat-cmd"><a href="#bat-cmd" class="headerlink" title="bat/cmd"></a>bat/cmd</h1><h2 id="cmd和-bat"><a href="#cmd和-bat" class="headerlink" title=".cmd和.bat"></a><em>.cmd和</em>.bat</h2><p># <a href="https://blog.csdn.net/bingjie1217/article/details/12947327" target="_blank" rel="noopener">windows批处理(cmd/bat)编程详解</a><br>开始之前先简单说明下cmd文件和bat文件的区别：在本质上两者没有区别，<br>都是简单的文本编码方式，都可以用记事本创建、编辑和查看。两者所用的命令行代码也是共用的，</p>
<p>只是cmd文件中允许使用的命令要比bat文件多。cmd文件只有在windows2000以上的系统中才能运行，而bat文件则没有这个限制。<br>从它们的文件描述中也可以看出以上的区别：cmd文件的描述是“windows nt命令脚本”， bat文件的描述是“ms dos批处理文件”</p>
<p>如果没有一定的相关知识恐怕不容易看懂和理解批处理文件，也就更谈不上自己动手编写了.批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为 .bat 或 .cmd。在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统就会调用cmd.exe按照该文件中各个命令出现的顺序来逐个运行它们。使用批处理文件（也被称为批处理程序或脚本），可以简化日常或重复性任务。当然我们的这个版本的主要内容是介绍批处理在入侵中一些实际运用，例如我们后面要提到的用批处理文件来给系统打补丁、批量植入后门程序等。下面就开始我们批处理学习之旅吧。</p>
<h2 id="bat注释"><a href="#bat注释" class="headerlink" title="bat注释"></a>bat注释</h2><p><a href="https://blog.csdn.net/wh_19910525/article/details/8125762" target="_blank" rel="noopener">bat批处理的注释语句</a><br>在批处理中，段注释有一种比较常用的方法：   </p>
<pre><code>goto start   
 = 可以是多行文本，可以是命令   
 = 可以包含重定向符号和其他特殊字符   
 = 只要不包含 :start 这一行，就都是注释   
:start  
</code></pre><p>另外，还有其他各种注释形式，比如：<br>   1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>    2、rem 注释内容（不能出现重定向符号和管道符号）<br>    3、echo 注释内容（不能出现重定向符号和管道符号）〉nul<br>    4、if not exist nul 注释内容（不能出现重定向符号和管道符号）<br>    5、:注释内容（注释文本不能与已有标签重名）<br>    6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）<br>    7、goto 标签 注释内容（可以用作说明goto的条件和执行内容）<br>    8、:标签 注释内容（可以用作标签下方段的执行内容）   </p>
<h2 id="bat结束后窗口不退出"><a href="#bat结束后窗口不退出" class="headerlink" title="bat结束后窗口不退出"></a>bat结束后窗口不退出</h2><p>### 常规<br><!-- [不让bat文件运行命令结束后cmd窗口自动关闭](https://blog.csdn.net/muyimo/article/details/73302070)    --><br>方法1<br>假设你的bat名字叫aaa.bat你可以新开一个bat，内容是<br>start aaa.bat<br>然后这个新的bat是不会自动关闭的     </p>
<p>方法2<br>要执行bat后不退出，可以在bat里的最后添加pause命令，暂停等待<br>（不过再按键盘就没了）     </p>
<p>方法3 推荐！！<br>只要在bat文件最后运行个cmd.exe就行了。。。</p>
<p>###   修改注册表，所有文件适用<br><!-- [让bat文件运行后不自动关闭](https://blog.csdn.net/wind19/article/details/4888430)    --><br> .bat文件运行后不关闭窗口的方法<br>1、在批处理里面加上 cmd 或 pause，这样可以针对几个bat文件  </p>
<p>2、改注册表， 所有的bat文件都会受到影响<br>在HKEY_CLASSES_ROOT/batfile/shell/open/command<br>里面把默认项的值改成cmd /E:ON /V:ON /F:ON /k “%1” %* 就可以了   </p>
<h1 id="B-脚本语言024-VBS"><a href="#B-脚本语言024-VBS" class="headerlink" title="B 脚本语言024  VBS"></a>B 脚本语言024  VBS</h1><p><a href="https://blog.csdn.net/Loongstyle/article/details/80035012" target="_blank" rel="noopener">[初识vbs和bat]</a><br>VBScript是Visual Basic Script的简称，即 Visual Basic 脚本语言，有时也被缩写为VBS。<br>它是一种微软环境下的轻量级的解释型语言，它使用COM组件、WMI、WSH、ADSI访问系统中的元素，对系统进行管理。同时它又是asp动态网页默认的编程语言，配合asp内建对象和ADO对象，用户很快就能掌握访问数据库的asp动态网页开发技术。     </p>
<p><a href="https://zhidao.baidu.com/question/1637068886107596380.html" target="_blank" rel="noopener">VBS和BAT的区别</a>    </p>
<h2 id="bat和vbs比较一"><a href="#bat和vbs比较一" class="headerlink" title="bat和vbs比较一"></a>bat和vbs比较一</h2><p>bat常用于<br>1处理文件，例如压缩，复制，新建文件夹等<br>2程序管理，例如启动程序和结束程序等<br>3网络管理，上传文件，查看ip等<br>4系统设置，修改注册表，权限设置，    </p>
<p>bat一般都能调用系统本身的命令bat 一般运行都有个黑框的<br>vbs一般都是隐藏运行的，bat能做的vbs一般都能做，也可以处理文件，管理程序等   </p>
<p>vbs与BAT不同的是<br>1vbs能模拟按键，比如你可以做个VBS自动按F5，自己刷新，有了这个功能就能控制很多软件了。甚至能破解一些密码<br>2vbs的窗口不像BAT那样，我对BAT窗口感到好无赖，因为在BAT进行选择的话，先输入某个键，还要敲回车键的，而vbs用鼠标点就行了。   </p>
<!-- 
## bat和vbs比较二   
BAT 是MS-DOS的批处理文件，执行的是DOS命令。    
VBS其实是VB script的简写，执行的是VB的脚本命令。    

BAT常做简单的系统操作。如删除系统垃圾，重复拷贝文件……BAT相对而言简单应用，通过if和for语句构成应用的小程序。     
VBS是开发网站的语言(动网就是用VBS些的)。    
但VBS有 Windows 脚本宿主对象模型根对象的访问，也就是可以在windows下执行。所以可以用VBS开发Win下的小程序。   
VBS用法和VB一样，但灵活性更强。比如VB变量必须先定义再使用，而VBS可以随心所欲的使用变量(最好养成先定义在使用的习惯，可以增强可读性)。vbs变量间的灵活性也很强，比如字符型和整型几乎是一样使用的不必刻意去转换，可是细节的地方还是要明确的转换的。VBS简单易用，后缀可以是.vbs .vbe 就是JS脚本 在Win底下运行的话就要改成.jse相信你会喜欢vbs的
-->
<h2 id="vbs"><a href="#vbs" class="headerlink" title="vbs"></a>vbs</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>python等也可以写脚本<br>程序打包语言:NSIS </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>JS模式</title>
    <url>/pdf/js/JS%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.2 星期一 23:15</p>

<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><h3 id="1-1-模式"><a href="#1-1-模式" class="headerlink" title="1.1 模式"></a>1.1 模式</h3><h3 id="1-2-javascript：基本概念"><a href="#1-2-javascript：基本概念" class="headerlink" title="1.2 javascript：基本概念"></a>1.2 javascript：基本概念</h3><h3 id="1-3-ECMAScript-5"><a href="#1-3-ECMAScript-5" class="headerlink" title="1.3 ECMAScript 5"></a>1.3 ECMAScript 5</h3><h3 id="1-4-JSLint"><a href="#1-4-JSLint" class="headerlink" title="1.4 JSLint"></a>1.4 JSLint</h3><h3 id="1-5-Console"><a href="#1-5-Console" class="headerlink" title="1.5 Console"></a>1.5 Console</h3><h2 id="二-基本技巧"><a href="#二-基本技巧" class="headerlink" title="二 基本技巧"></a>二 基本技巧</h2><!-- ### 2.1 编写可
### 2.2 
### 2.3 
### 2.4 
### 2.5 
### 2. 
### 2. -->     
<p>编写可维护的代码<br>尽量少用全局变量<br>for循环<br>for-in循环<br>不要增加内置的原型<br>switch模式<br>避免使用隐式类型转换<br>使用parseInt()的数值约定<br>编码约定<br>命名约定<br>编写注释<br>编写API文档<br>编写可读性强的代码<br>同行互查<br>在正式发布时精简代码<br>运行JSLint</p>
<h2 id="三-字面量和构造函数"><a href="#三-字面量和构造函数" class="headerlink" title="三 字面量和构造函数"></a>三 字面量和构造函数</h2><h3 id="3-1-对象字面量"><a href="#3-1-对象字面量" class="headerlink" title="3.1 对象字面量"></a>3.1 对象字面量</h3><h3 id="3-2-自定义构造函数"><a href="#3-2-自定义构造函数" class="headerlink" title="3.2 自定义构造函数"></a>3.2 自定义构造函数</h3><h3 id="3-3-强制使用new的模式"><a href="#3-3-强制使用new的模式" class="headerlink" title="3.3 强制使用new的模式"></a>3.3 强制使用new的模式</h3><h3 id="3-4-数组字面量"><a href="#3-4-数组字面量" class="headerlink" title="3.4 数组字面量"></a>3.4 数组字面量</h3><h3 id="3-5-JSON"><a href="#3-5-JSON" class="headerlink" title="3.5 JSON"></a>3.5 JSON</h3><h3 id="3-6-正则表达式字面量"><a href="#3-6-正则表达式字面量" class="headerlink" title="3.6 正则表达式字面量"></a>3.6 正则表达式字面量</h3><h3 id="3-7-基本类型包装器"><a href="#3-7-基本类型包装器" class="headerlink" title="3.7 基本类型包装器"></a>3.7 基本类型包装器</h3><h3 id="3-8-错误对象"><a href="#3-8-错误对象" class="headerlink" title="3.8 错误对象"></a>3.8 错误对象</h3><h2 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h2><h3 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h3><h3 id="4-2-回调模式"><a href="#4-2-回调模式" class="headerlink" title="4.2 回调模式"></a>4.2 回调模式</h3><h3 id="4-3-返回函数"><a href="#4-3-返回函数" class="headerlink" title="4.3 返回函数"></a>4.3 返回函数</h3><h3 id="4-4-自定义函数"><a href="#4-4-自定义函数" class="headerlink" title="4.4 自定义函数"></a>4.4 自定义函数</h3><h3 id="4-5-即时函数"><a href="#4-5-即时函数" class="headerlink" title="4.5 即时函数"></a>4.5 即时函数</h3><h3 id="4-6-即时对象初始化"><a href="#4-6-即时对象初始化" class="headerlink" title="4.6 即时对象初始化"></a>4.6 即时对象初始化</h3><h3 id="4-7-初始化时分支"><a href="#4-7-初始化时分支" class="headerlink" title="4.7 初始化时分支"></a>4.7 初始化时分支</h3><h3 id="4-8-函数属性-备忘模式"><a href="#4-8-函数属性-备忘模式" class="headerlink" title="4.8 函数属性-备忘模式"></a>4.8 函数属性-备忘模式</h3><h3 id="4-9-配置对象"><a href="#4-9-配置对象" class="headerlink" title="4.9 配置对象"></a>4.9 配置对象</h3><h3 id="4-0-Curry"><a href="#4-0-Curry" class="headerlink" title="4.0 Curry"></a>4.0 Curry</h3><h2 id="五-对象创建模式"><a href="#五-对象创建模式" class="headerlink" title="五 对象创建模式"></a>五 对象创建模式</h2><h3 id="5-1-命名空间模式"><a href="#5-1-命名空间模式" class="headerlink" title="5.1 命名空间模式"></a>5.1 命名空间模式</h3><h3 id="5-2-声明依赖关系"><a href="#5-2-声明依赖关系" class="headerlink" title="5.2 声明依赖关系"></a>5.2 声明依赖关系</h3><h3 id="5-3-私有属性和方法"><a href="#5-3-私有属性和方法" class="headerlink" title="5.3 私有属性和方法"></a>5.3 私有属性和方法</h3><h3 id="5-4-模块模式"><a href="#5-4-模块模式" class="headerlink" title="5.4 模块模式"></a>5.4 模块模式</h3><h3 id="5-5-沙箱模式"><a href="#5-5-沙箱模式" class="headerlink" title="5.5 沙箱模式"></a>5.5 沙箱模式</h3><h3 id="5-6-静态成员"><a href="#5-6-静态成员" class="headerlink" title="5.6 静态成员"></a>5.6 静态成员</h3><h3 id="5-7-对象常量"><a href="#5-7-对象常量" class="headerlink" title="5.7 对象常量"></a>5.7 对象常量</h3><h3 id="5-8-链模式"><a href="#5-8-链模式" class="headerlink" title="5.8 链模式"></a>5.8 链模式</h3><h3 id="5-9-method-方法"><a href="#5-9-method-方法" class="headerlink" title="5.9 method()方法"></a>5.9 method()方法</h3><h2 id="六-代码复用模式"><a href="#六-代码复用模式" class="headerlink" title="六 代码复用模式"></a>六 代码复用模式</h2><h3 id="6-1-传统与现代继承模式的比较"><a href="#6-1-传统与现代继承模式的比较" class="headerlink" title="6.1 传统与现代继承模式的比较"></a>6.1 传统与现代继承模式的比较</h3><h3 id="6-2-使用类式继承时的预期结果"><a href="#6-2-使用类式继承时的预期结果" class="headerlink" title="6.2 使用类式继承时的预期结果"></a>6.2 使用类式继承时的预期结果</h3><h3 id="6-3-类式继承模式-1-默认模式"><a href="#6-3-类式继承模式-1-默认模式" class="headerlink" title="6.3 类式继承模式#1-默认模式"></a>6.3 类式继承模式#1-默认模式</h3><h3 id="6-4-类式继承模式-2-借用构造函数"><a href="#6-4-类式继承模式-2-借用构造函数" class="headerlink" title="6.4 类式继承模式#2-借用构造函数"></a>6.4 类式继承模式#2-借用构造函数</h3><h3 id="6-5-类式继承模式-3-借用和设置原型"><a href="#6-5-类式继承模式-3-借用和设置原型" class="headerlink" title="6.5 类式继承模式#3-借用和设置原型"></a>6.5 类式继承模式#3-借用和设置原型</h3><h3 id="6-6-类式继承模式-4-共享原型"><a href="#6-6-类式继承模式-4-共享原型" class="headerlink" title="6.6 类式继承模式#4-共享原型"></a>6.6 类式继承模式#4-共享原型</h3><h3 id="6-7-类式继承模式-5-临时构造函数"><a href="#6-7-类式继承模式-5-临时构造函数" class="headerlink" title="6.7 类式继承模式#5-临时构造函数"></a>6.7 类式继承模式#5-临时构造函数</h3><h3 id="6-8-Klass"><a href="#6-8-Klass" class="headerlink" title="6.8 Klass"></a>6.8 Klass</h3><h3 id="6-9-原型继承"><a href="#6-9-原型继承" class="headerlink" title="6.9 原型继承"></a>6.9 原型继承</h3><h3 id="6-0-通过复制属性实现继承"><a href="#6-0-通过复制属性实现继承" class="headerlink" title="6.0 通过复制属性实现继承"></a>6.0 通过复制属性实现继承</h3><h3 id="6-1-借用方法"><a href="#6-1-借用方法" class="headerlink" title="6.1 借用方法"></a>6.1 借用方法</h3><h2 id="七-设计模式"><a href="#七-设计模式" class="headerlink" title="七 设计模式"></a>七 设计模式</h2><h3 id="7-1-单体"><a href="#7-1-单体" class="headerlink" title="7.1 单体"></a>7.1 单体</h3><h3 id="7-2-工厂"><a href="#7-2-工厂" class="headerlink" title="7.2 工厂"></a>7.2 工厂</h3><h3 id="7-3-迭代器"><a href="#7-3-迭代器" class="headerlink" title="7.3 迭代器"></a>7.3 迭代器</h3><h3 id="7-4-装饰者"><a href="#7-4-装饰者" class="headerlink" title="7.4 装饰者"></a>7.4 装饰者</h3><h3 id="7-5-策略"><a href="#7-5-策略" class="headerlink" title="7.5 策略"></a>7.5 策略</h3><h3 id="7-6-外观"><a href="#7-6-外观" class="headerlink" title="7.6 外观"></a>7.6 外观</h3><h3 id="7-7-代理"><a href="#7-7-代理" class="headerlink" title="7.7 代理"></a>7.7 代理</h3><h3 id="7-8-中介者"><a href="#7-8-中介者" class="headerlink" title="7.8 中介者"></a>7.8 中介者</h3><h3 id="7-9-观察者"><a href="#7-9-观察者" class="headerlink" title="7.9 观察者"></a>7.9 观察者</h3><h2 id="八-DOM和浏览器模式"><a href="#八-DOM和浏览器模式" class="headerlink" title="八 DOM和浏览器模式"></a>八 DOM和浏览器模式</h2><h3 id="8-1-关注分离"><a href="#8-1-关注分离" class="headerlink" title="8.1 关注分离"></a>8.1 关注分离</h3><h3 id="8-2-DOM脚本"><a href="#8-2-DOM脚本" class="headerlink" title="8.2 DOM脚本"></a>8.2 DOM脚本</h3><h3 id="8-3-事件"><a href="#8-3-事件" class="headerlink" title="8.3 事件"></a>8.3 事件</h3><h3 id="8-4-长期运行脚本"><a href="#8-4-长期运行脚本" class="headerlink" title="8.4 长期运行脚本"></a>8.4 长期运行脚本</h3><h3 id="8-5-远程脚本"><a href="#8-5-远程脚本" class="headerlink" title="8.5 远程脚本"></a>8.5 远程脚本</h3><h3 id="8-6-配置javascript"><a href="#8-6-配置javascript" class="headerlink" title="8.6 配置javascript"></a>8.6 配置javascript</h3><h3 id="8-7-载入策略"><a href="#8-7-载入策略" class="headerlink" title="8.7 载入策略"></a>8.7 载入策略</h3><p style="text-align:right">23:27 </p>]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>HTML与CSS权威指南</title>
    <url>/pdf/html/HTML%E4%B8%8ECSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.1 星期六</p>

<h2 id="第1章-Web时代的变迁"><a href="#第1章-Web时代的变迁" class="headerlink" title="第1章 Web时代的变迁"></a>第1章 Web时代的变迁</h2><p>1 迎接新的Web时代<br>2 HTML 5会受欢迎的理由<br>3 可以方向使用HTML 5的三个理由<br>4 HTML 5要解决的三个问题   </p>
<h2 id="第2章-HTML-5与HTML-4-的区别"><a href="#第2章-HTML-5与HTML-4-的区别" class="headerlink" title="第2章 HTML 5与HTML 4 的区别"></a>第2章 HTML 5与HTML 4 的区别</h2><p>1 语法的改变<br>2 新增的元素和废除的元素<br>3 新增的属性和废除的属性<br>4 全局属性    </p>
<h2 id="第3章-HTML-5的结构"><a href="#第3章-HTML-5的结构" class="headerlink" title="第3章 HTML 5的结构"></a>第3章 HTML 5的结构</h2><p>1 新增的主体结构元素<br>2 新增的非主体结构元素<br>3 HTML 5结构    </p>
<h2 id="第4章-表单与文件"><a href="#第4章-表单与文件" class="headerlink" title="第4章 表单与文件"></a>第4章 表单与文件</h2><p>1 新增元素与属性<br>2 表单验证<br>3 增强的页面元素   ———–未<br>4 文件API<br>5 拖放API<br>（2017.7.1 六 23：06）</p>
<p>第5章 绘制图形<br>第6章 多媒体播放<br>第7章 本地存储<br>第8章 离线应用程序<br>第9章 通信API<br>第10章 使用Web Workers处理线程<br>第11章 获取地理位置信息    </p>
<h2 id="第12章-CSS-3概述-208-目录13"><a href="#第12章-CSS-3概述-208-目录13" class="headerlink" title="第12章 CSS 3概述      208    目录13"></a>第12章 CSS 3概述      208    目录13</h2><p>1 概要介绍<br>2 使用css 3能做什么    </p>
<h2 id="第13章选择器"><a href="#第13章选择器" class="headerlink" title="第13章选择器"></a>第13章选择器</h2><p>1 选 概述<br>2 属性选<br>3 结构性伪类选<br>4 UI元素状态选<br>5 通用兄弟元素选<br>第14章使用选择器在页面中插入内容    —–内容未看<br>1 使用选择器插入文字<br>2插入图像文件<br>3 使用content属性来插入项目编号    </p>
<h2 id="第15章文字与字体相关样式"><a href="#第15章文字与字体相关样式" class="headerlink" title="第15章文字与字体相关样式"></a>第15章文字与字体相关样式</h2><p>1 给文字与文本添加阴影    text-shadow<br>2 让文本自动换行   word-break<br>3 让长单词与URL地址自动换行   word-wrap<br>4 使用服务器端字体   Web Font与@font-face<br>5修改字体种类而保持字体尺寸不变    font-size-adjust    </p>
<h2 id="第16章盒相关样式"><a href="#第16章盒相关样式" class="headerlink" title="第16章盒相关样式"></a>第16章盒相关样式</h2><p>1 盒的类型<br>2 对于盒中容纳不下的内容的显示<br>3 对盒使用阴影<br>4 指定针对元素的宽度与高度的计算方法    </p>
<h2 id="第17章与背景和边框相关样式"><a href="#第17章与背景和边框相关样式" class="headerlink" title="第17章与背景和边框相关样式"></a>第17章与背景和边框相关样式</h2><p>1 与背景相关的新增属性<br>2 在一个元素中显示多个背景图像<br>3 圆角边框的绘制<br>4 使用圆角边框    </p>
<h2 id="第18章css-3中的变形处理"><a href="#第18章css-3中的变形处理" class="headerlink" title="第18章css 3中的变形处理"></a>第18章css 3中的变形处理</h2><p>1 transform功能的基础知识<br>2 对一个元素使用多种变形的方法    </p>
<h2 id="第19章css-3中的动画功能"><a href="#第19章css-3中的动画功能" class="headerlink" title="第19章css 3中的动画功能"></a>第19章css 3中的动画功能</h2><p>1 transitions功能<br>2 animations功能    </p>
<h2 id="第20章布局相关样式"><a href="#第20章布局相关样式" class="headerlink" title="第20章布局相关样式"></a>第20章布局相关样式</h2><p>1 多栏布局<br>2 盒布局   ??是不是现在变成了 Flex布局    </p>
<h2 id="第21章Media-Queries相关样式"><a href="#第21章Media-Queries相关样式" class="headerlink" title="第21章Media Queries相关样式"></a>第21章Media Queries相关样式</h2><p>1 根据浏览器的窗口大小来选择使用不同的样式<br>2 在iphone中的显示<br>3 media queries的使用方法    </p>
<h2 id="第22章-css-3的其他重要样式和属性"><a href="#第22章-css-3的其他重要样式和属性" class="headerlink" title="第22章 css 3的其他重要样式和属性"></a>第22章 css 3的其他重要样式和属性</h2><p>1 颜色相关样式<br>2 用户界面相关样<br>3 取消对元素的样式指定—initial属性值    </p>
<h2 id="第23章综合实例"><a href="#第23章综合实例" class="headerlink" title="第23章综合实例"></a>第23章综合实例</h2><p>1 使用HTML 5中的新增结构元素来构建网页<br>2 使用HTML 5+SS 3来构建Web应用程序    </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>Web性能权威指南</title>
    <url>/pdf/opti/Web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.1 星期日 11:55</p>

<!-- 读：2017.5 -->
<p># 第一部分　网络技术概览</p>
<h2 id="第-1-章-延迟与带宽-3"><a href="#第-1-章-延迟与带宽-3" class="headerlink" title="第 1 章　延迟与带宽 3"></a>第 1 章　延迟与带宽 3</h2><p>1.1　速度是关键 .3<br>1.2　延迟的构成 .4<br>1.3　光速与传播延迟 .6<br>1.4　延迟的最后一公里 .7<br>1.5　网络核心的带宽 .8<br>1.6　网络边缘的带宽 .9<br>1.7　目标：高带宽和低延迟 .10   </p>
<h2 id="第-2-章-TCP-的构成-13"><a href="#第-2-章-TCP-的构成-13" class="headerlink" title="第 2 章　TCP 的构成 .13"></a>第 2 章　TCP 的构成 .13</h2><p>2.1　三次握手 .14<br>2.2　拥塞预防及控制 .16<br>    2.2.1　流量控制 16<br>    2.2.2　慢启动 18<br>    2.2.3　拥塞预防 24<br>2.3　带宽延迟积 .25<br>2.4　队首阻塞 .27<br>2.5　针对 TCP 的优化建议28<br>    2.5.1　服务器配置调优 29<br>    2.5.2　应用程序行为调优 30<br>    2.5.3　性能检查清单 30   </p>
<h2 id="第-3-章-UDP-的构成-31"><a href="#第-3-章-UDP-的构成-31" class="headerlink" title="第 3 章　UDP 的构成 .31"></a>第 3 章　UDP 的构成 .31</h2><p>3.1　无协议服务 .32<br>3.2　UDP 与网络地址转换器  .34<br>    3.2.1　连接状态超时 35<br>    3.2.2　NAT 穿透 36<br>    3.2.3　STUN、TURN 与 ICE .37<br>3.3　针对 UDP 的优化建议 .39   </p>
<h2 id="第-4-章-传输层安全（TLS）-41"><a href="#第-4-章-传输层安全（TLS）-41" class="headerlink" title="第 4 章　传输层安全（TLS）  41"></a>第 4 章　传输层安全（TLS）  41</h2><p>4.1　加密、身份验证与完整性 .42<br>4.2　TLS 握手 .44<br>    4.2.1　应用层协议协商（ALPN） 46<br>    4.2.2　服务器名称指示（SNI） 47<br>4.3　TLS 会话恢复 .48<br>    4.3.1　会话标识符 48<br>    4.3.2　会话记录单 49<br>4.4　信任链与证书颁发机构 .50<br>4.5　证书撤销 .52<br>    4.5.1　证书撤销名单（CRL） .53<br>    4.5.2　在线证书状态协议（OCSP） 54<br>4.6　TLS 记录协议 .54<br>4.7　针对 TLS 的优化建议 55<br>    4.7.1　计算成本 55<br>    4.7.2　尽早完成（握手） 56<br>    4.7.3　会话缓存与无状态恢复 58<br>    4.7.4　TLS 记录大小 59<br>    4.7.5　TLS 压缩 60<br>    4.7.6　证书链的长度<br>    4.7.7　OCSP 封套<br>    4.7.8　HTTP 严格传输安全（HSTS）<br>4.8　性能检查清单<br>4.9　测试与验证    </p>
<p># 第二部分　无线网络性能   </p>
<h2 id="第-5-章-无线网络概览"><a href="#第-5-章-无线网络概览" class="headerlink" title="第 5 章　无线网络概览"></a>第 5 章　无线网络概览</h2><p>5.1　无所不在的连接 .69<br>5.2　无线网络的类型 .70<br>5.3　无线网络的性能基础 .71<br>    5.3.1　带宽 71<br>    5.3.2　信号强度 74<br>    5.3.3　调制 75<br>5.4　测量现实中的无线性能 .76   </p>
<h2 id="第-6-章-Wi-Fi-79"><a href="#第-6-章-Wi-Fi-79" class="headerlink" title="第 6 章　Wi-Fi 79"></a>第 6 章　Wi-Fi 79</h2><p>6.1　从以太网到无线局域网 .79<br>6.2　Wi-Fi 标准及功能 81<br>6.3　测量和优化 Wi-Fi 性能 .81<br>6.4　针对 Wi-Fi 的优化建议 .84<br>    6.4.1　利用不计流量的带宽 84<br>    6.4.2　适应可变带宽 85<br>    6.4.3　适应可变的延迟时间 86   </p>
<h2 id="第-7-章-移动网络-87"><a href="#第-7-章-移动网络-87" class="headerlink" title="第 7 章　移动网络 87"></a>第 7 章　移动网络 87</h2><p>7.1　G 字号移动网络简介 .87<br>    7.1.1　最早提供数据服务的 2G.88<br>    7.1.2　3GPP 与 3GPP2 .89<br>    7.1.3　3G 技术的演进 91<br>    7.1.4　IMT-Advanced 的 4G 要求 93<br>    7.1.5　长期演进（LTE） .94<br>    7.1.6　HSPA+ 推进世界范围内的 4G 普及 95<br>    7.1.7　为多代并存的未来规划 96<br>7.2　设备特性及能力 .97<br>7.3　无线电资源控制器（RRC） .99<br>    7.3.1　3G、4G 和 Wi-Fi 对电源的要求 101<br>    7.3.2　LTE RRC 状态机 .102<br>    7.3.3　HSPA 与 HSPA+（UMTS）RRC 状态机 104<br>    7.3.4　EV-DO（CDMA）  RRC 状态机 106<br>    7.3.5　低效率的周期性传输 107<br>7.4　端到端的运营商架构 .108<br>    7.4.1　无线接入网络（RAN） 108<br>    7.4.2　核心网络 110<br>    7.4.3　回程容量与延迟 112<br>7.5　移动网络中的分组流 .113<br>    7.5.1　初始化请求 113<br>    7.5.2　入站数据流 116<br>7.6　异质网络（HetNet） .117<br>7.7　真实的 3G、4G 和 Wi-Fi 性能 119   </p>
<h2 id="第-8-章-移动网络的优化建议-121"><a href="#第-8-章-移动网络的优化建议-121" class="headerlink" title="第 8 章　移动网络的优化建议 121"></a>第 8 章　移动网络的优化建议 121</h2><p>8.1　节约用电 .122<br>8.2　消除周期性及无效的数据传输 .124<br>8.3　预测网络延迟上限 .126<br>    8.3.1　考虑 RRC 状态切换 127<br>    8.3.2　解耦用户交互与网络通信 128<br>    8.4　面对多网络接口并存的现实 .128<br>8.5　爆发传输数据并转为空闲 .130<br>8.6　把负载转移到 Wi-Fi 网络 .131<br>8.7　遵从协议和应用最佳实践 .131   </p>
<p># 第三部分　HTTP   </p>
<h2 id="第-9-章-HTTP-简史-135"><a href="#第-9-章-HTTP-简史-135" class="headerlink" title="第 9 章　HTTP 简史 135"></a>第 9 章　HTTP 简史 135</h2><p>9.1　HTTP 0.9：只有一行的协议 .135<br>9.2　HTTP 1.0：迅速发展及参考性 RFC 136<br>9.3　HTTP 1.1：互联网标准 .138<br>9.4　HTTP 2.0：改进传输性能 .141   </p>
<h2 id="第-10-章-Web-性能要点-143"><a href="#第-10-章-Web-性能要点-143" class="headerlink" title="第 10 章　Web 性能要点 .143"></a>第 10 章　Web 性能要点 .143</h2><p>10.1　超文本、网页和 Web 应用 144<br>10.2　剖析现代 Web 应用 146<br>    10.2.1　速度、性能与用户期望 .147<br>    10.2.2　分析资源瀑布 .148<br>10.3　性能来源：计算、渲染和网络访问 .151<br>    10.3.1　更多带宽其实不（太）重要 .152<br>    10.3.2　延迟是性能瓶颈 .152<br>10.4　人造和真实用户性能度量 .154<br>10.5　针对浏览器的优化建议 .157   </p>
<h2 id="第-11-章-HTTP-1-x-161"><a href="#第-11-章-HTTP-1-x-161" class="headerlink" title="第 11 章　HTTP 1.x .161"></a>第 11 章　HTTP 1.x .161</h2><p>11.1　持久连接的优点 .163<br>11.2　HTTP 管道 165<br>11.3　使用多个 TCP 连接 169<br>11.4　域名分区 .171<br>11.5　度量和控制协议开销 .173<br>11.6　连接与拼合 .174<br>11.7　嵌入资源 .177   </p>
<h2 id="第-12-章-HTTP-2-0-179"><a href="#第-12-章-HTTP-2-0-179" class="headerlink" title="第 12 章　HTTP 2.0.179"></a>第 12 章　HTTP 2.0.179</h2><p>12.1　历史及其与 SPDY 的渊源 .180<br>12.2　走向 HTTP 2.0 181<br>12.3　设计和技术目标 .182<br>    12.3.1　二进制分帧层 .183<br>    12.3.2　流、消息和帧 .184<br>    12.3.3　多向请求与响应 .185<br>    12.3.4　请求优先级 .186<br>    12.3.5　每个来源一个连接 .188<br>    12.3.6　流量控制 .189<br>    12.3.7　服务器推送 .190<br>    12.3.8　首部压缩 .192<br>    12.3.9　有效的 HTTP 2.0 升级与发现 194<br>12.4　二进制分帧简介 .196<br>    12.4.1　发起新流 .197<br>    12.4.2　发送应用数据 .198<br>    12.4.3　HTTP 2.0 帧数据流分析 .199   </p>
<h2 id="第-13-章-优化应用的交付-201"><a href="#第-13-章-优化应用的交付-201" class="headerlink" title="第 13 章　优化应用的交付 .201"></a>第 13 章　优化应用的交付 .201</h2><p>13.1　经典的性能优化最佳实践 .203<br>    13.1.1　在客户端缓存资源 .204<br>    13.1.2　压缩传输的数据  205<br>    13.1.3　消除不必要的请求字节 .206<br>    13.1.4　并行处理请求和响应 .207<br>13.2　针对 HTTP 1.x 的优化建议 .208<br>13.3　针对 HTTP 2.0 的优化建议 .209<br>    13.3.1　去掉对 1.x 的优化 209<br>    13.3.2　双协议应用策略 .210<br>    13.3.3　1.x 与 2.0 的相互转换 212<br>    13.3.4　评估服务器质量与性能 .213<br>    13.3.5　2.0 与 TLS .214<br>    13.3.6　负载均衡器、代理及应用服务器 .215   </p>
<p># 第四部分　浏览器 API 与协议   </p>
<h2 id="第-14-章-浏览器网络概述-219"><a href="#第-14-章-浏览器网络概述-219" class="headerlink" title="第 14 章　浏览器网络概述 .219"></a>第 14 章　浏览器网络概述 .219</h2><p>14.1　连接管理与优化 .220<br>14.2　网络安全与沙箱 .222<br>14.3　资源与客户端状态缓存 .222<br>14.4　应用 API 与协议 223   </p>
<h2 id="第-15-章-XMLHttpRequest-225"><a href="#第-15-章-XMLHttpRequest-225" class="headerlink" title="第 15 章　XMLHttpRequest 225"></a>第 15 章　XMLHttpRequest 225</h2><p>15.1　XHR 简史 .226<br>15.2　跨源资源共享（CORS） 227<br>15.3　通过 XHR 下载数据 230<br>15.4　通过 XHR 上传数据 231<br>15.5　监控下载和上传进度 .233<br>15.6　通过 XHR 实现流式数据传输 234<br>15.7　实时通知与交付 .236<br>    15.7.1　通过 XHR 实现轮询 .237<br>    15.7.2　通过 XHR 实现长轮询 .238<br>15.8　XHR 使用场景及性能 .240   </p>
<h2 id="第-16-章-服务器发送事件-243"><a href="#第-16-章-服务器发送事件-243" class="headerlink" title="第 16 章　服务器发送事件 .243"></a>第 16 章　服务器发送事件 .243</h2><p>16.1　EventSource API 243<br>16.2　Event Stream 协议 245<br>16.3　SSE 使用场景及性能 .248   </p>
<h2 id="第-17-章-WebSocket251"><a href="#第-17-章-WebSocket251" class="headerlink" title="第 17 章　WebSocket251"></a>第 17 章　WebSocket251</h2><p>17.1　WebSocket API252<br>    17.1.1　WS 与 WSS .253<br>    17.1.2　接收文本和二进制数据 .253<br>    17.1.3　发送文本和二进制数据 .255<br>    17.1.4　子协议协商 .256<br>17.2　WebSocket 协议 257<br>    17.2.1　二进制分帧层 .258<br>    17.2.2　协议扩展 .260<br>    17.2.3　HTTP 升级协商 261<br>17.3　WebSocket 使用场景及性能 264<br>    17.3.1　请求和响应流 .264<br>    17.3.2　消息开销 .265<br>    17.3.3　数据效率及压缩 .266<br>    17.3.4　自定义应用协议 .266<br>    17.3.5　部署 WebSocket 基础设施 .267<br>17.4　性能检查表 .269   </p>
<h2 id="第-18-章-WebRTC-271"><a href="#第-18-章-WebRTC-271" class="headerlink" title="第 18 章　WebRTC .271"></a>第 18 章　WebRTC .271</h2><p>18.1　标准和 WebRTC 的发展 272<br>18.2　音频和视频引擎 .272<br>18.3　实时网络传输 .276<br>18.4　建立端到端的连接 .280<br>    18.4.1　发信号和协商会话 .280<br>    18.4.2　会话描述协议（SDP） 282<br>    18.4.3　交互连接建立（ICE） .285<br>    18.4.4　增量提供（Trickle ICE） .288<br>    18.4.5　跟踪 ICE 收集和连接状态 .289<br>    18.4.6　完整的示例 .291<br>18.5　交付媒体和应用数据 .295<br>    18.5.1　通过 DTLS 实现安全通信 .296<br>    18.5.2　通过 SRTP 和 SRTCP 交付媒体 298<br>    18.5.3　通过 SCTP 交付应用数据 301<br>18.6　DataChannel 305<br>    18.6.1　设置与协商 .307<br>    18.6.2　配置消息次序和可靠性 .309<br>    18.6.3　部分可靠交付与消息大小 .311<br>18.7　WebRTC 使用场景及性能 .312<br>    18.7.1　音频、视频和数据流 .312<br>    18.7.2　多方通信架构 .313<br>    18.7.3　基础设施及容量规划 .314<br>    18.7.4　数据效率及压缩 .315<br>18.8　性能检查表 .316</p>
<p style="text-align:right">2018.7.1 星期日 12:05</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>opti</category>
      </categories>
  </entry>
  <entry>
    <title>WEB界面设计</title>
    <url>/pdf/des/WEB%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>直截了当、简化交互、足不出户、提供邀请、使用交换、即时反应</p>
<a id="more"></a>
<p style="text-align:right">2018.6.30 星期六 12:23</p>

<!-- 读：2018.6.25/27 -->
<!-- 只有1，2，4，9，12章内容；    -->
<!-- 不允许复制/导出文本，所以就没有cc内容     -->
<p>交互设计模式</p>
<p>原理一：直截了当</p>
<h2 id="第1章-页内编辑"><a href="#第1章-页内编辑" class="headerlink" title="第1章 页内编辑"></a>第1章 页内编辑</h2><p>单字段行内、多字段行内、覆盖层、表格、群组、模块配置</p>
<h2 id="第2章-利用拖放"><a href="#第2章-利用拖放" class="headerlink" title="第2章 利用拖放"></a>第2章 利用拖放</h2><p>趣味瞬间、拖放的用途、拖放模块、拖放列表、拖放对象、拖放操作、拖放集合、</p>
<h2 id="第3章-直接选择"><a href="#第3章-直接选择" class="headerlink" title="第3章 直接选择"></a>第3章 直接选择</h2><p>原理二：简化交互<br>原理三：足不出户</p>
<p>原理四：提供邀请</p>
<h2 id="第9章-静态邀请"><a href="#第9章-静态邀请" class="headerlink" title="第9章 静态邀请"></a>第9章 静态邀请</h2><p>引导操作邀请、漫游探索邀请</p>
<h2 id="第10章-动态邀请"><a href="#第10章-动态邀请" class="headerlink" title="第10章 动态邀请"></a>第10章 动态邀请</h2><p>空。没内容   </p>
<p>原理五：使用交换</p>
<h2 id="第12章-变换的目的"><a href="#第12章-变换的目的" class="headerlink" title="第12章 变换的目的"></a>第12章 变换的目的</h2><p>增添魅力、增进沟通、滑入与划出    </p>
<p>原理六：即时反应</p>
<p style="text-align:right">12：50 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>des</category>
      </categories>
  </entry>
  <entry>
    <title>学习Js数据结构与算法</title>
    <url>/pdf/js/%E5%AD%A6%E4%B9%A0js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.30 星期六 12:14</p>

<!-- 读：*2017 -->
<h2 id="第-1-章-JavaScript-简介-1"><a href="#第-1-章-JavaScript-简介-1" class="headerlink" title="第 1 章 JavaScript 简介.1"></a>第 1 章 JavaScript 简介.1</h2><h3 id="1-1-环境搭建1"><a href="#1-1-环境搭建1" class="headerlink" title="1.1 环境搭建1"></a>1.1 环境搭建1</h3><p>1.1.1 浏览器2<br>1.1.2 使用 Web 服务器（XAMPP）3<br>1.1.3 使用 Node.js 搭建 Web 服务器4 </p>
<h3 id="1-2-JavaScript-基础6"><a href="#1-2-JavaScript-基础6" class="headerlink" title="1.2 JavaScript 基础6"></a>1.2 JavaScript 基础6</h3><p>1.2.1 变量7<br>1.2.2 操作符8<br>1.2.3 真值和假值11<br>1.2.4 相等操作符（==和===）12 </p>
<h3 id="1-3-控制结构13"><a href="#1-3-控制结构13" class="headerlink" title="1.3 控制结构13"></a>1.3 控制结构13</h3><p>1.3.1 条件语句14<br>1.3.2 循环15 </p>
<h3 id="1-4-函数-16"><a href="#1-4-函数-16" class="headerlink" title="1.4 函数.16"></a>1.4 函数.16</h3><h3 id="1-5-面向对象编程16"><a href="#1-5-面向对象编程16" class="headerlink" title="1.5 面向对象编程16"></a>1.5 面向对象编程16</h3><h3 id="1-6-调试工具18"><a href="#1-6-调试工具18" class="headerlink" title="1.6 调试工具18"></a>1.6 调试工具18</h3><p>1.7 小结.18 </p>
<h2 id="第-2-章-数组19"><a href="#第-2-章-数组19" class="headerlink" title="第 2 章 数组19"></a>第 2 章 数组19</h2><h3 id="2-1-为什么用数组19"><a href="#2-1-为什么用数组19" class="headerlink" title="2.1 为什么用数组19"></a>2.1 为什么用数组19</h3><h3 id="2-2-创建和初始化数组20"><a href="#2-2-创建和初始化数组20" class="headerlink" title="2.2 创建和初始化数组20"></a>2.2 创建和初始化数组20</h3><h3 id="2-3-添加和删除元素21"><a href="#2-3-添加和删除元素21" class="headerlink" title="2.3 添加和删除元素21"></a>2.3 添加和删除元素21</h3><h3 id="2-4-二维和多维数组24"><a href="#2-4-二维和多维数组24" class="headerlink" title="2.4 二维和多维数组24"></a>2.4 二维和多维数组24</h3><h3 id="2-5-JavaScript-的数组方法参考-26"><a href="#2-5-JavaScript-的数组方法参考-26" class="headerlink" title="2.5 JavaScript 的数组方法参考.26"></a>2.5 JavaScript 的数组方法参考.26</h3><p>2.5.1 数组合并27<br>2.5.2 迭代器函数27<br>2.5.3 搜索和排序28<br>2.5.4 输出数组为字符串.31<br>2.6 小结.32 </p>
<h2 id="第-3-章-栈-33"><a href="#第-3-章-栈-33" class="headerlink" title="第 3 章 栈.33"></a>第 3 章 栈.33</h2><h3 id="3-1-栈的创建33"><a href="#3-1-栈的创建33" class="headerlink" title="3.1 栈的创建33"></a>3.1 栈的创建33</h3><h3 id="3-2-从十进制到二进制38"><a href="#3-2-从十进制到二进制38" class="headerlink" title="3.2 从十进制到二进制38"></a>3.2 从十进制到二进制38</h3><p>3.3 小结.39 </p>
<h2 id="第-4-章-队列40"><a href="#第-4-章-队列40" class="headerlink" title="第 4 章 队列40"></a>第 4 章 队列40</h2><h3 id="4-1-创建队列40"><a href="#4-1-创建队列40" class="headerlink" title="4.1 创建队列40"></a>4.1 创建队列40</h3><p>4.1.1 完整的 Queue 类.42<br>4.1.2 使用 Queue 类.43 </p>
<h3 id="4-2-优先队列44"><a href="#4-2-优先队列44" class="headerlink" title="4.2 优先队列44"></a>4.2 优先队列44</h3><h3 id="4-3-循环队列——击鼓传花-46"><a href="#4-3-循环队列——击鼓传花-46" class="headerlink" title="4.3 循环队列——击鼓传花.46"></a>4.3 循环队列——击鼓传花.46</h3><p>4.4 小结.47 </p>
<h2 id="第-5-章-链表48"><a href="#第-5-章-链表48" class="headerlink" title="第 5 章 链表48"></a>第 5 章 链表48</h2><h3 id="5-1-创建一个链表49"><a href="#5-1-创建一个链表49" class="headerlink" title="5.1 创建一个链表49"></a>5.1 创建一个链表49</h3><p>5.1.1 向链表尾部追加元素.50<br>5.1.2 从链表中移除元素.52<br>5.1.3 在任意位置插入一个元素.54<br>5.1.4 实现其他方法56   </p>
<h3 id="5-2-双向链表58"><a href="#5-2-双向链表58" class="headerlink" title="5.2 双向链表58"></a>5.2 双向链表58</h3><p>5.2.1 在任意位置插入一个新元素.59<br>5.2.2 从任意位置移除元素.61   </p>
<h3 id="5-3-循环链表64"><a href="#5-3-循环链表64" class="headerlink" title="5.3 循环链表64"></a>5.3 循环链表64</h3><p>5.4 小结.64 </p>
<h2 id="第-6-章-集合65"><a href="#第-6-章-集合65" class="headerlink" title="第 6 章 集合65"></a>第 6 章 集合65</h2><h3 id="6-1-创建一个集合65"><a href="#6-1-创建一个集合65" class="headerlink" title="6.1 创建一个集合65"></a>6.1 创建一个集合65</h3><p>6.1.1 has(value)方法66<br>6.1.2 add 方法66<br>6.1.3 remove 和 clear 方法67<br>6.1.4 size 方法68<br>6.1.5 values 方法.69<br>6.1.6 使用 Set 类.69 </p>
<h3 id="6-2-集合操作70"><a href="#6-2-集合操作70" class="headerlink" title="6.2 集合操作70"></a>6.2 集合操作70</h3><p>6.2.1 并集.70<br>6.2.2 交集.71<br>6.2.3 差集.72<br>6.2.4 子集.73<br>6.3 小结.74 </p>
<h2 id="第-7-章-字典和散列表-75"><a href="#第-7-章-字典和散列表-75" class="headerlink" title="第 7 章 字典和散列表.75"></a>第 7 章 字典和散列表.75</h2><h3 id="7-1-字典-75"><a href="#7-1-字典-75" class="headerlink" title="7.1 字典.75"></a>7.1 字典.75</h3><p>7.1.1 创建一个字典75<br>7.1.2 使用 Dictionary 类78 </p>
<h3 id="7-2-散列表-79"><a href="#7-2-散列表-79" class="headerlink" title="7.2 散列表.79"></a>7.2 散列表.79</h3><p>7.2.1 创建一个散列表79<br>7.2.2 使用 HashTable 类81<br>7.2.3 散列表和散列集合.82<br>7.2.4 处理散列表中的冲突.82<br>7.2.5 创建更好的散列函数.90<br>7.3 小结.91 </p>
<h2 id="第-8-章-树-92"><a href="#第-8-章-树-92" class="headerlink" title="第 8 章 树.92"></a>第 8 章 树.92</h2><h3 id="8-1-树的相关术语92"><a href="#8-1-树的相关术语92" class="headerlink" title="8.1 树的相关术语92"></a>8.1 树的相关术语92</h3><h3 id="8-2-二叉树和二叉搜索树93"><a href="#8-2-二叉树和二叉搜索树93" class="headerlink" title="8.2 二叉树和二叉搜索树93"></a>8.2 二叉树和二叉搜索树93</h3><p>8.2.1 创建 BinarySearchTree 类.94<br>8.2.2 向树中插入一个键.95 </p>
<h3 id="8-3-树的遍历-98"><a href="#8-3-树的遍历-98" class="headerlink" title="8.3 树的遍历.98"></a>8.3 树的遍历.98</h3><p>8.3.1 中序遍历98<br>8.3.2 先序遍历99<br>8.3.3 后序遍历100 </p>
<h3 id="8-4-搜索树中的值101"><a href="#8-4-搜索树中的值101" class="headerlink" title="8.4 搜索树中的值101"></a>8.4 搜索树中的值101</h3><p>8.4.1 搜索最小值和最大值.101<br>8.4.2 搜索一个特定的值.103<br>8.4.3 移除一个节点104 </p>
<h3 id="8-5-更多关于二叉树的知识-108"><a href="#8-5-更多关于二叉树的知识-108" class="headerlink" title="8.5 更多关于二叉树的知识.108"></a>8.5 更多关于二叉树的知识.108</h3><p>8.6 小结.109 </p>
<h2 id="第-9-章-图-110"><a href="#第-9-章-图-110" class="headerlink" title="第 9 章 图.110"></a>第 9 章 图.110</h2><h3 id="9-1-图的相关术语110"><a href="#9-1-图的相关术语110" class="headerlink" title="9.1 图的相关术语110"></a>9.1 图的相关术语110</h3><h3 id="9-2-图的表示-112"><a href="#9-2-图的表示-112" class="headerlink" title="9.2 图的表示.112"></a>9.2 图的表示.112</h3><p>9.2.1 邻接矩阵112<br>9.2.2 邻接表.113<br>9.2.3 关联矩阵114 </p>
<h3 id="9-3-创建图类-114"><a href="#9-3-创建图类-114" class="headerlink" title="9.3 创建图类.114"></a>9.3 创建图类.114</h3><h3 id="9-4-图的遍历-116"><a href="#9-4-图的遍历-116" class="headerlink" title="9.4 图的遍历.116"></a>9.4 图的遍历.116</h3><p>9.4.1 广度优先搜索117<br>9.4.2 深度优先搜索122<br>9.5 小结.128 </p>
<h2 id="第-10-章-排序和搜索算法129"><a href="#第-10-章-排序和搜索算法129" class="headerlink" title="第 10 章 排序和搜索算法129"></a>第 10 章 排序和搜索算法129</h2><h3 id="10-1-排序算法-129"><a href="#10-1-排序算法-129" class="headerlink" title="10.1 排序算法.129"></a>10.1 排序算法.129</h3><p>10.1.1 冒泡排序130<br>10.1.2 选择排序133<br>10.1.3 插入排序134<br>10.1.4 归并排序135<br>10.1.5 快速排序138 </p>
<h3 id="10-2-搜索算法-142"><a href="#10-2-搜索算法-142" class="headerlink" title="10.2 搜索算法.142"></a>10.2 搜索算法.142</h3><p>10.2.1 顺序搜索143<br>10.2.2 二分搜索143<br>10.3 小结.145 </p>
<h2 id="第-11-章-算法补充知识146"><a href="#第-11-章-算法补充知识146" class="headerlink" title="第 11 章 算法补充知识146"></a>第 11 章 算法补充知识146</h2><h3 id="11-1-递归-146"><a href="#11-1-递归-146" class="headerlink" title="11.1 递归.146"></a>11.1 递归.146</h3><p>11.1.1 JavaScript 调用栈大小的 限制.147<br>11.1.2 斐波那契数列147 </p>
<h3 id="11-2-动态规划-149"><a href="#11-2-动态规划-149" class="headerlink" title="11.2 动态规划.149"></a>11.2 动态规划.149</h3><h3 id="11-3-贪心算法-152"><a href="#11-3-贪心算法-152" class="headerlink" title="11.3 贪心算法.152"></a>11.3 贪心算法.152</h3><h3 id="11-4-大-O-表示法-153"><a href="#11-4-大-O-表示法-153" class="headerlink" title="11.4 大 O 表示法.153"></a>11.4 大 O 表示法.153</h3><p>11.4.1 理解大 O 表示法153<br>11.4.2 时间复杂度比较155 </p>
<h3 id="11-5-用算法娱乐身心156"><a href="#11-5-用算法娱乐身心156" class="headerlink" title="11.5 用算法娱乐身心156"></a>11.5 用算法娱乐身心156</h3><p>11.6 小结.157 </p>
<p>附录 A 时间复杂度速查表.158 </p>
<p style="text-align:right">12：22 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>计算机导论</title>
    <url>/pdf/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.30 星期六 11:57</p>

<!-- 读（前4章）： ~2018.1 -->
<!-- 后两章（8，9）缺内容，一直重复 7.19，1.20的习题 -->
<h2 id="一-计算机基本概念"><a href="#一-计算机基本概念" class="headerlink" title="一 计算机基本概念"></a>一 计算机基本概念</h2><h3 id="1-1-计算机的结构"><a href="#1-1-计算机的结构" class="headerlink" title="1.1 计算机的结构"></a>1.1 计算机的结构</h3><h3 id="1-2-总线结构"><a href="#1-2-总线结构" class="headerlink" title="1.2 总线结构"></a>1.2 总线结构</h3><h3 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h3><h3 id="1-4-存储器中的数据表示"><a href="#1-4-存储器中的数据表示" class="headerlink" title="1.4 存储器中的数据表示"></a>1.4 存储器中的数据表示</h3><h3 id="1-5-二进制，八，十六进制系统之间的数制转换"><a href="#1-5-二进制，八，十六进制系统之间的数制转换" class="headerlink" title="1.5 二进制，八，十六进制系统之间的数制转换"></a>1.5 二进制，八，十六进制系统之间的数制转换</h3><h3 id="1-6-在系统中构造数字的规则"><a href="#1-6-在系统中构造数字的规则" class="headerlink" title="1.6 在系统中构造数字的规则"></a>1.6 在系统中构造数字的规则</h3><h3 id="1-7-二、八、十六进制系统中的算数运算"><a href="#1-7-二、八、十六进制系统中的算数运算" class="headerlink" title="1.7 二、八、十六进制系统中的算数运算"></a>1.7 二、八、十六进制系统中的算数运算</h3><h3 id="1-8-计算机中数的表示"><a href="#1-8-计算机中数的表示" class="headerlink" title="1.8 计算机中数的表示"></a>1.8 计算机中数的表示</h3><h2 id="二-程序规划与设计"><a href="#二-程序规划与设计" class="headerlink" title="二 程序规划与设计"></a>二 程序规划与设计</h2><h3 id="2-1-程序设计"><a href="#2-1-程序设计" class="headerlink" title="2.1 程序设计"></a>2.1 程序设计</h3><h3 id="2-2-解决问题"><a href="#2-2-解决问题" class="headerlink" title="2.2 解决问题"></a>2.2 解决问题</h3><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a>2.3 算法</h3><h2 id="三-程序编码与简单输入、输出"><a href="#三-程序编码与简单输入、输出" class="headerlink" title="三 程序编码与简单输入、输出"></a>三 程序编码与简单输入、输出</h2><h3 id="3-1-程序设计语言"><a href="#3-1-程序设计语言" class="headerlink" title="3.1 程序设计语言"></a>3.1 程序设计语言</h3><h3 id="3-2-变量和常量"><a href="#3-2-变量和常量" class="headerlink" title="3.2 变量和常量"></a>3.2 变量和常量</h3><h3 id="3-3-赋值语句"><a href="#3-3-赋值语句" class="headerlink" title="3.3 赋值语句"></a>3.3 赋值语句</h3><h3 id="3-4-算术表达和运算符优先顺序"><a href="#3-4-算术表达和运算符优先顺序" class="headerlink" title="3.4 算术表达和运算符优先顺序"></a>3.4 算术表达和运算符优先顺序</h3><h3 id="3-5-注释语句"><a href="#3-5-注释语句" class="headerlink" title="3.5 注释语句"></a>3.5 注释语句</h3><h3 id="3-6-简单输入-输出"><a href="#3-6-简单输入-输出" class="headerlink" title="3.6 简单输入/输出"></a>3.6 简单输入/输出</h3><h3 id="3-7-编写一个完整的程序"><a href="#3-7-编写一个完整的程序" class="headerlink" title="3.7 编写一个完整的程序"></a>3.7 编写一个完整的程序</h3><h2 id="四-控制结构与程序的编写"><a href="#四-控制结构与程序的编写" class="headerlink" title="四 控制结构与程序的编写"></a>四 控制结构与程序的编写</h2><h3 id="4-1-布尔表达式"><a href="#4-1-布尔表达式" class="headerlink" title="4.1 布尔表达式"></a>4.1 布尔表达式</h3><h3 id="4-2-控制结构-定义"><a href="#4-2-控制结构-定义" class="headerlink" title="4.2 控制结构-定义"></a>4.2 控制结构-定义</h3><h3 id="4-3-选择"><a href="#4-3-选择" class="headerlink" title="4.3 选择"></a>4.3 选择</h3><h3 id="4-4-循环"><a href="#4-4-循环" class="headerlink" title="4.4 循环"></a>4.4 循环</h3><h2 id="五-函数和子过程"><a href="#五-函数和子过程" class="headerlink" title="五 函数和子过程"></a>五 函数和子过程</h2><h3 id="5-1-函数"><a href="#5-1-函数" class="headerlink" title="5.1 函数"></a>5.1 函数</h3><h3 id="5-2-子过程"><a href="#5-2-子过程" class="headerlink" title="5.2 子过程"></a>5.2 子过程</h3><h3 id="5-3-标识符的作用域和生命周期"><a href="#5-3-标识符的作用域和生命周期" class="headerlink" title="5.3 标识符的作用域和生命周期"></a>5.3 标识符的作用域和生命周期</h3><h3 id="5-4-参数传递机制"><a href="#5-4-参数传递机制" class="headerlink" title="5.4 参数传递机制"></a>5.4 参数传递机制</h3><h2 id="六-数组和字符串"><a href="#六-数组和字符串" class="headerlink" title="六 数组和字符串"></a>六 数组和字符串</h2><h3 id="6-1-数组简介"><a href="#6-1-数组简介" class="headerlink" title="6.1 数组简介"></a>6.1 数组简介</h3><h3 id="6-2-Visual-Basic中的数组"><a href="#6-2-Visual-Basic中的数组" class="headerlink" title="6.2 Visual Basic中的数组"></a>6.2 Visual Basic中的数组</h3><h3 id="6-3-C-C-和JAVA的数组"><a href="#6-3-C-C-和JAVA的数组" class="headerlink" title="6.3 C/C++ 和JAVA的数组"></a>6.3 C/C++ 和JAVA的数组</h3><h3 id="6-4-查找"><a href="#6-4-查找" class="headerlink" title="6.4 查找"></a>6.4 查找</h3><h3 id="6-5-排序"><a href="#6-5-排序" class="headerlink" title="6.5 排序"></a>6.5 排序</h3><h2 id="七-数据文件"><a href="#七-数据文件" class="headerlink" title="七 数据文件"></a>七 数据文件</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><h3 id="7-2-数据术语"><a href="#7-2-数据术语" class="headerlink" title="7.2 数据术语"></a>7.2 数据术语</h3><h3 id="7-3-文件组织"><a href="#7-3-文件组织" class="headerlink" title="7.3 文件组织"></a>7.3 文件组织</h3><h3 id="7-4-文本文件和二进制文件"><a href="#7-4-文本文件和二进制文件" class="headerlink" title="7.4 文本文件和二进制文件"></a>7.4 文本文件和二进制文件</h3><h3 id="7-5-打开和关闭文件"><a href="#7-5-打开和关闭文件" class="headerlink" title="7.5 打开和关闭文件"></a>7.5 打开和关闭文件</h3><h2 id="八-面向对象编程"><a href="#八-面向对象编程" class="headerlink" title="八 面向对象编程"></a>八 面向对象编程</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><h3 id="8-2-继承和数据抽象"><a href="#8-2-继承和数据抽象" class="headerlink" title="8.2 继承和数据抽象"></a>8.2 继承和数据抽象</h3><h3 id="8-3-的优势"><a href="#8-3-的优势" class="headerlink" title="8.3 的优势"></a>8.3 的优势</h3><h3 id="8-4-Visual-Basic中的面向对象"><a href="#8-4-Visual-Basic中的面向对象" class="headerlink" title="8.4 Visual Basic中的面向对象"></a>8.4 Visual Basic中的面向对象</h3><h3 id="8-5-C-中的类和继承"><a href="#8-5-C-中的类和继承" class="headerlink" title="8.5 C++中的类和继承"></a>8.5 C++中的类和继承</h3><h3 id="8-6-Java中的类和继承"><a href="#8-6-Java中的类和继承" class="headerlink" title="8.6 Java中的类和继承"></a>8.6 Java中的类和继承</h3><h2 id="九-数据结构"><a href="#九-数据结构" class="headerlink" title="九 数据结构"></a>九 数据结构</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><h3 id="9-2-链表"><a href="#9-2-链表" class="headerlink" title="9.2 链表"></a>9.2 链表</h3><h3 id="9-3-堆栈"><a href="#9-3-堆栈" class="headerlink" title="9.3 堆栈"></a>9.3 堆栈</h3><h3 id="9-4-队列"><a href="#9-4-队列" class="headerlink" title="9.4 队列"></a>9.4 队列</h3><p style="text-align:right">12：07 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>Js自定义log函数</title>
    <url>/sum/js/js%E8%87%AA%E5%AE%9A%E4%B9%89log%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.28 星期四 14：38</p>

<!-- CEF中自定义log函数：cloudClass -->  
<p>自定义log函数：区分命名空间，自定义输出；获得正确的行号，可以在控制台追踪；<br><!-- 不考虑debug.js 及debug.js的 blockboxing:blackbox方式获取正确行号   --></p>
<h2 id="DebugView中特殊情况"><a href="#DebugView中特殊情况" class="headerlink" title="DebugView中特殊情况"></a>DebugView中特殊情况</h2><p>1. 不能输出object（函数定义 输出的是string，不确定能不能重定义）。<br>2. 而且，用bind方法，无法获取正确的行号。<br>3. 最后一点，可能需要区分命名空间，过滤需要的信息    </p>
<h2 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h2><p>定义样式区分（颜色/背景色等）<br><code>console.log(&#39;%c &#39;+this.name+&#39;关闭.现在秒数：&#39;,&#39;background:#777;color:&#39;+this.name,new Date().getSeconds())</code><br>&lt;!–<br>参考：<br>[[042 深入浅出妙用 Javascript 中 apply、call、bind]]<br><a href="https://ask.helplib.com/javascript/post_723894" target="_blank" rel="noopener">javascript - 扩展 console.log 而不影响日志行</a></p>
<p>其他：<br><a href="https://codeday.me/bug/20170813/57793.html" target="_blank" rel="noopener">javascript – console.log包装器,保留行号并支持大多数方法？</a><br><a href="https://cloud.tencent.com/developer/ask/97534" target="_blank" rel="noopener">正确的行号为console.log一个适当的包装？</a><br> –&gt;</p>
<h2 id="SMTC"><a href="#SMTC" class="headerlink" title="SMTC"></a>SMTC</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v1.0：cef中不能输出正确行号；写法也有些别扭</span></span><br><span class="line"><span class="keyword">var</span> log=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsCEF)&#123;</span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line">        [...arguments].forEach(<span class="function"><span class="params">v</span>=&gt;</span>str+=(<span class="built_in">JSON</span>.stringify(v)+<span class="string">';'</span>))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'h5Debug|'</span>+str);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// console.log.apply(console,arguments) //不能正确显示行号</span></span><br><span class="line">        <span class="comment">// console.log.bind(this) 没有输出</span></span><br><span class="line">        log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// v3（改进）： cef 输出正确行号和对象的字符串值</span></span><br><span class="line"><span class="keyword">if</span>(IsCEF)&#123;</span><br><span class="line">    <span class="comment">// log=console.log.bind(this,'h5Debug|') // if not need string info,but right num</span></span><br><span class="line">    log=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// if need sting info and right line num</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line">        [...arguments].forEach(<span class="function"><span class="params">v</span>=&gt;</span>str+=(<span class="built_in">JSON</span>.stringify(v)+<span class="string">';'</span>))</span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Error</span>().stack;</span><br><span class="line">        <span class="keyword">var</span> arr=stack.split(<span class="string">"\n"</span>)[<span class="number">2</span>].split(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">var</span> line = arr[arr.length<span class="number">-2</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'h5Debug('</span>+line+<span class="string">')|'</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// log=console.log.bind(this,'local|')</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v2：基于v1的cef尝试：bind和立即执行函数。问题：cef 有行号没值/有值行号不正确。。 </span></span><br><span class="line">    <span class="comment">//和v1 写法上不同；</span></span><br><span class="line"><span class="keyword">if</span>(IsCEF)&#123;</span><br><span class="line">    <span class="comment">/* log=function()&#123; //不是正确行号</span></span><br><span class="line"><span class="comment">        var str='h5Debug|';</span></span><br><span class="line"><span class="comment">        [...arguments].forEach(v=&gt;str+=(JSON.stringify(v)+';'))</span></span><br><span class="line"><span class="comment">        console.log(str);</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">// log=console.log.bind(this,'h5Debug|') // 有行号只有 “h5Debug|”  没有对象的字符串值输出，</span></span><br><span class="line">    log=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 有行号只有 “h5Debug|”  没有对象的字符串值输出;</span></span><br><span class="line">        <span class="comment">// 立即执行函数不是这么玩的，它只调用一次，以后的调用arguments为空，所以就只有h5Debug，和上面没有区别</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">'h5Debug|'</span>;</span><br><span class="line">        [...arguments].forEach(<span class="function"><span class="params">v</span>=&gt;</span>str+=(<span class="built_in">JSON</span>.stringify(v)+<span class="string">';'</span>))</span><br><span class="line">        <span class="built_in">console</span>.log(str); <span class="comment">// 只在开始定义时调用一次</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log.bind(<span class="keyword">this</span>,str)</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log=<span class="built_in">console</span>.log.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// log=console.log.bind(this,'local|')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>cef和debugView入门</title>
    <url>/sum/jsplus/cef%E5%92%8CdebugView%E5%85%A5%E9%97%A8(005)/</url>
    <content><![CDATA[<h2 id="CEF入门"><a href="#CEF入门" class="headerlink" title="CEF入门"></a>CEF入门</h2><p># [CEF中文教程(google chrome浏览器控件) – CEF简介]<br>嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。</p>
<p>它的设计思想政治就是易用且兼顾性能。CEF基本的框架包含C/C++程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和Chromium&amp;Webkit的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，javascript对象以及javascript扩展，宿主程序可以随意地控件资源下载，导航，下下文内容和打印等，并且可以跟Google Chrome浏览器一起，支持高性能和Html5 技术,</p>
<p>浏览器事件:<br>JavaScript扩展：<br>框架总览：所有的文件前缀都是Cef<br>框架的建立和销毁：<br>平台无关：<br>框架接口：<br>CefBrowser是主要的浏览器窗口类，可以用静态的函数CreateBrowser() 和CreateBrowserSync() 来创建一个新的浏览器窗口。<br>CefFrame 代表一个浏览器窗口的框架，每个浏览器窗口有一个顶层的主框架，而这个主框架可以用GetMainFrame() 方法得到。<br>CefClient是主浏览器窗口的代表接口，这个接口做为参数传递给CreateBrowser()<br>CefRequest 代表URL，方法，发送数据和头文件等这样的请求。<br>CefSchemeHandleFactory 类是被用来处理像myscheme://mydomain类似客户计划的请求       CefReadHandler和CefWriteHandle是一个读写数据的简单接口。<br>CefV8Handler,CefV8Value和CefV8Context是被用来创建和访问JavaScript对象。 </p>
<!-- 其它：  
[~~CEF中文教程(google chrome浏览器控件) -- CEF编译~~](http://www.itboth.com/d/ErEjQz/cef-chrome-google)    
[~~Windows上使用CEF嵌入基于chrome内核浏览器小例~~](http://www.itboth.com/d/6nqeYb/cef-windows-chrome)   

[~~CEF Windows开发环境搭建~~](https://blog.csdn.net/foruok/article/details/50468642)     
[~~Cef功能开发经验总结~~](https://blog.csdn.net/zhangzq86/article/details/70171121)   
-->
<h2 id="DebugView入门"><a href="#DebugView入门" class="headerlink" title="DebugView入门"></a>DebugView入门</h2><p># DebugView 调试入门<br>debugview 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。<br>支持Debug、Release模式编译的程序（即该软件捕获的是exe直接运行时，抛出的信息，而不是Visual Studio调试时的），<br>甚至支持内核程序，<br>而且能够定制各种过滤条件，让你只看到关心的输出信息，而且可以定制高亮显示的内容等等，非常方便。</p>
<p>一、System.Diagnostics.Debug.Write方法（Debug模式生成的exe）<br>二、System.Diagnostics.Debugger.Log方法（Debug与Release通用）<br>三、Kernal32.dll中的OutputDebugString方法（Debug与Release通用）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.Diagnostics.Debug.WriteLine(&quot;测试DebugView！！deg&quot;);</span><br><span class="line">System.Diagnostics.Debugger.Log(0, null, &quot;测试DebugView！！release&quot;);</span><br><span class="line">OutputDebugString(&quot;测试DebugView！JianKunKing&quot;);</span><br></pre></td></tr></table></figure></p>
<p># DebugView使用笔记<br><a href="https://blog.csdn.net/a200800170331/article/details/52415709" target="_blank" rel="noopener">https://blog.csdn.net/a200800170331/article/details/52415709</a><br>1. 什么是DebugView?<br>它是Sysinternals公司的系列调试工具。可以捕获程序中由TRACE()和OutputDebugString输出的信息。<br>2. C++需要完成哪些工作呢？<br>将打印的信息用OutputDebugString输出，示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UseDebugView  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UseDebugView  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span>  </span></span><br><span class="line"><span class="keyword">char</span> g_Debug[<span class="number">256</span>];  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UseDebugView  </span></span><br><span class="line">    sprintf_s(g_Debug, <span class="number">256</span>, <span class="string">"FJL---【循环求和】[In]\n"</span>);  </span><br><span class="line">    OutputDebugStringA(g_Debug);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        sum += i;  </span><br><span class="line">        <span class="comment">//printf("sum is %d!\n", sum);  </span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UseDebugView  </span></span><br><span class="line">    sprintf_s(g_Debug, <span class="number">256</span>, <span class="string">"FJL--【循环求和】[Out]\n"</span>);  </span><br><span class="line">    OutputDebugStringA(g_Debug);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们能在debugview看到输出的信息，是不是一定程度就可以调程序了呢？！</p>
<p>3. DebugView需要完成的工作？<br>首先，设定DebugView的View条件，如下所示：<br>然后，运行程序，观察DebugView界面显示字符串：  </p>
<p>总结：<br>C++设置我们期望的执行位置提示字符串；DebugView观察是否按照预期将其输出，根据输出的信息，便可以推断出代码问题所在。</p>
<p>调试工具不是万能的，只是一种辅助！！！</p>
<p># DebugView 调试<br><a href="https://blog.csdn.net/a379039233/article/details/79413497" target="_blank" rel="noopener">https://blog.csdn.net/a379039233/article/details/79413497</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test_Console.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">捕捉Release模式的Win32程序输出的调试信息，请选中“Capture Global Win32”选项. </span><br><span class="line">可以远程捕获！  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_VIEW</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_VIEW</span></span><br><span class="line">        CString str;</span><br><span class="line">        str.Format(_T(<span class="string">"Module: %d\r\n"</span>),cnt++);</span><br><span class="line">        <span class="comment">//sprintf_s(buf,"%d\n",cnt);</span></span><br><span class="line">        <span class="comment">//TRACE(_T("Module: %d\r\n"), cnt);</span></span><br><span class="line">        OutputDebugString(str);</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其它：<br><a href="http://charlesbc.blogspot.com/2008/09/debugview.html" target="_blank" rel="noopener">程湘之间：DebugView</a>   </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/pdf/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.25 星期一 22:23</p>

<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><h3 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h3><h3 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="*1.2 因特网概述"></a>*1.2 因特网概述</h3><p>网络的网络，因特网发展的三个阶段，因特网的标准化工作</p>
<h3 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="*1.3 因特网的组成"></a>*1.3 因特网的组成</h3><p>边缘部分，核心部分</p>
<h3 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h3><h3 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h3><p>计算机网络的定义，几种不同类别的网络</p>
<h3 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="*1.6 计算机网络的性能"></a>*1.6 计算机网络的性能</h3><p>性能指标，非性能指标</p>
<h3 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h3><p>形成，协议与划分层次，五层协议的体系结构，实体、协议、服务和服务访问点，TCP/IP的体系结构 </p>
<h2 id="二-物理层"><a href="#二-物理层" class="headerlink" title="二 物理层"></a>二 物理层</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="*2.1 基本概念"></a>*2.1 基本概念</h3><h3 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="*2.2 数据通信的基础知识"></a>*2.2 数据通信的基础知识</h3><p>数据通信系统的模型，有关新到的几个基本概念，信道的极限容量</p>
<h3 id="2-3-物理层下面的传输每天"><a href="#2-3-物理层下面的传输每天" class="headerlink" title="2.3 物理层下面的传输每天"></a>2.3 物理层下面的传输每天</h3><p>导向传输媒体，非导向传输媒体</p>
<h3 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="*2.4 信道复用技术"></a>*2.4 信道复用技术</h3><p>频分、时分、统计时分 复用，波分复用，码分复用</p>
<h3 id="2-5-数据传输系统"><a href="#2-5-数据传输系统" class="headerlink" title="*2.5 数据传输系统"></a>*2.5 数据传输系统</h3><h3 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="*2.6 宽带接入技术"></a>*2.6 宽带接入技术</h3><p>xDSL技术，光纤同轴混合网（HFC网），FTTx技术</p>
<h2 id="三-数据链路层"><a href="#三-数据链路层" class="headerlink" title="三 数据链路层"></a>三 数据链路层</h2><h3 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="*3.1 使用点对点信道的数据链路层"></a>*3.1 使用点对点信道的数据链路层</h3><p>数据链路和帧，三个基本问题</p>
<h3 id="3-2-点对点协议PPP"><a href="#3-2-点对点协议PPP" class="headerlink" title="*3.2 点对点协议PPP"></a>*3.2 点对点协议PPP</h3><p>特点，帧格式，工作状态</p>
<h3 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="*3.3 使用广播信道的数据链路层"></a>*3.3 使用广播信道的数据链路层</h3><p>局域网的数据链路层，CSMA/CD协议</p>
<h3 id="3-4-使用广播信道的以太网"><a href="#3-4-使用广播信道的以太网" class="headerlink" title="3.4 使用广播信道的以太网"></a>3.4 使用广播信道的以太网</h3><p>使用集线器的星形拓扑，以太网的信道利用率，以太网的MAC层</p>
<h3 id="3-5-扩展的以太网"><a href="#3-5-扩展的以太网" class="headerlink" title="*3.5 扩展的以太网"></a>*3.5 扩展的以太网</h3><p>在物理层扩展以太网，在数据链路层扩展</p>
<h3 id="3-6-高速以太网"><a href="#3-6-高速以太网" class="headerlink" title="*3.6 高速以太网"></a>*3.6 高速以太网</h3><p>100BASE-T，吉比特，10吉比特，使用高速以太网进行宽度接入</p>
<h3 id="3-7-其他类型的高速局域网或接口"><a href="#3-7-其他类型的高速局域网或接口" class="headerlink" title="3.7 其他类型的高速局域网或接口"></a>3.7 其他类型的高速局域网或接口</h3><h2 id="四-网络层"><a href="#四-网络层" class="headerlink" title="四 网络层"></a>四 网络层</h2><h3 id="4-1-提供两种服务"><a href="#4-1-提供两种服务" class="headerlink" title="*4.1 提供两种服务"></a>*4.1 提供两种服务</h3><h3 id="4-2-网际协议"><a href="#4-2-网际协议" class="headerlink" title="*4.2 网际协议"></a>*4.2 网际协议</h3><p>虚拟的互联网络，分类的IP地址，IP地址与硬件地址，地址解析协议ARP和逆地址解析协议RARP，IP数据报的格式，IP层转发分组的流程</p>
<h3 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="*4.3 划分子网和构造超网"></a>*4.3 划分子网和构造超网</h3><p>划分子网，使用子网时分组的转发，无分类编址CIDR(构造超网)</p>
<h3 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="*4.4 网际控制报文协议ICMP"></a>*4.4 网际控制报文协议ICMP</h3><p>种类，应用举例</p>
<h3 id="4-5-因特网的路由选择协议"><a href="#4-5-因特网的路由选择协议" class="headerlink" title="*4.5 因特网的路由选择协议"></a>*4.5 因特网的路由选择协议</h3><p>几个基本概念，内部网关协议RIP、OSPF、BGP，路由器的构成</p>
<h3 id="4-6-IP多播"><a href="#4-6-IP多播" class="headerlink" title="4.6 IP多播"></a>4.6 IP多播</h3><p>基本概念，在局域网上进行硬件多播，网际组管理协议IGMP和多播路由选择协议</p>
<h3 id="4-7-虚拟专用网VPN和网络地址转换NAT"><a href="#4-7-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.7 虚拟专用网VPN和网络地址转换NAT"></a>4.7 虚拟专用网VPN和网络地址转换NAT</h3><p>VPN,NAT</p>
<h2 id="五-运输层"><a href="#五-运输层" class="headerlink" title="五 运输层"></a>五 运输层</h2><h3 id="5-1-协议概述"><a href="#5-1-协议概述" class="headerlink" title="*5.1 协议概述"></a>*5.1 协议概述</h3><p>进程之间通信，两个主要协议，端口</p>
<h3 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="*5.2 用户数据报协议UDP"></a>*5.2 用户数据报协议UDP</h3><p>概述，首部格式</p>
<h3 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="*5.3 传输控制协议TCP概述"></a>*5.3 传输控制协议TCP概述</h3><p>主要特点，连接</p>
<h3 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="*5.4 可靠传输的工作原理"></a>*5.4 可靠传输的工作原理</h3><p>停止等待协议，连续ARQ协议</p>
<h3 id="5-5-TCO报文段的首部格式"><a href="#5-5-TCO报文段的首部格式" class="headerlink" title="*5.5 TCO报文段的首部格式"></a>*5.5 TCO报文段的首部格式</h3><h3 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6 TCP可靠传输的实现"></a>5.6 TCP可靠传输的实现</h3><p>*以字节为单位的滑动窗口，*超时重传时间的选择，选择确认SACK</p>
<h3 id="5-7-TCP的流量控制"><a href="#5-7-TCP的流量控制" class="headerlink" title="5.7  TCP的流量控制"></a>5.7  TCP的流量控制</h3><p>*利用滑动窗口实现流量控制，必须考虑传输效率</p>
<h3 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="*5.8 TCP的拥塞控制"></a>*5.8 TCP的拥塞控制</h3><p>一般原理，几种控制方法，随机早期检测RED</p>
<h3 id="5-9-TCP的运输连接管理"><a href="#5-9-TCP的运输连接管理" class="headerlink" title="5.9 TCP的运输连接管理"></a>5.9 TCP的运输连接管理</h3><p>*连接建立，*连接释放，有限状态机</p>
<h2 id="六-应用层"><a href="#六-应用层" class="headerlink" title="六 应用层"></a>六 应用层</h2><h3 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="*6.1 域名系统DNS"></a>*6.1 域名系统DNS</h3><p>概述，因特网的域名结构，域名服务器</p>
<h3 id="6-2-文件传输协议"><a href="#6-2-文件传输协议" class="headerlink" title="6.2 文件传输协议"></a>6.2 文件传输协议</h3><p>FTP概述，基本工作原理，简单文件传输协议TFTP</p>
<h3 id="6-3-远程终端协议TELNET"><a href="#6-3-远程终端协议TELNET" class="headerlink" title="6.3 远程终端协议TELNET"></a>6.3 远程终端协议TELNET</h3><h3 id="6-4-万维网WWW"><a href="#6-4-万维网WWW" class="headerlink" title="*6.4 万维网WWW"></a>*6.4 万维网WWW</h3><p>概述，统一资源定位符URL，超文本传送协议HTTP，万维网的文档，万维网的信息检索系统</p>
<h3 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="*6.5 电子邮件"></a>*6.5 电子邮件</h3><p>概述，简单电子邮件传送协议SMTP,信息格式，邮件读取协议POP3和IMAP，基于万维网的电子邮件，通用因特网邮件扩充MIME</p>
<h3 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="*6.6 动态主机配置协议DHCP"></a>*6.6 动态主机配置协议DHCP</h3><h3 id="6-7-简单网络管理协议SNMP"><a href="#6-7-简单网络管理协议SNMP" class="headerlink" title="6.7 简单网络管理协议SNMP"></a>6.7 简单网络管理协议SNMP</h3><p>网络管理的基本概念，管理信息结构SMI，管理信息库MIB,SNMP的新协议数据单元和报文</p>
<h3 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h3><p>系统调用和应用编程接口，几种常用的系统调用</p>
<h2 id="七-网络安全"><a href="#七-网络安全" class="headerlink" title="七 网络安全"></a>七 网络安全</h2><h3 id="7-1-问题概述"><a href="#7-1-问题概述" class="headerlink" title="*7.1 问题概述"></a>*7.1 问题概述</h3><p>计算机网络面临的安全性 威胁，安全的内容，一般的数据加密模型</p>
<h3 id="7-2-两类密码体制"><a href="#7-2-两类密码体制" class="headerlink" title="*7.2 两类密码体制"></a>*7.2 两类密码体制</h3><p>对称密钥密码体制，公钥体制</p>
<h3 id="7-3-数字签名"><a href="#7-3-数字签名" class="headerlink" title="*7.3 数字签名"></a>*7.3 数字签名</h3><h3 id="7-4-鉴别"><a href="#7-4-鉴别" class="headerlink" title="*7.4 鉴别"></a>*7.4 鉴别</h3><p>报文鉴别，实体鉴别</p>
<h3 id="7-5-密钥分配"><a href="#7-5-密钥分配" class="headerlink" title="*7.5 密钥分配"></a>*7.5 密钥分配</h3><p>对称密钥分配，公钥的分配</p>
<h3 id="7-6-因特网使用的安全协议"><a href="#7-6-因特网使用的安全协议" class="headerlink" title="7.6 因特网使用的安全协议"></a>7.6 因特网使用的安全协议</h3><p>网络层，运输层，应用层</p>
<h3 id="7-7-链路加密与端到端加密"><a href="#7-7-链路加密与端到端加密" class="headerlink" title="*7.7 链路加密与端到端加密"></a>*7.7 链路加密与端到端加密</h3><h3 id="7-8-防火墙"><a href="#7-8-防火墙" class="headerlink" title="*7.8 防火墙"></a>*7.8 防火墙</h3><h2 id="八-因特网上的音频-视频服务"><a href="#八-因特网上的音频-视频服务" class="headerlink" title="八 因特网上的音频/视频服务"></a>八 因特网上的音频/视频服务</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="*8.1 概述"></a>*8.1 概述</h3><h3 id="8-2-流式存储音频-视频"><a href="#8-2-流式存储音频-视频" class="headerlink" title="8.2 流式存储音频/视频"></a>8.2 流式存储音频/视频</h3><p>具有元文件的万维网服务器，<em>媒体服务器， </em>实时流式协议RTSP</p>
<h3 id="8-3-交互式音频-视频"><a href="#8-3-交互式音频-视频" class="headerlink" title="*8.3 交互式音频/视频"></a>*8.3 交互式音频/视频</h3><p>IP电话概述，IP电话所需的几种应用协议，实时运输协议RTP，实时运输控制协议RTCP，H.323，会话发起协议SIP</p>
<h3 id="8-4-改进“尽最大努力交付”的服务"><a href="#8-4-改进“尽最大努力交付”的服务" class="headerlink" title="8.4 改进“尽最大努力交付”的服务"></a>8.4 改进“尽最大努力交付”的服务</h3><p>使因特网提供服务质量，调度和管制机制，综合服务IntServ与资源预留协议RSVP，区分服务DiffServ</p>
<h2 id="九-无线网络"><a href="#九-无线网络" class="headerlink" title="九 无线网络"></a>九 无线网络</h2><h3 id="9-1-无线局域网WLAN"><a href="#9-1-无线局域网WLAN" class="headerlink" title="9.1 无线局域网WLAN"></a>9.1 无线局域网WLAN</h3><p>*组成，802.11局域网的物理层，MAC层协议，MAC帧</p>
<h3 id="9-2-无线个人区域网WPAN"><a href="#9-2-无线个人区域网WPAN" class="headerlink" title="9.2 无线个人区域网WPAN"></a>9.2 无线个人区域网WPAN</h3><h3 id="9-3-无线城域王WMAN"><a href="#9-3-无线城域王WMAN" class="headerlink" title="9.3 无线城域王WMAN"></a>9.3 无线城域王WMAN</h3><h2 id="零-下一代因特网"><a href="#零-下一代因特网" class="headerlink" title="零 下一代因特网"></a>零 下一代因特网</h2><h3 id="0-1-下一代网际协议IPv6（IPng）"><a href="#0-1-下一代网际协议IPv6（IPng）" class="headerlink" title="*0.1 下一代网际协议IPv6（IPng）"></a>*0.1 下一代网际协议IPv6（IPng）</h3><p>解决IP地址耗尽的措施，基本首部，扩展首部，地址空间，过渡，ICMPv6</p>
<h3 id="0-2-多协议标记交换MPLS"><a href="#0-2-多协议标记交换MPLS" class="headerlink" title="0.2 多协议标记交换MPLS"></a>0.2 多协议标记交换MPLS</h3><p>产生背景，工作原理，首部的位置与格式</p>
<h3 id="0-3-P2P文件共享"><a href="#0-3-P2P文件共享" class="headerlink" title="0.3 P2P文件共享"></a>0.3 P2P文件共享</h3><p style="text-align:right">23：08 </p>


<p>IPv4: 32/8 4个十进制： 192.168.0.1<br>Ipv6: 128/16 8个十六进制:  <em>:</em>:<em>:</em>:<em>:</em>:<em>:</em>  (可省略)    </p>
<p>十六进制对照表<br>0000 0001 0010 0011 0100 0101 0110 0111<br> 0     1    2   3     4    5    6   7   </p>
<p>1000 1001 1010 1011 1100 1101 1110 1111<br> 8     9   A    B     C    D    E   F   </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>WEB前端设计修炼之道</title>
    <url>/pdf/des/WEB%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<!-- 读：2017.5 -->
<p style="text-align:right">2018.6.24 星期日 11:54</p>


<h2 id="一-web前端开发ABC"><a href="#一-web前端开发ABC" class="headerlink" title="一 web前端开发ABC"></a>一 web前端开发ABC</h2><h3 id="1-1-web大局观"><a href="#1-1-web大局观" class="headerlink" title="1.1 web大局观"></a>1.1 web大局观</h3><p>web诞生，网络技术领导者W3C，不断优化的客户端技术，服务端技术的成熟</p>
<h3 id="1-2-地位、曲线和使命"><a href="#1-2-地位、曲线和使命" class="headerlink" title="1.2 地位、曲线和使命"></a>1.2 地位、曲线和使命</h3><p>路漫漫，千军易得一将难求，望而却步的学习曲线，如何自身定位</p>
<h3 id="1-3-前端开发所需掌握的技术"><a href="#1-3-前端开发所需掌握的技术" class="headerlink" title="1.3 前端开发所需掌握的技术"></a>1.3 前端开发所需掌握的技术</h3><h3 id="1-4-常用工具"><a href="#1-4-常用工具" class="headerlink" title="1.4 常用工具"></a>1.4 常用工具</h3><p>设计，原型，调试，辅助</p>
<h2 id="二-打造前端设计的基石-交出你的原型稿"><a href="#二-打造前端设计的基石-交出你的原型稿" class="headerlink" title="二 打造前端设计的基石-交出你的原型稿"></a>二 打造前端设计的基石-交出你的原型稿</h2><h3 id="2-1-UCD-以用户为中心的设计原则"><a href="#2-1-UCD-以用户为中心的设计原则" class="headerlink" title="2.1 UCD-以用户为中心的设计原则"></a>2.1 UCD-以用户为中心的设计原则</h3><p>关注用户，用户调研，更含蓄的方式</p>
<h3 id="2-2-交出第一份设计稿"><a href="#2-2-交出第一份设计稿" class="headerlink" title="2.2 交出第一份设计稿"></a>2.2 交出第一份设计稿</h3><p>为什么原型设计很重要，原型如何表现，做好原型产品的注意事项</p>
<h3 id="2-3-让工具帮助你"><a href="#2-3-让工具帮助你" class="headerlink" title="2.3 让工具帮助你"></a>2.3 让工具帮助你</h3><p>创建用户模型，Balsamiq Mockups设计概念图，Axure RP设计交互原型，更真实的表现</p>
<h2 id="三-从过去到未来-前端设计演变之路"><a href="#三-从过去到未来-前端设计演变之路" class="headerlink" title="三 从过去到未来-前端设计演变之路"></a>三 从过去到未来-前端设计演变之路</h2><h3 id="3-1-最熟悉的陌生人"><a href="#3-1-最熟悉的陌生人" class="headerlink" title="3.1 最熟悉的陌生人"></a>3.1 最熟悉的陌生人</h3><p>浏览器之争，性能对比，ie PK web标准</p>
<h3 id="3-2-结构的变迁"><a href="#3-2-结构的变迁" class="headerlink" title="3.2 结构的变迁"></a>3.2 结构的变迁</h3><p>表格噩梦，基于div和css的布局结构</p>
<h3 id="3-3-不单纯是脚本"><a href="#3-3-不单纯是脚本" class="headerlink" title="3.3 不单纯是脚本"></a>3.3 不单纯是脚本</h3><p>js的原貌，华丽的进化，ajax不得不提，脚本框架的出现</p>
<h3 id="3-4-接触未来一-初探html5"><a href="#3-4-接触未来一-初探html5" class="headerlink" title="3.4 接触未来一-初探html5"></a>3.4 接触未来一-初探html5</h3><p>摘要，结构，flash杀手canvas，设计一个布局结构文档，对表单的支持</p>
<h3 id="3-5-接触未来二-css3的世界很精彩"><a href="#3-5-接触未来二-css3的世界很精彩" class="headerlink" title="3.5 接触未来二-css3的世界很精彩"></a>3.5 接触未来二-css3的世界很精彩</h3><p>选择器的变化，布局的变化，样式的变化，动画 </p>
<h2 id="四-让你的设计深入人心-可用性设计"><a href="#四-让你的设计深入人心-可用性设计" class="headerlink" title="四 让你的设计深入人心-可用性设计"></a>四 让你的设计深入人心-可用性设计</h2><h3 id="4-1-可用性原则"><a href="#4-1-可用性原则" class="headerlink" title="4.1 可用性原则"></a>4.1 可用性原则</h3><p>别让我思考，停止你的假设，针对扫描而设计</p>
<h3 id="4-2-高可用性页面"><a href="#4-2-高可用性页面" class="headerlink" title="4.2 高可用性页面"></a>4.2 高可用性页面</h3><p>导航之道，当链接变成云，设计可用的表单，拒绝写作艺术</p>
<h3 id="4-3-可用性测试"><a href="#4-3-可用性测试" class="headerlink" title="4.3 可用性测试"></a>4.3 可用性测试</h3><p>如何测试，现象与本质</p>
<h3 id="4-4-巧妙应对错误"><a href="#4-4-巧妙应对错误" class="headerlink" title="4.4 巧妙应对错误"></a>4.4 巧妙应对错误</h3><p>提前预防，设计有用的信息，人性化操作</p>
<h3 id="4-5-系统一致性设计"><a href="#4-5-系统一致性设计" class="headerlink" title="4.5 系统一致性设计"></a>4.5 系统一致性设计</h3><p>规范设计，有始有终</p>
<h2 id="五-原型模型化"><a href="#五-原型模型化" class="headerlink" title="五 原型模型化"></a>五 原型模型化</h2><h3 id="5-1-布局之道"><a href="#5-1-布局之道" class="headerlink" title="5.1 布局之道"></a>5.1 布局之道</h3><p>基本布局样式属性，基于网络系统的css框架布局，流体布局</p>
<h3 id="5-2-样式就是设计"><a href="#5-2-样式就是设计" class="headerlink" title="5.2 样式就是设计"></a>5.2 样式就是设计</h3><p>必须了解样式技术，使用样式完成所有事件</p>
<h3 id="5-3-动态交互之美"><a href="#5-3-动态交互之美" class="headerlink" title="5.3 动态交互之美"></a>5.3 动态交互之美</h3><p>js设计新思维，jquery是最佳实践，一个关于tab导航的交互例子</p>
<h3 id="5-4-设计理念的碰撞与融合"><a href="#5-4-设计理念的碰撞与融合" class="headerlink" title="5.4 设计理念的碰撞与融合"></a>5.4 设计理念的碰撞与融合</h3><p>png透明色的应用，大菜单，tab选项卡，模态窗口，unobrusive的web开发</p>
<h2 id="六-探索、品味、总结-经典设计思维"><a href="#六-探索、品味、总结-经典设计思维" class="headerlink" title="六 探索、品味、总结-经典设计思维"></a>六 探索、品味、总结-经典设计思维</h2><h3 id="6-1-平衡网站的色彩"><a href="#6-1-平衡网站的色彩" class="headerlink" title="6.1 平衡网站的色彩"></a>6.1 平衡网站的色彩</h3><p>色彩的联想，色彩三要素，流行配色</p>
<h3 id="6-2-简洁的思想斗争"><a href="#6-2-简洁的思想斗争" class="headerlink" title="6.2 简洁的思想斗争"></a>6.2 简洁的思想斗争</h3><p>有效利用空白，是时候“减肥”了，简洁的背后</p>
<h3 id="6-3-排版艺术"><a href="#6-3-排版艺术" class="headerlink" title="6.3 排版艺术"></a>6.3 排版艺术</h3><p>充分了解你要使用的字体，其他重要排版要素</p>
<h3 id="6-4-80-的情况下我们可以这样做"><a href="#6-4-80-的情况下我们可以这样做" class="headerlink" title="6.4 80%的情况下我们可以这样做"></a>6.4 80%的情况下我们可以这样做</h3><p>轻松导航，便捷检索，快速选择，有效帮助  </p>
<h2 id="七-让你的设计更加完美-优化技巧和最佳实践"><a href="#七-让你的设计更加完美-优化技巧和最佳实践" class="headerlink" title="七 让你的设计更加完美-优化技巧和最佳实践"></a>七 让你的设计更加完美-优化技巧和最佳实践</h2><h3 id="7-1-性能在前端的重要性"><a href="#7-1-性能在前端的重要性" class="headerlink" title="7.1 性能在前端的重要性"></a>7.1 性能在前端的重要性</h3><h3 id="7-2-前端性能优化的基本原则"><a href="#7-2-前端性能优化的基本原则" class="headerlink" title="7.2 前端性能优化的基本原则"></a>7.2 前端性能优化的基本原则</h3><p>页面内容，服务器</p>
<h3 id="7-3-让自己更容易被发现"><a href="#7-3-让自己更容易被发现" class="headerlink" title="7.3 让自己更容易被发现"></a>7.3 让自己更容易被发现</h3><p>SEO策略，前端搜索引擎友好，其他，维护SEO效果</p>
<h2 id="八-思考与展望-浅谈web发展的未来"><a href="#八-思考与展望-浅谈web发展的未来" class="headerlink" title="八 思考与展望-浅谈web发展的未来"></a>八 思考与展望-浅谈web发展的未来</h2><h3 id="8-1-不可思议的web2-0"><a href="#8-1-不可思议的web2-0" class="headerlink" title="8.1 不可思议的web2.0"></a>8.1 不可思议的web2.0</h3><p>是一场必然的革命，web2.0的新生活，云时代的脚本</p>
<h3 id="8-2-REST"><a href="#8-2-REST" class="headerlink" title="8.2 REST"></a>8.2 REST</h3><p>什么是，初探，ajax和rest组合</p>
<h3 id="8-3-Mashup与Widget"><a href="#8-3-Mashup与Widget" class="headerlink" title="8.3 Mashup与Widget"></a>8.3 Mashup与Widget</h3><p>什么是Mashup，实践，1+1&gt;2，Widget</p>
<h3 id="8-4-拥抱未来，拥抱Web3-0"><a href="#8-4-拥抱未来，拥抱Web3-0" class="headerlink" title="8.4 拥抱未来，拥抱Web3.0"></a>8.4 拥抱未来，拥抱Web3.0</h3><p>什么样，语义网，web3.0先行者</p>
<h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p style="text-align:right">12：13 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>des</category>
      </categories>
  </entry>
  <entry>
    <title>JS忍者秘籍</title>
    <url>/pdf/js/JS%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.24 星期日 00：24 </p>

<!-- 2016/2017 读；第二本（除犀书）   -->
<!-- 接下来，高效js、函数式等，js面向对象是2017.5；还有几个css实战案例、基础等 -->
<!-- 2017.5：编写高质量代码，前端设计修炼之道 -->
<p># 第一部分 准入训练</p>
<h2 id="一-进入忍者世界"><a href="#一-进入忍者世界" class="headerlink" title="一 进入忍者世界"></a>一 进入忍者世界</h2><h3 id="1-1-即将探索js库"><a href="#1-1-即将探索js库" class="headerlink" title="1.1 即将探索js库"></a>1.1 即将探索js库</h3><h3 id="1-2-理解js语言"><a href="#1-2-理解js语言" class="headerlink" title="1.2 理解js语言"></a>1.2 理解js语言</h3><h3 id="1-3-跨浏览器注意事项"><a href="#1-3-跨浏览器注意事项" class="headerlink" title="1.3 跨浏览器注意事项"></a>1.3 跨浏览器注意事项</h3><h3 id="1-4-当前最佳实践"><a href="#1-4-当前最佳实践" class="headerlink" title="1.4 当前最佳实践"></a>1.4 当前最佳实践</h3><p>测试、性能</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><h2 id="二-利用测试和调试武装自己"><a href="#二-利用测试和调试武装自己" class="headerlink" title="二 利用测试和调试武装自己"></a>二 利用测试和调试武装自己</h2><h3 id="2-1-调试代码"><a href="#2-1-调试代码" class="headerlink" title="2.1 调试代码"></a>2.1 调试代码</h3><p>日志记录、断点</p>
<h3 id="2-2-测试用例生成"><a href="#2-2-测试用例生成" class="headerlink" title="2.2 测试用例生成"></a>2.2 测试用例生成</h3><h3 id="2-3-测试框架"><a href="#2-3-测试框架" class="headerlink" title="2.3 测试框架"></a>2.3 测试框架</h3><p>QUnit，YUI Test，JsUnit，新出</p>
<h3 id="2-4-测试套件基础知识"><a href="#2-4-测试套件基础知识" class="headerlink" title="2.4 测试套件基础知识"></a>2.4 测试套件基础知识</h3><p>断言、测试组、异步测试</p>
<h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p># 第二部分 见习训练</p>
<h2 id="三-函数是根基"><a href="#三-函数是根基" class="headerlink" title="三 函数是根基"></a>三 函数是根基</h2><h3 id="3-1-函数的独特之处"><a href="#3-1-函数的独特之处" class="headerlink" title="3.1 函数的独特之处"></a>3.1 函数的独特之处</h3><p>函数式特性、使用比较器排序</p>
<h3 id="3-2-声明"><a href="#3-2-声明" class="headerlink" title="3.2 声明"></a>3.2 声明</h3><h3 id="3-3-调用"><a href="#3-3-调用" class="headerlink" title="3.3 调用"></a>3.3 调用</h3><p>参数到形参、做为函数/方法/构造器进行调用、apply和call</p>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><h2 id="四-挥舞函数"><a href="#四-挥舞函数" class="headerlink" title="四 挥舞函数"></a>四 挥舞函数</h2><h3 id="4-1-匿名"><a href="#4-1-匿名" class="headerlink" title="4.1 匿名"></a>4.1 匿名</h3><h3 id="4-2-递归"><a href="#4-2-递归" class="headerlink" title="4.2 递归"></a>4.2 递归</h3><p>普通函数/方法中递归，引用丢失，内联命名函数，callee</p>
<h3 id="4-3-视为对象"><a href="#4-3-视为对象" class="headerlink" title="4.3 视为对象"></a>4.3 视为对象</h3><p>函数存储，自记忆，伪造数组方法</p>
<h3 id="4-4-可变长度参数"><a href="#4-4-可变长度参数" class="headerlink" title="4.4 可变长度参数"></a>4.4 可变长度参数</h3><p>apply，重载</p>
<h3 id="4-5-函数判断"><a href="#4-5-函数判断" class="headerlink" title="4.5 函数判断"></a>4.5 函数判断</h3><h2 id="五-闭包"><a href="#五-闭包" class="headerlink" title="五 闭包"></a>五 闭包</h2><h3 id="5-1-如何工作"><a href="#5-1-如何工作" class="headerlink" title="5.1 如何工作"></a>5.1 如何工作</h3><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>私有变量，回调与计时器</p>
<h3 id="5-3-绑定上下文"><a href="#5-3-绑定上下文" class="headerlink" title="5.3 绑定上下文"></a>5.3 绑定上下文</h3><h3 id="5-4-偏应用函数"><a href="#5-4-偏应用函数" class="headerlink" title="5.4 偏应用函数"></a>5.4 偏应用函数</h3><h3 id="5-5-重载"><a href="#5-5-重载" class="headerlink" title="5.5 重载"></a>5.5 重载</h3><p>缓存记忆，函数包装</p>
<h3 id="5-6-即时函数"><a href="#5-6-即时函数" class="headerlink" title="5.6 即时函数"></a>5.6 即时函数</h3><p>临时作用域和私有变量，循环，类库包装</p>
<h2 id="六-原型与面向对象"><a href="#六-原型与面向对象" class="headerlink" title="六 原型与面向对象"></a>六 原型与面向对象</h2><h3 id="6-1-实例化和原型"><a href="#6-1-实例化和原型" class="headerlink" title="6.1 实例化和原型"></a>6.1 实例化和原型</h3><p>对象实例化，构造器判断对象类型</p>
<h3 id="6-2-疑难陷进"><a href="#6-2-疑难陷进" class="headerlink" title="6.2 疑难陷进"></a>6.2 疑难陷进</h3><p>扩展对象，扩展数字，子类化原生对象，实例化问题</p>
<h3 id="6-3-编写类风格的代码"><a href="#6-3-编写类风格的代码" class="headerlink" title="6.3 编写类风格的代码"></a>6.3 编写类风格的代码</h3><p>检测函数是否可序列化，子类的实例化，保留父级方法</p>
<h2 id="七-正则表达式"><a href="#七-正则表达式" class="headerlink" title="七 正则表达式"></a>七 正则表达式</h2><h3 id="7-1-为什么很牛"><a href="#7-1-为什么很牛" class="headerlink" title="7.1 为什么很牛"></a>7.1 为什么很牛</h3><h3 id="7-2-进阶"><a href="#7-2-进阶" class="headerlink" title="7.2 进阶"></a>7.2 进阶</h3><p>解释，术语与操作符</p>
<h3 id="7-3-编译"><a href="#7-3-编译" class="headerlink" title="7.3 编译"></a>7.3 编译</h3><h3 id="7-4-捕获匹配的片段"><a href="#7-4-捕获匹配的片段" class="headerlink" title="7.4 捕获匹配的片段"></a>7.4 捕获匹配的片段</h3><p>简单，全局，引用，分组</p>
<h3 id="7-5-利用函数进行替换"><a href="#7-5-利用函数进行替换" class="headerlink" title="7.5 利用函数进行替换"></a>7.5 利用函数进行替换</h3><h3 id="7-6-利用解决常见问题"><a href="#7-6-利用解决常见问题" class="headerlink" title="7.6 利用解决常见问题"></a>7.6 利用解决常见问题</h3><p>修剪str，匹配换行符，Unicode，转义字符</p>
<h2 id="八-驯服线程和定时器"><a href="#八-驯服线程和定时器" class="headerlink" title="八 驯服线程和定时器"></a>八 驯服线程和定时器</h2><h3 id="8-1-如何工作的"><a href="#8-1-如何工作的" class="headerlink" title="8.1 如何工作的"></a>8.1 如何工作的</h3><p>设置和清除，。。</p>
<h3 id="8-2-延迟的最小化及其可靠性"><a href="#8-2-延迟的最小化及其可靠性" class="headerlink" title="8.2 延迟的最小化及其可靠性"></a>8.2 延迟的最小化及其可靠性</h3><h3 id="8-3-处理昂贵的计算过程"><a href="#8-3-处理昂贵的计算过程" class="headerlink" title="8.3 处理昂贵的计算过程"></a>8.3 处理昂贵的计算过程</h3><h3 id="8-4-中央定时器控制"><a href="#8-4-中央定时器控制" class="headerlink" title="8.4 中央定时器控制"></a>8.4 中央定时器控制</h3><h3 id="8-5-异步测试"><a href="#8-5-异步测试" class="headerlink" title="8.5 异步测试"></a>8.5 异步测试</h3><p># 第三部分 忍者训练</p>
<h2 id="九-运行时代码求值"><a href="#九-运行时代码求值" class="headerlink" title="九 运行时代码求值"></a>九 运行时代码求值</h2><h3 id="9-1-机制"><a href="#9-1-机制" class="headerlink" title="9.1 机制"></a>9.1 机制</h3><p>eval()，函数构造器，定时器，全局作用域内，安全的代码求值</p>
<h3 id="9-2-函数反编译"><a href="#9-2-函数反编译" class="headerlink" title="9.2 函数反编译"></a>9.2 函数反编译</h3><h3 id="9-3-实战"><a href="#9-3-实战" class="headerlink" title="9.3 实战"></a>9.3 实战</h3><p>json转化，导入命名空间，js压缩和混淆，动态重写代码，面向切面的脚本标签，元语言和领域特定语言</p>
<h2 id="零-with语句"><a href="#零-with语句" class="headerlink" title="零 with语句"></a>零 with语句</h2><p><strong>$_PS:</strong> 略过 。。。</p>
<h3 id="0-1-怎么回事"><a href="#0-1-怎么回事" class="headerlink" title="0.1 怎么回事"></a>0.1 怎么回事</h3><h3 id="0-2-真实示例"><a href="#0-2-真实示例" class="headerlink" title="0.2 真实示例"></a>0.2 真实示例</h3><h3 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h3><h3 id="0-4-测试"><a href="#0-4-测试" class="headerlink" title="0.4 测试"></a>0.4 测试</h3><h3 id="0-5"><a href="#0-5" class="headerlink" title="0.5"></a>0.5</h3><h2 id="一-开发跨浏览器策略"><a href="#一-开发跨浏览器策略" class="headerlink" title="一 开发跨浏览器策略"></a>一 开发跨浏览器策略</h2><h3 id="1-1-选择要支持的浏览器"><a href="#1-1-选择要支持的浏览器" class="headerlink" title="1.1 选择要支持的浏览器"></a>1.1 选择要支持的浏览器</h3><h3 id="1-2-五大开发关注点"><a href="#1-2-五大开发关注点" class="headerlink" title="1.2 五大开发关注点"></a>1.2 五大开发关注点</h3><p>bug和差异，bug修复，与外部代码共存，缺失的功能，回归</p>
<h3 id="1-3-实现策略"><a href="#1-3-实现策略" class="headerlink" title="1.3 实现策略"></a>1.3 实现策略</h3><p>安全的跨修复，对象检测，特性仿真，不可检测的问题</p>
<h3 id="1-4-减少假设"><a href="#1-4-减少假设" class="headerlink" title="1.4 减少假设"></a>1.4 减少假设</h3><h2 id="二-洞悉特性、属性和样式"><a href="#二-洞悉特性、属性和样式" class="headerlink" title="二 洞悉特性、属性和样式"></a>二 洞悉特性、属性和样式</h2><h3 id="2-1-dom特性和dom属性"><a href="#2-1-dom特性和dom属性" class="headerlink" title="2.1 dom特性和dom属性"></a>2.1 dom特性和dom属性</h3><p>跨浏览器命名，命名限制，xml和html差异，自定义特性的行为，性能注意事项</p>
<h3 id="2-2-跨的attribute问题"><a href="#2-2-跨的attribute问题" class="headerlink" title="2.2 跨的attribute问题"></a>2.2 跨的attribute问题</h3><p>dom的id/name膨胀，url规范，style特性，type特性，tab index问题，节点名称</p>
<h3 id="2-3-令人头疼的样式"><a href="#2-3-令人头疼的样式" class="headerlink" title="2.3 令人头疼的样式"></a>2.3 令人头疼的样式</h3><p>在何处，属性命名，float，像素值转换，测量高度和宽度，opacity，颜色</p>
<h3 id="2-4-获取计算样式"><a href="#2-4-获取计算样式" class="headerlink" title="2.4 获取计算样式"></a>2.4 获取计算样式</h3><p># 第三部分 火影训练</p>
<h2 id="三-不老事件"><a href="#三-不老事件" class="headerlink" title="三 不老事件"></a>三 不老事件</h2><h3 id="3-1-绑定和解绑事件处理程序"><a href="#3-1-绑定和解绑事件处理程序" class="headerlink" title="3.1 绑定和解绑事件处理程序"></a>3.1 绑定和解绑事件处理程序</h3><h3 id="3-2-event对象"><a href="#3-2-event对象" class="headerlink" title="3.2 event对象"></a>3.2 event对象</h3><h3 id="3-3-处理程序的管理"><a href="#3-3-处理程序的管理" class="headerlink" title="3.3 处理程序的管理"></a>3.3 处理程序的管理</h3><p>几种存储相关信息，管理事件处理程序</p>
<h3 id="3-4-事件触发"><a href="#3-4-事件触发" class="headerlink" title="3.4 事件触发"></a>3.4 事件触发</h3><h3 id="3-5-冒泡与委托"><a href="#3-5-冒泡与委托" class="headerlink" title="3.5 冒泡与委托"></a>3.5 冒泡与委托</h3><p>给祖先元素，修复浏览器不足</p>
<h3 id="3-6-文档就绪事件"><a href="#3-6-文档就绪事件" class="headerlink" title="3.6 文档就绪事件"></a>3.6 文档就绪事件</h3><h2 id="四-dom操纵"><a href="#四-dom操纵" class="headerlink" title="四 dom操纵"></a>四 dom操纵</h2><h3 id="4-1-向dom注入html"><a href="#4-1-向dom注入html" class="headerlink" title="4.1 向dom注入html"></a>4.1 向dom注入html</h3><p>html转为dom，dom插入文档，脚本执行</p>
<h3 id="4-2-克隆元素"><a href="#4-2-克隆元素" class="headerlink" title="4.2 克隆元素"></a>4.2 克隆元素</h3><h3 id="4-3-删除元素"><a href="#4-3-删除元素" class="headerlink" title="4.3 删除元素"></a>4.3 删除元素</h3><h3 id="4-4-文本内容"><a href="#4-4-文本内容" class="headerlink" title="4.4 文本内容"></a>4.4 文本内容</h3><p>设置文本，获取</p>
<h2 id="五-css选择器引擎"><a href="#五-css选择器引擎" class="headerlink" title="五 css选择器引擎"></a>五 css选择器引擎</h2><h3 id="5-1-wec-selectors-api"><a href="#5-1-wec-selectors-api" class="headerlink" title="5.1 wec selectors api"></a>5.1 wec selectors api</h3><h3 id="5-2-利用XPath-查找元素"><a href="#5-2-利用XPath-查找元素" class="headerlink" title="5.2 利用XPath 查找元素"></a>5.2 利用XPath 查找元素</h3><h3 id="5-3-纯dom实现"><a href="#5-3-纯dom实现" class="headerlink" title="5.3 纯dom实现"></a>5.3 纯dom实现</h3><p>对选择器进行解析，查找元素，过滤结果集，递归和合并，自下而上的选择器引用  </p>
<p style="text-align:right">1：09 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>JS面向对象编程指南</title>
    <url>/pdf/js/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.24 星期日 11:25</p><br>人民邮电<br>2013.3<br><br><!-- 读：2017.5   --><br>二，三，七-4  略过了<br><br>## 一 引言<br>### 1.1 回顾历史<br>### 1.2 变革之风<br>### 1.3 分析现状<br>### 1.4 展望未来<br>### 1.5 面向对象的程序设计<br>对象，类，封装，聚合，继承，多态<br>### 1.6 OOP概述<br>### 1.7 训练环境设置<br>### 1.8 使用firebug控制台<br><br>## 二 基本数据类型、数组、循环及条件表达式<br>### 2.1 变量<br>### 2.2 操作符<br>### 2.3 基本数据类型<br>### 2.4 基本数据类型综述<br>### 2.5 数组<br>### 2.6 条件与循环<br>### 2.7 注释<br><br>## 三 函数<br>### 3.1 什么是函数<br>### 3.2 预定义函数<br>### 3.3 变量的作用域<br>### 3.4 函数也是数据<br>### 3.5 闭包<br><br>## 四 对象<br>### 4.1 从数组到对象<br>### 4.2 内建对象<br>### 4.3<br>### 4.4<br>### 4.<br><br><br><br>## 五 原型<br>### 5.1 原型属性<br>利用原型添加方法与属性，利用原型的方法与属性，自身属性与原型，利用自身,isPrototypeOf(),神秘的<em>proto</em>链接<br>### 5.2 扩展内建对象<br>关于的讨论，一些原型陷进<br><br><br>## 六 继承<br><a href="https://github.com/Yalhu/forstudy/tree/master/OOP-proto%26Inherit" target="_blank" rel="noopener">源码</a><br>### 6.1 原型链<br>示例，将共享属性迁移到原型中去<br>### 6.2 只继承于原型<br>### 6.3 uber-子对象访问父对象的方式<br>### 6.4 将继承部分封装成函数<br>### 6.5 属性拷贝<br>### 6.6 小心处理引用拷贝<br>### 6.7 对象之间的继承<br>### 6.8 深拷贝<br>### 6.9 object()<br>### 6.0 原型继承与属性拷贝的混合应用<br>### 6.1 多重继承<br>### 6.2 寄生式继承<br>### 6.3 构造器借用<br><br>## 七 浏览器环境<br>### 7.1 在html页面中引入js代码<br>### 7.2 概述：BOM和DOM<br>### 7.3 BOM<br>window对象再探，navigator，firebug备忘，location，history，frames，screen，open/close,moveTo/resizeTo,alert/prompt/confirm,setTimeout/setInterval,document<br>### 7.4 DOM<br>Core DOM与 HTML DOM，DOM节点的访问，修改，新建，移除，只适用于html的dom对象<br>### 7.5 事件<br>内联html属性法，元素属性法，dom的事件监听器，捕捉法与冒泡法，阻断传播，阻止默认行为，跨浏览器事件监听，事件类型<br>### 7.6 XMLHttpRequest对象<br>发送请求，处理响应，在早于ie7版本创建XMLHtttpRequest对象，A代表异步，X代表XML，实例示范<br><br>## 八 编程模式与设计模式<br>### 8.1 编程模式<br>行为隔离，命名空间，初始化分支，延迟定义，配置对象，私有属性和方法，特权函数，私有函数的公有化，自执行函数，链式调用，JSON<br><br><p style="text-align:right">2019.4.6 星期六 12:25 $1</p><br>行为隔离：html,css,js<br>命名空间: namespace<br>初始化分支:不做过多假设，单独检测<br>延迟定义：第一次调用的时候设置<br>配置对象：第二个参数为对象，扩展方便<br>私有属性和方法：闭包（$PS-js模式: 构造函数和立即执行函数，揭示模式）<br>    Public:对象的属性（或方法）可以被所有人访问<br>    Private:只有对象自己可以访问这些属性<br>    Protectdd:仅该对象或其继承者才能访问这些属性<br>特权函数：普通的公共函数，但可以访问对象的私有属性和方法<br>私有函数的公有化：定义的私有函数又希望某些外部代码可以访问（$PS-js模式:揭示模式）<code>var _setStyle=function(){}</code><br>自执行函数:特别适合某些脚本加载是所执行的一次性初始化任务。也可用于创建和返回对象<br>链式调用：<br>JSON：不属于编程模式，是轻量级的数据交换格式<br><br>### 8.2 设计模式<br>单件1，单件2，工厂，装饰器，观察者<br><br>Book of Four或者Gang of Four或者GoF（代表书的4位作者）<br>大致三组：创建型，结构型，行为型。  共23个模式，发书后发现更多，只介绍4个<br><br>单件1：简单一个对象就是单件<br>单件2：构造器。1）检测全局变量；2）利用构造函数属性，但是该属性也是公有的；3）使用私有属性，利用闭包<br><br><br>### 3 工厂模式：多个相似对象而又不知道先使用哪种。代码根据输入或其他规则，自行决定创建那种类型对象<br>    $PS-js模式:Object<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态创建委托给工厂函数.把多个if替换</span></span><br><span class="line">MYAPP.dom.factory=<span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> MYAPP.dom[type]&#125;</span><br></pre></td></tr></table></figure><br><br>### 4 装饰器：结构型模式，考虑如何拓展对象的功能。不使用线性式（父-子-孙）<br>    为一个基础对象创建若干个装饰对象以拓展其功能。然后由程序自行选择不同的装饰起，不按不同的顺序使用它们。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰一颗圣诞树</span></span><br><span class="line"><span class="keyword">var</span> tree=&#123;&#125;</span><br><span class="line">tree.decorate=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'make sure the tree wont\'t fall'</span>)&#125;</span><br><span class="line">tree.getDecorator=<span class="function"><span class="keyword">function</span>(<span class="params">deco</span>)</span>&#123;</span><br><span class="line">    tree[deco].prototype=<span class="keyword">this</span>; <span class="comment">// 2 都继承自tree对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> tree[deco] <span class="comment">// 1 添加额外装饰器，实现为构造器函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 创建爱呢第一个装饰器 RedBalls,并设为tree的属性. $PS: 每次都把基础的decorate重写了一遍</span></span><br><span class="line">tree.RedBalls=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorate=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 提供decorate方法，先调用父类的方法</span></span><br><span class="line">        <span class="keyword">this</span>.RedBalls.prototype.decorate() </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'put on some red balls'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 添加其他装饰器，BlueBalls, Angel,</span></span><br><span class="line"><span class="comment">// 3 把装饰器都添加到基础对象中</span></span><br><span class="line">tree=tree.getDecorator(<span class="string">'RedBalls'</span>)</span><br><span class="line"><span class="comment">// 4 运行decorate方法</span></span><br><span class="line">tree.decorate()</span><br></pre></td></tr></table></figure><br><br>### 5 观察者：行为型模式，处理不同对象间互相通信。<br>订阅者/发行商模式。通常包含2类对象：一个或多个发行商对象，一个或多个订阅者对象<br>浏览器事件：浏览器-发行商， 事件订阅者会监听到这类事件，并在被通知。 浏览器为每一个订阅者发送一个事件对象<br><br>分两类：推送和发送。<br>推送实例。…混合类。。 任何一个对象都可以成为发行商，任何一个功能型对象都可以成为订阅者<br>观察者对象该有的属性和方法：1）由回调函数构成的订阅者数组；2）添加、删除；3）publish接受并传递数据给订阅者；4 make<br>$PS:观察者添加的订阅者是订阅者的一个方法/事件（回调），比如click，keydown，read，而不是一个对象。不能添加一个对象，需要添加的是对象的一个订阅行为（方法/事件），只有这样才是在行为发生的时候，订阅内容。该例中是‘读’的时候，而不是一个生硬的blogger对象<br>$PS: 下面例子发布者调用 <code>this.publish</code>好像有些问题<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observer=&#123;</span><br><span class="line">    addSubscriber:<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;<span class="keyword">this</span>.subscribers[<span class="keyword">this</span>.subscribers.length]=callback&#125;,</span><br><span class="line">    addSubscriber:<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;&#125;,</span><br><span class="line">    publish:<span class="function"><span class="keyword">function</span>(<span class="params">what</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.subscribers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[i] === <span class="string">'function'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.subscribers[i](what)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    make:<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">            o[i]=<span class="keyword">this</span>[i]</span><br><span class="line">            o.subscribers=[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建订阅者&gt;任意对象，某些重要事件发生时，调用publish方法</span></span><br><span class="line"><span class="keyword">var</span> blogger=&#123;</span><br><span class="line">    writeBolg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content=<span class="string">'today is '</span>+<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">this</span>.publish(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 转为发行商</span></span><br><span class="line">observer.make(blogger)</span><br><span class="line"><span class="comment">// 4 简单对象订阅blogger</span></span><br><span class="line"><span class="keyword">var</span> jack=&#123;</span><br><span class="line">    read:<span class="function"><span class="keyword">function</span>(<span class="params">what</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'i just read '</span>,what)&#125;</span><br><span class="line">&#125;</span><br><span class="line">blogger.addSubscriber(jack.read)</span><br></pre></td></tr></table></figure><br><br><p style="text-align:right">13:51 $1</p>


<p style="text-align:right">11:46</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>函数范式</title>
    <url>/pdf/js/%E5%87%BD%E6%95%B0%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.24 星期日 1:27</p>

<!-- 读:2016/2017 -->
<p># 第一部分</p>
<h2 id="一-我们在做什么"><a href="#一-我们在做什么" class="headerlink" title="一 我们在做什么"></a>一 我们在做什么</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><h3 id="1-2-一个简单的例子"><a href="#1-2-一个简单的例子" class="headerlink" title="1.2 一个简单的例子"></a>1.2 一个简单的例子</h3><h2 id="二-一等公民的函数"><a href="#二-一等公民的函数" class="headerlink" title="二 一等公民的函数"></a>二 一等公民的函数</h2><h3 id="2-1-快速概览"><a href="#2-1-快速概览" class="headerlink" title="2.1 快速概览"></a>2.1 快速概览</h3><h3 id="2-2-为何钟爱一等公民"><a href="#2-2-为何钟爱一等公民" class="headerlink" title="2.2 为何钟爱一等公民"></a>2.2 为何钟爱一等公民</h3><h2 id="三-纯函数的好处"><a href="#三-纯函数的好处" class="headerlink" title="三 纯函数的好处"></a>三 纯函数的好处</h2><h3 id="3-1-再次强调“纯”"><a href="#3-1-再次强调“纯”" class="headerlink" title="3.1 再次强调“纯”"></a>3.1 再次强调“纯”</h3><h3 id="3-2-副作用可能包括-。。"><a href="#3-2-副作用可能包括-。。" class="headerlink" title="3.2 副作用可能包括 。。"></a>3.2 副作用可能包括 。。</h3><h3 id="3-3-八年级数学"><a href="#3-3-八年级数学" class="headerlink" title="3.3 八年级数学"></a>3.3 八年级数学</h3><h3 id="3-4-追求“纯”的理由"><a href="#3-4-追求“纯”的理由" class="headerlink" title="3.4 追求“纯”的理由"></a>3.4 追求“纯”的理由</h3><h2 id="四-柯里化-curry"><a href="#四-柯里化-curry" class="headerlink" title="四 柯里化 curry"></a>四 柯里化 curry</h2><h3 id="4-1-不可或缺的curry"><a href="#4-1-不可或缺的curry" class="headerlink" title="4.1 不可或缺的curry"></a>4.1 不可或缺的curry</h3><h3 id="4-2-不仅仅是双关语-咖喱"><a href="#4-2-不仅仅是双关语-咖喱" class="headerlink" title="4.2 不仅仅是双关语/咖喱"></a>4.2 不仅仅是双关语/咖喱</h3><h2 id="五-代码组合-compose"><a href="#五-代码组合-compose" class="headerlink" title="五 代码组合 compose"></a>五 代码组合 compose</h2><h3 id="5-1-函数饲养"><a href="#5-1-函数饲养" class="headerlink" title="5.1 函数饲养"></a>5.1 函数饲养</h3><h3 id="5-2-pointfree"><a href="#5-2-pointfree" class="headerlink" title="5.2 pointfree"></a>5.2 pointfree</h3><h3 id="5-3-debug"><a href="#5-3-debug" class="headerlink" title="5.3 debug"></a>5.3 debug</h3><h3 id="5-4-范畴学"><a href="#5-4-范畴学" class="headerlink" title="5.4 范畴学"></a>5.4 范畴学</h3><h2 id="六-示例应用"><a href="#六-示例应用" class="headerlink" title="六 示例应用"></a>六 示例应用</h2><h3 id="6-1-声明式代码"><a href="#6-1-声明式代码" class="headerlink" title="6.1 声明式代码"></a>6.1 声明式代码</h3><h3 id="6-2-一个函数式的flickr"><a href="#6-2-一个函数式的flickr" class="headerlink" title="6.2 一个函数式的flickr"></a>6.2 一个函数式的flickr</h3><h3 id="6-3-有原则的重构"><a href="#6-3-有原则的重构" class="headerlink" title="6.3 有原则的重构"></a>6.3 有原则的重构</h3><h2 id="七-Hindley-Milner-类型签名"><a href="#七-Hindley-Milner-类型签名" class="headerlink" title="七 Hindley-Milner 类型签名"></a>七 Hindley-Milner 类型签名</h2><h3 id="7-1-初始类型"><a href="#7-1-初始类型" class="headerlink" title="7.1 初始类型"></a>7.1 初始类型</h3><h3 id="7-2-神秘的传奇故事"><a href="#7-2-神秘的传奇故事" class="headerlink" title="7.2 神秘的传奇故事"></a>7.2 神秘的传奇故事</h3><h3 id="7-3-缩小可能性范围"><a href="#7-3-缩小可能性范围" class="headerlink" title="7.3 缩小可能性范围"></a>7.3 缩小可能性范围</h3><h3 id="7-4-自有定理"><a href="#7-4-自有定理" class="headerlink" title="7.4 自有定理"></a>7.4 自有定理</h3><h2 id="八特百惠"><a href="#八特百惠" class="headerlink" title="八特百惠"></a>八特百惠</h2><h3 id="8-1-强大的容器"><a href="#8-1-强大的容器" class="headerlink" title="8.1 强大的容器"></a>8.1 强大的容器</h3><h3 id="8-2-第一个functor"><a href="#8-2-第一个functor" class="headerlink" title="8.2 第一个functor"></a>8.2 第一个functor</h3><h3 id="8-3-薛定谔的猫"><a href="#8-3-薛定谔的猫" class="headerlink" title="8.3 薛定谔的猫"></a>8.3 薛定谔的猫</h3><h3 id="8-4-“纯”错误处理"><a href="#8-4-“纯”错误处理" class="headerlink" title="8.4 “纯”错误处理"></a>8.4 “纯”错误处理</h3><h3 id="8-5-王老先生有作用。。。"><a href="#8-5-王老先生有作用。。。" class="headerlink" title="8.5 王老先生有作用。。。"></a>8.5 王老先生有作用。。。</h3><h3 id="8-6-异步任务"><a href="#8-6-异步任务" class="headerlink" title="8.6 异步任务"></a>8.6 异步任务</h3><h3 id="8-7-一点理论"><a href="#8-7-一点理论" class="headerlink" title="8.7 一点理论"></a>8.7 一点理论</h3><h2 id="九-Monad"><a href="#九-Monad" class="headerlink" title="九 Monad"></a>九 Monad</h2><h3 id="9-1-pointed-functor"><a href="#9-1-pointed-functor" class="headerlink" title="9.1 pointed functor"></a>9.1 pointed functor</h3><h3 id="9-2-混合比喻"><a href="#9-2-混合比喻" class="headerlink" title="9.2 混合比喻"></a>9.2 混合比喻</h3><h3 id="9-3-chain函数"><a href="#9-3-chain函数" class="headerlink" title="9.3 chain函数"></a>9.3 chain函数</h3><h3 id="9-4-理论"><a href="#9-4-理论" class="headerlink" title="9.4 理论"></a>9.4 理论</h3><h2 id="零-Applicative-Functor"><a href="#零-Applicative-Functor" class="headerlink" title="零 Applicative Functor"></a>零 Applicative Functor</h2><h3 id="0-1-应用applicative-functor"><a href="#0-1-应用applicative-functor" class="headerlink" title="0.1 应用applicative functor"></a>0.1 应用applicative functor</h3><h3 id="0-2-瓶中之船"><a href="#0-2-瓶中之船" class="headerlink" title="0.2 瓶中之船"></a>0.2 瓶中之船</h3><h3 id="0-3-协调与激励"><a href="#0-3-协调与激励" class="headerlink" title="0.3 协调与激励"></a>0.3 协调与激励</h3><h3 id="0-4-lift"><a href="#0-4-lift" class="headerlink" title="0.4 lift"></a>0.4 lift</h3><h3 id="0-5-免费开瓶器"><a href="#0-5-免费开瓶器" class="headerlink" title="0.5 免费开瓶器"></a>0.5 免费开瓶器</h3><h3 id="0-6-定律"><a href="#0-6-定律" class="headerlink" title="0.6 定律"></a>0.6 定律</h3><p style="text-align:right">1：43 </p>]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>高效JS简化版</title>
    <url>/pdf/js/%E9%AB%98%E6%95%88JS%E7%AE%80%E5%8C%96%E7%89%88/</url>
    <content><![CDATA[<p>详：.doc （颜色标注）<br>2章17条   </p>
<!-- 读：2016.* -->
<p style="text-align:right">2018.6.24 星期日 1:24</p>

<h2 id="第-1-章-让自己习惯-JavaScript"><a href="#第-1-章-让自己习惯-JavaScript" class="headerlink" title="第 1 章　让自己习惯 JavaScript"></a>第 1 章　让自己习惯 JavaScript</h2><h3 id="第-1-条：了解你使用的-JavaScript-版本"><a href="#第-1-条：了解你使用的-JavaScript-版本" class="headerlink" title="第 1 条：了解你使用的 JavaScript 版本"></a>第 1 条：了解你使用的 JavaScript 版本</h3><p>ES5 引入了另一种版本控制的考量——严格模式（strict mode）。<br>仍被视为是严格的。所以，为了达到更为普遍的兼容性，建议在严格模式下编写代码。</p>
<h3 id="第-2-条：理解-JavaScript-的浮点数"><a href="#第-2-条：理解-JavaScript-的浮点数" class="headerlink" title="第 2 条：理解 JavaScript 的浮点数"></a>第 2 条：理解 JavaScript 的浮点数</h3><p>双精度浮点数能完美地表示高达 53 位精度的整数  </p>
<p>然而，对于浮点数来说，却并不总是这样。<br>决方法是尽可能地采用整数值运算</p>
<h3 id="第-3-条：当心隐式的强制转换"><a href="#第-3-条：当心隐式的强制转换" class="headerlink" title="第 3 条：当心隐式的强制转换"></a>第 3 条：当心隐式的强制转换</h3><h3 id="第-4-条：原始类型优于封装对象"><a href="#第-4-条：原始类型优于封装对象" class="headerlink" title="第 4 条：原始类型优于封装对象"></a>第 4 条：原始类型优于封装对象</h3><h3 id="第-5-条：避免对混合类型使用-运算符"><a href="#第-5-条：避免对混合类型使用-运算符" class="headerlink" title="第 5 条：避免对混合类型使用 == 运算符"></a>第 5 条：避免对混合类型使用 == 运算符</h3><h3 id="第-6-条：了解分号插入的局限"><a href="#第-6-条：了解分号插入的局限" class="headerlink" title="第 6 条：了解分号插入的局限"></a>第 6 条：了解分号插入的局限</h3><h3 id="第-7-条：视字符串为16位的代码单元序列"><a href="#第-7-条：视字符串为16位的代码单元序列" class="headerlink" title="第 7 条：视字符串为16位的代码单元序列　"></a>第 7 条：视字符串为16位的代码单元序列　</h3><p>##　第 2 章　变量作用域</p>
<p>###　第 8 条：尽量少用全局对象</p>
<p>###　第 9 条：始终声明局部变量</p>
<p>###　第 10 条：避免使用 with</p>
<p>###　第 11 条：熟练掌握闭包</p>
<p>###　第 12 条：理解变量声明提升</p>
<p>###　第 13 条：使用立即调用的函数表达式创建局部作用域</p>
<p>###　第 14 条：当心命名函数表达式笨拙的作用域</p>
<p>###　第 15 条：当心局部块函数声明笨拙的作用域</p>
<p>###　第 16 条：避免使用 eval 创建局部变量</p>
<p>###　第 17 条：间接调用 eval 函数优于直接调用</p>
<p style="text-align:right">1.26 </p>]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>SQL必知必会</title>
    <url>/pdf/ser/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.24 星期日 21:01</p>

<!-- 读：2018.3 -->
<h2 id="第1课-了解SQL"><a href="#第1课-了解SQL" class="headerlink" title="第1课 了解SQL"></a>第1课 了解SQL</h2><p>1.1 数据库基础<br>1.1.1 数据库<br>1.1.2 表<br>1.1.3 列和数据类型<br>1.1.4 行<br>1.1.5 主键<br>1.2 什么是SQL<br>1.3 动手实践<br>1.4 小结</p>
<h2 id="第2课-检索数据"><a href="#第2课-检索数据" class="headerlink" title="第2课 检索数据"></a>第2课 检索数据</h2><p>2.1 SELECT语句<br>2.2 检索单个列<br>2.3 检索多个列<br>2.4 检索所有列<br>2.5 检索不同的值<br>2.6 限制结果<br>2.7 使用注释<br>2.8 小结</p>
<h2 id="第3课-排序检索数据"><a href="#第3课-排序检索数据" class="headerlink" title="第3课 排序检索数据"></a>第3课 排序检索数据</h2><p>3.1 排序数据<br>3.2 按多个列排序<br>3.3 按列位置排序<br>3.4 指定排序方向<br>3.5 小结</p>
<h2 id="第4课-过滤数据"><a href="#第4课-过滤数据" class="headerlink" title="第4课 过滤数据"></a>第4课 过滤数据</h2><p>4.1 使用WHERE子句<br>4.2 WHERE子句操作符<br>4.2.1 检查单个值<br>4.2.2 不匹配检查<br>4.2.3 范围值检查<br>4.2.4 空值检查<br>4.3 小结</p>
<h2 id="第5课-高级数据过滤"><a href="#第5课-高级数据过滤" class="headerlink" title="第5课 高级数据过滤"></a>第5课 高级数据过滤</h2><p>5.1 组合WHERE子句<br>5.1.1 AND操作符<br>5.1.2 OR操作符<br>5.1.3 求值顺序<br>5.2 IN操作符<br>5.3 NOT操作符<br>5.4 小结</p>
<h2 id="第6课-用通配符进行过滤"><a href="#第6课-用通配符进行过滤" class="headerlink" title="第6课 用通配符进行过滤"></a>第6课 用通配符进行过滤</h2><p>6.1 LIKE操作符<br>6.1.1 百分号（%）通配符<br>6.1.2 下划线（_）通配符<br>6.1.3 方括号（[ ]）通配符<br>6.2 使用通配符的技巧<br>6.3 小结</p>
<h2 id="第7课-创建计算字段"><a href="#第7课-创建计算字段" class="headerlink" title="第7课 创建计算字段"></a>第7课 创建计算字段</h2><p>7.1 计算字段<br>7.2 拼接字段<br>使用别名<br>7.3 执行算术计算<br>7.4 小结</p>
<h2 id="第8课-使用数据处理函数"><a href="#第8课-使用数据处理函数" class="headerlink" title="第8课 使用数据处理函数"></a>第8课 使用数据处理函数</h2><p>8.1 函数<br>函数带来的问题<br>8.2 使用函数<br>8.2.1 文本处理函数<br>8.2.2 日期和时间处理函数<br>8.2.3 数值处理函数<br>8.3 小结</p>
<h2 id="第9课-汇总数据"><a href="#第9课-汇总数据" class="headerlink" title="第9课 汇总数据"></a>第9课 汇总数据</h2><p>9.1 聚集函数<br>9.1.1 AVG()函数<br>9.1.2 COUNT()函数<br>9.1.3 MAX()函数<br>9.1.4 MIN()函数<br>9.1.5 SUM()函数<br>9.2 聚集不同值<br>9.3 组合聚集函数<br>9.4 小结</p>
<h2 id="第10课-分组数据"><a href="#第10课-分组数据" class="headerlink" title="第10课 分组数据"></a>第10课 分组数据</h2><p>10.1 数据分组<br>10.2 创建分组<br>10.3 过滤分组<br>10.4 分组和排序<br>10.5 SELECT子句顺序<br>10.6 小结</p>
<h2 id="第11课-使用子查询"><a href="#第11课-使用子查询" class="headerlink" title="第11课 使用子查询"></a>第11课 使用子查询</h2><p>11.1 子查询<br>11.2 利用子查询进行过滤<br>11.3 作为计算字段使用子查询<br>11.4 小结</p>
<h2 id="第12课-联结表"><a href="#第12课-联结表" class="headerlink" title="第12课 联结表"></a>第12课 联结表</h2><p>12.1 联结<br>12.1.1 关系表<br>12.1.2 为什么使用联结<br>12.2 创建联结<br>12.2.1 WHERE子句的重要性<br>12.2.2 内联结<br>12.2.3 联结多个表<br>12.3 小结</p>
<h2 id="第13课-创建高级联结"><a href="#第13课-创建高级联结" class="headerlink" title="第13课 创建高级联结"></a>第13课 创建高级联结</h2><p>13.1 使用表别名<br>13.2 使用不同类型的联结<br>13.2.1 自联结<br>13.2.2 自然联结<br>13.2.3 外联结<br>13.3 使用带聚集函数的联结<br>13.4 使用联结和联结条件<br>13.5 小结</p>
<h2 id="第14课-组合查询"><a href="#第14课-组合查询" class="headerlink" title="第14课 组合查询"></a>第14课 组合查询</h2><p>14.1 组合查询<br>14.2 创建组合查询<br>14.2.1 使用UNION<br>14.2.2 UNION规则<br>14.2.3 包含或取消重复的行<br>14.2.4 对组合查询结果排序<br>14.3 小结</p>
<h2 id="第15课-插入数据"><a href="#第15课-插入数据" class="headerlink" title="第15课 插入数据"></a>第15课 插入数据</h2><p>15.1 数据插入<br>15.1.1 插入完整的行<br>15.1.2 插入部分行<br>15.1.3 插入检索出的数据<br>15.2 从一个表复制到另一个表<br>15.3 小结</p>
<h2 id="第16课-更新和删除数据"><a href="#第16课-更新和删除数据" class="headerlink" title="第16课 更新和删除数据"></a>第16课 更新和删除数据</h2><p>16.1 更新数据<br>16.2 删除数据<br>16.3 更新和删除的指导原则<br>16.4 小结</p>
<h2 id="第17课-创建和操纵表"><a href="#第17课-创建和操纵表" class="headerlink" title="第17课 创建和操纵表"></a>第17课 创建和操纵表</h2><p>17.1 创建表<br>17.1.1 表创建基础<br>17.1.2 使用NULL值<br>17.1.3 指定默认值<br>17.2 更新表<br>17.3 删除表<br>17.4 重命名表<br>17.5 小结</p>
<h2 id="第18课-使用视图"><a href="#第18课-使用视图" class="headerlink" title="第18课 使用视图"></a>第18课 使用视图</h2><p>18.1 视图<br>18.1.1 为什么使用视图<br>18.1.2 视图的规则和限制<br>18.2 创建视图<br>18.2.1 利用视图简化复杂的联结<br>18.2.2 用视图重新格式化检索出的数据<br>18.2.3 用视图过滤不想要的数据<br>18.2.4 使用视图与计算字段<br>18.3 小结</p>
<h2 id="第19课-使用存储过程"><a href="#第19课-使用存储过程" class="headerlink" title="第19课 使用存储过程"></a>第19课 使用存储过程</h2><p>19.1 存储过程<br>19.2 为什么要使用存储过程<br>19.3 执行存储过程<br>19.3 执行存储过程<br>19.4 创建存储过程<br>19.5 小结</p>
<h2 id="第20课-管理事务处理"><a href="#第20课-管理事务处理" class="headerlink" title="第20课 管理事务处理"></a>第20课 管理事务处理</h2><p>20.1 事务处理<br>20.2 控制事务处理<br>20.2.1 使用ROLLBACK<br>20.2.2 使用COMMIT<br>20.2.3 使用保留点<br>20.3 小结</p>
<h2 id="第21课-使用游标"><a href="#第21课-使用游标" class="headerlink" title="第21课 使用游标"></a>第21课 使用游标</h2><p>21.1 游标<br>21.2 使用游标<br>21.2.1 创建游标<br>21.2.2 使用游标<br>21.2.3 关闭游标<br>21.3 小结</p>
<h2 id="第22课-高级SQL特性"><a href="#第22课-高级SQL特性" class="headerlink" title="第22课 高级SQL特性"></a>第22课 高级SQL特性</h2><p>22.1 约束<br>22.1.1 主键<br>22.1.2 外键<br>22.1.3 唯一约束<br>22.1.4 检查约束<br>22.2 索引<br>22.3 触发器<br>22.4 数据库安全<br>22.5 小结</p>
<p style="text-align:right">21：06 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统概论</title>
    <url>/pdf/ser/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<!-- 读：2018.6 -->
<p># 第一篇 基础篇</p>
<h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一 绪论"></a>一 绪论</h2><h3 id="1-1-数系统概述"><a href="#1-1-数系统概述" class="headerlink" title="1.1 数系统概述"></a>1.1 数系统概述</h3><p>数的四个基本概念,数系统的特点,数管理技术的产生和发展</p>
<h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><p>两类,概念模型,数据模型的组成要素,常用的数据模型,层次/网状/关系模型</p>
<h3 id="1-3-数系统的结构"><a href="#1-3-数系统的结构" class="headerlink" title="1.3 数系统的结构"></a>1.3 数系统的结构</h3><p>数系统模式的概念,数系统的三级模式结构,</p>
<h3 id="1-4-数系统的组成"><a href="#1-4-数系统的组成" class="headerlink" title="1.4 数系统的组成"></a>1.4 数系统的组成</h3><h2 id="二-关系数据库"><a href="#二-关系数据库" class="headerlink" title="二 关系数据库"></a>二 关系数据库</h2><h3 id="2-1-结构及形式化定义"><a href="#2-1-结构及形式化定义" class="headerlink" title="2.1 结构及形式化定义"></a>2.1 结构及形式化定义</h3><h3 id="2-2-关系操作"><a href="#2-2-关系操作" class="headerlink" title="2.2 关系操作"></a>2.2 关系操作</h3><h3 id="2-3-关系的完整性"><a href="#2-3-关系的完整性" class="headerlink" title="2.3 关系的完整性"></a>2.3 关系的完整性</h3><h3 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a>2.4 关系代数</h3><h3 id="2-5-关系演算"><a href="#2-5-关系演算" class="headerlink" title="*2.5 关系演算"></a>*2.5 关系演算</h3><h2 id="三-关系数据库标准语言SQL"><a href="#三-关系数据库标准语言SQL" class="headerlink" title="三 关系数据库标准语言SQL"></a>三 关系数据库标准语言SQL</h2><h3 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h3><h3 id="3-2-学生-课程数据库"><a href="#3-2-学生-课程数据库" class="headerlink" title="3.2 学生-课程数据库"></a>3.2 学生-课程数据库</h3><h3 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h3><p>，索引的建立与删除，数据字典</p>
<h3 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h3><p>单表、连接、嵌套、集合、基于派生表 的查询，select语句的一般格式</p>
<h3 id="3-5-更新数据库"><a href="#3-5-更新数据库" class="headerlink" title="3.5 更新数据库"></a>3.5 更新数据库</h3><h3 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h3><h3 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h3><h2 id="四-数据库安全性"><a href="#四-数据库安全性" class="headerlink" title="四 数据库安全性"></a>四 数据库安全性</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>不安全因素，安全标准简介</p>
<h3 id="4-2-控制"><a href="#4-2-控制" class="headerlink" title="4.2 控制"></a>4.2 控制</h3><p>用户身份，存取控制，自主存取控制方法，授权，数据库决赛，强制存取控制方法</p>
<h3 id="4-3-视图机制"><a href="#4-3-视图机制" class="headerlink" title="4.3 视图机制"></a>4.3 视图机制</h3><h3 id="4-4-审计"><a href="#4-4-审计" class="headerlink" title="4.4 审计"></a>4.4 审计</h3><h3 id="4-5-数据加密"><a href="#4-5-数据加密" class="headerlink" title="4.5 数据加密"></a>4.5 数据加密</h3><h3 id="4-6-其他安全性保护"><a href="#4-6-其他安全性保护" class="headerlink" title="4.6 其他安全性保护"></a>4.6 其他安全性保护</h3><h2 id="五-数据库完整性"><a href="#五-数据库完整性" class="headerlink" title="五 数据库完整性"></a>五 数据库完整性</h2><h3 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a>5.1 实体完整性</h3><h3 id="5-2-参照完"><a href="#5-2-参照完" class="headerlink" title="5.2 参照完"></a>5.2 参照完</h3><h3 id="5-3-用户定义"><a href="#5-3-用户定义" class="headerlink" title="5.3 用户定义"></a>5.3 用户定义</h3><h3 id="5-4-完整性的约束命名子句"><a href="#5-4-完整性的约束命名子句" class="headerlink" title="5.4 完整性的约束命名子句"></a>5.4 完整性的约束命名子句</h3><h3 id="5-5-域中的完整性限制"><a href="#5-5-域中的完整性限制" class="headerlink" title="*5.5 域中的完整性限制"></a>*5.5 域中的完整性限制</h3><h3 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a>5.6 断言</h3><h3 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a>5.7 触发器</h3><p># 第二篇 设计与应用开发篇</p>
<h2 id="六-关系数据理论"><a href="#六-关系数据理论" class="headerlink" title="六 关系数据理论"></a>六 关系数据理论</h2><h3 id="6-1-问题的提出"><a href="#6-1-问题的提出" class="headerlink" title="6.1 问题的提出"></a>6.1 问题的提出</h3><h3 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h3><h3 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h3><h3 id="6-4-模式的分解"><a href="#6-4-模式的分解" class="headerlink" title="*6.4 模式的分解"></a>*6.4 模式的分解</h3><h2 id="七-数据库设计"><a href="#七-数据库设计" class="headerlink" title="七 数据库设计"></a>七 数据库设计</h2><h3 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h3><p>特点，方法，基本步骤，各级模式</p>
<h3 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h3><p>任务，方法，数据字典</p>
<h3 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h3><p>概念模型，E-R模型，。。</p>
<h3 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h3><h3 id="7-5-物理结构设计"><a href="#7-5-物理结构设计" class="headerlink" title="7.5 物理结构设计"></a>7.5 物理结构设计</h3><h3 id="7-6-数据库的实施和维护"><a href="#7-6-数据库的实施和维护" class="headerlink" title="7.6 数据库的实施和维护"></a>7.6 数据库的实施和维护</h3><h2 id="八-数据库编程"><a href="#八-数据库编程" class="headerlink" title="八 数据库编程"></a>八 数据库编程</h2><h3 id="8-1-嵌入式SQL"><a href="#8-1-嵌入式SQL" class="headerlink" title="8.1 嵌入式SQL"></a>8.1 嵌入式SQL</h3><h3 id="8-2-过程化SQL"><a href="#8-2-过程化SQL" class="headerlink" title="8.2 过程化SQL"></a>8.2 过程化SQL</h3><h3 id="8-3-存储过程和函数"><a href="#8-3-存储过程和函数" class="headerlink" title="8.3 存储过程和函数"></a>8.3 存储过程和函数</h3><h3 id="8-4-ODBC编程"><a href="#8-4-ODBC编程" class="headerlink" title="8.4 ODBC编程"></a>8.4 ODBC编程</h3><h3 id="8-5-OLE-DB"><a href="#8-5-OLE-DB" class="headerlink" title="*8.5 OLE DB"></a>*8.5 OLE DB</h3><h3 id="8-6-JDBC编程"><a href="#8-6-JDBC编程" class="headerlink" title="*8.6 JDBC编程"></a>*8.6 JDBC编程</h3><p># 第三篇 系统篇</p>
<h2 id="九-关系查询处理和查询优化"><a href="#九-关系查询处理和查询优化" class="headerlink" title="九 关系查询处理和查询优化"></a>九 关系查询处理和查询优化</h2><h3 id="9-1-关系数据库系统的查询处理"><a href="#9-1-关系数据库系统的查询处理" class="headerlink" title="9.1 关系数据库系统的查询处理"></a>9.1 关系数据库系统的查询处理</h3><h3 id="9-2-关系数据库系统的查询优化"><a href="#9-2-关系数据库系统的查询优化" class="headerlink" title="9.2 关系数据库系统的查询优化"></a>9.2 关系数据库系统的查询优化</h3><h3 id="9-3-代数优化"><a href="#9-3-代数优化" class="headerlink" title="9.3 代数优化"></a>9.3 代数优化</h3><h3 id="9-4-物理优化"><a href="#9-4-物理优化" class="headerlink" title="9.4 物理优化"></a>9.4 物理优化</h3><h3 id="9-5-查询计划的执行"><a href="#9-5-查询计划的执行" class="headerlink" title="*9.5 查询计划的执行"></a>*9.5 查询计划的执行</h3><h2 id="零-数据库恢复技术"><a href="#零-数据库恢复技术" class="headerlink" title="零 数据库恢复技术"></a>零 数据库恢复技术</h2><h3 id="0-1-事务的基本概念"><a href="#0-1-事务的基本概念" class="headerlink" title="0.1 事务的基本概念"></a>0.1 事务的基本概念</h3><h3 id="0-2-数据库恢复概述"><a href="#0-2-数据库恢复概述" class="headerlink" title="0.2 数据库恢复概述"></a>0.2 数据库恢复概述</h3><h3 id="0-3-故障的种类"><a href="#0-3-故障的种类" class="headerlink" title="0.3 故障的种类"></a>0.3 故障的种类</h3><h3 id="0-4-恢复的实现技术"><a href="#0-4-恢复的实现技术" class="headerlink" title="0.4 恢复的实现技术"></a>0.4 恢复的实现技术</h3><p>数据传输，登记日志文件</p>
<h3 id="0-5-恢复策略"><a href="#0-5-恢复策略" class="headerlink" title="0.5 恢复策略"></a>0.5 恢复策略</h3><p>事务故障，系统故障，介质故障</p>
<h3 id="0-6-具有检查点的恢复技术"><a href="#0-6-具有检查点的恢复技术" class="headerlink" title="0.6 具有检查点的恢复技术"></a>0.6 具有检查点的恢复技术</h3><h3 id="0-7-数据库镜像"><a href="#0-7-数据库镜像" class="headerlink" title="0.7 数据库镜像"></a>0.7 数据库镜像</h3><h2 id="一-并发控制"><a href="#一-并发控制" class="headerlink" title="一 并发控制"></a>一 并发控制</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><h3 id="1-2-封锁"><a href="#1-2-封锁" class="headerlink" title="1.2 封锁"></a>1.2 封锁</h3><h3 id="1-3-封锁协议"><a href="#1-3-封锁协议" class="headerlink" title="1.3 封锁协议"></a>1.3 封锁协议</h3><h3 id="1-4-活锁和死锁"><a href="#1-4-活锁和死锁" class="headerlink" title="1.4 活锁和死锁"></a>1.4 活锁和死锁</h3><h3 id="1-5-并发调度的可串行性"><a href="#1-5-并发调度的可串行性" class="headerlink" title="1.5 并发调度的可串行性"></a>1.5 并发调度的可串行性</h3><h3 id="1-6-两段锁协议"><a href="#1-6-两段锁协议" class="headerlink" title="1.6 两段锁协议"></a>1.6 两段锁协议</h3><h3 id="1-7-封锁的粒度"><a href="#1-7-封锁的粒度" class="headerlink" title="1.7 封锁的粒度"></a>1.7 封锁的粒度</h3><h3 id="1-8-其他并发控制机制"><a href="#1-8-其他并发控制机制" class="headerlink" title="*1.8 其他并发控制机制"></a>*1.8 其他并发控制机制</h3><p>多版本，改进的多版本 </p>
<h2 id="二-数据库管理系统"><a href="#二-数据库管理系统" class="headerlink" title="二 数据库管理系统"></a>二 数据库管理系统</h2><h3 id="2-1-数据库管理系统的基本功能"><a href="#2-1-数据库管理系统的基本功能" class="headerlink" title="2.1 数据库管理系统的基本功能"></a>2.1 数据库管理系统的基本功能</h3><h3 id="2-2-系统结构"><a href="#2-2-系统结构" class="headerlink" title="2.2 系统结构"></a>2.2 系统结构</h3><p>层次结构，运行过程示例</p>
<h3 id="2-3-语言处理"><a href="#2-3-语言处理" class="headerlink" title="2.3 语言处理"></a>2.3 语言处理</h3><p>任务和工作步骤，解释方法，预编译</p>
<h3 id="2-4-数据存取层"><a href="#2-4-数据存取层" class="headerlink" title="2.4 数据存取层"></a>2.4 数据存取层</h3><p>系统结构，功能子系统</p>
<h3 id="2-5-缓冲区管理"><a href="#2-5-缓冲区管理" class="headerlink" title="2.5 缓冲区管理"></a>2.5 缓冲区管理</h3><h3 id="2-6-数据库物理组织"><a href="#2-6-数据库物理组织" class="headerlink" title="2.6 数据库物理组织"></a>2.6 数据库物理组织</h3><p>#  第四篇 新技术篇</p>
<h2 id="三-数据库技术发展概述"><a href="#三-数据库技术发展概述" class="headerlink" title="三 数据库技术发展概述"></a>三 数据库技术发展概述</h2><h3 id="3-1-数据库技术发展历史回顾"><a href="#3-1-数据库技术发展历史回顾" class="headerlink" title="3.1 数据库技术发展历史回顾"></a>3.1 数据库技术发展历史回顾</h3><h3 id="3-2-数据库发展的三个阶段"><a href="#3-2-数据库发展的三个阶段" class="headerlink" title="3.2 数据库发展的三个阶段"></a>3.2 数据库发展的三个阶段</h3><p>第一代，第二代，新一代</p>
<h3 id="3-3-数据库系统发展的特点"><a href="#3-3-数据库系统发展的特点" class="headerlink" title="3.3 数据库系统发展的特点"></a>3.3 数据库系统发展的特点</h3><h3 id="3-4-数据管理技术的发展趋势"><a href="#3-4-数据管理技术的发展趋势" class="headerlink" title="3.4 数据管理技术的发展趋势"></a>3.4 数据管理技术的发展趋势</h3><h2 id="四-大数据管理"><a href="#四-大数据管理" class="headerlink" title="四 大数据管理"></a>四 大数据管理</h2><h3 id="4-1-大数据概述"><a href="#4-1-大数据概述" class="headerlink" title="4.1 大数据概述"></a>4.1 大数据概述</h3><h3 id="4-2-大数据的应用"><a href="#4-2-大数据的应用" class="headerlink" title="4.2 大数据的应用"></a>4.2 大数据的应用</h3><p>感知现在 预测未来-互联网文本大数据管理与挖掘<br>数据服务 实时推荐-基于大数据分析的用户建模</p>
<h3 id="4-3-大数据管理系统"><a href="#4-3-大数据管理系统" class="headerlink" title="4.3 大数据管理系统"></a>4.3 大数据管理系统</h3><p>NoSQL，NewSQL，MapReduce</p>
<h2 id="五-内存数据库系统"><a href="#五-内存数据库系统" class="headerlink" title="五 内存数据库系统"></a>五 内存数据库系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><h3 id="5-2-发展历史"><a href="#5-2-发展历史" class="headerlink" title="5.2 发展历史"></a>5.2 发展历史</h3><h3 id="5-3-特性"><a href="#5-3-特性" class="headerlink" title="5.3 特性"></a>5.3 特性</h3><h3 id="5-4-关键技术"><a href="#5-4-关键技术" class="headerlink" title="5.4 关键技术"></a>5.4 关键技术</h3><p>数据存储，查询处理及优化，并发与恢复</p>
<h2 id="六-数据仓库与联机分析处理技术"><a href="#六-数据仓库与联机分析处理技术" class="headerlink" title="六 数据仓库与联机分析处理技术"></a>六 数据仓库与联机分析处理技术</h2><h3 id="6-1-数据仓库计算"><a href="#6-1-数据仓库计算" class="headerlink" title="6.1 数据仓库计算"></a>6.1 数据仓库计算</h3><h3 id="6-2-联机分析处理技术"><a href="#6-2-联机分析处理技术" class="headerlink" title="6.2 联机分析处理技术"></a>6.2 联机分析处理技术</h3><h3 id="6-3-数据挖掘技术"><a href="#6-3-数据挖掘技术" class="headerlink" title="6.3 数据挖掘技术"></a>6.3 数据挖掘技术</h3><h3 id="6-4-大数据时代的新型数据仓库"><a href="#6-4-大数据时代的新型数据仓库" class="headerlink" title="6.4 大数据时代的新型数据仓库"></a>6.4 大数据时代的新型数据仓库</h3><p style="text-align:right">21：59</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>Js模块规范</title>
    <url>/sum/jsplus/js%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83(014)/</url>
    <content><![CDATA[<p style="text-align:right">2019.5.31 星期五</p>

<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>下面一堆东西都作废。<br>jQuery3.4的封装方式可以到处使用。和 UMD 的语法糖稍微有一点差别。$PS: 咱也不敢问   </p>
<p>CMD是中文开发者（玉伯？），可以直接去sea.js 了解到 js 模块的历史。<br>AMD是英文。中文教程也有一堆   </p>
<p><strong>一堆东西，就不赘述了</strong><br>5分钟上手，原因/特性等也是明明白白。实现没有去了解     </p>
<p>Sea.js: <a href="https://seajs.github.io/seajs/" target="_blank" rel="noopener">https://seajs.github.io/seajs/</a><br>    <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">https://github.com/seajs/seajs</a>      </p>
<p>require.js:<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">https://github.com/requirejs/requirejs</a><br>    <a href="https://requirejs.org/" target="_blank" rel="noopener">https://requirejs.org/</a>      </p>
<p>browserify: <a href="https://github.com/browserify/browserify" target="_blank" rel="noopener">https://github.com/browserify/browserify</a><br>    <a href="http://browserify.org/" target="_blank" rel="noopener">http://browserify.org/</a>      </p>
<p>$PS: seajs, requirejs 都有打包方案。browserify的打包稍微有一些区别（把node包打包浏览器可以用），合并/压缩文件等没有细看；      </p>
<p># <a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener">前端模块化开发那点历史</a>      </p>
<blockquote>
<p>写在前面<br>不谈什么：传统的模块化开发方式，比如文件拆分、全局变量、命名空间，以及 YUI3 式的模块化开发方式。有兴趣的可阅读：#547<br>谈什么： 关于 CommonJS、AMD、Node.js、CMD 等相关的故事与未来趋势，很有意思。<br>不一定精准：本文是基于史实的扯淡，因此部分文字特别是时间都是模糊记忆，不一定精准。关于流派、趋势则是个人在社区的感受，不代表客观看法。（看法都是主观&gt; 的，呵呵）  </p>
</blockquote>
<p># <a href="https://seajs.github.io/seajs/docs/#docs" target="_blank" rel="noopener">Sea.js 使用文档</a><br>## 探讨<br>前端模块化开发那点历史<br>从 CommonJS 到 Sea.js<br>与 Node.js 兼容<br>与 RequireJS 的异同<br>与 OzJS 的探讨      </p>
<h1 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h1><p># <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a>      </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。    </p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。  </p>
<p>$PS: 静态加载(非运行加载)，所以又很多限制。但是有 import() 函数了        </p>
<p># <a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现</a>   </p>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>defer与async的区别是：<br>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<br>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。<br>一句话，defer是“渲染完再执行”，async是“下载完就执行”。<br>另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。  </p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入type=”module”属性。</p>
<p>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。    </p>
<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。  $PS: async并不会顺序执行<br><code>&lt;script&gt;</code>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。<br>一旦使用了async属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>
<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p>它们有两个重大差异。    </p>
<p>(1) CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。<br>(2) CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。   </p>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。<br>而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p>
<h3 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h3><p>概述<br>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。<br>目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。  </p>
<p>………</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">&lt;p style=&quot;text-align:right&quot;&gt;2018.6.22 星期五&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\# [Node中没搞明白require和import，你会被坑的很惨](http://imweb.io/topic/582293894067ce9726778be9)</span><br><span class="line">ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口�??</span><br><span class="line"></span><br><span class="line">不把require和import整清楚，会在未来的标准编程中死的很难看�?</span><br><span class="line"></span><br><span class="line">## require时代的模�??</span><br><span class="line">node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样�??</span><br><span class="line"></span><br><span class="line">node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD，虽各有不同，但总之还是希望保持较为统一的代码风格�?</span><br><span class="line">```javascript</span><br><span class="line">// a.js</span><br><span class="line">// -------- node -----------</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  a : function() &#123;&#125;,</span><br><span class="line">  b : &apos;xxx&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ----------- AMD or CMD ----------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    a : function() &#123;&#125;,</span><br><span class="line">    b : &apos;xxx&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line">可以看出，为了保持风格的高度统一，除了在浏览器端的模块中要使用一个define函数来提供模块的闭包以外，其他代码可以完全一致�?</span><br><span class="line">```</span><br><span class="line">// b.js</span><br><span class="line"></span><br><span class="line">// ------------ node ---------</span><br><span class="line">var m = require(&apos;./a&apos;);</span><br><span class="line">m.a();</span><br><span class="line"></span><br><span class="line">// ------------ AMD or CMD -------------</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">   var m = require(&apos;./a&apos;);</span><br><span class="line">   m.a();</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line">在使用上，也非常相似。虽然AMD or CMD提供了更加丰富的风格，但是我们本文主要是讨论node环境下，所以不做扩展�?</span><br><span class="line"></span><br><span class="line">\## ES6中的module</span><br><span class="line">## 该用require还是import�??</span><br><span class="line">require的使用非常简单，它相当于module.exports的传送门，module.exports后面的内容是什么，require的结果就是什么，对象、数字、字符串、函数……再把require的结果赋值给某个变量，相当于把require和module.exports进行平行空间的位置重叠�?</span><br><span class="line"></span><br><span class="line">而且require理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用，比如�??</span><br><span class="line">```javascript</span><br><span class="line">require(&apos;./a&apos;)(); // a模块是一个函数，立即执行a模块函数</span><br><span class="line">var data = require(&apos;./a&apos;).data; // a模块导出的是一个对�??</span><br><span class="line">var a = require(&apos;./a&apos;)[0]; // a模块导出的是一个数�??</span><br><span class="line">```</span><br><span class="line">你在使用时，完全可以忽略模块化这个概念来使用require，仅仅把它当做一个node内置的全局函数，它的参数甚至可以是表达式：</span><br><span class="line">```javascript</span><br><span class="line">require(process.cwd() + &apos;/a&apos;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">但是import则不同，它是编译时的（require是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多�?</span><br><span class="line">从理解上，require是赋值过程，import是解构过程，当然，require也可以将结果解构赋值给一组变量，但是import在遇到default时，和require则完全不同：var $ = require(&apos;jquery&apos;);和import $ from &apos;jquery&apos;是完全不同的两种概念�??</span><br><span class="line"></span><br><span class="line">上面完全没有回答“改用require还是import？”这个问题，因为这个问题就目前而言，根本没法回答，因为目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require。这也是为什么在模块导出时使用module.exports，在引入模块时使用import仍然起效，因为本质上，import会被转码为require去执行�?</span><br><span class="line"></span><br><span class="line">但是，我们要知道这样一个道理，ES7很快也会发布，js引擎们会尽快实现ES6标准的规定，如果一个引擎连标准都实现不了，就会被淘汰，ES6是迟早的事。如果你现在仍然在代码中部署require，那么等到ES6被引擎支持时，你必须升级你的代码，而如果现在开始部署import，那么未来可能只需要做很少的改动。（完）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\# [JS模块规范：AMD、UMD、CMD、commonJS、ES6 module]</span><br><span class="line">##  commonJS</span><br><span class="line">1、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存�?</span><br><span class="line">2、模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载�?</span><br><span class="line"></span><br><span class="line">环境：服务器环境</span><br><span class="line">应用：nodejs的模块规范是参照commonJS实现的�?</span><br><span class="line"></span><br><span class="line">1、导入：require(&apos;路径&apos;)   </span><br><span class="line">2、导出：module.exports和exports   </span><br><span class="line">注意：module.exports和exports的的区别是exports只是对module.exports的一个引用，相当于Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行var exports = module.exports;这样的命令�?</span><br><span class="line">demo</span><br><span class="line"></span><br><span class="line">## AMD</span><br><span class="line">1、异步加�??   </span><br><span class="line">2、管理模块之间的依赖性，便于代码的编写和维护�??   </span><br><span class="line"></span><br><span class="line">环境：浏览器环境</span><br><span class="line">应用：requireJS是参照AMD规范实现�??</span><br><span class="line"></span><br><span class="line">1、导入：require([&apos;模块名称&apos;], function (&apos;模块变量引用&apos;)&#123;// 代码&#125;);   </span><br><span class="line">3、导出：define(function ()&#123;return &apos;�??&apos;);</span><br><span class="line"></span><br><span class="line">## CMD</span><br><span class="line">1、CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖�?</span><br><span class="line"></span><br><span class="line">环境：浏览器环境</span><br><span class="line">应用：seajs是参照UMD规范实现的，requireJS的最新的几个版本也是部分参照了UMD规范的实�??</span><br><span class="line"></span><br><span class="line">1、导入：define(function(require, exports, module) &#123;&#125;);   </span><br><span class="line">2、导出：define(function ()&#123;return &apos;�??&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## UMD</span><br><span class="line">1、兼容AMD和commonJS规范的同时，还兼容全局引用的方�??</span><br><span class="line"></span><br><span class="line">环境：浏览器或服务器环境</span><br><span class="line">应用：无</span><br><span class="line"></span><br><span class="line">1、无导入导出规范，只有如下的一个常规写法：</span><br><span class="line"></span><br><span class="line">## ES6 module</span><br><span class="line">1、按需加载（编译时加载�??  </span><br><span class="line">2、import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加�??</span><br><span class="line"></span><br><span class="line">环境：浏览器或服务器环境（以后可能支持）   </span><br><span class="line">应用：ES6的最新语法支持规�??</span><br><span class="line"></span><br><span class="line">1、导入：import &#123;模块名A，模块名B...&#125; from &apos;模块路径&apos;    </span><br><span class="line">2、导出：export和export default    </span><br><span class="line">3、import(&apos;模块路径&apos;).then()方法    </span><br><span class="line">注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法�??</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\# [关于AMD,CMD,CommonJS及UMD规范](https://www.tuicool.com/articles/nueqi27)</span><br><span class="line">## AMD规范</span><br><span class="line">AMD规范，全称”Asynchronous Module Definition”，称为 异步模块加载规范 。</span><br><span class="line">一般应用在浏览器端。</span><br><span class="line">流行的浏览器端异步加载库 RequireJS （ 中文网站 ）实现的就是AMD规范。</span><br><span class="line"></span><br><span class="line">AMD讲究的是前置执行。</span><br><span class="line">```javascript</span><br><span class="line">//    filename: foo.js</span><br><span class="line">define([&apos;jquery&apos;, &apos;underscore&apos;], function ($, _) &#123;</span><br><span class="line">    //    methods</span><br><span class="line">    function a()&#123;&#125;;    //    private because it&apos;s not returned (see below)</span><br><span class="line">    function b()&#123;&#125;;    //    public because it&apos;s returned</span><br><span class="line">    function c()&#123;&#125;;    //    public because it&apos;s returned</span><br><span class="line"></span><br><span class="line">    //    exposed public methods</span><br><span class="line">    return &#123;</span><br><span class="line">        b: b,</span><br><span class="line">        c: c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line">define 是AMD规范用来声明模块的接口，</span><br><span class="line">示例中的第一个参数是一个数组，表示当前模块的依赖。第二个参数是一个回调函数，表示此模块的执行体。</span><br><span class="line">只有当依赖数组中的所有依赖模块都是可用的时，AMD模块加载器（比如RequireJS）才会去执行回调函数并返回此模块的暴露接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## CMD规范</span><br><span class="line">CMD规范，全称”Common Module Definition”，称为 通用模块加载规范 。$PS: 普通模块加载规范</span><br><span class="line">一般也是用在浏览器端。</span><br><span class="line">浏览器端异步加载库 Sea.js 实现的就是CMD规范。</span><br><span class="line">```javascript</span><br><span class="line">define(function (require, exports, module) &#123;</span><br><span class="line">    // load dependence</span><br><span class="line">    var $ = require(&apos;jquery&apos;);</span><br><span class="line">    </span><br><span class="line">    //    methods</span><br><span class="line">    function myFunc()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //    exposed public methods</span><br><span class="line">    return myFunc;</span><br><span class="line">&#125;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">CMD规范倾向依赖就近 ，稍微复杂一点例子  </span><br><span class="line">```javascript</span><br><span class="line">define(function (requie, exports, module) &#123;</span><br><span class="line">    // 依赖可以就近书写</span><br><span class="line">    var a = require(&apos;./a&apos;);</span><br><span class="line">    a.test();</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">     // 软依赖</span><br><span class="line">    if (status) &#123;</span><br><span class="line">        var b = requie(&apos;./b&apos;);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## CommonJS规范</span><br><span class="line">根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</span><br><span class="line"></span><br><span class="line">CommonJS规范一般应用于服务端（Node.js平台），而且CommonJS加载模块采用的是同步方式（这跟他适用的场景有关系）。</span><br><span class="line"></span><br><span class="line">同时，得力于 Browserify 这样的第三方工具，我们可以在浏览器端使用采用CommonJS规范的js文件。</span><br><span class="line">```javascript</span><br><span class="line">//    filename: foo.js</span><br><span class="line">var $ = require(&apos;jquery&apos;);</span><br><span class="line">var _ = require(&apos;underscore&apos;);</span><br><span class="line"></span><br><span class="line">//    methods</span><br><span class="line">function a()&#123;&#125;;    //    private because it&apos;s omitted from module.exports (see below)</span><br><span class="line">function b()&#123;&#125;;    //    public because it&apos;s defined in module.exports</span><br><span class="line">function c()&#123;&#125;;    //    public because it&apos;s defined in module.exports</span><br><span class="line"></span><br><span class="line">//    exposed public methods</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    b: b,</span><br><span class="line">    c: c</span><br><span class="line">&#125;;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## UMD规范</span><br><span class="line">因为AMD，CommonJS规范是两种不一致的规范，虽然他们应用的场景也不太一致，但是人们仍然是期望有一种统一的规范来支持这两种规范。于是，UMD（Universal Module Definition，称之为 通用模块规范 ）规范诞生了。</span><br><span class="line"></span><br><span class="line">客观来说，这个UMD规范看起来的确没有AMD和CommonJS规范简约。但是它支持AMD和CommonJS规范，同时还支持古老的全局模块模式。</span><br><span class="line">```javascript</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">        // AMD</span><br><span class="line">        define([&apos;jquery&apos;], factory); // $_PS: factory 依赖jquery</span><br><span class="line">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">        // Node, CommonJS-like</span><br><span class="line">        module.exports = factory(require(&apos;jquery&apos;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Browser globals (root is window)</span><br><span class="line">        root.returnExports = factory(root.jQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(this, function ($) &#123;</span><br><span class="line">    //    methods</span><br><span class="line">    function myFunc()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //    exposed public method</span><br><span class="line">    return myFunc;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">// $PS: 上面是有依赖的（jquery）。如果没有依赖应该是下文</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(&apos;myFunc&apos;, factory); </span><br><span class="line">        // define(&apos;myFunc&apos;,[], factory); // 中间的依赖可以省略</span><br><span class="line">		// define([&quot;alpha&quot;], function (alpha) &#123;&#125;) // 匿名模块。 define还可以只有一个参数define(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.myFunc = factory(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(typeof window !== &quot;undefined&quot; ? window : this, function (root) &#123;</span><br><span class="line">    //    methods</span><br><span class="line">    function myFunc()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //    exposed public method</span><br><span class="line">    return myFunc;</span><br><span class="line">&#125;));</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">个人觉得UMD规范更像一个语法糖。应用UMD规范的js文件其实就是一个立即执行函数。函数有两个参数，第一个参数是当前运行时环境，第二个参数是模块的定义体。在执行UMD规范时，会优先判断是当前环境是否支持AMD环境，然后再检验是否支持CommonJS环境，否则认为当前环境为浏览器环境（ window ）。当然具体的判断顺序其实是可以调换的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\# [什么是前端模块规范AMD，CMD，CommonJS和UMD？](https://www.jianshu.com/p/00ee4e45c0cd)  </span><br><span class="line">这是webpack下babel的配置文�??.babelrc�??</span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;es2015&quot;:&#123;</span><br><span class="line">                &quot;modules&quot;:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;:[]</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">使ES6模块语法转换到另一个模块类�??(默认启用“commonjs”)�?? 设置为假则不变换模块。或者传�??(“amd”、“umd”,“systemjs”、“commonjs”).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其它：    </span><br><span class="line">[关于 CommonJS AMD CMD UMD 规范的差异总结](http://www.cnblogs.com/imwtr/p/4666181.html)     </span><br><span class="line">[编码规范：模块和加载器](http://codespec.lookapi.org/#/module?id=moduleid)</span><br></pre></td></tr></table></figure>
<p><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del><del>~</del>~~</p>
<h1 id="jQuery的封装方式"><a href="#jQuery的封装方式" class="headerlink" title="jQuery的封装方式"></a>jQuery的封装方式</h1><p style="text-align:right">2019.5.30 星期四</p>

<p>封装pagination。借鉴了jquery-3.4<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cc from jquery: &lt;https://code.jquery.com/jquery-3.4.1.js&gt;</span></span><br><span class="line">;( <span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// For CommonJS and CommonJS-like environments where a proper `window`</span></span><br><span class="line">		<span class="comment">// is present, execute the factory and get jQuery.</span></span><br><span class="line">		<span class="comment">// For environments that do not have a `window` with a `document`</span></span><br><span class="line">		<span class="comment">// (such as Node.js), expose a factory as module.exports.</span></span><br><span class="line">		<span class="comment">// This accentuates the need for the creation of a real `window`.</span></span><br><span class="line">		<span class="comment">// e.g. var jQuery = require("jquery")(window);</span></span><br><span class="line">        <span class="comment">// See ticket #14549 for more info.</span></span><br><span class="line">        </span><br><span class="line">		<span class="built_in">module</span>.exports = global.document ?</span><br><span class="line">			factory( global, <span class="literal">true</span> ) :</span><br><span class="line">			<span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> ( !w.document ) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"CoPagination requires a window with a document"</span> );</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> factory( w );</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		factory( global );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass this if window is not defined yet</span></span><br><span class="line">&#125; )( <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>param0.hideOnSinglePage - 只有一页时是否隐藏. $_NEXT</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>param0.pagerCount - 显示页码按钮的数量，当总页数超过该值时会折叠。大于等�?? 5 且小于等�?? 21 的奇�??  $PS: 不知道为啥小�??21</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>param0.layout - 要展示的内容。limits, prev, pager, next, jumper,  total,count </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CoPagination</span>(<span class="params">&#123;ele=<span class="string">'.co-pagination'</span>,hideOnSinglePage=false,curr=<span class="number">1</span>,count=<span class="number">1</span>,limit=<span class="number">10</span>,limits=[<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>],pagerCount=<span class="number">7</span>,prevText=<span class="string">'&lt;'</span>,nextText=<span class="string">'&gt;'</span>,layout=[<span class="string">'limits'</span>,<span class="string">'prev'</span>,<span class="string">'pager'</span>,<span class="string">'next'</span>,<span class="string">'jumper'</span>]&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dom=<span class="built_in">document</span>.querySelectorAll(ele)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>.curr=curr</span><br><span class="line">        </span><br><span class="line">        pagerCount%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(pagerCount+=<span class="number">1</span>)</span><br><span class="line">        pagerCount&lt;<span class="number">7</span>&amp;&amp;(pagerCount=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.count=count</span><br><span class="line">        <span class="keyword">this</span>.limit=limit</span><br><span class="line">        <span class="keyword">this</span>.limits=limits</span><br><span class="line">        <span class="keyword">this</span>.pagerCount=pagerCount</span><br><span class="line">        <span class="keyword">this</span>.prevText=prevText</span><br><span class="line">        <span class="keyword">this</span>.nextText=nextText</span><br><span class="line">        <span class="keyword">this</span>.layout=layout</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.init()</span><br><span class="line">    &#125;</span><br><span class="line">    CoPagination.prototype=&#123;</span><br><span class="line">        <span class="keyword">constructor</span>:CoPagination,</span><br><span class="line">        init:function()&#123;</span><br><span class="line">            <span class="keyword">this</span>.renderHtml()</span><br><span class="line">        &#125;,</span><br><span class="line">        renderHtml()&#123;&#125;,</span><br><span class="line">        renderPagerHtml(curr)&#123;&#125;,</span><br><span class="line">        changeCurr(curr)&#123;&#125;,</span><br><span class="line">        changeLimit(limit)&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register as a named AMD module, since jQuery can be concatenated with other</span></span><br><span class="line"><span class="comment">// files that may use define, but not via a proper concatenation script that</span></span><br><span class="line"><span class="comment">// understands anonymous AMD modules. A named AMD is safest and most robust</span></span><br><span class="line"><span class="comment">// way to register. Lowercase jquery is used because AMD module names are</span></span><br><span class="line"><span class="comment">// derived from file names, and jQuery is normally delivered in a lowercase</span></span><br><span class="line"><span class="comment">// file name. Do this after creating the global so that if an AMD module wants</span></span><br><span class="line"><span class="comment">// to call noConflict to hide this version of jQuery, it will work.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that for maximum portability, libraries that are not jQuery should</span></span><br><span class="line"><span class="comment">// declare themselves as anonymous modules, and avoid setting a global if an</span></span><br><span class="line"><span class="comment">// AMD loader is present. jQuery is a special case. For more information, see</span></span><br><span class="line"><span class="comment">// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $PS: 和上面定义的 UMD 语法糖 稍微有些区别</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">	define( <span class="string">"copagination"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> CoPagination;</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose jQuery and $ identifiers, even in AMD</span></span><br><span class="line"><span class="comment">// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span></span><br><span class="line"><span class="comment">// and CommonJS for browser emulators (#13566)</span></span><br><span class="line"><span class="keyword">if</span> ( !noGlobal ) &#123;</span><br><span class="line">	<span class="comment">// window.jQuery = window.$ = jQuery;</span></span><br><span class="line">	<span class="built_in">window</span>.CoPagination = CoPagination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CoPagination;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ES6 </span></span><br><span class="line"><span class="comment">class CoPagination&#123;</span></span><br><span class="line"><span class="comment">    constructor(&#123;dom=''&#125;=&#123;&#125;)&#123;</span></span><br><span class="line"><span class="comment">        this.dom=dom</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    _pagerHtml=''</span></span><br><span class="line"><span class="comment">    init()&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>Css使用记录</title>
    <url>/sum/css/css%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="二期"><a href="#二期" class="headerlink" title="二期"></a>二期</h2><ol>
<li><a href="https://blog.csdn.net/yb305/article/details/72357010" target="_blank" rel="noopener">父容器display:flex后，子元素的内部元素height:100%无效解决方法</a><br>解救办法：父类容器position:relative;子元素：position:absolute;width:100%,height:100%;</li>
<li>display：flex 的直接子元素，高度默认是100%； 如果设置 改元素<code>align-self:center</code>,元素就会变为行内块，高度就不是100%，可以设置垂直居中    </li>
<li>display:flex 下的子元素，比如div的宽度会撑开父元素宽度，出现横向滚动条；此时可以给改元素添加 <code>heigth:0%</code> 消除影响</li>
<li>iconfont transform 失效，需要改为inline-block/block<blockquote>
<p>transform适用于：所有块级元素及某些内联元素<br> <a href="https://blog.csdn.net/promiseCao/article/details/82757251" target="_blank" rel="noopener">transform失效了？iconfont字体图标无法旋转，无法缩放？的解决办法</a></p>
</blockquote>
</li>
<li><p>【CSS】文字旋转90度<br> <a href="https://blog.csdn.net/weixin_41728561/article/details/84373347" target="_blank" rel="noopener">【CSS】文字旋转90度</a>   </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 方法一**/</span><br><span class="line">.xuanzhuan &#123;</span><br><span class="line">    -moz-transform: rotate(90deg);</span><br><span class="line">    -webkit-transform: rotate(90deg);  </span><br><span class="line">    display: block;</span><br><span class="line">    position: absolute;</span><br><span class="line">    filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=3)</span><br><span class="line">    text-transform: uppercase;</span><br><span class="line">&#125;</span><br><span class="line">/* 方法二**/</span><br><span class="line">writing-mode: vertical-rl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网页强制横屏。或者js实现方式<code>document.documentElement.requestFullscreen();screen.orientation.lock(&quot;portrait-primary&quot;);</code><br><a href="http://www.cnblogs.com/blfshiye/p/4937293.html" target="_blank" rel="noopener">[HTML5: Screen Orientation API]</a><br><a href="http://www.php.cn/css-tutorial-360008.html" target="_blank" rel="noopener">[页面强制横屏]</a>    </p>
<p><a href="https://www.jb51.net/css/663929.html" target="_blank" rel="noopener">[Css实现手机端页面强制横屏的方法示例]</a>      </p>
<blockquote>
<p>P.S. 如果你的页面里有from表单要填的话，应该用 「弹出遮罩层让用户旋转手机」 的解决方案。检测手机竖屏下，提示用关闭屏幕旋转锁定，并横置手机。想想手机浏览器还是竖屏，而内容却被强制横屏的画面有多奇怪吧…</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-- css单位：vmin/vmax, vh/vw --*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmin</span>; </span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmax</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmin</span>;</span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmax</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#gyroContain</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmax</span>;</span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmin</span>;</span><br><span class="line">        <span class="attribute">transform-origin</span>: top left;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>) <span class="built_in">translate</span>(<span class="number">0</span>,-<span class="number">100vmin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">    <span class="selector-tag">html</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmax</span>;</span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmax</span>;</span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-id">#gyroContain</span>&#123;</span><br><span class="line">        <span class="attribute">width </span>: <span class="number">100vmax</span>;</span><br><span class="line">        <span class="attribute">height </span>: <span class="number">100vmin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p> $PS: 当时是解决ppt在线浏览横屏，结果office文档在线浏览url跳转了，跳出当前页面了。反而使loading横屏了    </p>
<h2 id="一期"><a href="#一期" class="headerlink" title="一期"></a>一期</h2></li>
<li>css是区分大小的，而html不区分大小写  </li>
<li>icon-font 不闪烁且只加载一次:本地加载(file:///D:/dev/…/html)不需要crossorigin;如果是服务器加载，需要添加属性：crossorigin。<br><code>&lt;link rel=&quot;preload&quot; as=&quot;font&quot; type=&quot;font/ttf&quot; crossorigin href=&quot;font/iconfont.ttf&quot;&gt;</code>   </li>
<li>绝对定位后，父元素会失去高度<br>解决，1。Overflow：hidden，2。设置高度</li>
<li>float 撑开父元素高度<ol>
<li>父元素设置高度</li>
<li>父元素后添加元素，clear:both; 可以利用 :after,再添加overflow，zoom</li>
<li>父元素 overflow:hidden</li>
<li>父元素也设置float，但是要设置宽度。 和overflow是一个原理</li>
</ol>
</li>
<li>BFC   左右布局中margin, overflow</li>
<li>多个块内元素 中间会有莫名的留白<br> 1)行内元素设置：vertial-align:bottom；2)父元素设置font-size:0;3)line-height足够小也可以;4)margin<br> div中img—inline-block和文本:img-display:block<br> ul下li:取消li之间的空格/破坏html的结构<br> inline-block有overflow-（只要不是visible—）: 上面img也是inline-block    </li>
<li><p>图片自适应–缩放，最大限度充满容器</p>
<pre><code>.wrapper{
    width:300px;  
    height:300px;  
    border:solid 1px #000;  
    background-color:red;  
    background-image:url(images/donghua1.jpg); /*图片地址*/  
    background-image:url(images/donghua3.jpg); /*图片地址*/  
    background-origin:content;  /*从content区域开始显示背景*/
    background-position:50% 50%;  /*图片上下左右居中*/  
    background-size:contain;    /*保持图像本身的宽高比例，将图片缩放到宽度或高度正好适应定义背景的区域*/  
    background-repeat:no-repeat; /*图像不重复显示*/  
}
</code></pre></li>
<li><p>重复嵌套的两个style，第一个定义样式不生效</p>
<pre><code>&lt;style&gt;
&lt;style&gt;
    .outer{
        //这里的样式不生效    
    }
    .inner{
        // 有效
    }
&lt;/style&gt;
&lt;/style&gt;
</code></pre></li>
<li>style标签结合属性contenteditable*,可以在页面直接显示样式表，并且可编辑</li>
<li><p>tr,td 是table元素定义height无效，改写display，或者嵌套div ;<br> table设置layout:fixed 可以限定宽高</p>
</li>
<li><p>搜索结果展示，超出隐藏/… 。包括垂直方向     </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.serch-description&#123;/*\\*/</span><br><span class="line">    max-width: 150px;// 垂直方向 max-height:95px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">.serch-description:hover&#123;</span><br><span class="line">    max-height:none;</span><br><span class="line">    white-space: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 多行文字:<br> 在webkit内核的浏览器中，多行文字省略可以采用CSS属性-webkit-line-clamp实现。<br> 方案二：clamp.js</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.multiple-line &#123;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      text-overflow: ellipsis;</span><br><span class="line">      display: -webkit-box; // 而且-webkit-box已经被flex替代,但是不能用flex代替</span><br><span class="line">      -webkit-line-clamp: 2;</span><br><span class="line">      -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器兼容性记录</title>
    <url>/sum/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E8%AE%B0%E5%BD%95(011)/</url>
    <content><![CDATA[<p>实际中遇到的浏览器兼容性 记录<br><a id="more"></a></p>
<p>默认是和chrome比较/区别</p>
<h2 id="一-ie"><a href="#一-ie" class="headerlink" title="一 ie"></a>一 ie</h2><ol>
<li>width：initial无效；前面加  width:auto;<br>top：initial同    </li>
<li>ie :before伪元素，不支持font-size:3em<br>rem是支持的<blockquote>
<p><a href="https://connect.microsoft.com/IE/feedback/details/813398/ie-11-css-before-with-font-size-in-em-units-ignores-css-precedence-rules" target="_blank" rel="noopener">https://connect.microsoft.com/IE/feedback/details/813398/ie-11-css-before-with-font-size-in-em-units-ignores-css-precedence-rules</a><br><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/107657/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/107657/</a> </p>
</blockquote>
</li>
</ol>
<h3 id="1-ie10-不支持（ie10以上支持）"><a href="#1-ie10-不支持（ie10以上支持）" class="headerlink" title="1 ie10 不支持（ie10以上支持）"></a>1 ie10 不支持（ie10以上支持）</h3><h3 id="2-ie9-不支持（ie9以上支持）"><a href="#2-ie9-不支持（ie9以上支持）" class="headerlink" title="2 ie9 不支持（ie9以上支持）"></a>2 ie9 不支持（ie9以上支持）</h3><h3 id="3-ie8-不支持（ie8以上支持）"><a href="#3-ie8-不支持（ie8以上支持）" class="headerlink" title="3 ie8 不支持（ie8以上支持）"></a>3 ie8 不支持（ie8以上支持）</h3><ol>
<li>CSS3：圆角，阴影，flex布局,opacity<ul>
<li>圆角和阴影：PIE.js pie.htc ; 阴影只能黑色   </li>
<li>Opacity:可以通过jq解决—定义方式不一样：filter(opacity:50)</li>
</ul>
</li>
</ol>
<h3 id="4-ie7-不支持（ie7以上支持）"><a href="#4-ie7-不支持（ie7以上支持）" class="headerlink" title="4 ie7 不支持（ie7以上支持）"></a>4 ie7 不支持（ie7以上支持）</h3><ol>
<li>table—cell</li>
</ol>
<h3 id="5-ie6、ie5"><a href="#5-ie6、ie5" class="headerlink" title="5 ie6、ie5"></a>5 ie6、ie5</h3><h2 id="二-ff"><a href="#二-ff" class="headerlink" title="二 ff"></a>二 ff</h2><ol>
<li>table下div，100%布局时，ff要给table下子元素设置高度px或者100%，不能只设置table的高度   </li>
<li>ff下iframe高度不会撑开父元素，导致下面的区块出现在video上；控制条高度，和中间圆点和chrome也不一样</li>
</ol>
<h2 id="三-safari"><a href="#三-safari" class="headerlink" title="三 safari"></a>三 safari</h2><p>windows safari 不做考虑；默认MacOS safari</p>
<h2 id="四-国产浏览器（360-QQ-UC等）"><a href="#四-国产浏览器（360-QQ-UC等）" class="headerlink" title="四 国产浏览器（360/QQ/UC等）"></a>四 国产浏览器（360/QQ/UC等）</h2><p>目前，还没有做过</p>
<h2 id="二-分别匹配不同的浏览器"><a href="#二-分别匹配不同的浏览器" class="headerlink" title="二- 分别匹配不同的浏览器"></a>二- 分别匹配不同的浏览器</h2><p>ie6:  _,        <em>,       \9<br>ie7: !import,   </em>,  *+,  \9<br>ie8: !import,             \9,   \0<br>ff:  !import,<br>safari/opera:!import,   nth-of-type(1)<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Webkit内核兼容CSS选择器样式，chrome safari */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span>(<span class="attribute">-ms-high-contrast:</span>active),(<span class="attribute">-ms-high-contrast:</span>none) &#123;</span><br><span class="line">    //ie10,11，\9不行</span><br><span class="line">    //https://www.jb51.net/css/104691.html</span><br><span class="line">&#125;</span><br><span class="line">@supports (display: -moz-box) &#123;// firefox</span><br><span class="line">    //https://developer.mozilla.org/en-US/docs/Web/CSS/%40supports</span><br><span class="line">&#125;</span><br><span class="line">@-moz-document url-prefix() &#123;// 该规则只在 Firefox 中有效，而且还必须要加 -moz- 前缀！</span><br><span class="line">    //https://developer.mozilla.org/en-US/docs/Web/CSS/@document </span><br><span class="line">    //（This is an experimental technology）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>url()：匹配整个URL；   </li>
<li>url-prefix()：匹配文档的URL是否以参数指定的值开头；   </li>
<li>domain()：匹配文档的域名是否为参数中指定的域名或者为它的子域名；   </li>
<li>regexp()：匹配文档的URL是否和参数中指定的正则表达式匹配.该表达式必须匹配整个URL。    </li>
</ul>
<p>Mozilla CSS:    <a href="extensionshttps://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_Extensions" target="_blank" rel="noopener">extensionshttps://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_Extensions</a>    </p>
<h2 id="一-移动设备"><a href="#一-移动设备" class="headerlink" title="一- 移动设备"></a>一- 移动设备</h2><ol>
<li>伪元素:before，的样式（颜色等）在低端机中 无效</li>
<li>某些设备（低端机）中无法播放视频</li>
<li>galaxy note8 分辨率，dpi有点高：横屏 媒体查询 直接显示了pc端样式<br>参考 acuview.css中的媒体查询 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-resolution:</span> <span class="number">522dpi</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span> <span class="number">3</span>), (<span class="attribute">min--moz-device-pixel-ratio:</span> <span class="number">3</span>), (<span class="attribute">-o-min-device-pixel-ratio:</span> <span class="number">3</span>/<span class="number">1</span>), (<span class="attribute">min-device-pixel-ratio:</span> <span class="number">3</span>), (<span class="attribute">min-resolution:</span> <span class="number">3dppx</span>) &#123;</span><br><span class="line">    <span class="selector-id">#video</span>, <span class="selector-id">#frmVideo</span>&#123;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">260px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Html使用记录</title>
    <url>/sum/jsplus/html%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>dom.getAttribute(‘’)是不区分大小写的,jQuery也不区分<br>document.all 能区分ie浏览器   </p>
<ol>
<li>浏览器可以通过tabindex属性 定义元素获得焦点的顺序</li>
<li><p>禁止设备的右键。好像没有生效，因为是系统级的<br> <a href="https://stackoverflow.com/questions/12304012/preventing-default-context-menu-on-longpress-longclick-in-mobile-safari-ipad" target="_blank" rel="noopener">Preventing default context menu on longpress / longclick in mobile Safari (iPad / iPhone)</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e.preventDefault();</span><br><span class="line"></span><br><span class="line">*:not(input):not(textarea) &#123;</span><br><span class="line">    -webkit-user-select: none; /* disable selection/Copy of UIWebView */</span><br><span class="line">    -webkit-touch-callout: none; /* disable the IOS popup when long-press on a link */</span><br><span class="line">&#125; </span><br><span class="line">html,body &#123; -webkit-touch-callout: none !important; &#125;</span><br><span class="line">a &#123; -webkit-user-select: none !important; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>video标签的可用性、优先权，结合controls=true考虑</p>
</li>
<li>video标签resize，父元素100%；也可以结合设置min-height</li>
<li>音视频自动播放 权限受到限制：同源/用户操作等，静音可以播放</li>
<li>style标签结合属性contenteditable*,可以在页面直接显示样式表，并且可编辑</li>
<li>input file accept <code>accept=&quot;image/gif, image/jpeg&quot;</code> <code>accept=&quot;video/*&quot;</code><br> 只会在选择是只显示这些文件。用户还可以手动选所有文件类型。<br> 需要判断 e.target.files[0].type 或者 file.name<br> <a href="https://blog.csdn.net/libinemail/article/details/51022922" target="_blank" rel="noopener">HTML accept 属性-规定能够通过文件上传进行提交的文件类型</a><br> <a href="https://blog.csdn.net/hanshileiai/article/details/44702923" target="_blank" rel="noopener">html input=”file” 浏览时只显示指定文件类型 xls、xlsx、csv</a></li>
<li><p>contenteditable 获取光标问题，并定位到最后。需要加 <code>tabindex</code> 属性，不是这个<br> <a href="https://www.cnblogs.com/cdwp8/p/4309960.html" target="_blank" rel="noopener">[div/span等获取焦点问题(tabindex属性的简单理解)]</a><br> <a href="https://blog.csdn.net/laoxiao1987/article/details/41946107" target="_blank" rel="noopener">[div contenteditable光标位置问题]</a><br> <a href="https://www.cnblogs.com/duhongyu216/articles/3560548.html" target="_blank" rel="noopener">[input、textarea、div(contenteditable=true)光标定位到最后]</a>   </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定位input、textarea</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">po_Last</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.focus();<span class="comment">//解决ff不获取焦点无法定位问题</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection) &#123;<span class="comment">//ie11 10 9 ff safari</span></span><br><span class="line">        <span class="keyword">var</span> max_Len=obj.value.length;<span class="comment">//text字符数</span></span><br><span class="line">        obj.setSelectionRange(max_Len, max_Len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;<span class="comment">//ie10 9 8 7 6 5</span></span><br><span class="line">        <span class="keyword">var</span> range = obj.createTextRange();<span class="comment">//创建range</span></span><br><span class="line">        range.collapse(<span class="literal">false</span>);<span class="comment">//光标移至最后</span></span><br><span class="line">        range.select();<span class="comment">//避免产生空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位div(contenteditable = "true")</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">po_Last_Div</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.getSelection) &#123;<span class="comment">//ie11 10 9 ff safari</span></span><br><span class="line">        obj.focus(); <span class="comment">//解决ff不获取焦点无法定位问题</span></span><br><span class="line">        <span class="keyword">var</span> range = <span class="built_in">window</span>.getSelection();<span class="comment">//创建range</span></span><br><span class="line">        range.selectAllChildren(obj);<span class="comment">//range 选择obj下所有子内容</span></span><br><span class="line">        range.collapseToEnd();<span class="comment">//光标移至最后</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection) &#123;<span class="comment">//ie10 9 8 7 6 5</span></span><br><span class="line">        <span class="keyword">var</span> range = <span class="built_in">document</span>.selection.createRange();<span class="comment">//创建选择对象</span></span><br><span class="line">        <span class="comment">//var range = document.body.createTextRange();</span></span><br><span class="line">        range.moveToElementText(obj);<span class="comment">//range定位到obj</span></span><br><span class="line">        range.collapse(<span class="literal">false</span>);<span class="comment">//光标移至最后</span></span><br><span class="line">        range.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iframe 上属性。<code>&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; allowtransparency=&quot;yes&quot;</code> crossorigin还可以设置<code>use-credentials</code> sandbox可以设置多个值<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener"><iframe></iframe></a>   </p>
<p> <a href="https://www.jianshu.com/p/7ec986aa28a7" target="_blank" rel="noopener">深入浅出iframe</a><br><code>&lt;iframe src=&quot;demo.html&quot; height=&quot;300&quot; width=&quot;500&quot; name=&quot;demo&quot; scrolling=&quot;auto&quot; sandbox=&quot;allow-same-origin allow-scripts&quot;&gt;&lt;/iframe&gt;</code><br>做CSP（内容安全策略）  通过CSP配置sandbox和child-src可以设置iframe的有效地址，它限制适iframe的行为，包括阻止弹出窗口,防止插件和脚本的执行,而且可以执行一个同源策略。<br><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;child-src &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; www.easonwong.com&quot;&gt;</code>  </p>
<blockquote>
<p>或者通过HTTP头部信息加上Content-Security-Policy字段    </p>
</blockquote>
<p>$PS: 解决word嵌套在iframe打开错误提示，结果发现不是这个原因了。中途给chrome启动添加了参数<code>--disable-web-security</code><br>之前好像是可以打开的。 把设置都去掉报新的错误，js文件都404，比如 <a href="https://view.officeapps.live.com/op/zh/strings.js" target="_blank" rel="noopener">https://view.officeapps.live.com/op/zh/strings.js</a></p>
<p>$PS: <code>crossorigin=&quot;anonymous</code> <code>crossorigin=use-credentials</code></p>
<blockquote>
<p>在HTML5中，一些 HTML 元素提供了对 CORS 的支持， 例如 <code>&lt;img&gt; 和 &lt;video&gt;</code><br>[CORS settings attributes] (<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes</a>)   </p>
</blockquote>
<p> $PS: 当时做视频avplayer 嵌套的在iframe中，好像是用了crossorign      </p>
<h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><h3 id="video-在微信中的怪癖"><a href="#video-在微信中的怪癖" class="headerlink" title="video 在微信中的怪癖"></a>video 在微信中的怪癖</h3></li>
<li>video的库好像并不会生效，强行使用原生。video.js,和TCPlayer    </li>
<li>video 在企业微信中播放或暂停，点击是中间会出现 按钮；所以 只需要一个中间的按钮，播放后去掉，就不再显示<br>而在微信浏览器中 开始加的播放按钮播放时去掉后就不会出现了。没有可以再次点击的按钮，继续播放。需要在暂停后再显示出来   </li>
<li>video在微信浏览器，和企业微信 中 是原生控件，层级比较高，播放时滚动会覆盖在页面上<br> <a href="https://www.v2ex.com/t/294868" target="_blank" rel="noopener">安卓手机 video 标签 层级问题</a><br> <a href="https://www.cnblogs.com/simonbaker/p/5435076.html" target="_blank" rel="noopener">html5 video在安卓大部分浏览器包括微信最顶层的问题</a></li>
<li>在微信浏览器的video标签加上<code>x5-video-player-type=&quot;h5&quot;</code> ，播放的时候会进入全屏（可以解决2的层级覆盖问题）。在全屏状态下，视频控件左上角的返回按钮可以返回页面，视频停留在当前帧（需要手动显示添加的中间播放按钮）。点击手机中间的home键，会从当前页面退出返回上一层级（就是home键的页面返回/退出）<br> <a href="https://www.karlew.com/archives/665" target="_blank" rel="noopener">安卓浏览器video层级最高问题解决方案</a><br> <a href="https://www.cnblogs.com/duanyue/p/7844255.html" target="_blank" rel="noopener">关于移动端video标签层级问题</a><br> <a href="https://blog.csdn.net/jiajunmiku/article/details/86570276" target="_blank" rel="noopener">安卓系统video视频层级问题</a></li>
</ol>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ol>
<li>在 HTML5 中，action 属性不再是必需的。 </li>
<li>form中只有button时,默认会submit,需要指定 type=”button”</li>
<li>action=”javascript:void(0)”  也可以防止默认提交.正常 onsubmit:return false;  </li>
<li><p>表单里没有选择路径的控件webkitdirectory,也只能是当前路径/一层,而且会有弹窗:需要指定受信任网站</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input id="meeASP" name="mee" type="file"   webkitdirectory&gt;</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#meeASP'</span>).addEventListener(<span class="string">'change'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> e.target.files)</span><br><span class="line">    <span class="built_in">console</span>.log(entry.name, entry.webkitRelativePath);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表单type=text 获取到的值(value)都是string类型,包括radio,<br>radio/checkbox 默认的value是”on”,不论有没有选中;option也需要设置value<br>jQuery prop得到radio/checkbox的值是boolean;attr是 undefined/undefined<br>jQuery 获得disabled, prop:true/false; attr:disabled/undefined   </p>
</li>
</ol>
<p>原生DOM Node的checked/disabled等是boolean,<br>checked在Node的attributes对象中没有该键值;disabled在attributes对象中有该键值,不同类型不同值.<br>没有selected,有selectedIndex,这些值是number;在Node.attributes对象中没有该键值.  </p>
<p>jQuery 的 attr(‘type’),对于select为undefiend, 需要手动设置type;设置为label的属性,有for也可以生效.  </p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><!-- \# [form表单那点事儿(上) 基础篇](https://segmentfault.com/a/1190000005803696) -->
<ol>
<li>没有 name 和有 disable 的字段不会被提交</li>
<li>同一个表单中，相同name的字段值会发生覆盖，radio 和 checkbox 除外</li>
<li>在低版本浏览器中，name可以作为id使用</li>
<li>忽略或使用浏览器不支持的 type 会转为 type=text</li>
<li>低版本浏览器不支持动态改变 type</li>
<li>点击 button 会默认提交表单</li>
<li>低版本浏览器需要指定 button 的 type=submit 才会提交表单</li>
<li>文本域的光标颜色由字体颜色决定</li>
<li>form表单不能互相嵌套</li>
<li>表单元素可以不在表单的html结构内 示例代码</li>
<li>在表单最后一个input元素中敲回车，会触发表单提交</li>
</ol>
<ol start="8">
<li>$(‘form’).serializeArray() 多选框未选中时,没有字段,添加type=hidden的相同name input;或者重新定义jquery方法  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"serAuto"</span> <span class="attr">id</span>=<span class="string">"serAuto"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"serAuto"</span> <span class="attr">value</span>=<span class="string">"false"</span> <span class="attr">type</span>=<span class="string">"hidden"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>If checkbox is not selected, form field is not submitted. That is why there is always false value in hidden field. If you leave checkbox unchecked, form will still have value from hidden field. That is how ASP.NET MVC handles checkbox values.</p>
</blockquote>
<!-- [asp.net mvc: why is Html.CheckBox generating an additional hidden input](https://stackoverflow.com/questions/2697299/asp-net-mvc-why-is-html-checkbox-generating-an-additional-hidden-input)   

[jQuery - serializeArray() is not getting the value of the checked checkbox](https://stackoverflow.com/questions/24338177/jquery-serializearray-is-not-getting-the-value-of-the-checked-checkbox)
[JQuery Serialize Method and Checkboxes](https://tdanemar.wordpress.com/2010/08/24/jquery-serialize-method-and-checkboxes/) 
$PS: 重写jQuery

[jquery serialize表单序列化，当radio或checkbox 全部未选中时，没有序列化到对象中的原因分析和解决方案](https://blog.csdn.net/caixiajia/article/details/77740490)
$PS:ghostsf_serialize
-->
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.ghostsf_serialize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">this</span>.serializeArray();</span><br><span class="line">    <span class="keyword">var</span> $radio = $(<span class="string">'input[type=radio],input[type=checkbox]'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> temp = &#123;&#125;;</span><br><span class="line">    $.each($radio, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!temp.hasOwnProperty(<span class="keyword">this</span>.name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($(<span class="string">"input[name='"</span> + <span class="keyword">this</span>.name + <span class="string">"']:checked"</span>).length == <span class="number">0</span>) &#123;</span><br><span class="line">                temp[<span class="keyword">this</span>.name] = <span class="string">""</span>;</span><br><span class="line">                a.push(&#123;<span class="attr">name</span>: <span class="keyword">this</span>.name, <span class="attr">value</span>: <span class="string">""</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//console.log(a);</span></span><br><span class="line">    <span class="keyword">return</span> jQuery.param(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ## 2 重写jQuery</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    $.fn.serialize = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $.param(<span class="keyword">this</span>.serializeArray(options));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $.fn.serializeArray = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = $.extend(&#123;</span><br><span class="line">        checkboxesAsBools: <span class="literal">false</span></span><br><span class="line">    &#125;, options || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rselectTextarea = <span class="regexp">/select|textarea/i</span>;</span><br><span class="line">    <span class="keyword">var</span> rinput = <span class="regexp">/text|hidden|password|search/i</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.elements ? $.makeArray(<span class="keyword">this</span>.elements) : <span class="keyword">this</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name &amp;&amp; !<span class="keyword">this</span>.disabled &amp;&amp;</span><br><span class="line">            (<span class="keyword">this</span>.checked</span><br><span class="line">            || (o.checkboxesAsBools &amp;&amp; <span class="keyword">this</span>.type === <span class="string">'checkbox'</span>)</span><br><span class="line">            || rselectTextarea.test(<span class="keyword">this</span>.nodeName)</span><br><span class="line">            || rinput.test(<span class="keyword">this</span>.type));</span><br><span class="line">        &#125;)</span><br><span class="line">        .map(<span class="function"><span class="keyword">function</span> (<span class="params">i, elem</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> val = $(<span class="keyword">this</span>).val();</span><br><span class="line">            <span class="keyword">return</span> val == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            $.isArray(val) ?</span><br><span class="line">            $.map(val, <span class="function"><span class="keyword">function</span> (<span class="params">val, i</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">name</span>: elem.name, <span class="attr">value</span>: val &#125;;</span><br><span class="line">            &#125;) :</span><br><span class="line">            &#123;</span><br><span class="line">                name: elem.name,</span><br><span class="line">                value: (o.checkboxesAsBools &amp;&amp; <span class="keyword">this</span>.type === <span class="string">'checkbox'</span>) ? <span class="comment">//moar ternaries!</span></span><br><span class="line">                       (<span class="keyword">this</span>.checked ? <span class="string">'true'</span> : <span class="string">'false'</span>) :</span><br><span class="line">                       val</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;).get();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"> $(<span class="string">'form'</span>).serializeArray(&#123; <span class="attr">checkboxesAsBools</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Js使用记录</title>
    <url>/sum/js/js%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li>数组中删除/过滤 特定/随机 元素   </li>
<li><p>delete 慎用，虽然只可以删除自己，但原型链仍会作用<br>是用来删除对象属性的，而不是变量，比如：<code>var a;</code>。严格模式会报错</p>
</li>
<li><p>数组sort可以同时按照多个属性排序  </p>
</li>
<li>按照中文排序<code>return nameA.localeCompare(nameB,systemInfo.lang);</code></li>
<li><p>hybris开发 提供一段字符串以供调用(c++)   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v0 行内：空head，有body </span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'&lt;body style="padding:5px 0;line-height:100%;color:#fff;background:#000;font-family:\'Microsoft Yahei\';font-size:25px;text-align:center;"&gt;&lt;span style="color:#FD6400"&gt;0&lt;/span&gt; 天 &lt;span style="color:#FD6400"&gt;7&lt;/span&gt; 时 &lt;span style="color:#FD6400"&gt;49&lt;/span&gt; 分 &lt;span style="color:#FD6400"&gt;23&lt;/span&gt; 秒&lt;/body&gt;'</span>;</span><br><span class="line"><span class="comment">// v0.1 行内： 同v0  </span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'&lt;html&gt;&lt;body style="padding:5px 0;color:#fff;background:#000;font-family:\'Microsoft Yahei\';font-size:25px;text-align:center;"&gt;&lt;span style="color:#FD6400"&gt;0&lt;/span&gt; 天 &lt;span style="color:#FD6400"&gt;7&lt;/span&gt; 时 &lt;span style="color:#FD6400"&gt;49&lt;/span&gt; 分 &lt;span style="color:#FD6400"&gt;23&lt;/span&gt; 秒&lt;/body&gt;&lt;/html&gt;'</span>;</span><br><span class="line"><span class="comment">// v1.0: style: .html() 文档没有head和body</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'&lt;body&gt;&lt;style&gt;html&#123;background:#000;color:#fff;&#125;span&#123;color:#FD6400&#125;&lt;/style&gt;sdfsfs&lt;span&gt; clorlo &lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="comment">// v1.1 style: .html() 文档没有head和body</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'&lt;head&gt;&lt;style&gt;html&#123;background:#000;color:#fff;&#125;span&#123;color:#FD6400&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;sdfsfs&lt;span&gt; clorlo &lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line">$(<span class="string">'html'</span>).html(str);<span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>语句简写(三元操作或者短路运算)在赋值时需要注意<code>()</code>的添加   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 三元操作，后面的赋值不加`()`会报错：`Uncaught ReferenceError: Invalid left-hand side in assignment`</span></span><br><span class="line">v.SubscribeDisplayName&amp;&amp;(sTitle = v.SubscribeDisplayName.formatForJS());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 赋值操作中，短路运算不加`()`会影响 str的赋值：`Philip&lt;/a&gt;`;`&amp;&amp;`前面的都没有计进去 </span></span><br><span class="line"> str = <span class="string">'&lt;a href="login/channel.php?id='</span> + <span class="built_in">encodeURIComponent</span>(d[<span class="number">3</span>]) + <span class="string">'"&gt;'</span> + (oCdrData.FAuthorName&amp;&amp;oCdrData.FAuthorName.formatForHTML()) + <span class="string">'&lt;/a&gt;'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[1,2,3].map(parseInt)//[1, NaN, NaN]</code> parseInt(string, radix) radix:可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。<br>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。<br>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。   </p>
</li>
<li><code>numObj.toString([radix])</code>  radix: 指定要用于数字到字符串的转换的基数(从2到36)。如果未指定 radix 参数，则默认值为 10。<br>对于 Number 对象，toString() 方法以指定的基数返回该对象的字符串表示。对象覆盖了 Object 对象上的 toString() 方法，它不是继承的 Object.prototype.toString()。<br>进行数字到字符串的转换时，建议用小括号将要转换的目标括起来，防止出错。<code>(8).toString(2) //1000</code><br><code>Object.prototype.toString.call(null);//&quot;[object Null]&quot;</code>    </li>
<li><p>生成一个随机数<code>(Math.random()*Math.pow(2,64)).toString(36)</code><br><code>Math.random().toString(36).substring(2)</code></p>
<!-- [有趣的js---获取随机字符串](https://blog.csdn.net/maomaolaoshi/article/details/80573058) -->
<p>Math.random: 这个随机数的小数长度不固定，但是经过测试（一亿次），最小出现过4位，最大出现过24位。如果运气不是特别特别差的话，基本上是不会出现0的情况。小数期望长度16位。  </p>
<p>Number对象拥有toString方法，该方法可以将Number对象转化成字符串。<br> 三十六进制实际上就是（0-9，a-z），十个数字加26个英文字母。<br> 将随机数转变成三十六进制，实际就相当于变成了数字+字母的随机字符串<br> 我们所要做的就是取小数点后面的字符串  </p>
<p> <code>(&quot;0000&quot; + (Math.random()*Math.pow(36,4) &lt;&lt; 0).toString(36)).slice(-4)</code></p>
 <!-- [从一行JavaScript代码生成随机字符串说起](http://bayescafe.com/webfrontend/generate-random-string-in-javascript.html) -->
<p> 想要获得更长的字符串怎么办？也很简单啦，只要用Math.floor代替&lt;&lt;取整就可以了。  </p>
</li>
<li><code>JSON.parse(s)</code>的时候 字符串中不可以带<code>\r,\n,\t</code>需要换成<code>\\r,\\n,或者&#39;&#39;</code>.<br> 但是如果是经过 JSON.stringify()过的可以解析通过<code>var s={name:&#39;sdf\r\nsadf&#39;} ss=JSON.stringify(s);var r=JSON.parse(ss)</code></li>
<li><p>js unicode编码    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span>.charCodeAt(<span class="number">0</span>); <span class="comment">/*97*/</span></span><br><span class="line"><span class="string">'a'</span>.charCodeAt().toString(<span class="number">16</span>); <span class="comment">/*61*/</span></span><br><span class="line"><span class="string">'\u0061'</span>  <span class="comment">/* 'a' */</span></span><br><span class="line"><span class="string">'a'</span>.length <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">'中'</span>.length <span class="comment">/* 1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后台直接返回一个json对象处理：<br>xhr和fetch经处理后返回的都是字符串类型，需要解析。JSON.parse()并不能成功解析<br>xhr:<code>jsonO=eval(&quot;(&quot;+data+&quot;)&quot;)</code><br>fetch: <code>res.text().then(data=&gt;{jsonO=eval(&quot;(&quot;+data+&quot;)&quot;)})</code></p>
</li>
<li><p>js预解析不过的时候，页面会报停，包括函数内部出错。   </p>
</li>
<li>本地页面(file协议)请求数据时的问题：xhr和fetch，没有试过axios<br>不知为什么访问本地服务器api就可以<br>1. 向本地的服务器-192.168.1.81发起请求都ok<br>2. 向公网发出的请求：<br>xhr:捕获到error，但是network中可以看到数据；status:200;type:xhr    <pre><code>浏览器报错：Failed to load https://www.hello.com/api?...
    No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access.
</code></pre>fetch-mode:cors:捕获到error，network中可以看不到数据；status:200;type:fetch    <pre><code>浏览器报错: 和上面一样；加了一行：
    If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled.
</code></pre>fetch-mode:no-cors: 没有捕获到error，network中没有数据；status:200;type:fetch   <pre><code>成功的回调中body:null;bodyUsed:false; ok:false;status:0;type:opaque;url:&quot;&quot;
即使header中做了相关设置    
</code></pre></li>
</ol>
<ol>
<li>jquery深拷贝<code>classInfoData = $.extend(true,[],classInfo);</code></li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js内存管理</title>
    <url>/sum/js/js%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(013)/</url>
    <content><![CDATA[<p>四种常见的内存泄露</p>
<ol>
<li>全局变量</li>
<li>被遗忘的定时器和回调</li>
<li>闭包（closure）</li>
<li>额外的 DOM 引用</li>
</ol>
<p># [js数据类型，及内存存储学习笔记]     </p>
<h2 id="二-Js中对象的存储问题："><a href="#二-Js中对象的存储问题：" class="headerlink" title="二 Js中对象的存储问题："></a>二 Js中对象的存储问题：</h2><p>两中类型的特点：<br>（1）基本类型在内存中占据固定大小的空间，因此被保存在栈内存中。<br>（2）从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本     </p>
<p>（3）引用类型的值是对像，保存在堆内存中，引用类型的值是引用访问的<br>（4）包含引用类型的值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针<br>（5）从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。   </p>
<p>（6）用typeof操作符来确定是哪种基本类型，typeof是一个操作符，而不是一个函数，因此typeof后面的圆括号可有可无，用instanceof操作符来确定是哪种引用类型。   </p>
<p>栈的优势就是存取速度比堆要快，仅次于直接位于CPU中的寄存器，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。</p>
<p>而对于js简单数据类型而言，他们占用内存比较小，如果放在堆中，查找会浪费很多时间，而把堆中的数据放入栈中也会影响栈的效率。比如对象和数组是可以无限拓展的，正好放在可以动态分配大小的堆中。</p>
<h2 id="三-Js中内存管理"><a href="#三-Js中内存管理" class="headerlink" title="三 Js中内存管理"></a>三 Js中内存管理</h2><p>Js是一门具有自动垃圾收集机制的编程语言。<br>Js的垃圾回收机制内容：<br>（1）离开作用域的值将被自动标记为可以回收，（比如局部变量，在运行完之后，就被自动标记，闭包的时候，属于特殊情况），因此将在垃圾收集期间被删除。<br>（2）“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不适用的值加上标记，然后在回收其内存。一般这些都是用在全局变量上。<br>（3）“引用计数”，另一种垃圾收集算法，这种算法的思想是，跟踪记录所有值被引用的次数，该算法在当前的搜索引擎中都不在使用  </p>
<p>#1 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">内存管理</a>    </p>
<p style="text-align:right">2018.10.16 星期二 16:02 #1</p>

<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：<br>1. 分配你所需要的内存<br>2. 使用分配到的内存（读、写）<br>3. 不需要时将其释放\归还<br>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。      </p>
<h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><p>#### 值的初始化:<br>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p>
<p>#### 通过函数调用分配内存<br>有些函数调用结果是分配对象内存：<br>有些方法分配新变量或者新对象：  </p>
<h3 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<h3 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
<p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 </p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p>
<p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<p>#### 限制：循环引用<br>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。    </p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
<p>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从2012年起，所有现代浏览器都使用了<strong>标记-清除垃圾回收算法</strong>。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<p>#### 循环引用不再是问题了<br>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。</p>
<p>#### 限制: 那些无法从根对象查询到的对象都将被清除<br>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。<br><!-- $end:#1 --></p>
<h2 id="V8-内存分配与垃圾回收"><a href="#V8-内存分配与垃圾回收" class="headerlink" title="V8 内存分配与垃圾回收"></a>V8 内存分配与垃圾回收</h2><p># [V8 内存分配与垃圾回收]<br>V8 将内存空间主要分为：新生代 和 老生代 两种 。<br>### 1、新生代空间<br>新生代空间中的对象为存活时间较短的对象，大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁 。<br>它将堆内存一分为二，每一部分空间称为 semispace，其中一个处于使用状态（from 空间），另一个处于闲置状态（to 空间）<br>新生代的垃圾回收采用 <strong>Scavenge 算法</strong> ，其工作原理如下：<br>### 2、老生代空间<br>老生代空间中的对象为存活时间长或常驻内存对象，大多数从新生代晋升的对象会被移动到这里。<br>老生代占用内存较多，如果使用 Scavenge算法，不仅会浪费一半空间，复制如此大块的内存消耗时间将会很长，所以 Scavenge 算法显然不适合。<br>V8 对于老生代中的垃圾回收，采用 <strong>Mark-Sweep （标记清除） 和 Mark-Compact（标记整理）</strong> 相结合 。       </p>
<p>### 3、三种回收策略比较<br>### 4、垃圾回收引起的性能问题<br>为了避免出现 JavaScript 应用逻辑 与 垃圾回收操作 产生不一致的冲突，垃圾回收的三种基本算法都需要将应用逻辑暂停下来，待垃圾回收完成后，再恢复执行应用逻辑，这种行为被称为全停顿 。<br>为降低全堆垃圾回收而导致的停顿时间，V8 做了以下改善措施：<br>(1) 限制堆内存大小<br>(2) 增量式垃圾回收:<br>V8 后续还引入 Lazy Sweep（延迟清除）、Incremental Compaction （增量式整理），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行整理，进一步利用多核性能来降低每次停顿的时间。     </p>
<p>### 5、垃圾回收的触发条件<br>作用域： 能形成作用域的函数调用、with 语句 以及 全局作用域。<br>闭包：  V8 无法主动回收内存中的闭包引用和全局变量引用。     </p>
<p>### 6、内存泄漏<br>通常，造成内存泄漏的原因有如下几个：<br>队列消费不及时<br>作用域未释放</p>
<p style="text-align:right">16:17 #1</p>


<p># [JavaScript内存优化]<br><!-- > 更详尽的内容可以购买我的好朋友朴灵的书《深入浅出Node.js 》进行学习  --></p>
<h2 id="2-JavaScript-的内存回收机制"><a href="#2-JavaScript-的内存回收机制" class="headerlink" title="2 JavaScript 的内存回收机制"></a>2 JavaScript 的内存回收机制</h2><p>在V8 中，所有的JavaScript 对象都是通过『堆』来进行内存分配的。  </p>
<p>当我们在代码中声明变量并赋值时，V8 就会在堆内存中分配一部分给这个变量。如果已申请的内存不足以存储这个变量时，V8 就会继续申请内存，直到堆的大小达到了V8 的内存上限为止。默认情况下，V8 的堆内存的大小上限在64位系统中为1464MB，在32位系统中则为732MB，即约1.4GB 和0.7GB。    </p>
<p>另外，V8 对堆内存中的JavaScript 对象进行分代管理：新生代和老生代。新生代即存活周期较短的JavaScript 对象，如临时变量、字符串等；而老生代则为经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。 </p>
<p>垃圾回收算法一直是编程语言的研发中是否重要的​​一环，而V8 中所使用的垃圾回收算法主要有以下几种：<br>    Scavange 算法：通过复制的方式进行内存空间管理，主要用于新生代的内存空间；<br>    Mark-Sweep 算法和Mark-Compact 算法：通过标记来对堆内存进行整理和回收，主要用于老生代对象的检查和回收。</p>
<h2 id="3-优化你的JavaScript"><a href="#3-优化你的JavaScript" class="headerlink" title="3 优化你的JavaScript"></a>3 优化你的JavaScript</h2><p>3.1 善用函数<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;(function(win, doc, $, undefined) &#123;</span><br><span class="line">    // 主业务代码</span><br><span class="line">&#125;)(window, document, jQuery);</span><br></pre></td></tr></table></figure></p>
<p>3.2 绝对不要定义全局变量<br>3.3 手工解除变量引用<br>3.4 善用回调<br>3.5 良好的闭包管理<br>3.6 内存不是缓存</p>
<h2 id="4-检查JavaScript-的内存使用情况"><a href="#4-检查JavaScript-的内存使用情况" class="headerlink" title="4 检查JavaScript 的内存使用情况"></a>4 检查JavaScript 的内存使用情况</h2><p>4.1 Blink / Webkit 浏览器<br>4.2 Node.js 中的内存检查    </p>
<!-- $end -->
<p>其他：<br><a href="https://robin-front.github.io/2017/09/19/how-to-handle-4-common-memory-leaks.html" target="_blank" rel="noopener">如何处理4种常见的内存泄露</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js性能技巧</title>
    <url>/sum/js/js%E6%80%A7%E8%83%BD%E6%8A%80%E5%B7%A7(005)/</url>
    <content><![CDATA[<h1 id="高效的JavaScript"><a href="#高效的JavaScript" class="headerlink" title="[高效的JavaScript]"></a>[高效的JavaScript]</h1><p>本文会展示一些能提升 Web 应用性能的改变，其范围涉及 ECMAScript —— JavaScript 的核心语言、DOM 和文件加载。</p>
<h1 id="如何让你的JavaScript代码更加语义化-0052-D"><a href="#如何让你的JavaScript代码更加语义化-0052-D" class="headerlink" title="[如何让你的JavaScript代码更加语义化] 0052-D"></a>[如何让你的JavaScript代码更加语义化] 0052-D</h1><p>三、小结<br>代码的优化，需要考虑的维度很多。但是代码的优化并不是减少代码量，有的时候我们需要增加代码来提高代码的可阅读性。</p>
<p>正确标记变量<br>封装某个动作<br>注意函数的写法<br>不容易理解的东西，加注释</p>
<p># [JavaScript：少一点条件语句] 0053-Dgone</p>
<h1 id="在js开发中，如何减少if-else语句的使用"><a href="#在js开发中，如何减少if-else语句的使用" class="headerlink" title="[在js开发中，如何减少if else语句的使用]"></a>[在js开发中，如何减少if else语句的使用]</h1><p>第一步：优化if逻辑<br>第二步：尽量少使用else<br>可以使用 if + return<br>1 switch/case<br>2.hash 表<br>3.重构，用 OO 里面的继承或者组合<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// # 2</span><br><span class="line">var ceos = &#123;&quot;Apple&quot;:&quot;Jobs&quot;, &quot;microsoft&quot;:&quot;Gates&quot;, &quot;Google&quot;:&quot;Larry&quot;&#125;;</span><br><span class="line">val = ceos[key];</span><br><span class="line">// # 3</span><br><span class="line">function getName(type) &#123;</span><br><span class="line">    var data = &#123;</span><br><span class="line">        monkey: &apos;monkey name&apos;,</span><br><span class="line">        cat: &apos;cat name&apos;,</span><br><span class="line">        dog: &apos;dog name&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return data[type] ? data[type] : data[&apos;dog&apos;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="如何无痛降低-if-else-面条代码复杂度-0053-D"><a href="#如何无痛降低-if-else-面条代码复杂度-0053-D" class="headerlink" title="[如何无痛降低 if else 面条代码复杂度]  0053-D"></a>[如何无痛降低 if else 面条代码复杂度]  0053-D</h1><h1 id="巧用匿名函数重构你的代码"><a href="#巧用匿名函数重构你的代码" class="headerlink" title="[巧用匿名函数重构你的代码]"></a>[巧用匿名函数重构你的代码]</h1><p>按照重构的惯例，先指出代码中的坏味（Bad Smell）：<br>定义冗长的重复配置<br>条件多变的集合过滤<br>说一不二的方法调用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # 1 </span></span><br><span class="line">&#123;</span><br><span class="line">  html: (<span class="function"><span class="keyword">function</span>(<span class="params">fruits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fruits.map(<span class="function"><span class="params">it</span> =&gt;</span> <span class="string">`&lt;label&gt;&lt;input type="checkbox" name="<span class="subst">$&#123;it.name&#125;</span>" title="<span class="subst">$&#123;it.title&#125;</span>" /&gt; <span class="subst">$&#123;it.title&#125;</span>&lt;/label&gt;`</span>).join(<span class="string">''</span>);</span><br><span class="line">  &#125;([</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">title</span>: <span class="string">'Apple'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">title</span>: <span class="string">'Banana'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'orange'</span>, <span class="attr">title</span>: <span class="string">'Orange'</span>&#125;</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 2 </span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">filterByName(filterBySex(filterByAge(students, <span class="number">21</span>), <span class="string">'male'</span>), <span class="string">'LiLei'</span>);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">list, fn</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> filtered = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn(list[i], i) === <span class="literal">true</span>) &#123;</span><br><span class="line">      filtered.push(list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filtered;</span><br><span class="line">&#125;</span><br><span class="line">filter(students, <span class="function"><span class="keyword">function</span>(<span class="params">member</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> member.name === <span class="string">'LiLei'</span> &amp;&amp; member.age === <span class="number">21</span> &amp;&amp; member.sex === <span class="string">'male'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">data, fn</span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// 最小执行单元</span></span><br><span class="line">  <span class="keyword">let</span> single = <span class="function"><span class="params">it</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        status: <span class="string">'success'</span>,</span><br><span class="line">        data: fn(it)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        status: <span class="string">'failed'</span>,</span><br><span class="line">        error: e.toString()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      status: <span class="string">'success'</span>,</span><br><span class="line">      data: data.map(single)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">inNum</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> execute(inNum, it =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(it))) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The input is not a number'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> it * <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="12个有关于JavaScript的小技巧"><a href="#12个有关于JavaScript的小技巧" class="headerlink" title="[12个有关于JavaScript的小技巧]"></a>[12个有关于JavaScript的小技巧]</h1><p>1、使用 !!操作符转换布尔值:要变量的值为：0、null、” “、undefined 或者NaN 都将返回的是 false，反之返回的是 true。比如下面的示例：<br>2、使用 + 将字符串转换成数字 +”1234” // 1234  +’sdfs’//NaN<br>6、检测对象中属性  ‘querySelector’ in document<br>7、获取数组中最后一个元素: array.slice(-1),array.slice(-3)// 4,5,6<br>8、数组截断 array.length = 3<br>9、替换所有string.replace(/hn/g, “ana”)<br>10、合并数组  array1.push.apply(array1, array2)<br>11、将 NodeList 转换成数组 [].slice.call(elements)  |var arrayElements = Array.from(elements);<br>12、数组元素的洗牌  list.sort(function() { Math.random() - 0.5 })</p>
<p>3、并符条件  4、使用 || 运算符<br><del>5、在循环中缓存 array.length</del></p>
<p># [19+ 个 JavaScript 快速编程技巧 — SitePoint]  0059-Dgone<br>19 双位取反运算符速记法 ~~4.9 === 4  //true</p>
<h1 id="JavaScript-性能优化的小知识总结"><a href="#JavaScript-性能优化的小知识总结" class="headerlink" title="[JavaScript 性能优化的小知识总结]"></a>[JavaScript 性能优化的小知识总结]</h1><h2 id="避免全局查找"><a href="#避免全局查找" class="headerlink" title="避免全局查找"></a>避免全局查找</h2><p>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>如果针对的是不断运行的代码，不应该使用 setTimeout，而应该是用 setInterval，因为 setTimeout 每一次都会初始化一个定时器，而 setInterval 只会在开始的时候初始化一个定时器  </p>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>如果要连接多个字符串，应该少使用 +=，如</p>
<pre><code>s+=a;
s+=b;
s+=c;
</code></pre><p>应该写成 s+=a + b + c；</p>
<p>而如果是收集字符串，比如多次对同一个字符串进行 += 操作的话，最好使用一个缓存，使用 JavaScript 数组来收集，最后使用 join 方法连接起来</p>
<p>##避免 with 语句<br>和函数类似 ，with 语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，由于额外的作用域链的查找，在 with 语句中执行的代码肯定会比外面执行的代码要慢，在能不使用 with 语句的时候尽量不要使用 with 语句。</p>
<p>##　数字转换成字符串<br>般最好用 <code>&quot;&quot; + 1</code>来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：<br>(“” +) &gt; String() &gt; .toString() &gt; new String() </p>
<h2 id="浮点数转换成整型"><a href="#浮点数转换成整型" class="headerlink" title="浮点数转换成整型"></a>浮点数转换成整型</h2><p>很多人喜欢使用 parseInt()，其实 parseInt() 是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用 Math.floor() 或者 Math.round()</p>
<h2 id="各种类型转换"><a href="#各种类型转换" class="headerlink" title="各种类型转换"></a>各种类型转换</h2><pre><code>var myVar =&quot;3.14159&quot;,
str =&quot;&quot;+ myVar,//  to string  
i_int =~~myVar,  //  to integer  
f_float =1* myVar,  //  to float  
b_bool =!!myVar,  /*  to boolean - any string with length
                    and any number except 0 are true */
array =[myVar];  //  to array  
</code></pre><p>如果定义了 toString() 方法来进行类型转换的话，推荐显式调用 toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的 toString() 方法尝试能否转化为 String，所以直接调用这个方法效率会更高</p>
<h2 id="多个类型声明"><a href="#多个类型声明" class="headerlink" title="多个类型声明"></a>多个类型声明</h2><p>在 JavaScript 中所有变量都可以使用单个 var 语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间，就如上面代码一样，上面代码格式也挺规范，让人一看就明了。</p>
<h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><p>如 var name=values[i]; i++; 前面两条语句可以写成 var name=values[i++]</p>
<h2 id="使用直接量"><a href="#使用直接量" class="headerlink" title="使用直接量"></a>使用直接量</h2><pre><code>var aTest =newArray();//替换为
var aTest =[];
var aTest =new Object();//替换为
var aTest ={};
var reg =new RegExp();//替换为
var reg =/../;
//如果要创建具有一些特性的一般对象，也可以使用字面量，如下：
var oFruit =new Object();
oFruit.color =&quot;red&quot;;
oFruit.name =&quot;apple&quot;;
//前面的代码可用对象字面量来改写成这样：
var oFruit ={ color:&quot;red&quot;, name:&quot;apple&quot;};
</code></pre><h2 id="使用-DocumentFragment-优化多次-append"><a href="#使用-DocumentFragment-优化多次-append" class="headerlink" title="使用 DocumentFragment 优化多次 append"></a>使用 DocumentFragment 优化多次 append</h2><p>一旦需要更新 DOM, 请考虑使用文档碎片来构建 DOM 结构，然后再将其添加到现存的文档中。</p>
<pre><code>var frag = document.createDocumentFragment();
for(var i =0; i &lt;1000; i++){
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
</code></pre><h2 id="使用一次-innerHTML-赋值代替构建-dom-元素"><a href="#使用一次-innerHTML-赋值代替构建-dom-元素" class="headerlink" title="使用一次 innerHTML 赋值代替构建 dom 元素"></a>使用一次 innerHTML 赋值代替构建 dom 元素</h2><p>对于大的 DOM 更改，使用 innerHTML 要比使用标准的 DOM 方法创建同样的 DOM 结构快得多。</p>
<pre><code>var frag = document.createDocumentFragment();
for(var i =0; i &lt;1000; i++){
    var el = document.createElement(&apos;p&apos;);
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//可以替换为：
var html =[];
for(var i =0; i &lt;1000; i++){
    html.push(&apos;&lt;p&gt;&apos;+ i +&apos;&lt;/p&gt;&apos;);
}
document.body.innerHTML = html.join(&apos;&apos;);
</code></pre><p>通过模板元素 clone，替代 createElement<br>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素<br>删除 DOM 节点<br>使用事件代理<br>重复使用的调用结果，事先保存到局部变量<br>注意 NodeList<br>优化循环<br>展开循环<br>避免双重解释<br>缩短否定检测<br>条件分支<br>使用常量<br>避免与 null 进行比较<br>避免全局量<br>尊重对象的所有权<br>循环引用<br>通过 javascript 创建的 dom 对象，必须 append 到页面中<br>释放 dom 元素占用的内存<br>释放 javascript 对象<br>避免 string 的隐式装箱<br>松散耦合<br>性能方面的注意事项<br>避免错误应注意的地方<br>== 和 === 的区别<br>不要使用生偏语法<br>函数返回统一类型<br>总是检查数据类型<br>何时用单引号，何时用双引号<br>部署</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js错误处理</title>
    <url>/sum/js/js%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(004)/</url>
    <content><![CDATA[<h1 id="前端异常监控"><a href="#前端异常监控" class="headerlink" title="前端异常监控"></a>前端异常监控</h1><p><a href="https://github.com/wayou/wayou.github.io/issues/8" target="_blank" rel="noopener">https://github.com/wayou/wayou.github.io/issues/8</a>   </p>
<p>如果说前端的异常监控有个救星的话，我想那就是 <code>window.onerror</code> 这个全局错误监听事件了。它给了我们统一处理前端全局错误的机会，使得错误上报有了一线生机。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">messageOrEvent, source, lineno, colno, error</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>message: 错误信息，在 HTML 中的 <code>onerror</code> 属性中设置的回调可以传递事件</li>
<li>source: 出错文件的 url</li>
<li>lineno: 出错位置的行数</li>
<li>colno: 出错时的列数</li>
<li>error: 出错时的 Error 对象。</li>
</ul>
<p>实践中发现最后个参数 Error 对象中的值因浏览器的实现各有差异，比如 Chrome 中包含 <code>message</code> 和 <code>stack</code>，而 Safari 中则包含了前面四个参数的所有值。这在下面的示例代码的结果中可以看得出来。</p>
<h2 id="牵出来溜一溜"><a href="#牵出来溜一溜" class="headerlink" title="牵出来溜一溜"></a>牵出来溜一溜</h2><p><em>注意</em><br><code>window.onerror</code> 需要在有服务端的情况下才能正常工作，本地直接打开页面测试获取不到任何有用的错误信息。可以在命令行启动一个简单的服务端来进行测试。<br>因为 Mac 自带 Python，一般需要用到服务端的时候，我喜欢用 Python 自带的 <code>SimpleHTTPServer</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer</span><br><span class="line">or</span><br><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure>
<p>以下代码我们对全局错误进行监听，然后将错误打印到页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, source, line, col, error</span>) </span>&#123;</span><br><span class="line">    printError.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printError</span>(<span class="params">msg, source, line, col, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> detail =</span><br><span class="line">        <span class="string">'msg:'</span> +</span><br><span class="line">        msg +</span><br><span class="line">        <span class="string">'\ncourse:'</span> +</span><br><span class="line">        source +</span><br><span class="line">        <span class="string">'\nline:'</span> +</span><br><span class="line">        line +</span><br><span class="line">        <span class="string">'\ncol:'</span> +</span><br><span class="line">        col +</span><br><span class="line">        <span class="string">'\nerror:'</span> +</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(error, <span class="built_in">Object</span>.getOwnPropertyNames(error));</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'pre'</span>);</span><br><span class="line">    div.innerHTML = detail</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在页面放上按钮以触发错误。这里测试了两种错误，一种运行时 JS 的抛错，另一种手动在代码中抛出的错误。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"excptionGenerate()"</span>&gt;</span>点我执行出错代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"throwError()"</span>&gt;</span>点我手动抛出异常<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-error-print.png?e=1585218234&token=your qiniu access key:Ai5m8Bd_Jk1WyYRwYNIBkwsKWII=" alt="Chrome 中异常的捕获与打印"></p>
<p><em>Chrome 中异常的捕获与打印</em></p>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/safari-error-print.png?e=1585218234&token=your qiniu access key:-BuNyLsAYKnNb0NCnrvcFONkKFA=" alt="Safari 中异常的捕获与打印"></p>
<p><em>Safari 中异常的捕获与打印</em></p>
<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>要知道，最初版本的全局错误监听事件是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">messageOrEvent, source, lineno</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>后来才增加了 <code>colno</code> 和 <code>error</code>。而后来加的这两个参数其实是非常有用的。</p>
<p>因为线上代码一般为压缩过的代码，所有内容都在一行，假如没有提供发生问题的列数，这样的错误日志要追查起来很不方便。<br>错误对象则直接提供了错误堆栈信息（通过 <code>error.stack</code> 访问），就像我们在浏览器控制台看到的一样，对于定位问题十分有帮助。</p>
<p>主流浏览器中， Chrome， Safari 已经完成了5个参数的支持。</p>
<p>Firefox 从 31 开始支持了完整的5个参数。</p>
<p>截止到目前， 微软的 Edge 浏览器还没有实现对新增两个参数的支持。其实现情况可以在<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/runtimeerrorreportingerrorevent/?q=onerror" target="_blank" rel="noopener">这里</a>查阅得到。</p>
<ul>
<li>小贴士 *<blockquote>
<p>过程中顺便发现了微软Edge<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/catalog/?page=1&amp;q=queryselector" target="_blank" rel="noopener">这个API Catalog页面</a>可以查到主流浏览器对名前端特性的实现情况，数据比 caniuse 全，譬如 <code>window.onerror</code> 在 caniuse 上则没有。</p>
</blockquote>
</li>
</ul>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/ms-edge-onerror-compatability.png?e=1585218234&token=your qiniu access key:qiJLhKZy_YXOCQ3v1xDA8EqgrsM=" alt="MS Edge 浏览器对 `window.onerror` 第五个参数的实现情况"></p>
<p><em>MS Edge 浏览器对 <code>window.onerror</code> 第五个参数的实现情况</em></p>
<p>从这里也可以看到，其他主流浏览器都已经有了完整的支持。</p>
<p>IE，（逃~）</p>
<h2 id="垫片"><a href="#垫片" class="headerlink" title="垫片"></a>垫片</h2><p>对于不提供第5个参数的环境，我们是拿不到错误堆栈信息的。这种情况下对错误的追查帮助不大。</p>
<p>但是，手动在代码中捕获并抛出的错误，是带了堆栈信息的。这就有了补救的希望。我们可以将可能出错的地方，或者我们期望进行监控的地方，使用 try catch。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatchError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        printError(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> detail = <span class="string">'error:'</span> +</span><br><span class="line">            <span class="built_in">JSON</span>.stringify(error, <span class="built_in">Object</span>.getOwnPropertyNames(error)) +</span><br><span class="line">            <span class="string">'\n\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'code'</span>);</span><br><span class="line">    div.innerHTML = detail</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在页面中添加按钮来调用新的测试函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"tryCatchError()"</span>&gt;</span>利用 try catch 捕获异常并打印错误堆栈<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/try-catch-print.png?e=1585218234&token=your qiniu access key:Sqq_5zopXt5NZkgeKDpdav6enXo=" alt="try catch 中打印错误"></p>
<p><em>try catch 中打印错误</em></p>
<p>我们看到，这种方式确实能得到详细的报错堆栈。</p>
<h4 id="这一段其实无关紧要"><a href="#这一段其实无关紧要" class="headerlink" title="这一段其实无关紧要"></a>这一段其实无关紧要</h4><p>因为最后两个参数是后面加的，有理由相信，在很老很老很老的 Chrome 版本中，也是不支持全部5个参数的。来自Ben Vinegar的<a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html" target="_blank" rel="noopener">这篇文章</a>指出 Chrome 46 开始支持全部5个参数的。</p>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-onerr-compatability.png?e=1585218234&token=your qiniu access key:L7aUMTzzG9k8ZHrKMEBvk_uyNuE=" alt></p>
<p>为此我们不妨找一个老版本来验一下。我去 <a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html" target="_blank" rel="noopener">Chrome 的历史仓库中</a> 下到了 <a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/100293/" target="_blank" rel="noopener">Chromium 15</a> （Chrome 正式发布前的开发版）。</p>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chromium-15.png?e=1585218234&token=your qiniu access key:ixW9w05OXUE1LMtpHplTso9W6Jw=" alt="拥有历史厚重感的老版本 Chrome"></p>
<p><em>拥有历史厚重感的老版本 Chrome</em></p>
<p>打开它，仿佛打开了一个刚出土的文物，在 Retina 屏上，它的皮肤已经略出了清晰的锯齿，这是历史的厚重，这是岁月刻下的痕迹。</p>
<p>不过还好，它的功能依然完好，跑起来我们的示例代码来驾轻就熟。</p>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-15-without-last-2-arguments.png?e=1585218234&token=your qiniu access key:TxmFAOHa4WfSHwvQSnJfGHtStZk=" alt="老版本的 Chrome 果然是没有后两位参数的"></p>
<p><em>老版本的 Chrome 果然是没有后两位参数的</em></p>
<h2 id="全局无法捕获的情况"><a href="#全局无法捕获的情况" class="headerlink" title="全局无法捕获的情况"></a>全局无法捕获的情况</h2><p>除了考虑上面的浏览器兼容性问题外，还有其他一些情况，也是无法通过这个全局的 onerror 获取到详细报错信息的。</p>
<h3 id="跨域情况的错误捕获-CDN"><a href="#跨域情况的错误捕获-CDN" class="headerlink" title="跨域情况的错误捕获(CDN)"></a>跨域情况的错误捕获(CDN)</h3><p><code>window.onerror</code> 有个限制，来自非同域的代码有报错，不会给出错误的详细信息，只能得到一个 <code>Script error.</code>。这是浏览器出于安全考虑，不向第三方泄露信息而做的一个措施。但往往线上代码大部分都部署在 CDN，所以这个限制的影响还挺常见。</p>
<p>不过还好，某些浏览器中可以通过配置来更改这一行为，让我们能正常拿到报错的详细信息。</p>
<p>还有一点，就是虽然在 <code>window.onerror</code> 中倒不到详细的报错信息，但在浏览器控制台是可以看到详细信息的。</p>
<p><em>如果是跨域脚本，则提示去控制台查看报错信息</em><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> string = msg.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> substring = <span class="string">"script error"</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.indexOf(substring) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        alert(<span class="string">'Script Error: See Browser Console for Detail'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = [</span><br><span class="line">            <span class="string">'Message: '</span> + msg,</span><br><span class="line">            <span class="string">'URL: '</span> + url,</span><br><span class="line">            <span class="string">'Line: '</span> + lineNo,</span><br><span class="line">            <span class="string">'Column: '</span> + columnNo,</span><br><span class="line">            <span class="string">'Error object: '</span> + <span class="built_in">JSON</span>.stringify(error)</span><br><span class="line">        ].join(<span class="string">' - '</span>);</span><br><span class="line"></span><br><span class="line">        alert(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>控制台能看到对于线上的错误监控来说没多大用，还是得解决上报的问题。我们来看看如何设置跨域脚本让我们可以捕获时拿到错误堆栈信息。</p>
<p>下面看跨域脚本的配置。</p>
<ul>
<li><p>CDN 上开启允许跨域  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin:*</span><br><span class="line">或者</span><br><span class="line">Access-Control-Allow-Origin: domain of your site</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后 script 标签上设置跨域标识为匿名</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span> <span class="attr">src</span>=<span class="string">"//url/for/your/cdn/scripts"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>唯一需要注意的是，一旦在前端设置了 <code>crossorigin</code>，要确保服务端相应设置了允许跨域的响应头，否则整个脚本文件会加载失败，影响页面正常功能。</p>
<p>目前来看，除了 Opera外，各主流浏览器都有支持此属性。</p>
<p><img src="http://you img base url/https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/cors-loading-browser-compatability.png?e=1585218234&token=your qiniu access key:CBl2WZjF9i6_Jrm1gvwrFAat5sc=" alt="跨域脚本加载浏览器兼容性"></p>
<p><em>跨域脚本加载浏览器兼容性</em></p>
<h3 id="iframe-中异常的捕获"><a href="#iframe-中异常的捕获" class="headerlink" title="iframe 中异常的捕获"></a>iframe 中异常的捕获</h3><p>iframe 中发生异常，外界的 <code>onerror</code> 是不会触发的。但如果 iframe 地址同域，那么我们就可以设置 iframe 的全局 <code>onerror</code> 进行监听。</p>
<pre><code class="js"><span class="built_in">document</span>.getElementById(<span class="string">"myiframe"</span>).contentWindow.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    alert(<span class="string">'error!!'</span>);
    <span class="keyword">return</span> <span class="literal">false</span>;
}
</code></pre>
<p>以上代码需要保证在 iframe 加载完成后进行。</p>
<p>非同域情况下，如果 ifame 内的内容不来自第三方，也就是你自己可以控制，那么可以通过与 iframe 内进行通信的方式，将异常信息抛出来。iframe 通信试有很多，譬如 <code>postMessage</code>。这里不展开了。</p>
<p>非同域且内容不受自己控制的情况下，除了在控制台查看错误详细信息，真的没其他办法可以捕获了。</p>
<h3 id="代码压缩在错误捕获中的还原"><a href="#代码压缩在错误捕获中的还原" class="headerlink" title="代码压缩在错误捕获中的还原"></a>代码压缩在错误捕获中的还原</h3><p>线上代码一般是压缩过的，如何更友好地展示还原事件发生地，对于错误上报也是个挑战。因为在错误监听的回调里面提供了列数，所以对于压缩后的代码，定位起位置来也不是难事，再结合错误对象里的报错堆栈信息，能够很好地定位代码的位置及原因。</p>
<p>关于压缩后的代码，有 sourse map 可以映射到源码，如果我们在异常捕获时通过与 soruce map 文件结合起来，那么就有可能在还原错误时分析出其在未压缩源码中的位置。目前来看，已经有相关的服务实现了这一功能，<a href="https://docs.sentry.io/clients/javascript/sourcemaps/" target="_blank" rel="noopener">sentry 的文档</a>中有提到。</p>
<p>前面讨论了一下错误详细信息的获取，最终我们是想在客户端收集到这些信息，再加上 ua, 发生错误的时间，设备相关信息等上报到服务端。总之，能够获取到信息越全越好，方便我们后期定位处理问题。当然，这套体系，市面上是有现成库已经做了的，来自 GitHub的这个代码仓库<a href="https://github.com/cheeaun/javascript-error-logging" target="_blank" rel="noopener">cheeaun/javascript-error-logging</a>收集了前端异常监控相关的资源，从 <a href="https://github.com/topics/error-monitoring" target="_blank" rel="noopener">GitHub 这个专题页面</a>也能找到许多。上面的坑库里面也都会覆盖到。 </p>
<p>Happy trouble shotting :)</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror" target="_blank" rel="noopener">GlobalEventHandlers.onerror</a></li>
<li><a href="https://danlimerick.wordpress.com/2014/01/18/how-to-catch-javascript-errors-with-window-onerror-even-on-chrome-and-firefox/" target="_blank" rel="noopener">How to catch JavaScript Errors with window.onerror (even on Chrome and Firefox)</a></li>
<li><a href="https://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox" target="_blank" rel="noopener">Cryptic “Script Error.” reported in Javascript in Chrome and Firefox</a></li>
<li><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html" target="_blank" rel="noopener">Capture and report JavaScript errors with window.onerror</a></li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/catalog/?page=1&amp;q=queryselector" target="_blank" rel="noopener">MS Edge API Catalog</a></li>
<li><a href="https://trackjs.com/blog/script-error-javascript-forensics/" target="_blank" rel="noopener">Script Error: JavaScript Forensics</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes" target="_blank" rel="noopener">CORS settings attributes</a></li>
<li><a href="https://stackoverflow.com/questions/6327128/can-i-catch-exception-of-iframe-in-parent-window-of-iframe" target="_blank" rel="noopener">can I catch exception of Iframe in parent window of Iframe</a></li>
</ul>
<p><strong>后记</strong></p>
<p>后续可以开垦的点：</p>
<ul>
<li>本地模拟跨域</li>
<li>自己实现异常上报的库</li>
</ul>
<h1 id="10-种最常见的-Javascript-错误"><a href="#10-种最常见的-Javascript-错误" class="headerlink" title="[10 种最常见的 Javascript 错误]"></a>[10 种最常见的 Javascript 错误]</h1><!-- <http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227829&idx=1&sn=b4ae3261e63665a7bc0c24fb5dc8fe99&chksm=bd495f318a3ed6272d0e9766d38a3543f85796c723a9b7156d670f9c6942c0a2e1a0fbbd3e7f&mpshare=1&scene=1&srcid=0319D6JctIxuF3ajH8gfkgBz#rd>    
**$_YX:** https://app.yinxiang.com/shard/s67/nl/18114453/c193eb4a-d618-4c9c-bca3-c276c84aa530?title=%E3%80%90%E7%AC%AC1199%E6%9C%9F%E3%80%9110%20%E7%A7%8D%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%20Javascript%20%E9%94%99%E8%AF%AF  -->
<p style="text-align:right">2018.4.15 星期日 11:30</p>

<p><img src="http://you img base url/https://app.yinxiang.com/shard/s67/res/9b87bb20-10ce-4888-869e-d36369639b5e/640.jpg?e=1585218234&token=your qiniu access key:R33ner0Ps9lutbMsVVqIkrBcG7w=" alt="JavaScript-错误-Top-10"><br><img src="http://you img base url/images/JavaScript-错误-Top-10.jpg?e=1585218234&token=your qiniu access key:qkPGf6pJJ1y9pTVcNEXj6u9Vr8o=" alt="JavaScript-错误-Top-10"></p>
<h2 id="JavaScript-错误-Top-10"><a href="#JavaScript-错误-Top-10" class="headerlink" title="JavaScript-错误-Top-10"></a>JavaScript-错误-Top-10</h2><p>为了便于阅读，我们将每个错误描述都缩短了。接下来，让我们深入到每一个错误，来确定什么会导致它，以及如何避免创建它。</p>
<h3 id="1-Uncaught-TypeError-Cannot-read-property"><a href="#1-Uncaught-TypeError-Cannot-read-property" class="headerlink" title="1. Uncaught TypeError: Cannot read property"></a>1. Uncaught TypeError: Cannot read property</h3><h3 id="2-TypeError-‘undefined’-is-not-an-object"><a href="#2-TypeError-‘undefined’-is-not-an-object" class="headerlink" title="2. TypeError: ‘undefined’ is not an object"></a>2. TypeError: ‘undefined’ is not an object</h3><p>这是在 Safari 中读取属性或调用未定义对象上的方法时发生的错误。您可以在 Safari Developer Console 中轻松测试。这与 1 中提到的 Chrome 的错误基本相同，但 Safari 使用了不同的错误消息提示语。</p>
<h3 id="3-TypeError-null-is-not-an-object"><a href="#3-TypeError-null-is-not-an-object" class="headerlink" title="3. TypeError: null is not an object"></a>3. TypeError: null is not an object</h3><p>这是在 Safari 中读取属性或调用空对象上的方法时发生的错误。 </p>
<h3 id="4-unknown-Script-error"><a href="#4-unknown-Script-error" class="headerlink" title="4. (unknown): Script error"></a>4. (unknown): Script error</h3><p>当未捕获的 JavaScript 错误（通过window.onerror处理程序引发的错误，而不是捕获在try-catch中）被浏览器的跨域策略限制时，会产生这类的脚本错误。 例如，如果您将您的 JavaScript 代码托管在 CDN 上，则任何未被捕获的错误将被报告为“脚本错误” 而不是包含有用的堆栈信息。这是一种浏览器安全措施，旨在防止跨域传递数据，否则将不允许进行通信。</p>
<p>要获得真正的错误消息，请执行以下操作：<br>发送 ‘Access-Control-Allow-Origin’ 头部<br>将 Access-Control-Allow-Origin 标头设置为 * 表示可以从任何域正确访问资源。 如有必要，您可以将域替换为您的域：例如，Access-Control-Allow-Origin：<a href="http://www.example.com。" target="_blank" rel="noopener">www.example.com。</a> 但是，处理多个域会变得棘手，如果你使用 CDN，可能由此产生更多的缓存问题会让你感觉到这种努力并不值得。 在这里看到更多。</p>
<p>这里有一些关于如何在各种环境中设置这个头文件的例子：</p>
<ol>
<li><p>Apache<br>在 JavaScript 文件所在的文件夹中，使用以下内容创建一个 .htaccess 文件：</p>
<pre><code>Header add Access-Control-Allow-Origin&quot;*&quot;
</code></pre></li>
<li><p>Nginx<br>将 add_header 指令添加到提供 JavaScript 文件的位置块中：</p>
<pre><code>location ~^/assets/{
    add_header Access-Control-Allow-Origin*;
}
</code></pre></li>
<li><p>HAProxy<br>将以下内容添加到您为 JavaScript 文件提供资源服务的后端：  </p>
<pre><code>rspadd Access-Control-Allow-Origin:\ *
</code></pre><p> 在 <code>&lt;script&gt;</code> 中设置 crossorigin=”anonymous”在您的 HTML 代码中，对于您设置了Access-Control-Allow-Origin header 的每个脚本，在 script 标签上设置crossorigin =“anonymous”。在脚本标记中添加 crossorigin 属性之前，请确保验证上述 header 正确发送。 在 Firefox 中，如果存在crossorigin属性，但Access-Control-Allow-Origin头不存在，则脚本将不会执行。</p>
</li>
</ol>
<h3 id="5-TypeError-Object-doesn’t-support-property"><a href="#5-TypeError-Object-doesn’t-support-property" class="headerlink" title="5. TypeError: Object doesn’t support property"></a>5. TypeError: Object doesn’t support property</h3><p>这是您在调用未定义的方法时发生在 IE 中的错误。<br>这相当于 Chrome 中的 “TypeError：”undefined“ is not a function” 错误。 是的，对于相同的逻辑错误，不同的浏览器可能具有不同的错误消息。</p>
<p>对于使用 JavaScript 命名空间的 Web 应用程序，这是一个 IE l浏览器的常见的问题。 在这种情况下，99.9％ 的原因是 IE 无法将当前名称空间内的方法绑定到 this 关键字。 例如：如果你 JS 中有一个命名空间 Rollbar 以及方法 isAwesome 。</p>
<h3 id="6-TypeError-‘undefined’-is-not-a-function"><a href="#6-TypeError-‘undefined’-is-not-a-function" class="headerlink" title="6. TypeError: ‘undefined’ is not a function"></a>6. TypeError: ‘undefined’ is not a function</h3><p>当您调用未定义的函数时，这是 Chrome 中产生的错误。</p>
<h3 id="7-Uncaught-RangeError-Maximum-call-stack"><a href="#7-Uncaught-RangeError-Maximum-call-stack" class="headerlink" title="7. Uncaught RangeError: Maximum call stack"></a>7. Uncaught RangeError: Maximum call stack</h3><p>这是 Chrome 在一些情况下会发生的错误。 一个是当你调用一个不终止的递归函数。您可以在 Chrome 开发者控制台中进行测试。</p>
<p>此外，如果您将值传递给超出范围的函数，也可能会发生这种情况。 许多函数只接受其输入值的特定范围的数字。 例如：Number.toExponential(digits) 和 Number.toFixed(digits) 接受 0 到 20 的数字，Number.toPrecision(digits)接受 1 到 21 的数字。</p>
<h3 id="8-TypeError-Cannot-read-property-‘length’"><a href="#8-TypeError-Cannot-read-property-‘length’" class="headerlink" title="8. TypeError: Cannot read property ‘length’"></a>8. TypeError: Cannot read property ‘length’</h3><p>这是 Chrome 中发生的错误，因为读取未定义变量的长度属性。 </p>
<h3 id="9-Uncaught-TypeError-Cannot-set-property"><a href="#9-Uncaught-TypeError-Cannot-set-property" class="headerlink" title="9. Uncaught TypeError: Cannot set property"></a>9. Uncaught TypeError: Cannot set property</h3><p>当我们尝试访问一个未定义的变量时，它总是返回 undefined，我们不能获取或设置任何未定义的属性。 </p>
<h3 id="10-ReferenceError-event-is-not-defined"><a href="#10-ReferenceError-event-is-not-defined" class="headerlink" title="10. ReferenceError: event is not defined"></a>10. ReferenceError: event is not defined</h3><p>当您尝试访问未定义的变量或超出当前范围的变量时，会引发此错误。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们希望你学到了新的东西，可以避免将来的错误，或者本指南帮助你解决了头痛的问题。   </p>
<p>尽管如此，即使有最佳实践，生产中也会出现意想不到的错误。能够查看影响用户的错误，并拥有快速解决问题的好工具，这一点非常重要。推荐 Rollbar。</p>
<p><strong>$_PS:</strong> 其它：<br>最后，为你推荐<br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226189&amp;idx=1&amp;sn=f4261914581c7ff3fbdf6947d551c983&amp;chksm=bd4959c98a3ed0df7569004780d1cf856aa4b70cafc24b3bce4bc7b23cc1dfc3aa7b08dcb179&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【第870期】JavaScript错误处理和堆栈追踪</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=207131517&amp;idx=1&amp;sn=a361eab27b7b036b0ea221615c07f2a1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【第318期】如何修复那些奇怪的 JavaScript 错误</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动条操作</title>
    <url>/sum/js/%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%93%8D%E4%BD%9C(025)/</url>
    <content><![CDATA[<h2 id="页面滚动时自动显示隐藏导航效果"><a href="#页面滚动时自动显示隐藏导航效果" class="headerlink" title="[页面滚动时自动显示隐藏导航效果]"></a>[页面滚动时自动显示隐藏导航效果]</h2><p>参考：<br><a href="https://mickey0524.github.io/2017/09/23/scroll-auto-show-hide/" target="_blank" rel="noopener">页面滚动时自动显示隐藏导航效果</a><br><a href="http://www.css88.com/archives/7883" target="_blank" rel="noopener">页面滚动时自动显示隐藏导航效果（jQuery）</a><br><strong>$_PS:</strong> 第二个原文章。已下载.html  </p>
<p>## 下拉刷新（移动端）</p>
<p># [滑向未来（现代 JS 与 CSS 滚动实现指南）]  </p>
<h2 id="消逝的滚动条"><a href="#消逝的滚动条" class="headerlink" title="消逝的滚动条"></a>消逝的滚动条</h2><h2 id="隐藏但可滚动"><a href="#隐藏但可滚动" class="headerlink" title="隐藏但可滚动"></a>隐藏但可滚动</h2><p>### <code>body{overflow:hidden}</code>“模态框抖动”问题<br>在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：<br>o:15px,edge:16,chrome/ff/ie:17<br>#### css<br>至于 Firefox，很不幸，没有任何办法隐藏滚动条。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container::-webkit-scrollbar &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">  -ms-overflow-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="外观争议"><a href="#外观争议" class="headerlink" title="外观争议"></a>外观争议</h2><h2 id="流畅的操作体验"><a href="#流畅的操作体验" class="headerlink" title="流畅的操作体验"></a>流畅的操作体验</h2><p>轮子<br>js:<code>elem.scrollIntoView({behavior: &#39;smooth&#39;});</code><br>css(草案):<code>html{scroll-behavior: smooth;}</code>   </p>
<h2 id="粘性-CSS"><a href="#粘性-CSS" class="headerlink" title="粘性 CSS"></a>粘性 CSS</h2><p><code>position: sticky</code></p>
<h2 id="全面使用函数节流"><a href="#全面使用函数节流" class="headerlink" title="全面使用函数节流"></a>全面使用函数节流</h2><h2 id="在视窗中显示"><a href="#在视窗中显示" class="headerlink" title="在视窗中显示"></a>在视窗中显示</h2><p><code>const rect = elem.getBoundingClientRect();</code><br><code>const observer = new IntersectionObserver(callback, options);</code></p>
<h2 id="滚动边界问题"><a href="#滚动边界问题" class="headerlink" title="滚动边界问题"></a>滚动边界问题</h2><h2 id="触屏之后"><a href="#触屏之后" class="headerlink" title="触屏之后"></a>触屏之后</h2><p># [无尽滚动的复杂度]<br>我们将会使用3种技术来达成目标：DOM回收、墓碑和滚动锚定</p>
<h2 id="自定义滚动条"><a href="#自定义滚动条" class="headerlink" title="自定义滚动条"></a>自定义滚动条</h2><p>参考：<br><a href="https://www.xiabingbao.com/scrollbar/2016/01/25/scrollbar.html" target="_blank" rel="noopener">[自定义滚动条]</a>   </p>
<ol>
<li>无滚动条但依然可以滚动</li>
<li><p>美化后的滚动条<br>只有webkit内核的浏览器（chrome, opera, safari等）才支持，<br>firefox到目前位置还不支持滚动条美化，<br>IE浏览器只支持修改滚动条的颜色，其他的则无法修改。   </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置垂直滚动条的宽度和水平滚动条的高度 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置滚动条的滑轨 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::-webkit-scrollbar-track</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滑块 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::-webkit-scrollbar-thumb</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 滑轨两头的监听按钮 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::-webkit-scrollbar-button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 横向滚动条和纵向滚动条相交处尖角 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::-webkit-scrollbar-corner</span> &#123;</span><br><span class="line">    <span class="comment">/*background-color: black;*/</span></span><br><span class="line">&#125;</span><br><span class="line">// ie</span><br><span class="line">scrollbar-arrow-color: color; //三角箭头的颜色/</span><br><span class="line">scrollbar-face-color: color; //立体滚动条的颜色（包括箭头部分的背景色）/</span><br><span class="line">scrollbar-3dlight-color: color; //立体滚动条亮边的颜色/</span><br><span class="line">scrollbar-highlight-color: color; //滚动条的高亮颜色（左阴影？）/</span><br><span class="line">scrollbar-shadow-color: color; //立体滚动条阴影的颜色/</span><br><span class="line">scrollbar-darkshadow-color: color; //立体滚动条外阴影的颜色/</span><br><span class="line">scrollbar-track-color: color; //立体滚动条背景颜色/</span><br><span class="line">scrollbar-base-color:color; //滚动条的基色/</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义滚动条<br>自定义滚动条借助js里的滚轮事件，mousemove事件等，使用div来模拟一个滚动条，然后根据位移，滚动条和内容移动相应的距离</p>
</li>
<li>使用mCustomScrollbar</li>
</ol>
<p>其它：<br><a href="http://www.alloyteam.com/2012/05/perfect-custom-scrollbar/" target="_blank" rel="noopener">完美的自定义滚动条</a><br>为何称之为完美呢？只因其具有以下优点：    </p>
<ol>
<li>兼容所有浏览器。</li>
<li>支持所有鼠标事件，包括长按。</li>
<li>样式可以完全自定义。</li>
<li>使用该组件无需改动原来的任何代码，也不要求原来的元素使用什么定位方式。</li>
<li>只需引进一两个js文件，再添加一句代码即可</li>
</ol>
<h2 id="判断方向"><a href="#判断方向" class="headerlink" title="判断方向"></a>判断方向</h2><p># <a href="http://zccst.iteye.com/blog/2197139" target="_blank" rel="noopener">croll时判断向下滚动还是向上滚动</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function()&#123;  </span><br><span class="line">    var p=0,t=0;  </span><br><span class="line">    $(window).scroll(function(e)&#123;  </span><br><span class="line">            p = $(this).scrollTop();  </span><br><span class="line">            if(t&lt;=p)&#123;//下滚  </span><br><span class="line">                .......  </span><br><span class="line">            &#125;  </span><br><span class="line">            else&#123;//上滚  </span><br><span class="line">                .......  </span><br><span class="line">            &#125;  </span><br><span class="line">            setTimeout(function()&#123;t = p;&#125;,0);         </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="是否滚动到底"><a href="#是否滚动到底" class="headerlink" title="是否滚动到底"></a>是否滚动到底</h2><p># <a href="https://www.haorooms.com/post/jquery_scroll_upanddown" target="_blank" rel="noopener">[jquery判断页面滚动条(scroll)是上滚还是下滚，且是否滚动到头部或者底部]</a>    </p>
<p>## 项目背景<br>webtouch（webapp）页面，防苹果手机safari浏览器，网上滑动，底部导航消失，滑动到底部又出现。向下滑动，底部导航出现。<br><strong>$_PS:</strong> 和/mobile 项目有点类似  </p>
<p>## 遇到问题<br>1、我一开始用swipeup和swipedown来做，发现因为有滚动条，不会触发。因此只能判断滚动条是上滚下滚等。关于手机手势，后面的文章会介绍，欢迎关注！<br>2、通过上滚下滚来让底部导航显示或者因此，安卓上面的浏览器都可以，但是苹果safari会一闪一闪，原因是苹果safari自动有个弹跳效果，导致事件重复执行，解决办法是给上滚下滚一个距离，滚动到一定距离后返回是上滚还是下滚。</p>
<p>## 单纯判断滚动条方向<br>以上方法手机苹果浏览器事件会跳动，解决方法及代码改进<br>滚动条滚动到底部和头部判断<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BottomJumpPage: function () &#123;</span><br><span class="line">    var scrollTop = $(this).scrollTop();</span><br><span class="line">    var scrollHeight = $(document).height();</span><br><span class="line">    var windowHeight = $(this).height();</span><br><span class="line">    if (scrollTop + windowHeight == scrollHeight) &#123;  //滚动到底部执行事件</span><br><span class="line">            console.dir(&quot;我到底部了&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">    if (scrollTop == 0) &#123;  //滚动到头部部执行事件</span><br><span class="line">        console.dir(&quot;我到头部了&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>## 判断div是否滚动到底部<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $(document).ready(function ()&#123;</span><br><span class="line">    var nScrollHight = 0; //滚动距离总长(注意不是滚动条的长度)</span><br><span class="line">    var nScrollTop = 0;   //滚动到的当前位置</span><br><span class="line">    var nDivHight = $(&quot;#div1&quot;).height();</span><br><span class="line">    $(&quot;#div1&quot;).scroll(function()&#123;</span><br><span class="line">        nScrollHight = $(this)[0].scrollHeight;</span><br><span class="line">        nScrollTop = $(this)[0].scrollTop;</span><br><span class="line">        if(nScrollTop + nDivHight &gt;= nScrollHight)</span><br><span class="line">        alert(&quot;滚动条到底部了&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p># <a href="https://www.jianshu.com/p/4c37a2a56586" target="_blank" rel="noopener">原生js——获取滚动条的高度</a>   </p>
<h2 id="浏览器获取滚动条高度的方法"><a href="#浏览器获取滚动条高度的方法" class="headerlink" title="浏览器获取滚动条高度的方法"></a>浏览器获取滚动条高度的方法</h2><p>浏览器  API<br>IE6/7/8   document.documentElement.scrollTop<br>IE9及以上   window.pageYOffset 或者 document.documentElement.scrollTop<br>Safari      window.pageYOffset或者document.body.scrollTop<br>Firefox     window.pageYOffset 或者 document.documentElement.scrollTop<br>Chrome  document.documentElement.scrollTop  </p>
<p>## 备注    </p>
<ul>
<li>很多技术博客上面说Chrome只能使用document.body.scrollTop来获取滚动条的高度。</li>
<li>但是我在测试的时候发现，Chrome不能使用document.body.scrollTop，只能使用document.documentElement.scrollTop来获取滚动条的高度。<br>如果使用document.body.scrollTop，那么所获得的数值始终是0。</li>
<li>不过大家不用国语在意这一点，我们直接封装一个函数来获取滚动条的高度即可。      </li>
</ul>
<p>## 封装获取滚动条高度的函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scroll_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="built_in">document</span>.documentElement.scrollTop) &#123;</span><br><span class="line">        scroll_top = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">        scroll_top = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scroll_top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p># <a href="https://www.jb51.net/article/42744.htm" target="_blank" rel="noopener">[判断滚动条到底部的JS代码]</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滚动条在Y轴上的滚动距离</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> scrollTop = <span class="number">0</span>, bodyScrollTop = <span class="number">0</span>, documentScrollTop = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.body)&#123;</span><br><span class="line">　　　　bodyScrollTop = <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.documentElement)&#123;</span><br><span class="line">　　　　documentScrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollTop = (bodyScrollTop - documentScrollTop &gt; <span class="number">0</span>) ? bodyScrollTop : documentScrollTop;</span><br><span class="line">　　<span class="keyword">return</span> scrollTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文档的总高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollHeight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> scrollHeight = <span class="number">0</span>, bodyScrollHeight = <span class="number">0</span>, documentScrollHeight = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.body)&#123;</span><br><span class="line">　　　　bodyScrollHeight = <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.documentElement)&#123;</span><br><span class="line">　　　　documentScrollHeight = <span class="built_in">document</span>.documentElement.scrollHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; <span class="number">0</span>) ? bodyScrollHeight : documentScrollHeight;</span><br><span class="line">　　<span class="keyword">return</span> scrollHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浏览器视口的高度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWindowHeight</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> windowHeight = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">　　　　windowHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　windowHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> windowHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">if</span>(getScrollTop() + getWindowHeight() == getScrollHeight())&#123;</span><br><span class="line">　　　　alert(<span class="string">"you are in the bottom!"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>## mobile/common.php:is_scrolled_bottom 函数</p>
<h2 id="自动滚动到底部"><a href="#自动滚动到底部" class="headerlink" title="自动滚动到底部"></a>自动滚动到底部</h2><p># <a href="http://zzc1684.iteye.com/blog/2171371" target="_blank" rel="noopener">[到最底部 - 4种方法]</a><br>方法一：<br>使用锚标记要滚动到的位置，然后通过click方法模拟点击滚动到锚所在位置<br>方法二：<br>利用DIV的scrollIntoView方法，将最底端滚动到可视位置<br>方法三：<br>scrollTop<br>方法4：<br>这个比较复杂也比较灵活一点，就是利用DIV+JS+图片构造一个滚动条，当然了图片是怎么好看怎么用了。<br>主要部分就是外层的DIV加个overflow:hidden属性，通过js代码调整内层DIV的margin-left和margin-top来控制内容的滚动，由于上面两种方法已经可以满足需求，所以这种方法没具体做深究，有兴趣的可以试一下  </p>
<p>其它：<br><a href="https://juejin.im/entry/5a9a7fcdf265da23866f5885" target="_blank" rel="noopener">实现一个自定义滚动条</a><br><a href="http://www.cnblogs.com/fengyuqing/p/javascript_scrollbar.html" target="_blank" rel="noopener">javascript自定义滚动条插件，几行代码的事儿</a><br><a href="https://blog.csdn.net/qq_28602957/article/details/72551708" target="_blank" rel="noopener">【JQuery】HTML自定义滚动条（mCustomScrollbar）</a><br><a href="https://www.jb51.net/article/73905.htm" target="_blank" rel="noopener">JS实现的页面自定义滚动条效果</a>    </p>
<h2 id="禁止滚动"><a href="#禁止滚动" class="headerlink" title="禁止滚动"></a>禁止滚动</h2><p>参考：<br><a href="https://blog.csdn.net/qq_35697034/article/details/78095760" target="_blank" rel="noopener">jquery 禁止滚动条滚动，并且滚动条不消失，页面大小不变</a><br><a href="https://segmentfault.com/q/1010000000523273" target="_blank" rel="noopener">JavaScript如何屏蔽页面的滚动？</a>   </p>
<ol>
<li>阻止所有能导致页面滚动的事件。 //scroll不能阻止，只能阻止mousewheel，鼠标拽滚动条就悲剧了</li>
<li>body overflow:hidden //win下右侧滚动条会消失导致页面横移，移动端阻止不了</li>
<li>把滚动部分单独放在一个div里，和弹出部分同级，body和window同高。 //所有涉及offset/scrollTop的方法都要修改。fix并且width100%的元素(比如微博顶栏)会压在内容区滚动条上</li>
<li>弹出时算scrollTop，给内容区fix然后top移动到目前位置，同时body给一个overflow-y:scroll强撑出滚动条</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top = $(<span class="built_in">document</span>).scrollTop();</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'scroll.unable'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        $(<span class="built_in">document</span>).scrollTop(top);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeUnScroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="built_in">document</span>).unbind(<span class="string">"scroll.unable"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 scroll/mousewheel</span></span><br><span class="line">handler = (event) -&gt; event.preventDefault()</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'mousewheel'</span>, handler)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">document</span>.body.removeEventListener(<span class="string">'mousewheel'</span>, handler), <span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//0 页面滚动条消失，页面大小会变</span></span><br><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'overflow'</span>,<span class="string">'hidden'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**********************  Start with disable/enable scroll function  **********************</span></span><br><span class="line"><span class="comment">// left: 37, up: 38, right: 39, down: 40,</span></span><br><span class="line"><span class="comment">// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = [<span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventDefault</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">if</span> (e.preventDefault)</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    e.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keydown</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = keys.length; i--;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.keyCode === keys[i]) &#123;</span><br><span class="line">            preventDefault(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wheel</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    preventDefault(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disable_scroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'DOMMouseScroll'</span>, wheel, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.onmousewheel = <span class="built_in">document</span>.onmousewheel = wheel;</span><br><span class="line">    <span class="built_in">document</span>.onkeydown = keydown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enable_scroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.removeEventListener) &#123;</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(<span class="string">'DOMMouseScroll'</span>, wheel, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.onmousewheel = <span class="built_in">document</span>.onmousewheel = <span class="built_in">document</span>.onkeydown = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端Tap事件学习</title>
    <url>/sum/js/%E7%A7%BB%E5%8A%A8%E7%AB%AFtap%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0(071)/</url>
    <content><![CDATA[<a id="more"></a>
<p># [从移动端 click 到摇一摇]<br>以前听到前辈们说移动端尽量不要使用click，click会比较迟钝，能用touchstart还是用touchstart。但是用touchstart会有一个问题，用户在滑动页面的时候要是不小心碰到了相关元素也会触发touchstart，所以两者都有缺点。那怎么办呢？</p>
<p>首先为什么移动端的click会迟钝呢？从谷歌的开发者文档《300ms tap delay, gone away》可以找到答案：<br>大意是说因为移动端要判断是否是双击，所以单击之后不能够立刻触发click，要等300ms，直到确认不是双击了才触发click。所以就导致了click有延迟。</p>
<p>### 1<br>更为重要的是，文档里面还提到在2014年的Chrome 32版本已经把这个延迟去掉了，如果有一个meta标签：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code><br>即把viewport设置成设备的实际像素，那么就不会有这300ms的延迟，并且这个举动受到了IE/Firefox/Safari(IOS 9.3)的支持，也就是说现在的移动端开发可以不用顾虑click会比较迟钝的问题。  </p>
<p>### 2<br>如果设置initial-scale=1.0，在chrome上是可以生效，但是Safari不会：<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0&quot;&gt;</code></p>
<p>### 3<br>还有第三种办法就是设置CSS：<br><code>html{touch-action:manipulation;}</code><br>这样也可以取消掉300ms的延迟，Chrome和Safari都可以生效。</p>
<h2 id="1-click-touch触发顺序"><a href="#1-click-touch触发顺序" class="headerlink" title="1. click/touch触发顺序"></a>1. click/touch触发顺序</h2><p>1. 可以看到click事件是在最后触发的，并且还看到300ms的延迟，实际的执行延迟要比这个大，因为浏览器的内核运行也需要消耗时间。</p>
<p>2. 现在加上viewport的meta标签，再观察结果，如下图所示：<br>可以看到，300ms的延迟没有了。</p>
<p>知道了click是在touchend之后触发的，现在我们来尝试一下实现一个tap事件。</p>
<h2 id="2-tap事件的实现"><a href="#2-tap事件的实现" class="headerlink" title="2. tap事件的实现"></a>2. tap事件的实现</h2><p>一个是zepto，另一个是fastclick<br>zepto有一个自定义事件tap，它是一个没有延迟的click事件。<br>而fastclick是在touchend之后生成一个click事件，并立即触发这个click，再取消原本的click事件。   </p>
<p>这两者的原理都是一样的，都是在touchend之后触发，一个是触发它自己定义的tap事件，一个是触发原生click。</p>
<p>所以怎么判定用户是点击还是在上下滑呢？<br>Zepto是用的位移偏差， 如果这个差值在30以内<br>而fastclick是用的时间偏差，分别记录touchstart和touchend的时间戳，如果它们的时间差大于700毫秒，<br>Chromium的源码，它里面封装了一些移动端的手势实现如tap，tap是根据时间位移判断是否要触发tap，</p>
<h2 id="3-摇一摇事件"><a href="#3-摇一摇事件" class="headerlink" title="3. 摇一摇事件"></a>3. 摇一摇事件</h2><p>html5新增了一个devicemotion的事件，可以使用手机的重力感应。如下代码所示：<br>window.ondevicemotion=function(event){<br>    vargravity=event.accelerationIncludingGravity;<br>    console.log(gravity.x,gravity.y,gravity.z);<br>}<br>当然判断是否摇一摇的算法不止上面一个，你还可以想出其它更好的方法。</p>
<h2 id="十行代码实现的studiotap事件"><a href="#十行代码实现的studiotap事件" class="headerlink" title="十行代码实现的studiotap事件"></a>十行代码实现的studiotap事件</h2><p><strong>$_PS:</strong> 十行代码自定义移动端tap事件，看源码感觉哪里有些不对:hasClass是什么鬼<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # Z 十行代码自定义移动端tap事件</span></span><br><span class="line">$$(<span class="built_in">document</span>).on(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!$$(e.target).hasClass(<span class="string">"disable"</span>)) </span><br><span class="line">    $$(e.target).data(<span class="string">"isMoved"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$$(<span class="built_in">document</span>).on(<span class="string">"touchmove"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!$$(e.target).hasClass(<span class="string">"disable"</span>)) </span><br><span class="line">    $$(e.target).data(<span class="string">"isMoved"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$$(<span class="built_in">document</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!$$(e.target).hasClass(<span class="string">"disable"</span>) &amp;&amp; $$(e.target).data(<span class="string">"isMoved"</span>) == <span class="number">0</span>) </span><br><span class="line">    $$(e.target).trigger(<span class="string">"tap"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// # 使用</span></span><br><span class="line"><span class="comment">// ? but，ipad中click事件会延迟200ms 触发， 同时还触发了tap </span></span><br><span class="line"><span class="comment">// 还要防止videojs中的冒泡事件  </span></span><br><span class="line">$$(<span class="string">'#div_video'</span>).on(<span class="string">'click tap'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e=e||event;<span class="comment">// for chrome which is diff from firefox</span></span><br><span class="line">    <span class="keyword">if</span>(e.target.parentElement.parentElement==<span class="keyword">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动设备软键盘操作</title>
    <url>/sum/js/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%BD%AF%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C(072)/</url>
    <content><![CDATA[<h2 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h2><p>全屏的时候也需要输入，无法获得输入框的高度；功能上不能把input放顶端，包括非全屏的时候不在顶端<br>假的input框需要计算位置/获取光标/文本内容/控制显示等     </p>
<p>故：<br>非全屏的时候，利用移动设备原生功能scorllIntoView自己滚动；没有做处理。<br>全屏的时候，获取焦点后设置输入框位置到顶端；失去焦点后再去除顶端位置的className<br>不是很漂亮的地方：input很容易失去焦点，以致input的位置来回移动     </p>
<p>需要利用移动设备的输入功能，包括不同地区的语言/表情/数字/输入法等，模拟移动键盘是想得多了。<br>后：colleague利用全屏时逻辑改动非全屏时，整个聊天区域到直播区，以防止直播内容被顶出视窗。失去焦点设置iframe返回原位置<br><!-- （个人认为有点多余） --></p>
<p># js对手机软键盘的监听<br>原文: <a href="http://www.cnblogs.com/hefenghefeng/p/7003152.html" target="_blank" rel="noopener">http://www.cnblogs.com/hefenghefeng/p/7003152.html</a>   </p>
<p>js还没有办法对手机软键盘直接进行监听的，但是可以有其他角度来判断软键盘是否弹起。比如输入框是否获取焦点等。</p>
<h2 id="ios-focusin和focusout"><a href="#ios-focusin和focusout" class="headerlink" title="ios: focusin和focusout"></a>ios: focusin和focusout</h2><p>focusin和focusout支持冒泡，对应focus和blur,<br>使用focusin和focusout的原因是focusin和focusout可以冒泡，focus和blur不会冒泡，这样就可以使用事件代理，处理多个输入框存在的情况。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusin'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//软键盘弹出的事件处理</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'focusout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//软键盘收起的事件处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="android-window-resize"><a href="#android-window-resize" class="headerlink" title="android: window resize"></a>android: window resize</h2><p>但是，实际中发现这种方法仅在ios上有效，键盘弹出和键盘收起与输入框的focusin和focusout一一对应。<br>在android中，点击键盘上的收起按钮，键盘虽然收起了，输入框仍然处于焦点状态，并没有触发focusout事件。</p>
<p>经实践，发现一种变通的方法。通过比较window resize后的clientHeight与最初进来页面时的clientHeight进行对比，如果小于最初的值，那么就可以认为是键盘弹出，否则，认为键盘收起。</p>
<p>在android中键盘弹出和收起会改变window的高度，因此监听window的resiz<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clientHeight = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nowClientHeight = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    <span class="keyword">if</span> (clientHeight &gt; nowClientHeight) &#123;</span><br><span class="line">        <span class="comment">//键盘弹出的事件处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//键盘收起的事件处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>或许有人问，ios为什么不用android的解决方式呢？因为ios的第三方键盘可能并不会导致window resize，所以无效。</p>
<p>附一张移动端webview对focusin、focusout的支持情况。</p>
<p># <a href="http://www.alloyteam.com/2017/03/moves-the-input-box-fill-series-a/" target="_blank" rel="noopener">[移动端输入框填坑系列一]</a><br>## textarea置底展示问题-获取高度，设置假input的位置</p>
<p>可以看出，键盘会将页面顶上去。那么如果希望可以将输入框和键盘完全贴合，我们可以使用div模拟一个假的输入框，使用定位将真正的输入框隐藏掉，当点击假的输入框的时候，将真正的输入框定位到键盘上方，并且手动获取输入框焦点。</p>
<p>在实现过程中需要注意下面几个问题：<br>1、真正的输入框的位置计算：<br>2、在ios下手动获取焦点不可以用click事件，需要使用tap事件才可以手动触发<br>3、当键盘收起的时候我们需要将真输入框再次隐藏掉，除了使用失去焦点（blur）方法，还有什么方法可以判断键盘是否收起呢？<br>4、因为textarea中的文字不能置底显示，当输入超过一行textarea需要自动调整高度   </p>
<p><strong>$_PS:</strong> 假input的有点复杂，有许多问题需要注意，没有上面的简单直接</p>
<p># [ 如何用 js 获取虚拟键盘高度？（适用所有平台）]  </p>
<h2 id="软键盘把输入框遮挡"><a href="#软键盘把输入框遮挡" class="headerlink" title="软键盘把输入框遮挡"></a>软键盘把输入框遮挡</h2><p>1. 第一个是通过把 input 布局尽量放在页面顶部，显然这个不是我们想要的，否决掉<br>2. 把 input 放在最底部，用来完成 footer 固定的效果，但是要局限页面高度不超过窗口高度，我们可以通过自制滚动控件来解除这个限制，那现在需要解决的技术点就变为实现一个模拟滚动控件<br>3. 通过比对软键盘弹出前后的 window.innerHeight 的高度差来得到键盘高度，从而根据这个高度来实现底部定位和输入剧中，但是该方法局限于不同设备平台的支持</p>
<p>### 针对 第二种方案 的限制<br>输入框定位在页面的最底部，当软键盘弹起时整个视图窗口页面向上卷动，到达最底部时停止。<br>这是因为当你首次 fouse 到输入框的时候软键盘弹出，浏览器会使页面会向上滚动，以确保 input 是可见的，该特性和 document.body.scrollIntoViewIfNeeded 方法是一致的，</p>
<p>1. 但是当你 body 的可滚动高度超过窗口高度时还会产生另一个问题：固定元素将随页面滚动 如下图:<br>因此浏览器关心的只是 input 是否被覆盖？实际上是 input 中的光标位置！那么这就解释了为什么输入框在底部的时候刚好勉强完成了，因为 input 在页面的底部时，软键盘弹出势必会遮挡住 input，因而浏览器会向上滚动至输入框可见的位置。</p>
<p>2. 但是如下图的效果这样就无法做到了，因为在输入框的下面还有一行工具栏，也就是说输入框并非在最底部的位置，那么浏览器在滚动到可视位置时只会确保到 input 可见，而对于工具栏是否可见则并不在浏览器的考虑范围内。</p>
<p>## IOING 的解决方案分析</p>
<p>## 用js 获取键盘高度的方法<br><strong>$_PS:</strong> andriod试过，没有这些个API<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//键盘弹起时为键盘高度，未弹起时为0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.keyboard.height)</span><br><span class="line"><span class="comment">// 通过键盘弹起事件获取</span></span><br><span class="line"><span class="built_in">window</span>.on(<span class="string">'keyboardup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.height)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 键盘收起事件</span></span><br><span class="line"><span class="built_in">window</span>.on(<span class="string">'keyboarddown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.height) <span class="comment">// 0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p># [移动端H5输入框、光标、数字键盘全假套件实现]</p>
<p>其它:<br><a href="https://www.zhihu.com/question/32746176" target="_blank" rel="noopener">移动web页面，input获取焦点弹出系统虚拟键盘时，挡住input，求解决方案？</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO必知必会51技</title>
    <url>/pdf/opti/SEO%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A51%E6%8A%80/</url>
    <content><![CDATA[<p>toc only.</p>
<p style="text-align:right">2018.6.11 一 00:03 </p>

<p>2018.4.30-5.1 读<br>人民邮电   2010.6  P255</p>
<h2 id="第1部分-搜素引擎的基本知识"><a href="#第1部分-搜素引擎的基本知识" class="headerlink" title="第1部分 搜素引擎的基本知识"></a>第1部分 搜素引擎的基本知识</h2><h3 id="1-获得蜘蛛、机器人和爬虫的关注"><a href="#1-获得蜘蛛、机器人和爬虫的关注" class="headerlink" title="1 获得蜘蛛、机器人和爬虫的关注"></a>1 获得蜘蛛、机器人和爬虫的关注</h3><h3 id="2-学会与Google共舞"><a href="#2-学会与Google共舞" class="headerlink" title="2 学会与Google共舞"></a>2 学会与Google共舞</h3><h3 id="3-流量？不，是有价值的流量"><a href="#3-流量？不，是有价值的流量" class="headerlink" title="3 流量？不，是有价值的流量"></a>3 流量？不，是有价值的流量</h3><h3 id="4-网上有你的口碑"><a href="#4-网上有你的口碑" class="headerlink" title="4 网上有你的口碑"></a>4 网上有你的口碑</h3><h2 id="第2部分-让站点脱颖而出"><a href="#第2部分-让站点脱颖而出" class="headerlink" title="第2部分 让站点脱颖而出"></a>第2部分 让站点脱颖而出</h2><h3 id="5-SEO是一个持续性工程，千万别做完了就扔在那"><a href="#5-SEO是一个持续性工程，千万别做完了就扔在那" class="headerlink" title="5 SEO是一个持续性工程，千万别做完了就扔在那"></a>5 SEO是一个持续性工程，千万别做完了就扔在那</h3><h3 id="6-SEO不是马后炮"><a href="#6-SEO不是马后炮" class="headerlink" title="6 SEO不是马后炮"></a>6 SEO不是马后炮</h3><h3 id="7-SEO效果不是马上生效，也不是持久不变"><a href="#7-SEO效果不是马上生效，也不是持久不变" class="headerlink" title="7 SEO效果不是马上生效，也不是持久不变"></a>7 SEO效果不是马上生效，也不是持久不变</h3><h3 id="8-你不再有主页"><a href="#8-你不再有主页" class="headerlink" title="8 你不再有主页"></a>8 你不再有主页</h3><h3 id="9-就算不是出版商，你也要像他们一样思考"><a href="#9-就算不是出版商，你也要像他们一样思考" class="headerlink" title="9 就算不是出版商，你也要像他们一样思考"></a>9 就算不是出版商，你也要像他们一样思考</h3><h3 id="10-网站和网页设计盘点"><a href="#10-网站和网页设计盘点" class="headerlink" title="10 网站和网页设计盘点"></a>10 网站和网页设计盘点</h3><h3 id="11-为用户撰写内容，搜索引擎随之而至"><a href="#11-为用户撰写内容，搜索引擎随之而至" class="headerlink" title="11 为用户撰写内容，搜索引擎随之而至"></a>11 为用户撰写内容，搜索引擎随之而至</h3><h3 id="12-关键字才是关键"><a href="#12-关键字才是关键" class="headerlink" title="12 关键字才是关键"></a>12 关键字才是关键</h3><h3 id="13-使用关键字分析和研究工具"><a href="#13-使用关键字分析和研究工具" class="headerlink" title="13 使用关键字分析和研究工具"></a>13 使用关键字分析和研究工具</h3><h3 id="14-网站统计也会带来坏消息"><a href="#14-网站统计也会带来坏消息" class="headerlink" title="14 网站统计也会带来坏消息"></a>14 网站统计也会带来坏消息</h3><h3 id="15-对新技术要三思而后行"><a href="#15-对新技术要三思而后行" class="headerlink" title="15 对新技术要三思而后行"></a>15 对新技术要三思而后行</h3><h3 id="16-内容管理系统的问题多多"><a href="#16-内容管理系统的问题多多" class="headerlink" title="16 内容管理系统的问题多多"></a>16 内容管理系统的问题多多</h3><h2 id="第3部分-这就是奇妙的标签"><a href="#第3部分-这就是奇妙的标签" class="headerlink" title="第3部分 这就是奇妙的标签"></a>第3部分 这就是奇妙的标签</h2><h3 id="17-标题中有什么？所有……"><a href="#17-标题中有什么？所有……" class="headerlink" title="17 标题中有什么？所有……"></a>17 标题中有什么？所有……</h3><h3 id="18-元标签的相对重要性"><a href="#18-元标签的相对重要性" class="headerlink" title="18 元标签的相对重要性"></a>18 元标签的相对重要性</h3><h3 id="19-图像、音频、视频和其他媒体的标签问题"><a href="#19-图像、音频、视频和其他媒体的标签问题" class="headerlink" title="19 图像、音频、视频和其他媒体的标签问题"></a>19 图像、音频、视频和其他媒体的标签问题</h3><h2 id="第4部分-关于链接"><a href="#第4部分-关于链接" class="headerlink" title="第4部分 关于链接"></a>第4部分 关于链接</h2><h3 id="20-相同的链接在搜索引擎面前会出现不同的结果"><a href="#20-相同的链接在搜索引擎面前会出现不同的结果" class="headerlink" title="20 相同的链接在搜索引擎面前会出现不同的结果"></a>20 相同的链接在搜索引擎面前会出现不同的结果</h3><h3 id="21-通过目录网站建立链接"><a href="#21-通过目录网站建立链接" class="headerlink" title="21 通过目录网站建立链接"></a>21 通过目录网站建立链接</h3><h3 id="22-将SEO公共关系做为链接策略"><a href="#22-将SEO公共关系做为链接策略" class="headerlink" title="22 将SEO公共关系做为链接策略"></a>22 将SEO公共关系做为链接策略</h3><h3 id="23-付费链接"><a href="#23-付费链接" class="headerlink" title="23 付费链接"></a>23 付费链接</h3><h3 id="24-交换链接"><a href="#24-交换链接" class="headerlink" title="24 交换链接"></a>24 交换链接</h3><h3 id="25-广告也是链接"><a href="#25-广告也是链接" class="headerlink" title="25 广告也是链接"></a>25 广告也是链接</h3><h3 id="26-让您的网站择邻而居"><a href="#26-让您的网站择邻而居" class="headerlink" title="26 让您的网站择邻而居"></a>26 让您的网站择邻而居</h3><h3 id="27-博客是巧妙的链接策略"><a href="#27-博客是巧妙的链接策略" class="headerlink" title="27 博客是巧妙的链接策略"></a>27 博客是巧妙的链接策略</h3><h3 id="28-关于nofollow"><a href="#28-关于nofollow" class="headerlink" title="28 关于nofollow"></a>28 关于nofollow</h3><h2 id="第5部分-那些也是搜索引擎吗"><a href="#第5部分-那些也是搜索引擎吗" class="headerlink" title="第5部分 那些也是搜索引擎吗"></a>第5部分 那些也是搜索引擎吗</h2><h3 id="29-搜索正在垂直化"><a href="#29-搜索正在垂直化" class="headerlink" title="29 搜索正在垂直化"></a>29 搜索正在垂直化</h3><h3 id="30-本地搜素"><a href="#30-本地搜素" class="headerlink" title="30 本地搜素"></a>30 本地搜素</h3><h3 id="31-目录网站提交"><a href="#31-目录网站提交" class="headerlink" title="31 目录网站提交"></a>31 目录网站提交</h3><h3 id="32-站外搜索引擎优化"><a href="#32-站外搜索引擎优化" class="headerlink" title="32 站外搜索引擎优化"></a>32 站外搜索引擎优化</h3><h3 id="33-通过搜索和个性化搜索"><a href="#33-通过搜索和个性化搜索" class="headerlink" title="33 通过搜索和个性化搜索"></a>33 通过搜索和个性化搜索</h3><h2 id="第6部分-你生活在社交网络中"><a href="#第6部分-你生活在社交网络中" class="headerlink" title="第6部分 你生活在社交网络中"></a>第6部分 你生活在社交网络中</h2><h3 id="34-为搜索引擎优化建立博客"><a href="#34-为搜索引擎优化建立博客" class="headerlink" title="34 为搜索引擎优化建立博客"></a>34 为搜索引擎优化建立博客</h3><h3 id="35-使用RSS-feeds来提升搜索引擎优化工作效果"><a href="#35-使用RSS-feeds来提升搜索引擎优化工作效果" class="headerlink" title="35 使用RSS feeds来提升搜索引擎优化工作效果"></a>35 使用RSS feeds来提升搜索引擎优化工作效果</h3><h3 id="36-让用户为你创建内容"><a href="#36-让用户为你创建内容" class="headerlink" title="36 让用户为你创建内容"></a>36 让用户为你创建内容</h3><h3 id="37-为图像、视频、链接和其他媒体打上标签"><a href="#37-为图像、视频、链接和其他媒体打上标签" class="headerlink" title="37 为图像、视频、链接和其他媒体打上标签"></a>37 为图像、视频、链接和其他媒体打上标签</h3><h2 id="第7部分-搜索排名"><a href="#第7部分-搜索排名" class="headerlink" title="第7部分 搜索排名"></a>第7部分 搜索排名</h2><h3 id="38-排名第一的悄然改变"><a href="#38-排名第一的悄然改变" class="headerlink" title="38 排名第一的悄然改变"></a>38 排名第一的悄然改变</h3><h3 id="39-PageRank不是关系网站生死存亡的关键因素"><a href="#39-PageRank不是关系网站生死存亡的关键因素" class="headerlink" title="39 PageRank不是关系网站生死存亡的关键因素"></a>39 PageRank不是关系网站生死存亡的关键因素</h3><h3 id="40-摇摆的长尾"><a href="#40-摇摆的长尾" class="headerlink" title="40 摇摆的长尾"></a>40 摇摆的长尾</h3><h2 id="第8部分-关于SEO管理"><a href="#第8部分-关于SEO管理" class="headerlink" title="第8部分 关于SEO管理"></a>第8部分 关于SEO管理</h2><h3 id="41-内部维护还是外包"><a href="#41-内部维护还是外包" class="headerlink" title="41 内部维护还是外包"></a>41 内部维护还是外包</h3><h3 id="42-雇用一名优秀i的搜索专家"><a href="#42-雇用一名优秀i的搜索专家" class="headerlink" title="42 雇用一名优秀i的搜索专家"></a>42 雇用一名优秀i的搜索专家</h3><h3 id="43-优秀的SEO应该注重细节的东西"><a href="#43-优秀的SEO应该注重细节的东西" class="headerlink" title="43 优秀的SEO应该注重细节的东西"></a>43 优秀的SEO应该注重细节的东西</h3><h2 id="第9部分-不作恶"><a href="#第9部分-不作恶" class="headerlink" title="第9部分 不作恶"></a>第9部分 不作恶</h2><h3 id="44-小心黑帽搜索引擎优化"><a href="#44-小心黑帽搜索引擎优化" class="headerlink" title="44 小心黑帽搜索引擎优化"></a>44 小心黑帽搜索引擎优化</h3><h3 id="45-搜索引擎对关键词堆砌和垃圾广告不“感冒”"><a href="#45-搜索引擎对关键词堆砌和垃圾广告不“感冒”" class="headerlink" title="45 搜索引擎对关键词堆砌和垃圾广告不“感冒”"></a>45 搜索引擎对关键词堆砌和垃圾广告不“感冒”</h3><h3 id="46-不要建立链接工厂"><a href="#46-不要建立链接工厂" class="headerlink" title="46 不要建立链接工厂"></a>46 不要建立链接工厂</h3><h3 id="47-想取消屏蔽是很难的"><a href="#47-想取消屏蔽是很难的" class="headerlink" title="47 想取消屏蔽是很难的"></a>47 想取消屏蔽是很难的</h3><h3 id="48-换到新域名将面临一定的压力"><a href="#48-换到新域名将面临一定的压力" class="headerlink" title="48 换到新域名将面临一定的压力"></a>48 换到新域名将面临一定的压力</h3><h2 id="第10部分-除此之外"><a href="#第10部分-除此之外" class="headerlink" title="第10部分 除此之外"></a>第10部分 除此之外</h2><h3 id="49-全球搜索引擎优化"><a href="#49-全球搜索引擎优化" class="headerlink" title="49 全球搜索引擎优化"></a>49 全球搜索引擎优化</h3><h3 id="50-移动SEO比以往更重要"><a href="#50-移动SEO比以往更重要" class="headerlink" title="50 移动SEO比以往更重要"></a>50 移动SEO比以往更重要</h3><h3 id="51-有时候你并不希望被找到"><a href="#51-有时候你并不希望被找到" class="headerlink" title="51 有时候你并不希望被找到"></a>51 有时候你并不希望被找到</h3>]]></content>
      <categories>
        <category>pdf</category>
        <category>opti</category>
      </categories>
  </entry>
  <entry>
    <title>代码整洁之道</title>
    <url>/pdf/opti/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>不用针对特定语言；<br>通类；<br>不全，只有P60；<br>看看目录就好了     </p>
<a id="more"></a>
<h2 id="第-1-章-整洁代码-1"><a href="#第-1-章-整洁代码-1" class="headerlink" title="第 1 章  整洁代码. 1"></a>第 1 章  整洁代码. 1</h2><p>1.1  要有代码. .2<br>1.2  糟糕的代码 2<br>1.3  混乱的代价 3<br>    1.3.1  华丽新设计4<br>    1.3.2  态度. . 4<br>    1.3.3  迷题. . 5<br>    1.3.4  整洁代码的艺术. 5<br>    1.3.5  什么是整洁代码. 6<br>1.4  思想流派10<br>1.5  我们是作者. 11<br>1.6  童子军军规. 12<br>1.7  前传与原则. 12<br>1.8  小结. . 12<br>1.9  文献. . 13    </p>
<h2 id="第-2-章-有意义的命名15"><a href="#第-2-章-有意义的命名15" class="headerlink" title="第 2 章  有意义的命名15"></a>第 2 章  有意义的命名15</h2><p>2.1  介绍. 15<br>2.2  名副其实16<br>2.3  避免误导17<br>2.4  做有意义的区分 18<br>2.5  使用读得出来的名称.19<br>2.6  使用可搜索的名称 20<br>2.7  避免使用编码.  21<br>    2.7.1  匈牙利语标记法. 21<br>    2.7.2  成员前缀 21<br>    2.7.3  接口和实现. 22<br>2.8  避免思维映射. 22<br>2.9   类名. 23<br>2.10  方法名 23<br>2.11  别扮可爱 23<br>2.12  每个概念对应一个词. 24<br>2.13  别用双关语. 24<br>2.14  使用解决方案领域名称 25<br>2.15  使用源自所涉问题领域的名称. 25<br>2.16  添加有意义的语境 25<br>2.17  不要添加没用的语境. 27<br>2.18  最后的话 27    </p>
<h2 id="第-3-章-函数-29"><a href="#第-3-章-函数-29" class="headerlink" title="第 3 章  函数 29"></a>第 3 章  函数 29</h2><p>3.1  短小 32<br>3.2  只做一件事 33<br>3.3  每个函数一个抽象层级. 34<br>3.4  switch 语句 35<br>3.5  使用描述性的名称. 36<br>3.6  函数参数 37<br>    3.6.1  一元函数的普遍形式. 38<br>    3.6.2  标识参数 38<br>    3.6.3  二元函数 38<br>    3.6.4  三元函数 39<br>    3.6.5  参数对象 39<br>    3.6.6  参数列表 40<br>    3.6.7  动词与关键字 40<br>3.7  无副作用 40<br>3.8  分隔指令与询问 42<br>3.9  使用异常替代返回错误码 42<br>    3.9.1  抽离 Try/Catch 代码块. 43<br>    3.9.2  错误处理就是一件事. 44<br>    3.9.3  Error.java 依赖磁铁. 44<br>3.10  别重复自己. 44<br>3.11  结构化编程. 45<br>3.12  如何写出这样的函数. 45<br>3.13  小结. 45<br>3.14  SetupTeardownIncluder 程序. 46<br>3.15  文献. 48    </p>
<h2 id="第-4-章-注释-49"><a href="#第-4-章-注释-49" class="headerlink" title="第 4 章  注释 49"></a>第 4 章  注释 49</h2><p>4.1  注释不能美化糟糕的代码 50<br>4.2  用代码来阐述. 51<br>4.3  好注释. 51<br>    4.3.1  法律信息 51<br>    4.3.2  提供信息的注释. 51<br>    4.3.3  对意图的解释 52<br>    4.3.4  阐释 53<br>    4.3.5  警示 53<br>    4.3.6  TODO 注释. 54<br>    4.3.7  放大 54<br>    4.3.8  公共 API 中的 Javadoc 55<br>4.4  坏注释. 55<br>    4.4.1  喃喃自语 55<br>    4.4.2  多余的注释. 56<br>    4.4.3  误导性注释. 58<br>    4.4.4  循规式注释. 58<br>    4.4.5  日志式注释. 59<br>    4.4.6  废话注释 59<br>    4.4.7  可怕的废话. 61<br>    4.4.8  能用函数或变量时就别用注释. 62<br>    4.4.9  位置标记 62<br>    4.4.10  括号后面的注释 62<br>    4.4.11  归属与署名 63<br>    4.4.12  注释掉的代码. 63<br>    4.4.13  HTML 注释 64<br>    4.4.14  非本地信息 64<br>    4.4.15  信息过多. 65<br>    4.4.16  不明显的联系. 65<br>    4.4.17  函数头 66<br>    4.4.18  非公共代码中的Javadoc. 66<br>    4.4.19  范例. 66<br>4.5  文献 69    </p>
<h2 id="第-5-章-格式-71"><a href="#第-5-章-格式-71" class="headerlink" title="第 5 章  格式 71"></a>第 5 章  格式 71</h2><p>5.1  格式的目的 72<br>5.2  垂直格式 72<br>    5.2.1  向报纸学习. 73<br>    5.2.2  概念间垂直方向上的区隔. 73<br>    5.2.3  垂直方向上的靠近 74<br>    5.2.4  垂直距离 75<br>    5.2.5  垂直顺序 79<br>5.3  横向格式 79<br>    5.3.1  水平方向上的区隔与靠近. 80<br>    5.3.2  水平对齐 81<br>    5.3.3  缩进 82<br>    5.3.4  空范围. 84<br>5.4  团队规则 84<br>5.5  鲍勃大叔的格式规则 85    </p>
<h2 id="第-6-章-对象和数据结构-87"><a href="#第-6-章-对象和数据结构-87" class="headerlink" title="第 6 章  对象和数据结构 87"></a>第 6 章  对象和数据结构 87</h2><p>6.1  数据抽象 87<br>6.2  数据、对象的反对称性. 89<br>6.3  得墨忒耳律 91<br>    6.3.1  火车失事 91<br>    6.3.2  混杂 92<br>    6.3.3  隐藏结构 92<br>6.4  数据传送对象. 93<br>6.5  小结 94<br>6.6  文献 94    </p>
<h2 id="第-7-章-错误处理-95"><a href="#第-7-章-错误处理-95" class="headerlink" title="第 7 章  错误处理 95"></a>第 7 章  错误处理 95</h2><p>7.1  使用异常而非返回码 96<br>7.2  先写 Try-Catch-Finally 语句. 97<br>7.3  使用不可控异常 98<br>7.4  给出异常发生的环境说明 99<br>7.5  依调用者需要定义异常类 99<br>7.6  定义常规流程 100<br>7.7  别返回 null 值 101<br>7.8  别传递 null 值 102<br>7.9  小结. 103<br>7.10 文献. 104    </p>
<h2 id="第-8-章-边界-105"><a href="#第-8-章-边界-105" class="headerlink" title="第 8 章  边界. 105"></a>第 8 章  边界. 105</h2><p>8.1  使用第三方代码. 106<br>8.2  浏览和学习边界. 107<br>8.3  学习 log4j 108<br>8.4  学习性测试的好处不只是免费. 110<br>8.5  使用尚不存在的代码. 110<br>8.6  整洁的边界 111<br>8.7  文献. 112    </p>
<h2 id="第-9-章-单元测试-113"><a href="#第-9-章-单元测试-113" class="headerlink" title="第 9 章  单元测试. 113"></a>第 9 章  单元测试. 113</h2><p>9.1  TDD 三定律 114<br>9.2  保持测试整洁 115<br>9.3  整洁的测试. 116<br>    9.3.1  面向特定领域的测试语言. 118<br>    9.3.2  双重标准. 119<br>9.4  每个测试一个断言 121<br>9.5  F.I.R.S.T. 122<br>9.6  小结. 123<br>9.7  文献. 124    </p>
<h2 id="第-10-章-类-125"><a href="#第-10-章-类-125" class="headerlink" title="第 10 章  类 125"></a>第 10 章  类 125</h2><p>10.1  类的组织 126<br>10.2  类应该短小. 126<br>    10.2.1  单一权责原则. 128<br>    10.2.2  内聚. 129<br>    10.2.3  保持内聚性就会得到许多短小的类 130<br>10.3  为了修改而组织. 136<br>10.4  文献. 139    </p>
<h2 id="第-11-章-系统-141"><a href="#第-11-章-系统-141" class="headerlink" title="第 11 章  系统. 141"></a>第 11 章  系统. 141</h2><p>11.1  如何建造一个城市. 142<br>11.2  将系统的构造与使用分开 142<br>    11.2.1  分解 main. 143<br>    11.2.2  工厂. 143<br>    11.2.3  依赖注入. 144<br>11.3  扩容 145<br>11.4  Java 代理. 148<br>11.5  纯 Java AOP 框架. 150<br>11.6  AspectJ 的方面 152<br>11.7  测试驱动系统架构. 153<br>11.8  优化决策. 154<br>11.9  明智使用添加了可论证价值的标准 154<br>11.10 系统需要领域特定语言. 154<br>11.11 小结 155<br>11.12 文献 155    </p>
<h2 id="第-12-章-迭进-157"><a href="#第-12-章-迭进-157" class="headerlink" title="第 12 章  迭进. 157"></a>第 12 章  迭进. 157</h2><p>12.1  通过迭进设计达到整洁目的 157<br>12.2  简单设计规则 1：运行所有测试 158<br>12.3  简单设计规则 2～4：重构 158<br>12.4  不可重复 159<br>12.5  表达力 161<br>12.6  尽可能少的类和方法. 162<br>12.7  小结. 162<br>12.8  文献. 162    </p>
<h2 id="第-13-章-并发编程-163"><a href="#第-13-章-并发编程-163" class="headerlink" title="第 13 章  并发编程 163"></a>第 13 章  并发编程 163</h2><p>13.1  为什么要并发 164<br>13.2  挑战. 165<br>13.3  并发防御原则 166<br>    13.3.1  单一权责原则. 166<br>    13.3.2  推论：限制数据作用域 166<br>    13.3.3  推论：使用数据复本 167<br>    13.3.4  推论：线程应尽可能地独立. 167<br>13.4  了解 Java 库 167<br>13.5  了解执行模型 168<br>    13.5.1  生产者-消费者模型. 169<br>    13.5.2  读者-作者模型. 169<br>    13.5.3  宴席哲学家 169<br>13.6  警惕同步方法之间的依赖. 169<br>13.7  保持同步区域微小 170<br>13.8  很难编写正确的关闭代码. 170<br>13.9  测试线程代码 171<br>    13.9.1  将伪失败看作可能的线程问题. 171<br>    13.9.2  先使非线程代码可工作 171<br>    13.9.3  编写可插拔的线程代码 172<br>    13.9.4  编写可调整的线程代码 172<br>    13.9.5  运行多于处理器 数量的线程. 172<br>    13.9.6  在不同平台上运行 172<br>    13.9.7  装置试错代码 173<br>    13.9.8  硬编码. 173<br>    13.9.9  自动化. 174<br>13.10  小结 175<br>13.11  文献 175    </p>
<h2 id="第-14-章-逐步改进-176"><a href="#第-14-章-逐步改进-176" class="headerlink" title="第 14 章  逐步改进 176"></a>第 14 章  逐步改进 176</h2><p>14.1  Args 的实现 177<br>14.2  Args：草稿 183<br>    14.2.1  所以我暂停了. 195<br>    14.2.2  渐进. 195<br>14.3  字符串参数. 197<br>14.4  小结. 234    </p>
<h2 id="第-15-章-JUnit-内幕-235"><a href="#第-15-章-JUnit-内幕-235" class="headerlink" title="第 15 章  JUnit 内幕 235"></a>第 15 章  JUnit 内幕 235</h2><p>15.1  JUnit 框架. 236<br>15.2  小结. 249    </p>
<h2 id="第-16-章-重构-SerialDate-251"><a href="#第-16-章-重构-SerialDate-251" class="headerlink" title="第 16 章  重构 SerialDate 251"></a>第 16 章  重构 SerialDate 251</h2><p>16.1  首先，让它能工作 252<br>16.2  让它做对 254<br>16.3  小结. 266<br>16.4  文献. 267    </p>
<h2 id="第-17-章-味道与启发-269"><a href="#第-17-章-味道与启发-269" class="headerlink" title="第 17 章  味道与启发. 269"></a>第 17 章  味道与启发. 269</h2><p>17.1  注释. 270<br>17.2  环境. 271<br>17.3  函数. 271<br>17.4  一般性问题. 272<br>17.5  Java. 288<br>17.6  名称. 291<br>17.7  测试. 294<br>17.8  小结. 295<br>17.9  文献. 296    </p>
<p>附录 A  并发编程 II. 297<br>A.1  客户端/服务器的例子. 297<br>A.1.1  服务器 297<br>A.1.2  添加线程代码. 298<br>A.1.3  观察服务器端. 299<br>A.1.4  小结. 301    </p>
<p>A.2  执行的可能路径. 301<br>A.2.1  路径数量. 302<br>A.2.2  深入挖掘. 303<br>A.2.3  小结. 305    </p>
<p>A.3  了解类库 305<br>A.3.1  Executor 框架 305<br>A.3.2  非锁定的解决方案. 306<br>A.3.3  非线程安全类. 307    </p>
<p>A.4  方法之间的依赖可能破坏并发代码 308<br>A.4.1  容忍错误. 309<br>A.4.2  基于客户代码的锁定 309<br>A.4.3  基于服务端的锁定. 311    </p>
<p>A.5  提升吞吐量. 312<br>A.5.1  单线程条件下的吞吐量. 313<br>A.5.2  多线程条件下的吞吐量. 313    </p>
<p>A.6  死锁. 314<br>A.6.1  互斥. 315<br>A.6.2  上锁及等待 315<br>A.6.3  无抢先机制 315<br>A.6.4  循环等待. 315<br>A.6.5  不互斥 316<br>A.6.6  不上锁及等待. 316<br>A.6.7  满足抢先机制. 317<br>A.6.8  不做循环等待. 317    </p>
<p>A.7  测试多线程代码. 317<br>A.8  测试线程代码的工具支持. 320<br>A.9  小结. 320<br>A.10 教程：完整代码范例. 321<br>A.10.1  客户端/服务器非 线程代码. 321<br>A.10.2  使用线程的客户端/服务器代码. 324    </p>
<p>附录 B  org.jfree.date.SerialDate 327<br>结束语. 389 </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>opti</category>
      </categories>
      <tags>
        <tag>opti</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能网站建设指南</title>
    <url>/pdf/opti/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>toc only.  </p>
<p style="text-align:right">2018.6.11 一 00:29</p>

<!-- read:2018.4.28-29  -->
<p>电子工业  2008.6 刘彦博·译 P173</p>
<h2 id="绪言A：前端性能能的重要性"><a href="#绪言A：前端性能能的重要性" class="headerlink" title="绪言A：前端性能能的重要性"></a>绪言A：前端性能能的重要性</h2><p>### 跟踪web页面性能<br>### 时间花在哪了<br>### 性能黄金法则</p>
<h2 id="绪言B：HTTP概述"><a href="#绪言B：HTTP概述" class="headerlink" title="绪言B：HTTP概述"></a>绪言B：HTTP概述</h2><p>### 压缩<br>### 条件GET请求<br>### Expires<br>### Keep-Alive<br>### 更多信息</p>
<h2 id="第1章：规则1———减少HTTP请求"><a href="#第1章：规则1———减少HTTP请求" class="headerlink" title="第1章：规则1———减少HTTP请求"></a>第1章：规则1———减少HTTP请求</h2><p>### 图片地图<br>### CSS Sprites<br>### 内联图片<br>### 合并脚本和样式表<br>### 小结</p>
<h2 id="第2章：规则2———使用内容发布网络"><a href="#第2章：规则2———使用内容发布网络" class="headerlink" title="第2章：规则2———使用内容发布网络"></a>第2章：规则2———使用内容发布网络</h2><p>### 内容发布网络<br>### 节省</p>
<h2 id="第3章：规则3———添加Expires头"><a href="#第3章：规则3———添加Expires头" class="headerlink" title="第3章：规则3———添加Expires头"></a>第3章：规则3———添加Expires头</h2><p>### Expires头<br>### Max-Age和mod_expires<br>### 空缓存VS完整缓存<br>### 不仅仅是图片<br>### 修订文件名<br>### 示例</p>
<h2 id="第4章：规则4———压缩组件"><a href="#第4章：规则4———压缩组件" class="headerlink" title="第4章：规则4———压缩组件"></a>第4章：规则4———压缩组件</h2><p>### 压缩是如何工作的<br>### 压缩什么<br>### 节省<br>### 配置<br>### 代理缓存<br>### 边缘情形<br>### 压缩的实际效果</p>
<h2 id="第5章：规则5———将样式表放在顶部"><a href="#第5章：规则5———将样式表放在顶部" class="headerlink" title="第5章：规则5———将样式表放在顶部"></a>第5章：规则5———将样式表放在顶部</h2><p>### 逐步呈现<br>### sleep.cgi<br>### 白屛<br>### 无样式内容的闪烁<br>### 前端工程师应该做什么</p>
<h2 id="第6章：规则6———将脚本放在底部"><a href="#第6章：规则6———将脚本放在底部" class="headerlink" title="第6章：规则6———将脚本放在底部"></a>第6章：规则6———将脚本放在底部</h2><p>### 脚本带来的问题<br>### 并行下载<br>### 脚本阻塞下载<br>### 最差情况：将脚本放在顶部<br>### 最佳情况：将脚本放在底部<br>### 正确地放置</p>
<h2 id="第7章：规则7———避免CSS表达式"><a href="#第7章：规则7———避免CSS表达式" class="headerlink" title="第7章：规则7———避免CSS表达式"></a>第7章：规则7———避免CSS表达式</h2><p>### 更新表达式<br>### 围绕问题展开工作<br>### 小结</p>
<h2 id="第8章：规则8———使用外部Javascript和CSS"><a href="#第8章：规则8———使用外部Javascript和CSS" class="headerlink" title="第8章：规则8———使用外部Javascript和CSS"></a>第8章：规则8———使用外部Javascript和CSS</h2><p>### 内联VS外置<br>### 典型的对比结果<br>### 主页<br>### 两全其美</p>
<h2 id="第9章：规则9———减少DNS查找"><a href="#第9章：规则9———减少DNS查找" class="headerlink" title="第9章：规则9———减少DNS查找"></a>第9章：规则9———减少DNS查找</h2><p>### DNS缓存和TTL<br>### 浏览器的视角<br>### 减少DNS查找</p>
<h2 id="第10章：规则10———精简Javascript"><a href="#第10章：规则10———精简Javascript" class="headerlink" title="第10章：规则10———精简Javascript"></a>第10章：规则10———精简Javascript</h2><p>### 精简<br>### 混淆<br>### 节省<br>### 示例<br>### 锦上添花</p>
<h2 id="第11章：规则11———避免重定向"><a href="#第11章：规则11———避免重定向" class="headerlink" title="第11章：规则11———避免重定向"></a>第11章：规则11———避免重定向</h2><p>### 重定向的类型<br>### 重定向是如何损伤性能的<br>### 重定向之外的其他选择</p>
<h2 id="第12章：规则12———移除重复脚本"><a href="#第12章：规则12———移除重复脚本" class="headerlink" title="第12章：规则12———移除重复脚本"></a>第12章：规则12———移除重复脚本</h2><p>### 重复脚本–确有其事<br>### 重复脚本损伤性能<br>### 避免重复脚本</p>
<h2 id="第13章：规则13———配置ETag"><a href="#第13章：规则13———配置ETag" class="headerlink" title="第13章：规则13———配置ETag"></a>第13章：规则13———配置ETag</h2><p>### ETag是什么<br>### ETag带来的问题<br>### ETag–用还是不用<br>### 现实世界中的ETag</p>
<h2 id="第14章：规则14———使Ajax可缓存"><a href="#第14章：规则14———使Ajax可缓存" class="headerlink" title="第14章：规则14———使Ajax可缓存"></a>第14章：规则14———使Ajax可缓存</h2><p>### Web2.0、DHTML和Ajax<br>### 异步与即时<br>### 优化Ajax请求<br>### 现实世界中的Ajax缓存</p>
<h2 id="第15章：析构十大网站"><a href="#第15章：析构十大网站" class="headerlink" title="第15章：析构十大网站"></a>第15章：析构十大网站</h2><p>Amazon,AOL,CNN,eBay,Google,MSN,MySpace,Wikipedia,Yahoo,Youtute        </p>
<h3 id="页面大小、响应时间、YSlow等级"><a href="#页面大小、响应时间、YSlow等级" class="headerlink" title="页面大小、响应时间、YSlow等级"></a>页面大小、响应时间、YSlow等级</h3><p>### 如何进行测试<br>### ….</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>opti</category>
      </categories>
      <tags>
        <tag>opti</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/sum/jsplus/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(000)/</url>
    <content><![CDATA[<p>互联网通信的五层协议</p>
<!-- <p style="text-align:right">2018.6.8 星期五 </p> -->
<a id="more"></a>
<p># [互联网是如何形成的]<br>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。<br>它们对电脑如何连接和组网，做出了详尽的规定</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>1.1 五层模型<br>或者7/4<br>应用 application<br>传输 transport<br>网络 netwrok<br>链接 link<br>实体 physical </p>
<p>1.2 层与协议</p>
<h2 id="二、实体层"><a href="#二、实体层" class="headerlink" title="二、实体层"></a>二、实体层</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p>
<p>它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>
<h2 id="三、链接层"><a href="#三、链接层" class="headerlink" title="三、链接层"></a>三、链接层</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</p>
<p>3.2 以太网协议<br>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>
<p>3.3 MAC地址<br>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p>
<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<p>3.4 广播<br>首先，一块网卡怎么会知道另一块网卡的MAC地址？  一种ARP协议  </p>
<p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p>
<h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><p>4.1 网络层的由来<br>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p>
<p>但是，这样做有一个重大的缺点：以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，<br>而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。<br>如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p>
<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，<br>MAC地址是绑定在网卡上的，<br>网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，<br>MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>
<p>4.2 IP协议<br>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。<br>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。<br>这个地址分成两个部分，前一部分代表网络，后一部分代表主机。  </p>
<p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。<br>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。<br>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。   方法是将两个IP地址与子网掩码分别进行AND运算   </p>
<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p>4.3 IP数据包<br>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>
<p>4.4 ARP协议<br>关于”网络层”，还有最后一点需要说明。<br>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>
<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。   </p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议</p>
<h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><p>5.1 传输层的由来<br>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口  </p>
<p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p>5.2 UDP协议<br>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>5.3 TCP协议<br>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。   </p>
<p>“应用层”的作用，就是规定应用程序的数据格式。</p>
<p># [网关(Gateway)]<br>那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。<br>比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。<br>而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。 </p>
<p>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p>
<p>## 什么是默认网关<br>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>mockData</title>
    <url>/sum/jsplus/mockData(023)/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.5 星期二 </p>

<h2 id="mock-data"><a href="#mock-data" class="headerlink" title="mock data"></a>mock data</h2><p>### [构建前端Mock Server的利器/Json-Server]</p>
<p>restful aip: json-server<br>整合Webpack Dev Server:proxy参数<br>加上Faker   </p>
<p>### [前端如何 Mock 数据]<br>#### Mock 的方式<br>前端模拟 API 数据方式有很多。<br>手动模拟<br>重写 Ajax<br>使用 Webpack 代理</p>
<p>#### Mock Server<br>以上，说的都是如何模拟数据，方便本地开发，但是代理接口请求之后，还需要接受该请求的服务器。</p>
<p>所以一个完整的数据模拟，应该包含 Mock Server。<br>可以使用的 Mock Server:<br>apiary: 可以生成文档，但是非个人使用得付费。<br>RAP: 功能貌似很强大，阿里妈妈MUX团队出品。<br>json-server: Node 编写，适合前端人员使用，但不能产生文档。</p>
<p>其它：<br><a href="https://juejin.im/entry/57bd37c2c4c9710061606b38" target="_blank" rel="noopener">为什么你需要一个 mock server</a><br><a href="https://www.zhihu.com/question/35436669" target="_blank" rel="noopener">你是如何构建 Web 前端 Mock Server 的？</a>  </p>
<h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p><a href="https://github.com/typicode/json-serve" target="_blank" rel="noopener">https://github.com/typicode/json-serve</a></p>
<p>Tip use modules like Faker, Casual, Chance or JSON Schema Faker.</p>
<h2 id="express-Webpack"><a href="#express-Webpack" class="headerlink" title="express/Webpack"></a>express/Webpack</h2><p>express+router<br>webpack: webpack-dev-server<br>webpack: webpack-hot-server    </p>
<p>proxy        </p>
<h2 id="faker-js"><a href="#faker-js" class="headerlink" title="faker.js"></a>faker.js</h2><p><a href="https://github.com/marak/Faker.js/" target="_blank" rel="noopener">https://github.com/marak/Faker.js/</a><br>marak.github.io/faker.js/  </p>
<h2 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h2><p><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">https://github.com/nuysoft/Mock</a><br><a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a><br><a href="http://mockjs.com/0.1/#mock" target="_blank" rel="noopener">http://mockjs.com/0.1/#mock</a><br>生成随机数据，拦截 Ajax 请求</p>
<p>puer-mock:<br><a href="https://github.com/ufologist/puer-mock" target="_blank" rel="noopener">https://github.com/ufologist/puer-mock</a></p>
<h2 id="fetch-api"><a href="#fetch-api" class="headerlink" title="fetch api"></a>fetch api</h2><p>### <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">使用 Fetch-MDN</a>   </p>
<p>提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>
<p>这种功能以前是使用  XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。</p>
<p>请注意，fetch规范与jQuery.ajax()主要有两种方式的不同，牢记：<br>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。<br>默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。</p>
<p>### /github/fetch<br><a href="http://github.github.io/fetch/" target="_blank" rel="noopener">http://github.github.io/fetch/</a><br>A window.fetch JavaScript polyfill.    </p>
<p>### Body.json()<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/json" target="_blank" rel="noopener">Body.json()-MDN</a><br>Body  mixin 的 json() 方法使用一个 Response 流，并将其读取完成。<br>它返回一个 promise ，解析结果是将文本体解析为 JSON。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">`https://cdn.xgqfrms.xyz/json/badges.json`</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`data = \n`</span>, data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="axios-api"><a href="#axios-api" class="headerlink" title="axios api"></a>axios api</h2><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a><br>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。  </p>
<blockquote>
<p>Promise based HTTP client for the browser and node.js</p>
</blockquote>
<p>Credits<br>axios is heavily inspired by the $http service provided in Angular. Ultimately axios is an effort to provide a standalone $http-like service for use outside of Angular.</p>
<p>其它：<br><a href="Axios 中文说明">Axios 中文说明</a><br><a href="https://segmentfault.com/a/1190000008470355" target="_blank" rel="noopener">axios 中文文档 翻译</a>   </p>
<h2 id="其它方式"><a href="#其它方式" class="headerlink" title="其它方式"></a>其它方式</h2><p>jQuery，vue-resource, angularjs-$http,     </p>
<p>## restful 和 graphQL 比较<br><a href="https://juejin.im/post/59793f625188253ded721c70" target="_blank" rel="noopener">【译】GraphQL vs. REST</a><br>    (<a href="https://github.com/xitu/gold-miner/blob/master/TODO/graphql-vs-rest.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO/graphql-vs-rest.md</a>)<br><a href="https://www.zcfy.cc/article/rest-apis-are-rest-in-peace-apis-long-live-graphql" target="_blank" rel="noopener">[安息吧 REST API，GraphQL 长存]</a><br><a href="http://www.infoq.com/cn/news/2017/07/graphql-vs-rest" target="_blank" rel="noopener">GraphQL和REST对比时需要注意些什么</a><br><a href="https://segmentfault.com/a/1190000012878342" target="_blank" rel="noopener">GraphQL和RESTful的比较</a><br><a href="https://blog.csdn.net/kikajack/article/details/79075405gg" target="_blank" rel="noopener">几种前后端接口的对比：RESTful，GraphQL，APIJSON</a><br><a href="https://blog.tonyseek.com/post/graphql-vs-restful/" target="_blank" rel="noopener">GraphQL vs RESTful API 的一些想法</a><br><a href="https://zhuanlan.zhihu.com/p/28678282" target="_blank" rel="noopener">GraphQL这个坑可以入了 （1）RESTful API痛点</a>   </p>
<p>其它：<br><a href="https://www.jianshu.com/p/2ad286397f7a?open_source=weibo_search" target="_blank" rel="noopener">【译】对比GraphQL与REST——两种HTTP API的差异</a>   </p>
<p>## restful<br>[<a href="http://www.cnblogs.com/artech/p/restful-wggeb-api-02.html" target="_blank" rel="noopener">我所理解的RESTful Web API [设计篇]]</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">[RESTful API 设计指南]</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a><br><a href="http://www.runoob.com/w3cnote/restful-architecggture.html" target="_blank" rel="noopener">RESTful 架构详解</a><br><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="noopener">怎样用通俗的语言解释REST，以及RESTful？</a>  </p>
<p>## graphQL<br><a href="http://graphql.org/learn/" target="_blank" rel="noopener">http://graphql.org/learn/</a><br>    zh: <a href="http://graphql.cn/learn/" target="_blank" rel="noopener">http://graphql.cn/learn/</a>   </p>
<p><a href="https://www.jiansgghu.com/p/2ec22fc1219c" target="_blank" rel="noopener">Graphql入门</a>      </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>mockData</title>
    <url>/sum/jsplus/yapi%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.5 星期二 </p>


<p>官网:<a href="https://yapi.ymfe.org/documents/mock.html" target="_blank" rel="noopener">https://yapi.ymfe.org/documents/mock.html</a><br>github:<a href="https://github.com/YMFE/yapi/" target="_blank" rel="noopener">https://github.com/YMFE/yapi/</a><br>mockjs:<a href="https://github.com/nuysoft/Mock/wiki/Text" target="_blank" rel="noopener">https://github.com/nuysoft/Mock/wiki/Text</a>   </p>
<h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><p>$RELATIVE:<br>    $BLOB:[mockData]<br>    $BLOB:[前后端分离]  </p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>见文档   </p>
<h2 id="内网部署"><a href="#内网部署" class="headerlink" title="内网部署"></a>内网部署</h2><p>浏览器可视部署，没有用docker<br>启动之前mongo 需要运行（可后台）<br>启动：node vendors/server/app.js     </p>
<h3 id="mongo搭建"><a href="#mongo搭建" class="headerlink" title="mongo搭建"></a>mongo搭建</h3><h2 id="使用记录"><a href="#使用记录" class="headerlink" title="使用记录"></a>使用记录</h2><h3 id="已踩"><a href="#已踩" class="headerlink" title="已踩"></a>已踩</h3><p>1. 部署失败。貌似这个插件json-path 安装遇到问题<br>    文件夹权限不够？npm安装要用源码？node版本太高？<br>    &gt; 应该是权限问题，但是不敢乱改，暂时是在执行npm install时加上了–unsafe-perm安装好了依赖，但是不知这样做后面升级或者其他操作会不会有坑。   [安装失败，Cannot find module ‘fs-extra’]  /YMFE/yapi/issues/458<br>2. 同一路径提示 相同接口，可以通过参数区别<br>    [对于同一路径带不同参数来表示多个接口的应该如何处理] /YMFE/yapi/issues/455<br>    [单入口的接口？ ]  /YMFE/yapi/issues/578</p>
<h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>3. 路径，必须以<code>/</code> 开头，不能全局设置共用路径，比如<code>/index</code><br>    [对于同一路径带不同参数来表示多个接口的应该如何处理]  /YMFE/yapi/issues/455<br>1. 全局mock问题，延迟和出现错乱<br>    <a href="https://github.com/YMFE/yapi/issues/759" target="_blank" rel="noopener">全局mock脚本生效有延迟</a><br>1. 发送请求，可以自动获取带cookie，而非写在全局的header设置中<br>   [强列建议： 后面的测试接口可以取前面接口返回的header中的字段，起码可以取返回Cookie] /YMFE/yapi/issues/334<br>    [建议将高级mock的cookie注入的httpOnly属性改成主动设置的]  /YMFE/yapi/issues/239</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js文件操作</title>
    <url>/sum/js/js%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C(009)/</url>
    <content><![CDATA[<p style="text-align:right">2018.6.28 星期四 </p>

<h2 id="文件对象-blob-和下载"><a href="#文件对象-blob-和下载" class="headerlink" title="文件对象(blob) 和下载"></a>文件对象(blob) 和下载</h2><p>### [blob和base64]：<br>Blob对象是一个代表二进制数据的基本对象，在它的基础上，又衍生出一系列相关的API，用来操作文件。</p>
<p>File对象：负责处理那些以文件形式存在的二进制数据，也就是操作本地文件；<br>FileList对象：File对象的网页表单接口；<br>FileReader对象：负责将二进制数据读入内存内容；<br>URL对象：用于对二进制数据生成URL。</p>
<p>### 下载<br>blobDownload.html/blobDownload-html&amp;txt.html</p>
<h2 id="文件上传-断点续传"><a href="#文件上传-断点续传" class="headerlink" title="文件上传/断点续传"></a>文件上传/断点续传</h2><!-- acuviewer/ video_upload.php: -->
<p>resumable.js+bootstrap-progressbar.js   </p>
<blockquote>
<p>Alternatives<br>If your aim is just to support progress indications during upload/uploading multiple files at once, Resumable.js isn’t for you. In those cases, something like <a href="http://www.plupload.com" target="_blank" rel="noopener">Plupload</a> provides the same features with wider browser support.</p>
</blockquote>
<!-- cloudClass -->
<p>jQuery-File-Upload</p>
<p>### SMTC: 略  </p>
<p>其它：<br><a href="https://github.com/moxiecode/plupload" target="_blank" rel="noopener">Plupload</a></p>
<!-- <p style="text-align:right">2018.6.1 星期五 </p> -->
<h2 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h2><p>需要input标签打开文件才可以<br>FileSystemObject 对象，没有试用过：创建新对象都不通过<br>websocket可以；cef等        </p>
<p># <a href="https://yalhu.github.io/tags/" target="_blank" rel="noopener">使用javascript读写本地文件的方法</a><br>2013年12月11日 23:47:36<br>【方法一】localStorage<br>【方法二】execCommand(“saveas”)<br>【方法三】File API      </p>
<p># <a href="https://blog.csdn.net/zmx729618/article/details/52610237" target="_blank" rel="noopener">JS读取本地文件及目录的方法</a><br>一、功能实现核心：FileSystemObject 对象<br>二、FileSystemObject编程三部曲<br>使用FileSystemObject 对象进行编程很简单，一般要经过如下的步骤： 创建FileSystemObject对象、应用相关方法、访问对象相关属性 。<br>(一)创建FileSystemObject对象<br>var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>上述代码执行后，fso就成为一个FileSystemObject对象实例。     </p>
<p>(二)应用相关方法<br>创建对象实例后，就可以使用对象的相关方法了。比如，使用CreateTextFile方法创建一个文本文件：<br>var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>var f1 = fso.createtextfile(“c://myjstest.txt”,true”);      </p>
<p>(三)访问对象相关属性<br>要访问对象的相关属性，首先要建立指向对象的句柄，这就要通过get系列方法实现：GetDrive负责获取驱动器信息，GetFolder负责获取文件夹信息，GetFile负责获取文件信息。比如，指向下面的代码后，f1就成为指向文件c:/test.txt的句柄：        </p>
<p>var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>var f1 = fso.GetFile(“c://myjstest.txt”);</p>
<p>…..</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域操作</title>
    <url>/sum/js/%E8%B7%A8%E5%9F%9F%E6%93%8D%E4%BD%9C(006)/</url>
    <content><![CDATA[<a id="more"></a>
<p># [前端常见跨域解决方案（全）]</p>
<h2 id="广义的跨域"><a href="#广义的跨域" class="headerlink" title="广义的跨域"></a>广义的跨域</h2><p>1.) 资源跳转： A链接、重定向、表单提交<br>2.) 资源嵌入：<code>&lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;</code>等dom标签，还有样式中background:url()、@font-face()等文件外链<br>3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</p>
<p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p>
<p>同源策略限制以下几种行为：<br>1.) Cookie、LocalStorage 和 IndexDB 无法读取<br>2.) DOM 和 Js对象无法获得<br>3.) AJAX 请求不能发送</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>4、 window.name + iframe跨域<br>3、 location.hash + iframe<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 <del>nginx代理跨域</del><br>8、 <del>nodejs中间件代理跨域</del><br>9、 WebSocket协议跨域</p>
<!-- \#end -->
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>服务端不能直接返回json字符串，会报错：Uncaught SyntaxError: Unexpected token :<br>正确格式参考（php版）：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$data=$_GET[<span class="string">'callback'</span>].<span class="string">'('</span>.json_encode($ret).<span class="string">')'</span>;</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure></p>
<p>只能是get；jquery也是get，即使post也会转为get(和ajax没有半毛钱关系，jQuery只是伪装)<br>从原理分析；区分get/post请求         </p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//page</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgChatIfrm</span>(<span class="params">type,data</span>)</span>&#123; <span class="comment">// assume ifrm had loaded</span></span><br><span class="line">    <span class="comment">// chatIfrm.contentWindow.postMessage(JSON.stringify(&#123;type,data&#125;),chatServer); //ie limit</span></span><br><span class="line">    chatIfrm.contentWindow.postMessage(&#123;type,data&#125;,chatServer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 如果ifrm没有loaded 发送消息，报错：</span></span><br><span class="line">    <span class="comment">// Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://192.168.1.61') does not match the recipient window's origin ('null').</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    log(<span class="string">'on message:'</span>,event) <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(event.origin!==chatServer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data=oData.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iframe</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msgTop</span>(<span class="params">type,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="built_in">window</span>)<span class="keyword">return</span>;</span><br><span class="line">    top.postMessage(&#123;type,data&#125;,<span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    log(event);</span><br><span class="line">    <span class="comment">/* 单独打开后iframe页面后，输出了undefined，undefined;  ff没有输出；估计是插件。另一个chrome也没事</span></span><br><span class="line"><span class="comment">    // <span class="doctag">NOTE:</span> 1.不知道为什么会接收到这样一条事件;不知道哪里发送了事件。</span></span><br><span class="line"><span class="comment">    // event:&#123;data:"",origin: "http://127.0.0.1:59353", lastEventId: "", source: Window&#125; //和本页面同</span></span><br><span class="line"><span class="comment">        // 正常发过来的是：&#123;data:"test",origin: "http://127.0.0.1:59353", lastEventId: "", source: Window&#125;</span></span><br><span class="line"><span class="comment">        // 所以，加了origin的判断</span></span><br><span class="line"><span class="comment">    // if(location.origin==event.origin) return; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if(event.origin!=top.location.origin) return; //top.location 会有跨域问题，取不到；本地文件也没有location</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MDN example: 是监听到消息，得到source后再发送消息</span></span><br><span class="line">    <span class="comment">// 我们能信任信息来源吗？</span></span><br><span class="line">    <span class="keyword">if</span> (event.origin !== <span class="string">"http://example.com:8080"</span>) <span class="keyword">return</span>;</span><br><span class="line">    event.source.postMessage(<span class="string">"hi there yourself!"</span>,event.origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他：<br><a href="https://github.com/Monine/monine.github.io/issues/2" target="_blank" rel="noopener">HTML5 跨域通信 API - window.postMessage()</a><br>通过<code>window.open()</code>打开的窗口</p>
<blockquote>
<p>在 var targetPage = window.open(‘<a href="http://target.com&#39;" target="_blank" rel="noopener">http://target.com&#39;</a>) 打开新页面之后需要等到 <a href="http://target.com" target="_blank" rel="noopener">http://target.com</a> 页面加载完成之后才能进行 postMessage 跨域通信，但是在跨域的情况下我们是无法对 targetPage 进行 onload 事件监听的，所以这里只能做 延迟 setTimeout 或者 定时 setInterval 处理。<br>同样的，在页面内嵌入 iframe 页面的情况下，我们也需要等到页面内的 iframe 加载完成之后进行 postMessage 跨域通信。</p>
</blockquote>
<p># [新手学跨域之iframe]</p>
<p style="text-align:right">2018.2.8 星期四 16:00</p>  

<p>页面嵌套iframe是比较常见的，比如QQ相关业务页面的登录框一般都是iframe的。使用ifrmae跨域要满足一个基本条件，父页面和子页面都是自己可以控制的，如果随便把iframe指向一个其他网站，想通过跨域手段操作它基本上是不可能的。<br><strong>$_PS:</strong> 跨域时的全屏操作 </p>
<h2 id="一-document-domain"><a href="#一-document-domain" class="headerlink" title="一 document.domain"></a>一 document.domain</h2><p>document.domain是比较常用的跨域方法。实现最简单但只能用于同一个主域下不同子域之间的跨域请求，比如 foo.com 和 img.foo.com 之间，img1.foo.com 和 img2.foo.com 之间。只要把两个页面的document.domain都指向主域就可以了，比如document.domain=’foo.com’;。<br>设置好后父页面和子页面就可以像同一个域下两个页面之间访问了。父页面通过ifr.contentWindow就可以访问子页面的window，子页面通过parent.window或parent访问父页面的window，接下来可以进一步获取dom和js。</p>
<h2 id="二-window-name"><a href="#二-window-name" class="headerlink" title="二 window.name"></a>二 window.name</h2><p>只要不关闭浏览器，window.name可以在不同页面加载后依然保持。尝试在浏览器打开百度baidu.com，然后在控制台输入window.name=’aaa’;回车，接着在地址栏输入qq.com转到腾讯首页，打开控制台输入window.name查看它的值，可以看到输出了”aaa”。</p>
<h2 id="三-location-hash"><a href="#三-location-hash" class="headerlink" title="三 location.hash"></a>三 location.hash</h2><p>较常用，把传递的数据依附在url上</p>
<h2 id="四-window-navigator"><a href="#四-window-navigator" class="headerlink" title="四 window.navigator"></a>四 window.navigator</h2><p>IE6的bug，父页面和子页面都可以访问window.navigator这个对象，在navigator上添加属性或方法可以共享。因为现在没有IE6环境，这里就不写例子了。</p>
<h2 id="五-postMessage"><a href="#五-postMessage" class="headerlink" title="五 postMessage"></a>五 postMessage</h2><p>HTML5新增方法，现在浏览器及IE8+支持，简单易用高大上。</p>
<p>.postMessage(message, targetOrigin)参数说明：<br>    message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)<br>    targetOrigin: 是限定消息接收范围，不限制请使用 ‘*’</p>
<p>‘message’, function(e)回调函数第一个参数接收 Event 对象，有三个常用属性：<br>    data: 消息<br>    origin: 消息来源地址<br>    source: 源 DOMWindow </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**&amp;_PS:** [window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)</span><br><span class="line"></span><br><span class="line">都是404了    </span><br><span class="line"># A jsonp</span><br><span class="line"># B iframe</span><br><span class="line"># C CORS</span><br><span class="line">## 一 XMLHttpRequest (modern browser)</span><br><span class="line">## 二 XDomainRequest (IE8+)</span><br><span class="line"># D 图像Ping (略)</span><br><span class="line"># E flash (略)</span><br></pre></td></tr></table></figure>
<p>其它参考：<br><!-- # Ajax 跨域，这应该是最全的解决方案了 --></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨页面通信</title>
    <url>/sum/js/%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1(015)/</url>
    <content><![CDATA[<!-- <p style="text-align:right">2018.2.24 星期六 15:46</p>   -->
<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-acuviewer-php-aculive-php"><a href="#一-acuviewer-php-aculive-php" class="headerlink" title="一 acuviewer.php aculive.php"></a>一 acuviewer.php aculive.php</h2><ol>
<li>localStorage：video播放速度，质量，字幕</li>
<li>iframe操作：全屏同源</li>
<li>postmessage：全屏跨域；其他大多通信，包括全屏聊天室通知</li>
<li>location.hash:聊天室全屏，为iframe中body添加样式 </li>
<li>cookie：登陆状态，没有接触</li>
<li>server：直播状态及其他，没有接触</li>
</ol>
<!-- <p style="text-align:right">16:01</p>   -->
<a id="more"></a> 
<p style="text-align:right">2018.2.8 星期四 12:24</p>  

<h1 id="A-跨页面通信的各种姿势"><a href="#A-跨页面通信的各种姿势" class="headerlink" title="A [跨页面通信的各种姿势]"></a>A [跨页面通信的各种姿势]</h1><p>链接：<a href="https://juejin.im/post/59bb7080518825396f4f5177" target="_blank" rel="noopener">https://juejin.im/post/59bb7080518825396f4f5177</a><br>作者简介：nekron 蚂蚁金服·数据体验技术团队  2017.9.15<br><strong>$_YX:</strong> [跨页面通信的各种姿势]   </p>
<p>将跨页面通讯类比计算机进程间的通讯，其实方法无外乎那么几种，而web领域可以实现的技术方案主要是类似于以下两种原理：</p>
<ul>
<li>获取句柄，定向通讯</li>
<li>共享内存，结合轮询或者事件通知来完成业务逻辑</li>
</ul>
<p>由于第二种原理更利于解耦业务逻辑，具体的实现方案比较多样。以下是具体的实现方案，简单介绍下，权当科普：</p>
<h2 id="一-获取句柄"><a href="#一-获取句柄" class="headerlink" title="一 获取句柄"></a>一 获取句柄</h2><h3 id="1-1-具体方案"><a href="#1-1-具体方案" class="headerlink" title="1.1 具体方案"></a>1.1 具体方案</h3><p>父页面通过window.open(url, name)方式打开的子页面可以获取句柄，然后通过postMessage完成通讯需求。</p>
<h3 id="1-2-tips"><a href="#1-2-tips" class="headerlink" title="1.2 tips"></a>1.2 tips</h3><h3 id="1-3-优劣"><a href="#1-3-优劣" class="headerlink" title="1.3 优劣"></a>1.3 优劣</h3><p>缺点是只能与自己打开的页面完成通讯，应用面相对较窄；但优点是在跨域场景中依然可以使用该方案。</p>
<h2 id="二-localStorage"><a href="#二-localStorage" class="headerlink" title="二 localStorage"></a>二 localStorage</h2><h3 id="2-1-具体方案"><a href="#2-1-具体方案" class="headerlink" title="2.1 具体方案"></a>2.1 具体方案</h3><h3 id="2-2-tips"><a href="#2-2-tips" class="headerlink" title="2.2 tips"></a>2.2 tips</h3><h3 id="2-3-优劣"><a href="#2-3-优劣" class="headerlink" title="2.3 优劣"></a>2.3 优劣</h3><p>API简单直观，兼容性好，除了跨域场景下需要配合其他方案，无其他缺点</p>
<h2 id="三-BroadcastChannel"><a href="#三-BroadcastChannel" class="headerlink" title="三 BroadcastChannel"></a>三 BroadcastChannel</h2><h3 id="3-1-具体方案"><a href="#3-1-具体方案" class="headerlink" title="3.1 具体方案"></a>3.1 具体方案</h3><p>和localStorage方案基本一致，额外需要初始化</p>
<h3 id="3-2-优劣"><a href="#3-2-优劣" class="headerlink" title="3.2 优劣"></a>3.2 优劣</h3><p>和localStorage方案没特别区别，都是同域、API简单，BroadcastChannel方案兼容性差些（chrome &gt; 58），但比localStorage方案生命周期短（不会持久化），相对干净些。</p>
<h2 id="四-SharedWorker"><a href="#四-SharedWorker" class="headerlink" title="四 SharedWorker"></a>四 SharedWorker</h2><h3 id="4-1-具体方案"><a href="#4-1-具体方案" class="headerlink" title="4.1 具体方案"></a>4.1 具体方案</h3><h3 id="4-2-优劣"><a href="#4-2-优劣" class="headerlink" title="4.2 优劣"></a>4.2 优劣</h3><h2 id="五-Cookie"><a href="#五-Cookie" class="headerlink" title="五 Cookie"></a>五 Cookie</h2><h3 id="5-1-具体方案"><a href="#5-1-具体方案" class="headerlink" title="5.1 具体方案"></a>5.1 具体方案</h3><p>一个古老的方案，有点localStorage的降级兼容版，我也是整理本文的时候才发现的，思路就是往document.cookie写入值，由于cookie的改变没有事件通知，所以只能采取轮询脏检查来实现业务逻辑。<br>方案比较丑陋，势必被淘汰的方案，贴一下原版思路地址，我就不写demo了。<br><a href="https://stackoverflow.com/questions/4079280/javascript-communication-between-browser-tabs-windows/4079423" target="_blank" rel="noopener">communication between browser windows (and tabs too) using cookies</a></p>
<h3 id="5-2-优劣"><a href="#5-2-优劣" class="headerlink" title="5.2 优劣"></a>5.2 优劣</h3><p>相较于其他方案没有存在优势的地方，只能同域使用，而且污染cookie以后还额外增加AJAX的请求头内容。</p>
<h2 id="六-Server"><a href="#六-Server" class="headerlink" title="六 Server"></a>六 Server</h2><p>之前的方案都是前端自行实现，势必受到浏览器限制，比如无法做到跨浏览器的消息通讯，比如大部分方案都无法实现跨域通讯（需要增加额外的postMessage逻辑才能实现）。通过借助服务端，还有很多增强方案，也一并说下。</p>
<h3 id="6-1-乞丐版"><a href="#6-1-乞丐版" class="headerlink" title="6.1 乞丐版"></a>6.1 乞丐版</h3><h3 id="6-2-Server-sent-Events-Websocket"><a href="#6-2-Server-sent-Events-Websocket" class="headerlink" title="6.2 Server-sent Events / Websocket"></a>6.2 Server-sent Events / Websocket</h3><h3 id="6-3-消息队列"><a href="#6-3-消息队列" class="headerlink" title="6.3 消息队列"></a>6.3 消息队列</h3><p>其它：<br><strong>$_YX:</strong>  [015 跨页面通信的各种姿势 - 掘金]</p>
<p>================  </p>
<h1 id="B-使用Cookie做跨页面通信"><a href="#B-使用Cookie做跨页面通信" class="headerlink" title="B 使用Cookie做跨页面通信"></a>B 使用Cookie做跨页面通信</h1><p><a href="https://www.web-tinker.com/article/20122.html" target="_blank" rel="noopener">https://www.web-tinker.com/article/20122.html</a></p>
<p>Cookie的存储在硬盘中的，而网页是运行在内存中的，他们会共用硬盘上的Cookie。而document.cookie这个属性不仅仅是一个Setter属性，还是个Getter属性。当我们访问这个属性时，它会从硬盘上保存的Cookie中读入数据。而Cookie是以域名和目录名来储存的，它没有精确到页面。这就意味着多个页面是共用一个Cookie的。既然页面之间有共同的数据存储区域，我们就可以利用它来实现跨页面的通信。</p>
<p>但是Cookie并没有change之类的事件，我们只能使用一个计时器去扫描。计时器的时间间隔可以依据项目需求来设置。下面是例子</p>
<pre><code>&lt;script&gt;
    onload=function(){
        //创建一个文本节点，用来显示当前数据
        var t=document.createTextNode(&quot;&quot;);
        document.body.appendChild(t);
        //创建计时器来扫描Cookie，间隔是1秒
        setInterval(function(){
            //读取Cookie
            var v=document.cookie.match(/data=(.+?)(?=;|$)/);
            t.data=v?decodeURIComponent(v[1]):&quot;&quot;;
        },1000);
        //按钮点击时把文本框内的内容放入Cookie中
        btn.onclick=function(){
            document.cookie=&quot;data=&quot;+encodeURIComponent(inp.value);
        };
    };  
&lt;/script&gt;
&lt;input id=&quot;inp&quot; /&gt;&lt;br/&gt;
&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;设置&quot; /&gt;
</code></pre><p><strong>$_PS:</strong> 上面那些都不是重点；</p>
<ol>
<li>A 内容丰富，但是华而不实；</li>
<li>只有postmessage,localstorage</li>
<li>勉强Server</li>
<li>cookie已经是没落方案了    </li>
</ol>
<p>=================</p>
<h1 id="C-跨浏览器tab页的通信解决方案尝试"><a href="#C-跨浏览器tab页的通信解决方案尝试" class="headerlink" title="C [跨浏览器tab页的通信解决方案尝试]"></a>C [跨浏览器tab页的通信解决方案尝试]</h1><p><a href="https://segmentfault.com/a/1190000011207317" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011207317</a><br>RoyalRover 2017年09月17日发布</p>
<p><strong>$_YX:</strong> [015【第1060期】跨浏览器tab页的通信解决方案尝试] </p>
<h2 id="一-目标"><a href="#一-目标" class="headerlink" title="一 目标"></a>一 目标</h2><h2 id="二-畅想"><a href="#二-畅想" class="headerlink" title="二 畅想"></a>二 畅想</h2><h3 id="2-1-case-1"><a href="#2-1-case-1" class="headerlink" title="2.1 case 1"></a>2.1 case 1</h3><p>两个需要交互的tab页面具有依赖关系。</p>
<p>如 A页面中通过JavaScript的window.open打开B页面，或者B页面通过iframe嵌入至A页面，此种情形最简单，可以通过HTML5的 window.postMessage API完成通信，由于postMessage函数是绑定在 window 全局对象下，因此通信的页面中必须有一个页面（如A页面）可以获取另一个页面（如B页面）的window对象，这样才可以完成单向通信；B页面无需获取A页面的window对象，如果需要B页面对A页面的通信，只需要在B页面侦听message事件，获取事件中传递的source对象，该对象即为A页面window对象的引用：</p>
<h3 id="2-2-case-2"><a href="#2-2-case-2" class="headerlink" title="2.2 case 2"></a>2.2 case 2</h3><p>两个打开的页面属于同源范畴。<br>若要实现两个互不相关的通源tab页面通信，可以使用一种比较巧妙的方式：localstorage。localStorage的存储遵循同源策略，因此</p>
<p>幸好，HTML5提供了storage事件，通过window对象侦听storage事件，</p>
<h3 id="2-3-case-3"><a href="#2-3-case-3" class="headerlink" title="2.3 case 3"></a>2.3 case 3</h3><p>两个互不相关的tab页面通信。<br>这种情况才是最急需解决的问题，如何实现两个没有任何关系的tab页面通信，这需要一些技巧，而且需要有同时修改这两个tab页面的权限，否则根本不可能实现这两个tab页的能力。</p>
<p>在上述条件满足的情况下，我们就可以使用case1 和 case2的技术完成case 3的需求，这需要我们巧妙的结合HTML5 postMessage API 和 storage事件实现这两个毫无关系的tab页面的连通。为此，我想到了iframe，通过在这两个tab页嵌入同一个iframe页实现“桥接”，最终完成通信：</p>
<p>tab A —–&gt; iframe A[bridge.html]<br>                     |<br>                     |<br>                    |/<br>             iframe B[bridge.html] —–&gt;  tab B </p>
<p>..</p>
<h1 id="D-前端通信篇"><a href="#D-前端通信篇" class="headerlink" title="D [前端通信篇]"></a>D [前端通信篇]</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>什么是同源策略及限制？前后端通信的ajax用原生该如何写？跨域问题该如何解决？如果你有这个疑问，这篇文章很适合你。</p>
<h2 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h2><p>同源的“源”包含3层意思：协议、域名和端口。三者之中只要有一个不一样，那就是可以称源不一样。</p>
<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是浏览器发出的用于隔离潜在恶意文件的关键的安全机制。</p>
<p>那么这个限制有哪些呢？主要有3个方面：</p>
<ol>
<li>Cookie、LocalStorage和IndexDB无法读取；</li>
<li>DOM无法获得；</li>
<li>AJAX请求不能发送；</li>
</ol>
<h2 id="前后端的通信方式"><a href="#前后端的通信方式" class="headerlink" title="前后端的通信方式"></a>前后端的通信方式</h2><p>Ajax<br>Websocket<br>CORS<br>Ajax是同源下的通信方式；Websocket不受同源策略的限制；CORS是新的通信标准，它支持跨域通信也支持同源通信。</p>
<h2 id="如何创建一个Ajax"><a href="#如何创建一个Ajax" class="headerlink" title="如何创建一个Ajax"></a>如何创建一个Ajax</h2><h2 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h2><p>1. JSONP<br>jsonp解决跨域本质是通过script标签的异步加载实现的，使用script标签进行ajax传输，不受同源策略的影响。</p>
<p>2. Hash<br>Hash就是url后面的#,hash改变页面是不会刷新的，所以这也是hash可以做跨域的原因。Search是url后面?后面的内容。所以search是不能做跨域通信的。</p>
<p>3. postMessage<br>h5中新增的方法</p>
<p>4. websocket<br>websocket可以做跨域，但是它出现的目的是为了解决实时通信的。</p>
<p>5. 搭建web服务器，对跨域请求做一个node代理<br>现在前端很多公司都会进行单独的部署，最多的就是使用express快速构建一个web服务器，用中间件的方式写一个代理。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>页面中特殊字符的处理</title>
    <url>/sum/js/%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="编码URI-javascript"><a href="#编码URI-javascript" class="headerlink" title="编码URI(javascript)"></a>编码URI(javascript)</h2><p># [JS操作cookie以及本地存储（sessionStorage 和 localStorage ）] 014-bD<br>JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：<br>unescape,decodeURI,decodeURIComponent 。</p>
<p>区别：<br>我们可以知道：escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。</p>
<p>而encodeURI()用于编码整个URI,因为URI中的合法字符都不会被编码转换。</p>
<p>encodeURIComponent方法在编码单个URIComponent 应当是最常用的，它可以将参数中的中文、特殊字符进行转义，而不会影响整个URL。</p>
<p>参考：<br><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a><br><a href="https://blog.csdn.net/xiongzhengxiang/article/details/6762568" target="_blank" rel="noopener">encodeURI encodeURIComponent 的作用 及 应用</a></p>
<h2 id="php中编码url"><a href="#php中编码url" class="headerlink" title="php中编码url"></a>php中编码url</h2><p># PHP - urlencode和rawurlencode的区别<br><a href="https://blog.csdn.net/amonest/article/details/6431183" target="_blank" rel="noopener">https://blog.csdn.net/amonest/article/details/6431183</a><br>看看PHP Manual对两个函数的说明：</p>
<p>urlencode：返回字符串，此字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 application/x-www-form-urlencoded 的媒体类型编码方式一样。由于历史原因，此编码在将空格编码为加号（+）方面与 RFC1738 编码（参见 rawurlencode()）不同。</p>
<p>rawurlencode：返回字符串，此字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。这是在 RFC 1738 中描述的编码，是为了保护原义字符以免其被解释为特殊的 URL 定界符，同时保护 URL 格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。</p>
<h2 id="acuviewer中特殊字符串"><a href="#acuviewer中特殊字符串" class="headerlink" title="acuviewer中特殊字符串"></a>acuviewer中特殊字符串</h2><p>页面中字符串显示如下：<br><code>Test Spcecial &lt;/chars&gt;Lecturer &#39;;&quot;:/.,?=-+_)(*&amp;^%$#@!</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"inc/header.js.php"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// header.js.php</span></span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">String.prototype.formatForJS = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s;</span><br><span class="line">    s = this.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\"</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">"&amp;#39;"</span>,<span class="string">"'"</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">"'"</span>,<span class="string">"\\'"</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'"'</span>,<span class="string">'&amp;quot;'</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'&gt;'</span>,<span class="string">'&amp;gt;'</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'&lt;'</span>,<span class="string">'&amp;lt;'</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">String.prototype.formatForHTML = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s;</span><br><span class="line">    s = this.replaceAll(<span class="string">"'"</span>,<span class="string">"&amp;apos;"</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'"'</span>,<span class="string">'&amp;quot;'</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'&gt;'</span>,<span class="string">'&amp;gt;'</span>);</span><br><span class="line">    s = s.replaceAll(<span class="string">'&lt;'</span>,<span class="string">'&amp;lt;'</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">v.SubscribeDisplayName&amp;&amp;(sTitle = v.SubscribeDisplayName.formatForJS());</span><br><span class="line">    <span class="comment">// 三元操作，后面的赋值不加`()`会报错：`Uncaught ReferenceError: Invalid left-hand side in assignment`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str = <span class="string">'&lt;?php echo $langmsg['</span><span class="number">1054</span><span class="string">'];?&gt;: &lt;a href="login/channel.php?id='</span> + encodeURIComponent(d[<span class="number">3</span>]) + <span class="string">'"&gt;'</span> + (oCdrData.FAuthorName&amp;&amp;oCdrData.FAuthorName.formatForHTML()) + <span class="string">'&lt;/a&gt;'</span>;</span><br><span class="line">    <span class="comment">// 赋值操作中，短路运算不加`()`会影响 str的赋值：`Philip&lt;/a&gt;`;`&amp;&amp;`前面的都没有计进去   </span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用acuview.php 中</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$subscribe_author_html = $langmsg[<span class="string">'1054'</span>] . <span class="string">':&amp;nbsp;&lt;a href="login/channel.php?id='</span> . rawurlencode($user_fid) . <span class="string">'"&gt;'</span>.htmlentities($studio[<span class="string">'FAuthorDisplayName'</span>]).<span class="string">'&lt;/a&gt;'</span>;        </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web存储</title>
    <url>/sum/js/web%E5%AD%98%E5%82%A8(014)/</url>
    <content><![CDATA[<h1 id="Cookie，session-localStorage-区别-014-aD"><a href="#Cookie，session-localStorage-区别-014-aD" class="headerlink" title="[Cookie，session, localStorage 区别] 014-aD"></a>[Cookie，session, localStorage 区别] 014-aD</h1><p>cookie的内容包括：名字、值、过期时间、路径和域；路径和域一起构成cookie的作用范围。<br>3 cookie 和 session 的区别<br>4 sessionStorage\localStorage\cookie区别：<br>6 浏览器本地存储与服务器存储的区别： </p>
<p>浏览器在一次 HTTP 请求中，需要传输一个 4097 字节的文本数据给服务端，可以采用那些方式?<br>a.存入indexDB、 b.写入cookie、 c.放在url参数、 d.写入session、 e.使用post、 f.放在local storage<br>解析：　<br>IndexdDB 是 HTML5 的本地存储，把一些数据存储到浏览器（客户端）中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用。<br>Cookie 通过在客户端 ( 浏览器 ) 记录信息确定用户身份，最大为 4 kb =4096b。<br>url 参数用的是 get 方法，从服务器上获取数据，大小不能大于 2 kb 。<br>Session 是服务器端使用的一种记录客户端状态的机制 。<br>post 是向服务器传送数据，数据量较大。<br>local Storage 也是 HTML5 的本地存储，将数据保存在客户端中（一般是永久的）。</p>
<p>作为前端 DB 的存储介质<br>表单自动持久化<br>Service Worker 的 CacheStorage。</p>
<h1 id="JS操作cookie以及本地存储（sessionStorage-和-localStorage-）"><a href="#JS操作cookie以及本地存储（sessionStorage-和-localStorage-）" class="headerlink" title="[JS操作cookie以及本地存储（sessionStorage 和 localStorage ）]"></a>[JS操作cookie以及本地存储（sessionStorage 和 localStorage ）]</h1><p>二、html5 web storage的浏览器支持情况<br>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是</p>
<p>补充：计算存储大小<br>参考 jslib/字符编码(0017)</p>
<h1 id="0143-D-本地存储和离线缓存"><a href="#0143-D-本地存储和离线缓存" class="headerlink" title="[0143-D 本地存储和离线缓存]"></a>[0143-D 本地存储和离线缓存]</h1><p>二 离线缓存<br>1&gt; 在html标签添加manifest属性<br>2&gt; 编写manifest文件</p>
<blockquote>
<p>manifest文件可分为三部分：<br>(1) CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存<br>(2)NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存<br>(3)FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</p>
</blockquote>
<p>3)离线缓存与传统浏览器缓存区别：<br>区别：<br>1、离线缓存是针对整个应用，浏览器缓存是单个文件<br>2、离线缓存断网了还是可以打开页面，浏览器缓存不行<br>3、离线缓存可以主动通知浏览器更新资源</p>
<p>三 本地存储和离线存储有什么不同<br>本地存储与离线缓存都是为了方便网页的加载，提高用户体验等。<br>本地存储一般存储的都是数据，而离线缓存一般存储的是网页等。</p>
<h1 id="详说-Cookie-LocalStorage-与-SessionStorage"><a href="#详说-Cookie-LocalStorage-与-SessionStorage" class="headerlink" title="[详说 Cookie, LocalStorage 与 SessionStorage]"></a>[详说 Cookie, LocalStorage 与 SessionStorage]</h1><table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th>localStorage-sessionStorage</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据的生命期</td>
<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td>除非被清除，否则永久保存–仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右</td>
<td>一般为5MB </td>
</tr>
<tr>
<td>与服务器端通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>需要程序员自己封装，源生的Cookie接口不友好</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
</tr>
</tbody>
</table>
<p><a href="http://jerryzou.com/posts/cookie-and-web-storage/" target="_blank" rel="noopener">详说 Cookie, LocalStorage 与 SessionStorage</a>  </p>
<h1 id="PHP中9大缓存技术总结"><a href="#PHP中9大缓存技术总结" class="headerlink" title="PHP中9大缓存技术总结"></a>PHP中9大缓存技术总结</h1><p><a href="http://www.imooc.com/article/1478" target="_blank" rel="noopener">PHP中9大缓存技术总结</a><br>1、全页面静态化缓存<br>2、页面部分缓存<br>3、数据缓存<br>4、查询缓存<br>5、按内容变更进行缓存<br>6、内存式缓存<br>7、apache缓存模块<br>8、php APC缓存扩展<br>9、Opcode缓存       </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码</title>
    <url>/sum/jsplus/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81(001)/</url>
    <content><![CDATA[<p># [JavaScript 有个 Unicode 的天坑]  0014-D   </p>
<h2 id="unicode-UTF-UCS"><a href="#unicode-UTF-UCS" class="headerlink" title="unicode UTF UCS"></a>unicode UTF UCS</h2><p>Unicode:用一个码点(code point)映射一个字符。码点值的范围是从U+0000到U+10FFFF，可以表示超过110万个符号<br>    Unicode最前面的65536个字符位，称为基本平面（BMP-—Basic Multilingual Plane），它的码点范围是从U+0000到U+FFFF<br>    补充平面16个</p>
<p>UTF（Unicode transformation format）Unicode转换格式，是服务于Unicode的，用于将一个Unicode码点转换为特定的字节序列。<br>UTF-8 可变字节序列，用1到4个字节表示一个码点<br>UCS（Universal Character Set）通用字符集，是一个ISO标准，目前与Unicode可以说是等价的。      </p>
<p>UTF-8对ASCⅡ编码是兼容的，都是一个字节，超过U+07FF的部分则用了复杂的转换方式来映射Unicode，<br>UTF-16对于BMP的码点，采用2个字节进行编码，而BMP之外的码点，用4个字节组成代理对<br>UCS-2是一个过时的编码方式，因为它只能编码基本平面（BMP)的码点，在BMP的编码上，与UTF-16是一致的，所以可以认为是UTF-16的一个子集。<br>UCS-4则与UTF-32等价，都是用4个字节来编码Unicode。</p>
<h2 id="javascript字符处理"><a href="#javascript字符处理" class="headerlink" title="javascript字符处理"></a>javascript字符处理</h2><p>javascript(引擎) UCS-2 编码</p>
<p>坑1——length属性<br>坑2——反转字符串<br>坑3——码点与字符互转<br>坑4——正则匹配<br>ES6的Unicode支持</p>
<p># [字符串js字符串与Unicode编码怎么做互相转换_百度知道]  0016-D  </p>
<h2 id="javascript字符普通处理"><a href="#javascript字符普通处理" class="headerlink" title="javascript字符普通处理"></a>javascript字符普通处理</h2><p>‘a’.charCodeAt(0)// 97<br>‘a’.charCodeAt().toString(16) //‘61’  即’\u0061’</p>
<p>String.fromCharCode(97) // ‘a’<br>‘\u0061’  // ‘a’</p>
<p>//十进制转其他<br>var x=97; x.toString(16) // ‘61’<br>//其他转十进制<br>parseInt(61,16) // 97<br>//其他转其他<br>//先用parseInt转成十进制再用toString转到目标进制 </p>
<h2 id="计算字符串字节数-x2-017-D"><a href="#计算字符串字节数-x2-017-D" class="headerlink" title="[计算字符串字节数] x2 017-D"></a>[计算字符串字节数] x2 017-D</h2><p>所以想办法在JavaScript中判断在UTF-8下存储的String的字节数，在网上找到很多关于Unicode介绍的文档，最重要的是字符编码数值对应的存储长度：</p>
<p>UCS-2编码(16进制) UTF-8 字节流(二进制)<br>0000 - 007F 0xxxxxxx （1字节）<br>0080 - 07FF 110xxxxx 10xxxxxx （2字节）<br>0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx （3字节）</p>
<p>if(charset === ‘utf-16’ || charset === ‘utf16’){<br>}else{// utf-8<br>    if (charCode &lt; 0x007f) {<br>        totalLength = totalLength + 1;<br>    } else if ((0x0080 &lt;= charCode) &amp;&amp; (charCode &lt;= 0x07ff)) {<br>        totalLength += 2;<br>    } else if ((0x0800 &lt;= charCode) &amp;&amp; (charCode &lt;= 0xffff)) {<br>        totalLength += 3;<br>    }<br>}</p>
<p># 补充： 计算JavaScript对象大小<br><a href="https://ask.helplib.com/javascript/post_307851" target="_blank" rel="noopener">JavaScript对象大小</a><br>js库：<a href="https://github.com/miktam/sizeof/blob/master/index.js" target="_blank" rel="noopener">https://github.com/miktam/sizeof/blob/master/index.js</a><br>nodejs： npm install object-sizeof<br>Google Chrome 堆分析器允许你检查对象内存使用情况：后我在 profiler ( 录制录音后) 中找到了对象的完整大小以及它在”保留的大小”下的所有内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">roughSizeOfObject</span>(<span class="params"> value, level </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level == <span class="literal">undefined</span>) level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">'boolean'</span> ) &#123;</span><br><span class="line">        bytes = <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">'string'</span> ) &#123;</span><br><span class="line">        bytes = value.length * <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">'number'</span> ) &#123;</span><br><span class="line">        bytes = <span class="number">8</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> value === <span class="string">'object'</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value[<span class="string">'__visited__'</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            value[<span class="string">'__visited__'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( i <span class="keyword">in</span> value ) &#123;</span><br><span class="line">            bytes += i.length * <span class="number">2</span>;</span><br><span class="line">            bytes+= <span class="number">8</span>;<span class="comment">//an assumed existence overhead</span></span><br><span class="line">            bytes+= roughSizeOfObject( value[i], <span class="number">1</span> )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(level == <span class="number">0</span>)&#123;</span><br><span class="line">        clear__visited__(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear__visited__</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value == <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> value[<span class="string">'__visited__'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> value)&#123;</span><br><span class="line">            clear__visited__(value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">roughSizeOfObject(<span class="string">'a'</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端路由</title>
    <url>/sum/js/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1(016)/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h2><p>pjax：history<br>react-router4+：两种模式，是动态路由(一般/之前 是静态路由)，有exact匹配,而且可以在服务器端的使用<br>vuejs： 两种模式可以选择<br>angularjs/vue router,<br>单页应用 …    </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><!-- \# [[前端路由的实现方式]](http://www.jianshu.com/p/5a5813648d87) -->
<p>最近一直在研究前后端分离，ajax可以很好的解决前后端分离的问题，但是又存在着浏览器无法前进后退，这个问题比较尴尬。但是采用前端路由的方式可以很好的解决这个问题。   </p>
<p>路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同。<br>传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。在这种场景下，出现了单页应用。   </p>
<p>单页应用，就是只有一个页面，用户访问一个网址，服务器返回的页面始终只有一个，不管用户改变了浏览器地址栏的内容或者在页面内发生了跳转，服务器不会重新返回新的页面，而是通过相应的js操作来实现页面的更改。而地址栏内容的改变，显示不同的页面，实现的手段就是前端路由。      </p>
<p>前端路由主要由两种方式实现：location.hash+hashchange事件，history.pushState()+popState事件<br><!-- $end --></p>
<h2 id="web路由"><a href="#web路由" class="headerlink" title="web路由"></a>web路由</h2><!-- \# [理解web路由] -->
<p>### 什么是路由<br>简单来说，路由就是URL到函数的映射。     </p>
<p>### router和route的区别<br>route就是一条路由，它将一个URL路径和一个函数进行映射，例如：  </p>
<p>### 服务器端路由<br>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。       </p>
<p>对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。<br>对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。</p>
<p>### 客户端路由<br>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：     </p>
<p>#### 1  基于Hash: location.hash+onhashchange事件<br>hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。       </p>
<p>#### 2 history: history.pushState/replaceState()+onpopState事件<br>通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。<br>但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pushState = history.pushState</span><br><span class="line">history.pushState = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushState.apply(history, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// emit a event or just run a callback</span></span><br><span class="line">  emitEventOrRunCallback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过，最好的方法还是使用实现好的<strong>history库</strong>。</p>
<p>#### 两种实现的比较<br>总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。  </p>
<p>但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。   </p>
<p>### 五 动态路由<br>上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。     </p>
<p>### 六  严格路由<br>在很多情况下，会遇到/foobar和/foobar/的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。      </p>
<!-- $end -->
<p>## 其它<br>stateObj是会被持久化的硬盘上进行存储的，至少firefox是这么说的，我猜只要历史记录不销毁，它关联的stateObj就会一直存在。<br>$PS: react-router 路由state的状态 存储在sessionStorage里面       </p>
<p>一、history.pushState和history.replaceState都不会触发这个事件<br>二、仅在浏览器前进后退操作、history.go/back/forward调用、hashchange的时候触发     </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http缓存</title>
    <url>/sum/js/http%E7%BC%93%E5%AD%98(004)/</url>
    <content><![CDATA[<p>304: not Modified<br>302 Found 重定向状态码     </p>
<p>本地存储解决方案很多，比如Flash SharedObject、Google Gears、Cookie、DOM Storage、User Data、window.name、Silverlight、Open Database等。</p>
<p># [HTTP 缓存机制一二三]:<br>Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。<br>浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容。</p>
<h2 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h2><p>Vary: User-Agent, Accept-Encoding</p>
<p>强制缓存：<br>param，http1.0  值：no-cache<br>    <code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</code><br>仅有IE才能识别这段meta标签含义<br>在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。</p>
<p>expires，http1.0<br>cache-control， http1.1/优先级高，通用头</p>
<p>cache-control:max-age=\<seconds>;s-maxage=\<seconds><br>    public/private, no-chche, no-store</seconds></seconds></p>
<p>协商缓存：<br>res/req<br>Last-Modified / If-Modified-Since<br>Etag / If-None-Match</p>
<p># [浏览器缓存机制剖析]</p>
<h2 id="vary-date-age等"><a href="#vary-date-age等" class="headerlink" title="vary date age等"></a>vary date age等</h2><p>vary: 对于服务器而言, 资源文件可能不止一个版本, 比如说压缩和未压缩, 针对不同的客户端, 通常需要返回不同的资源版本. 比如说老式的浏览器可能不支持解压缩<br>Vary:Accept-Encoding,User-Agent<br>Age:2383321 :表示命中代理服务器的缓存. 它指的是代理服务器对于请求资源的已缓存时间,<br>Date:Wed, 08 Mar 2017 16:12:42 GMT :响应生成的时间. 请求经过代理服务器时, 返回的Date未必是最新的, 通常这个时候, 代理服务器将增加一个Age字段告知该资源已缓存了多久.</p>
<p>其它：[浅谈浏览器http的缓存机制]  </p>
<h2 id="怎么让浏览器不缓存静态资源"><a href="#怎么让浏览器不缓存静态资源" class="headerlink" title="怎么让浏览器不缓存静态资源"></a>怎么让浏览器不缓存静态资源</h2><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../css/style.css?version=1.8.9&quot;/&gt;</code>   </p>
<p><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot;/&gt;</code><br>上述虽能禁用缓存, 但只有部分浏览器支持, 而且由于代理不解析HTML文档, 故代理服务器也不支持这种方式.</p>
<h2 id="F5-刷新，强制刷新"><a href="#F5-刷新，强制刷新" class="headerlink" title="F5/刷新，强制刷新"></a>F5/刷新，强制刷新</h2><p># [如何用 HTTP Caching 优化网站]  0043-D<br>Last-Modified 与 Etag 头（即是方式1和2）还是要请求服务器的，只是仅返回 304  头，不返回内容。所以浏览怎么 F5 ，304 都是有效的。但用 Ctrl+F5 是全新请求的（这是浏览器行为，不发送缓存相关的头）。</p>
<p>Expires 头与 max-age 缓存是不需要请求服务器的，直接从本地缓存中取。但 F5 会忽视缓存（所以使用 httpwatch 之类的 http 协议监察工具时，不要 F5 误认为 Expires 和 max-age 是无效的）。</p>
<p># [彻底理解浏览器的缓存机制] 004-D   </p>
<h2 id="内存缓存和硬盘缓存"><a href="#内存缓存和硬盘缓存" class="headerlink" title="内存缓存和硬盘缓存"></a>内存缓存和硬盘缓存</h2><p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p>
<p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：</p>
<p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p>
<p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>
<p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p>
<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Blob和base64</title>
    <url>/sum/jsplus/blob%E5%92%8Cbase64(021)/</url>
    <content><![CDATA[<p># [<a href="https://zh.wikipedia.org/wiki/Base64]" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Base64]</a></p>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p>基于64个可打印字符来表示二进制数据的表示方法。<br>Base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。   </p>
<p>由于 {\displaystyle 2^{6}=64} {\displaystyle 2^{6}=64}，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。</p>
<p>在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。等号=用来作为后缀用途。<br>使用时，在传输编码方式中指定Base64。使用的字符包括大小写拉丁字母各26个、数字10个、加号+和斜杠/，共64个字符，</p>
<p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。</p>
<p>编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC 822规定，每76个字符，还需要加上一个回车换行。</p>
<p>Base64编码方式：  </p>
<p># 文件和二进制数据的操作<br><a href="http://javascript.ruanyifeng.com/htmlapi/file.html" target="_blank" rel="noopener">[文件和二进制数据的操作]</a>  </p>
<p>历史上，JavaScript无法处理二进制数据。如果一定要处理的话，只能使用charCodeAt()方法，一个个字节地从文字编码转成二进制数据，还有一种办法是将 <strong>二进制数据转成Base64编码</strong>，再进行处理。这两种方法不仅速度慢，而且容易出错。ECMAScript 5引入了Blob对象，允许直接操作二进制数据。</p>
<p>Blob对象是一个代表二进制数据的基本对象，在它的基础上，又衍生出一系列相关的API，用来操作文件。</p>
<p>File对象：负责处理那些以文件形式存在的二进制数据，也就是操作本地文件；<br>FileList对象：File对象的网页表单接口；<br>FileReader对象：负责将二进制数据读入内存内容；<br>URL对象：用于对二进制数据生成URL。</p>
<h2 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h2><p>Blob（Binary Large Object）对象代表了一段二进制数据，提供了一系列操作接口。其他操作二进制数据的API（比如File对象），都是建立在Blob对象基础上的，继承了它的属性和方法。</p>
<p>生成Blob对象有两种方法：一种是使用Blob构造函数，另一种是对现有的Blob对象使用slice方法切出一部分。</p>
<p>## 2 FileList对象<br>## 3 File API<br>## 4 FileReader API<br>对于不同类型的文件，FileReader提供不同的方法读取文件。</p>
<p>readAsBinaryString(Blob|File)：返回二进制字符串，该字符串每个字节包含一个0到255之间的整数。<br>readAsText(Blob|File, opt_encoding)：返回文本字符串。默认情况下，文本编码格式是’UTF-8’，可以通过可选的格式参数，指定其他编码格式的文本。<br>readAsDataURL(Blob|File)：返回一个基于Base64编码的data-uri对象。<br>readAsArrayBuffer(Blob|File)：返回一个ArrayBuffer对象。   </p>
<p>onload事件的回调函数接受一个事件对象，该对象的target.result就是文件的内容。</p>
<p>## 5 综合实例：显示用户选取的本地图片</p>
<h2 id="URL对象"><a href="#URL对象" class="headerlink" title="URL对象"></a>URL对象</h2><p>URL对象用于生成指向File对象或Blob对象的URL。</p>
<p><code>var objecturl =  window.URL.createObjectURL(blob);</code>   </p>
<p>会对二进制数据生成一个URL，类似于“blob:http%3A//test.com/666e6730-f45c-47c1-8012-ccc706f17191”。这个URL可以放置于任何通常可以放置URL的地方，比如img标签的src属性。需要注意的是，即使是同样的二进制数据，每调用一次URL.createObjectURL方法，就会得到一个不一样的URL。</p>
<p>这个URL的存在时间，等同于网页的存在时间，一旦网页刷新或卸载，这个URL就失效。除此之外，也可以手动调用URL.revokeObjectURL方法，使URL失效。</p>
<p># [php – 什么是blob url,为什么使用它？]</p>
<h2 id="blob-url"><a href="#blob-url" class="headerlink" title="blob url"></a>blob url</h2><p>Blob网址只能由浏览器在内部生成。 URL.createObjectURL()将创建对Blob或File对象的特殊引用，稍后可以使用URL.revokeObjectURL()释放它。这些URL只能在浏览器的单个实例中和在同一会话(即页面/文档的生命周期)中本地使用。</p>
<p>Blob URL /对象URL是一种伪协议，允许Blob和File对象用作图像，二进制数据的下载链接等URL源。</p>
<h2 id="Data-URL和图片"><a href="#Data-URL和图片" class="headerlink" title="Data URL和图片"></a>Data URL和图片</h2><p># <a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data URL和图片</a><br>## 3 在CSS里使用Data URL<br>## 4 将图片转换成Data URL格式的方法</p>
<p># [MediaSource的使用以及封装MP4转加载Blob的插件]</p>
<h2 id="MediaSource-mp4转blob"><a href="#MediaSource-mp4转blob" class="headerlink" title="MediaSource/mp4转blob"></a>MediaSource/mp4转blob</h2><p>API allowing media data to be accessed from HTML video and audio elements.</p>
<h2 id="下载blob-视频"><a href="#下载blob-视频" class="headerlink" title="下载blob 视频"></a>下载blob 视频</h2><p># <a href="https://cloud.tencent.com/developer/ask/81565" target="_blank" rel="noopener">当url是blob url时，html5下载属性不起作用应该怎么解决？</a><br>注意：使用MediaStream对象作为此方法的输入正在被弃用。正在讨论是否应该彻底删除它。因此，应该尽量避免在MediaStream中使用此方法，而应该使用HTMLMediaElement.srcObject（）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function downloadvideo(video)&#123;</span><br><span class="line">    // const url = URL.createObjectURL(video.captureStream());// # 1 not ok</span><br><span class="line"></span><br><span class="line">    //adding a dom element and fetching it in HTMLMediaElement.</span><br><span class="line">    var mediaStream = video.captureStream();</span><br><span class="line">    HTMLMediaElement.srcObject = mediaStream;</span><br><span class="line">    var url = HTMLMediaElement.currentSrc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    const aelem = document.createElement(&apos;a&apos;);</span><br><span class="line">    document.body.appendChild(aelem);</span><br><span class="line">    aelem.setAttribute(&quot;href&quot;,url);</span><br><span class="line">    aelem.setAttribute(&quot;download&quot;,&quot;video.mp4&quot;);</span><br><span class="line">    aelem.click();</span><br><span class="line">    //URL.revokeObjectURL(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其它：<br><a href="https://stackoverflow.com/questions/14952052/convert-blob-url-to-normal-url" target="_blank" rel="noopener">Convert blob URL to normal URL</a>  </p>
<p>其它：<br><a href="https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html" target="_blank" rel="noopener">HTML5 Video Blob 初探</a></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>angular.js 坑</title>
    <url>/sum/jsplus/angularjs%E5%9D%91/</url>
    <content><![CDATA[<p>实际接触，认识到angularjs冰山一角；<br><strong>表单是交互中最难的</strong>，超过动画；有太多不确定因素，包括验证，数据缓存，提交，更新样式/状态等。     </p>
<p>angularjs:<a href="https://angularjs.org" target="_blank" rel="noopener">https://angularjs.org</a><br>angular:<a href="https://angular.io/" target="_blank" rel="noopener">https://angular.io/</a><br>实际使用的angularjs版本:1.3.15。没有把文档lu一遍<br><a href="https://code.angularjs.org/1.3.15/docs/api" target="_blank" rel="noopener">https://code.angularjs.org/1.3.15/docs/api</a>   </p>
<h2 id="一-基本"><a href="#一-基本" class="headerlink" title="一 基本"></a>一 基本</h2><p>angularjs：MVC,双向数据绑定，依赖注入，指令 …<br>功能强大，尤其是和表单/数据 操作；</p>
<p>双向数据绑定表单提交时，需要注意提交成功后才可以更新视图<br>验证功能，自己做了处理；没有用三方    </p>
<p>指令/过滤/element/函数 等都实用<br>没有实用路由功能<br>事件机制也没有研究，不像react等那么清楚</p>
<h3 id="控制器和依赖注入"><a href="#控制器和依赖注入" class="headerlink" title="控制器和依赖注入"></a>控制器和依赖注入</h3><p>$scope,$http,$timeout等需要注入才可以使用，包括自定义的服务。<br>三种注入方式，上面最合适 </p>
<p>$scope相当于作用域<br>没有实用嵌套，互相传递<br>$scope的方法：$scope.$apply(), $scope.$watch()   </p>
<ol>
<li>$watch   </li>
</ol>
<p>参考：<br><a href="http://bijian1013.iteye.com/blog/2108127" target="_blank" rel="noopener">详解AngularJS中的$watch</a>   </p>
<ol start="2">
<li>$http有三种方式的缓存可以利用   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.controller(<span class="string">'controller'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope,$http,$timeout</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 数据缓存</span></span><br><span class="line">	$http.get(<span class="string">'./db/quiz.php?act=get_quiz_report&amp;author='</span> + <span class="built_in">encodeURIComponent</span>($scope.oEditQuiz.FAuthor),&#123;<span class="attr">cache</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<br><a href="http://www.html-js.com/article/AngularJS-tips-about-Angular-http-cache-in-service" target="_blank" rel="noopener">说说Angular $http service中的缓存</a><br><a href="http://hbiao68.iteye.com/blog/2371290" target="_blank" rel="noopener">ular $http cache学习笔记</a>   </p>
<h3 id="angular方法"><a href="#angular方法" class="headerlink" title="angular方法"></a>angular方法</h3><p>copy,equals,forEach,element,… </p>
<p>isNumber,isObject没有用<br>forEach: 和ES5的参数，顺序不一样；如果不支持ES5,可以用ng<br>copy: 深度克隆<br>equals: 对象/数值的数值比较<br>element: jQ方式的dom操作<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jQuery Lite </span></span><br><span class="line">angular.element(<span class="string">'.table-headFixed_body .table tr'</span>).css(&#123;<span class="attr">background</span>:<span class="string">'#fff'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在全局得到$scope绑定数据，控制台可以调试 </span></span><br><span class="line"><span class="keyword">var</span> appElement = <span class="built_in">document</span>.querySelector(<span class="string">'[ng-controller=controller]'</span>);</span><br><span class="line">goScope = angular.element(appElement).scope();</span><br></pre></td></tr></table></figure></p>
<h3 id="ng-class"><a href="#ng-class" class="headerlink" title="ng-class"></a>ng-class</h3><p>对象时： 可以写表达式<br>className有特殊字符，比如<code>-</code>需要加引号  </p>
<p>结合css的优先级，样式切换的话，写一个ng-class(后定义的-优先级高，可以覆盖)就可以了<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-class</span>=<span class="string">"&#123;'quiz-bg-danger':quizQuestionView.correct===0&#125;"</span> <span class="attr">class</span>=<span class="string">"quiz-bg-success"</span>&gt;</span></span><br><span class="line">    &#123;&#123; quizQuestionView.correct?'&lt;?=$langmsg["1324"]?&gt;':'&lt;?=$langmsg["1325"]?&gt;' &#125;&#125;<span class="comment">&lt;!-- Correct/Incorrect --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><p>可以给默认选项；设置选中项值的类型。<br>还可以获取之前选项，进行更改前的验证（如果需要的话）。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-change</span>=<span class="string">"doQuizQuestionType('&#123;&#123;quizQuestionEdit.type&#125;&#125;')"</span> <span class="attr">ng-model</span>=<span class="string">"quizQue stionEdit.type"</span> <span class="attr">ng-options</span>=<span class="string">"x.id as x.name for x in quizQuestion_type"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"edit_quizType"</span> <span class="attr">id</span>=<span class="string">"quizQuestion_type"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"oEditQuiz.FQuizSetting.passingType"</span> <span class="attr">ng-options</span>=<span class="string">"x.id as x.name for x in quizSetting_types"</span> <span class="attr">name</span>=<span class="string">"quizSetting_type"</span> <span class="attr">id</span>=<span class="string">"quizSetting_type"</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$scope.quizQuestion_type=[</span><br><span class="line">	&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'&lt;?=$langmsg["1345"]?&gt;'</span>&#125;,<span class="comment">/* Multiple Choice */</span></span><br><span class="line">	&#123;<span class="attr">id</span>:<span class="number">0</span>,<span class="attr">name</span>:<span class="string">'&lt;?=$langmsg["1344"]?&gt;'</span>&#125;,<span class="comment">/* Multiple Response */</span></span><br><span class="line">	&#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'&lt;?=$langmsg["1346"]?&gt;'</span>&#125;<span class="comment">/* True/False */</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="http://www.voidcn.com/article/p-xhcqlnkn-bhs.html" target="_blank" rel="noopener">AngularJs select绑定数字类型问题</a><br><a href="https://codeday.me/bug/20170704/35101.html" target="_blank" rel="noopener">angularjs – ng-change获取新值和原始值</a>   </p>
<h3 id="单-多选框-切换"><a href="#单-多选框-切换" class="headerlink" title="单/多选框 切换"></a>单/多选框 切换</h3><p>单/多选框用一个(ng-checked)时，双向数据绑定的时候有点抽风。<br>有时传回来的数组，切换问题的时候竟然变成了对象，然后就会导致没有绑定，视图中不会选中。</p>
<p>可能是因为：开始的时候用了一个input标签，数据绑定方式不是ng的方式。导致数据变为对象；而且，视图也不会根据数据做出正确的更新。<br>包括答题的时候，userAnswers是undefined的，需要手动换成一个数组。  </p>
<p>最后：editMode,quizItem 中换成了两个标签，利用ng单/多选框的使用方式。  </p>
<ol>
<li>editMode,quizItem还是分离了，取消了ng-check,利用ng原生的数据绑定方法。<br> 但是需要为radio做未选中时数据为0，checkbox切换选中状态，添加了ng-click自己做控制。<br> 包括没有点击时，默认为undefined的情况。</li>
<li>dQuizReview 自定义样式，也抛弃了input的方式。可以用同一个元素（div/span等）表示了。样式/选中状态都可以灵活控制  </li>
<li><strong>CHECK:</strong> editMode切换问题的时候，正确选项可能不会正确绑定</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- dQuizItem --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span>  <span class="attr">ng-click</span>=<span class="string">"doQuizQuestionAnswers($event,$index)"</span>  <span class="attr">ng-true-value</span>=<span class="string">"1"</span> <span class="attr">ng-false-value</span>=<span class="string">"0"</span> <span class="attr">ng-model</span>=<span class="string">"quizQuestionEdit.answers[$index]"</span> <span class="attr">ng-show</span>=<span class="string">"quizQuestionEdit.type==0"</span> <span class="attr">title</span>=<span class="string">"&lt;?=$langmsg['1319']?&gt;"</span> <span class="attr">name</span>=<span class="string">"questionAnswerEdit&#123;&#123;$index&#125;&#125;"</span>  <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">ng-click</span>=<span class="string">"doQuizQuestionAnswers($event,$index)"</span> <span class="attr">ng-model</span>=<span class="string">"quizQuestionEdit.answers[$index]"</span> <span class="attr">ng-value</span>=<span class="string">"1"</span> <span class="attr">ng-hide</span>=<span class="string">"quizQuestionEdit.type==0"</span> <span class="attr">title</span>=<span class="string">"&lt;?=$langmsg['1319']?&gt;"</span> <span class="attr">name</span>=<span class="string">"questionAnswerEdit"</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;input ng-click="doQuizQuestionAnswers($event,$index)" ng-checked="quizQuestionEdit.answers[$index]==1" type="&#123;&#123;quizQuestionEdit.type?'radio':'checkbox'&#125;&#125;"  name="&#123;&#123;quizQuestionEdit.type?'questionAnswerEdit':'questionAnswerEdit'+$index&#125;&#125;" title="&lt;?=$langmsg['1319']?&gt;"&gt;check for correct answer --&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- dQuizReview --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"option in quizQuestionsReview[quizQuestionReviewIndex].options track by $index"</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"quizQuestionReview_ops_answers"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">b</span> <span class="attr">ng-show</span>=<span class="string">"quizQuestionsReview[quizQuestionReviewIndex]['answers'][$index]==1"</span> <span class="attr">class</span>=<span class="string">"answerReview-checked"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">ng-class</span>=<span class="string">"&#123;'answerReview-radio':quizQuestionsReview[quizQuestionReviewIndex].type===0&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"quizQuestionReview_ops_userAnswers"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">b</span> <span class="attr">ng-show</span>=<span class="string">"quizQuestionsReview[quizQuestionReviewIndex]['userAnswers'][$index]==1"</span> <span class="attr">class</span>=<span class="string">"answerReview-checked"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">ng-class</span>=<span class="string">"&#123;'answerReview-radio':quizQuestionsReview[quizQuestionReviewIndex].type===0&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"quizQuestionReview_ops_option"</span>&gt;</span></span><br><span class="line">           &#123;&#123;quizAnswer_tips[$index]&#125;&#125; &#123;&#123; option &#125;&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://guxinyan.github.io/2017/03/28/AngularJS%E4%B8%AD%E7%9A%84radio%E5%92%8Ccheckbox/#radio" target="_blank" rel="noopener">AngularJS中的radio和checkbox</a>     </p>
<h3 id="不靠谱的ng-checked"><a href="#不靠谱的ng-checked" class="headerlink" title="不靠谱的ng-checked"></a>不靠谱的ng-checked</h3><p>以下内容，可能还是因为利用一个input标签导致切换的问题。   </p>
<ol>
<li>只有ng-checked<br>不靠谱啊：第一次进去是好，切换next/previous 单选框不能绑定，多选框少了第一个<br>有文章说，单选 ng-checked 还要判断 == ，然并卵<blockquote>
<p>对于radio的绑定，主要指定属性==true,也就是<code>&lt;input id=&#39;sex&#39;  name=&quot;sex&quot;  type=&quot;radio&quot; ng-model=&#39;sex&#39; ng-checked=&quot;sex==true&quot;&gt;男</code><br>而不是单纯的指定属性，如果单纯指定属性不返回属性的值<br><a href="http://blog.csdn.net/u011127019/article/details/52556781" target="_blank" rel="noopener">http://blog.csdn.net/u011127019/article/details/52556781</a> </p>
</blockquote>
</li>
<li>拆分成两个input 只有ng-model<br>根本没有绑定，即单/多选框不会选中(View中)</li>
<li>ng-model + ng-checked<br>和只有 ng-checked 的情况差不多</li>
</ol>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="自定义过滤"><a href="#自定义过滤" class="headerlink" title="自定义过滤"></a>自定义过滤</h3><p>ng-model中不能写过滤，需要自己写指令，结合指令的model配置项<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   angular.module(<span class="string">'app'</span>, [])</span><br><span class="line">.filter(<span class="string">'seconds2str'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// cc from &lt;docs.videojs.com/utils_format-time.js.html&gt;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">seconds</span>)</span>&#123;</span><br><span class="line">		secodes=seconds&lt;<span class="number">0</span>?<span class="number">0</span>:seconds;</span><br><span class="line">		<span class="keyword">var</span> s=<span class="built_in">Math</span>.floor(seconds %<span class="number">60</span>);</span><br><span class="line">		<span class="keyword">var</span> m=<span class="built_in">Math</span>.floor(seconds / <span class="number">60</span> %<span class="number">60</span>);</span><br><span class="line">		<span class="keyword">var</span> h=<span class="built_in">Math</span>.floor(seconds / <span class="number">3600</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isNaN</span>(seconds)||seconds===<span class="literal">Infinity</span>)&#123;</span><br><span class="line">			h=m=s=<span class="string">'-'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		h=(h&gt;<span class="number">0</span>)?h+<span class="string">':'</span>:<span class="string">''</span>;</span><br><span class="line">		m=((h&gt;<span class="number">0</span>&amp;&amp;m&lt;<span class="number">10</span>)?<span class="string">'0'</span>+m:m)+<span class="string">':'</span>;</span><br><span class="line">		s=(s&lt;<span class="number">10</span>)?<span class="string">'0'</span>+s:s;</span><br><span class="line">		<span class="keyword">return</span> h+m+s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// number过滤器</span></span><br><span class="line"><span class="comment">// &lt;td&gt;&#123;&#123;(quizStu.FTotalAwarded/quizStu.FTotalPoints)*100|number:0&#125;&#125;&lt;/td&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://cloud.tencent.com/developer/ask/49852" target="_blank" rel="noopener">AngularJS - 如何将毫秒转换成xHours和yMins？</a><br><a href="https://blog.csdn.net/zk437092645/article/details/37882191" target="_blank" rel="noopener">angular input输入框中使用filter格式化日期</a>   </p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>可配置项还是很多的。return的方式，restrict/link/…,scope/element/…,注入的服务..     </p>
<p>输出会在页面加载定义的时候输出一次；余下的输出只有在return 相应的函数/监听才会有输出<br>自定义指令功能很丰富 </p>
<p>自定义指令，大小写:都是小写没问题；<br>定义时候有大写，html中使用时必须<code>-</code>隔离大写，html中大写没用</p>
<h4 id="获取焦点"><a href="#获取焦点" class="headerlink" title="获取焦点"></a>获取焦点</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** 两种方式   </span></span><br><span class="line"><span class="comment">    * $timeout的注入方式  </span></span><br><span class="line"><span class="comment">    * 监听时，是监听到变化时才会执行；所以要先把变量重新定义为false </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">.directive(<span class="string">'focusoncondition'</span>, [<span class="string">'$timeout'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">$timeout</span>) </span>&#123;</span><br><span class="line">	<span class="comment">/* var checkDirectivePrerequisites=function($timeout)&#123;</span></span><br><span class="line"><span class="comment">		if(!attrs.focusoncondition&amp;&amp;attrs.focusoncondition!="")&#123;</span></span><br><span class="line"><span class="comment">			throw "FocusOnCondition missing attribute to evaluate";</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125; */</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		restrict:<span class="string">"A"</span>,</span><br><span class="line">		link:<span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs,ctrls</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// checkDirectivePrerequisites(attrs);</span></span><br><span class="line">			scope.$watch(<span class="string">'isFocusOnQuestionTitle'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">cv,ov,</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// scope.$watch(attrs.focusoncondition,function(cv,ov)&#123;</span></span><br><span class="line">				<span class="comment">// console.log(cv)</span></span><br><span class="line">				<span class="keyword">if</span>(cv==<span class="literal">true</span>)&#123;</span><br><span class="line">					<span class="comment">// $timeout(function()&#123;element[0].focus()&#125;);</span></span><br><span class="line">					element[<span class="number">0</span>].focus()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;])</span><br><span class="line">   <span class="comment">// html</span></span><br><span class="line">   <span class="comment">//&lt;input focusoncondition="isFocusOnQuestionTitle" autofocus required &gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://ask.helplib.com/angularjs/post_798762" target="_blank" rel="noopener">focus - 以 Angular 方式，设置元素焦点</a><br><a href="https://blog.csdn.net/zcl_love_wx/article/details/51382197" target="_blank" rel="noopener">深究AngularJS——如何获取input的焦点（自定义指令）</a>   </p>
<h4 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// console.log('redirecitv')</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		restrict: <span class="string">'A'</span>, </span><br><span class="line">		link: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs</span>) </span>&#123;</span><br><span class="line">			element.bind(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">				<span class="comment">// console.log(element)</span></span><br><span class="line">				<span class="comment">//call the function that was passed </span></span><br><span class="line">		        scope.$apply(attrs.imageonload);</span><br><span class="line">	      	&#125;);</span><br><span class="line">			element.bind(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">// console.log('error');</span></span><br><span class="line">			&#125;);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">   <span class="comment">// html</span></span><br><span class="line">   <span class="comment">//&lt;img imageonload="gotoAS(img.index)" ng-repeat="img in imgList track by $index" ng-src="&#123;&#123;img.src&#125;&#125;" alt=""&gt;</span></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="http://www.jb51.net/article/105713.htm" target="_blank" rel="noopener">详解Angularjs 如何自定义Img的ng-load 事件</a><br><a href="http://blog.tcs-y.com/2017/09/05/angular-image-preload/" target="_blank" rel="noopener">angular实现图片预加载指令</a><br><a href="https://www.bbsmax.com/A/Vx5M1Bla5N/" target="_blank" rel="noopener">AngularJS中如果ng-src 图片加载失败怎么办</a>   </p>
<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p>参考：<br>1. <a href="https://blog.csdn.net/qq_36898102/article/details/78715976" target="_blank" rel="noopener">angularJS-滚动到底部触发事件</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;div class="box" when-scrolled="loadMore()"&gt;</span></span><br><span class="line"><span class="comment">//滚动指令   </span></span><br><span class="line">pro.directive(<span class="string">'whenScrolled'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">scope, elm, attr</span>) </span>&#123;    </span><br><span class="line">		<span class="comment">// 内层DIV的滚动加载    </span></span><br><span class="line">		<span class="keyword">var</span> raw = elm[<span class="number">0</span>];    </span><br><span class="line">		elm.bind(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">			<span class="keyword">if</span> (raw.scrollTop + raw.offsetHeight &gt;= raw.scrollHeight) &#123;   </span><br><span class="line">				scope.$apply(attr.whenScrolled);    </span><br><span class="line">			&#125;;    </span><br><span class="line">		&#125;);    </span><br><span class="line">	&#125;;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2. <a href="https://xiaogliu.github.io/2017/04/12/manipulate-dom-use-angular-directive/" target="_blank" rel="noopener">通过AngularJS指令操作DOM</a><br><del>同一个作者相同文章：<a href="http://www.jb51.net/article/113387.htm" target="_blank" rel="noopener">Angular.JS通过指令操作DOM的方法</a></del><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个引入jQuery操作DOM的指令如下：</span></span><br><span class="line">webApp.directive(<span class="string">"detailTopStick"</span>, [<span class="string">"$timeout"</span>, <span class="string">"$window"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$timeout, $window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span>,</span><br><span class="line">    link: <span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">      $timeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> navbar = $(<span class="string">".navbar-nav"</span>);</span><br><span class="line">        <span class="keyword">var</span> navbarOffsetTop = navbar.offset().top;</span><br><span class="line">        <span class="keyword">var</span> headerInfo = $(<span class="string">".header-info"</span>);</span><br><span class="line">        <span class="keyword">var</span> headerInfoMarginBottom = <span class="built_in">parseInt</span>(headerInfo.css(<span class="string">"margin-bottom"</span>));</span><br><span class="line">        <span class="keyword">var</span> navbarHeight = <span class="built_in">parseInt</span>(navbar.css(<span class="string">"height"</span>));</span><br><span class="line"></span><br><span class="line">        angular.element($<span class="built_in">window</span>).bind(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 窗口绑定resize事件</span></span><br><span class="line">          navbar.css(<span class="string">"width"</span>, headerInfo.width());</span><br><span class="line">          navbarOffsetTop = navbar.offset().top;</span><br><span class="line">          scope.$apply();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        angular.element($<span class="built_in">window</span>).bind(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ($<span class="built_in">window</span>.scrollY &gt; navbarOffsetTop) &#123;</span><br><span class="line">            navbar.css(<span class="string">"width"</span>, headerInfo.width());</span><br><span class="line">            navbar.addClass(<span class="string">"detail-navbar-fix"</span>);</span><br><span class="line">            headerInfo.css(<span class="string">"margin-bottom"</span>, headerInfoMarginBottom + navbarHeight);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            navbar.removeClass(<span class="string">"detail-navbar-fix"</span>);</span><br><span class="line">            headerInfo.css(<span class="string">"margin-bottom"</span>, headerInfoMarginBottom);</span><br><span class="line">          &#125;</span><br><span class="line">          scope.$apply();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        navbar.on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ($<span class="built_in">window</span>.scrollY &gt; navbarOffsetTop) &#123;</span><br><span class="line">            $<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, navbarOffsetTop);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p>
<p>其它：<br>3. <a href="http://www.voidcn.com/article/p-waidntxx-box.html" target="_blank" rel="noopener">angular 自定义 scroll事件</a>:<br>一个div里面包了很多个div,外面的div是可以的滚动的,而根据滚动到不同的区块时,每个内在的div要浮现出一块部分</p>
<p>4. <a href="https://yalishizhude.github.io/2015/12/02/angular-scrollpin/" target="_blank" rel="noopener">Duang~简单实用的angular滚动列表特效(移动端)</a>:<br>做成滚动时固定，然后可以被下一个元素顶上去的效果</p>
<p>5. <a href="https://segmentfault.com/q/1010000002656607" target="_blank" rel="noopener">angularjs 的操作dom一般如何写在指令或者服务中？</a><a href="https://xiaogliu.github.io/2017/04/12/manipulate-dom-use-angular-directive/" target="_blank" rel="noopener">通过AngularJS指令操作DOM</a><br><del>同一个作者相同文章：<a href="http://www.jb51.net/article/113387.htm" target="_blank" rel="noopener">Angular.JS通过指令操作DOM的方法</a></del><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个引入jQuery操作DOM的指令如下：</span></span><br><span class="line">webApp.directive(<span class="string">"detailTopStick"</span>, [<span class="string">"$timeout"</span>, <span class="string">"$window"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$timeout, $window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span>,</span><br><span class="line">    link: <span class="function"><span class="keyword">function</span> (<span class="params">scope</span>) </span>&#123;</span><br><span class="line">      $timeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> navbar = $(<span class="string">".navbar-nav"</span>);</span><br><span class="line">        <span class="keyword">var</span> navbarOffsetTop = navbar.offset().top;</span><br><span class="line">        <span class="keyword">var</span> headerInfo = $(<span class="string">".header-info"</span>);</span><br><span class="line">        <span class="keyword">var</span> headerInfoMarginBottom = <span class="built_in">parseInt</span>(headerInfo.css(<span class="string">"margin-bottom"</span>));</span><br><span class="line">        <span class="keyword">var</span> navbarHeight = <span class="built_in">parseInt</span>(navbar.css(<span class="string">"height"</span>));</span><br><span class="line"></span><br><span class="line">        angular.element($<span class="built_in">window</span>).bind(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 窗口绑定resize事件</span></span><br><span class="line">          navbar.css(<span class="string">"width"</span>, headerInfo.width());</span><br><span class="line">          navbarOffsetTop = navbar.offset().top;</span><br><span class="line">          scope.$apply();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        angular.element($<span class="built_in">window</span>).bind(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ($<span class="built_in">window</span>.scrollY &gt; navbarOffsetTop) &#123;</span><br><span class="line">            navbar.css(<span class="string">"width"</span>, headerInfo.width());</span><br><span class="line">            navbar.addClass(<span class="string">"detail-navbar-fix"</span>);</span><br><span class="line">            headerInfo.css(<span class="string">"margin-bottom"</span>, headerInfoMarginBottom + navbarHeight);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            navbar.removeClass(<span class="string">"detail-navbar-fix"</span>);</span><br><span class="line">            headerInfo.css(<span class="string">"margin-bottom"</span>, headerInfoMarginBottom);</span><br><span class="line">          &#125;</span><br><span class="line">          scope.$apply();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        navbar.on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ($<span class="built_in">window</span>.scrollY &gt; navbarOffsetTop) &#123;</span><br><span class="line">            $<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, navbarOffsetTop);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p>
<h3 id="ng-repeat-ng-model-数据筛选"><a href="#ng-repeat-ng-model-数据筛选" class="headerlink" title="ng-repeat + ng-model 数据筛选"></a>ng-repeat + ng-model 数据筛选</h3><p><strong>$_PS:</strong> 没有实通<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Search Records"</span> <span class="attr">ng-model</span>=<span class="string">"SearchText"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span> Name <span class="tag">&lt;/<span class="name">th</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Date of Birth <span class="tag">&lt;/<span class="name">th</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Address <span class="tag">&lt;/<span class="name">th</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Salary <span class="tag">&lt;/<span class="name">th</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">ng-repeat</span>=<span class="string">"employee in employees|filter :SearchText"</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;employee.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;employee.dateOfBirth &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;employee.Address &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;employee.Salary &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;&#123;&#123;employee.Salary| currency &#125;&#125;&lt;/td&gt;  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考链接：<br><a href="https://www.c-sharpcorner.com/article/search-and-multisearch-in-angularjs/" target="_blank" rel="noopener">Search And MultiSearch In AngularJS</a><br><a href="http://embed.plnkr.co/Jkp0zdxNFTKQEEMLYAth/preview" target="_blank" rel="noopener">Simple search and filter with AngularJs</a><br><a href="http://plnkr.co/edit/XklvXtc1AZpndjLvXrh8?p=preview" target="_blank" rel="noopener">http://plnkr.co/edit/XklvXtc1AZpndjLvXrh8?p=preview</a></p>
<h3 id="排序和serach"><a href="#排序和serach" class="headerlink" title="排序和serach"></a>排序和serach</h3><p>做了分页：一次取所有数据，拆分数据，单页显示<br>表格中是部分数据，利用 <code>|filter:x</code>/<code>|orderby:x</code> 只是对表格中有的数据排序/过滤</p>
<p>自己过滤整个数据，根据新数据，制作新的分页</p>
<h3 id="table分页"><a href="#table分页" class="headerlink" title="table分页"></a>table分页</h3><p>利用了第一种方式     </p>
<p>参考一：无插件<br><a href="https://www.cnblogs.com/cyclone77/p/5381278.html" target="_blank" rel="noopener">Angular.js+Bootstrap实现表格分页</a><br><strong>$_YX:</strong> <a href="https://app.yinxiang.com/shard/s67/nl/18114453/b7fe50c2-dd3b-4b97-859d-62969daaa89b?title=Angular.js%2BBootstrap%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%88%86%E9%A1%B5%20-%20Cyclone77%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD" target="_blank" rel="noopener">Angular.js+Bootstrap实现表格分页</a><br>参考二：插件ng-pagination<br><a href="https://www.jianshu.com/p/c39430338e5f" target="_blank" rel="noopener">angularjs+bootstrap自定义分页</a><br><a href="http://www.cnblogs.com/sword-successful/p/4605222.html" target="_blank" rel="noopener">基于Angularjs实现分页</a><br><a href="http://www.jb51.net/article/105233.htm" target="_blank" rel="noopener">详解angularjs结合pagination插件实现分页功能</a>   </p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>下面两个属于相同问题，button默认type为submit，更正<code>type=button</code>。</p>
<ol>
<li><p>button自动验证required<br>参考：<br><a href="https://blog.csdn.net/nsdnresponsibility/article/details/50999019" target="_blank" rel="noopener">form表单下的button按钮会自动提交表单的问题</a>   </p>
</li>
<li><p>error: “An invalid form control with name=’’ is not focusable.”。修改button类型后解决了<br> 参考一：修改button：<br> <a href="https://blog.csdn.net/linkerjunhao/article/details/51793299" target="_blank" rel="noopener">An invalid form control with name=’file[]’ is not focusable.间接点击form表单的\<input type="file">出现的问题</a><br> <a href="https://stackoverflow.com/questions/30644606/an-invalid-form-control-with-name-is-not-focusable-without-any-required-or-h" target="_blank" rel="noopener">An invalid form control with name=’’ is not focusable. WITHOUT ANY REQUIRED OR HIDDEN INPUTS</a></p>
<p> 参考二：form标签加 novalidate属性：<br> <a href="https://stackoverflow.com/questions/22148080/an-invalid-form-control-with-name-is-not-focusable" target="_blank" rel="noopener">An invalid form control with name=’’ is not focusable</a>   </p>
</li>
</ol>
<h3 id="ng-repeat动态添加-删除dom"><a href="#ng-repeat动态添加-删除dom" class="headerlink" title="ng-repeat动态添加/删除dom"></a>ng-repeat动态添加/删除dom</h3><p>直接操作dom不明智。<br>参考：<br><a href="http://yijiebuyi.com/blog/7702aba213aec9de43b129b3d2f3b30c.html" target="_blank" rel="noopener">angular.js 下如何动态插入删除dom节点</a></p>
<h3 id="自动滚动到底部"><a href="#自动滚动到底部" class="headerlink" title="自动滚动到底部"></a>自动滚动到底部</h3><p><del>操作dom性能是不是不好；有没有其他方式，比如指令。</del><br>操作dom的方法是原生js；非angular.element。      </p>
<p>和监听window/element滚动事件操作dom不一样，是插入加载数据后自动滚动到底部，非监听滚动到底部加载数据。所以写了一个自动滚动到底部的函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$scope.scrollWindow=<span class="function"><span class="keyword">function</span>(<span class="params">query</span>)</span>&#123;</span><br><span class="line">	dquiz(<span class="string">'scroll window ...'</span>);</span><br><span class="line">	<span class="comment">// var _el = document.getElementById(id);</span></span><br><span class="line">	<span class="keyword">var</span> _el = <span class="built_in">document</span>.querySelector(query);<span class="comment">// $_MORE: 要不要换成angular.element</span></span><br><span class="line">	<span class="comment">// dlog(_el.scrollTop);</span></span><br><span class="line">	<span class="keyword">if</span>(_el.scrollHeight &gt; _el.clientHeight)&#123;</span><br><span class="line">		_el.previousElementSibling.style.paddingRight=<span class="string">'17px'</span>;</span><br><span class="line">		_el.scrollTop = _el.scrollHeight;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		_el.previousElementSibling.style.paddingRight=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="ISSUES"><a href="#ISSUES" class="headerlink" title="ISSUES"></a>ISSUES</h2><ol>
<li>input输入值后，再清空，绑定数据为undefined</li>
</ol>
<p>注意事项：<br>radio/checkbox 绑定数据异常：数据绑定方式不规范（妄想一个dom利用两个不同的绑定方式）；数据切换时，绑定数据为undefined   </p>
<p>其它：<br><a href="https://github.com/huangtengfei/blog/issues/14" target="_blank" rel="noopener">关于 AngularJS 的一些问题</a>   </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>angular.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome简单实用</title>
    <url>/sum/others/chrome%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p style="text-align:right">2018.4.28 星期六 9.40</p>

<p>技术/组织强壮；<br>开发方便；<br>搜索不做对比；</p>
<h2 id="一-基本使用"><a href="#一-基本使用" class="headerlink" title="一 基本使用"></a>一 基本使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>支持正版；其他平台下载的可能是国内版。      </p>
<blockquote>
<p><a href="chrome://version" target="_blank" rel="noopener">chrome://version</a><br>正版：Google Inc.版权所有2018 Google Inc. 保留所有权利。</p>
</blockquote>
<p>国内下载地址： <a href="https://www.google.cn/chrome" target="_blank" rel="noopener">https://www.google.cn/chrome</a><br>国内地址可以打开：<a href="http://www.google.cn/" target="_blank" rel="noopener">http://www.google.cn/</a>   </p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>为什么在国内经常打不开 iTunes App Store 和 Mac App Store<br>以下设置1对我无效！设置1有时候根本连不上，气的我下载了pp助手。<br>1、在连接上网络的情况下，添加以下DNS服务器地址114.114.114.114、8.8.8.8； 然后就可以正常使用了。 8.8.8.8是谷歌的，或许被墙；114实测有效。<br>2、反而是默认空白的 DNS服务器地址上的更快。我家用的是浙江电信的宽带。</p>
<h3 id="url-list"><a href="#url-list" class="headerlink" title="url list"></a>url list</h3><p><a href="chrome://chrome-urls" target="_blank" rel="noopener">chrome://chrome-urls</a>  ==  <a href="chrome://about/" target="_blank" rel="noopener">chrome://about/</a><br><a href="chrome://setting" target="_blank" rel="noopener">chrome://setting</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>chrome 快捷方式打不开：可能是新旧版本不同，或者桌面任务栏快捷方式问题。重新安装或者移动任务栏快捷方式位置<br>chrome 设置–&gt;下载文件 导致页面奔溃：和搜狗输入法 有关，设置的时候把搜狗输入法切换成英文 或者关闭该输入法。搜狗输入法需V9以上  </p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>搜索页面也可以做很多设置。在搜索输入框下面，有设置/工具可以设置。<br>设置了结果打开方式。 </p>
<p>打开新标签页：</p>
<ol>
<li>ctrl+单击 或者 滚轮中间</li>
<li>谷歌的搜索引擎（默认安装好之后打开浏览器就是谷歌官网页面）→在搜索框中输入：设置→按回车键搜索一下——（搜索结果上面）设置→搜索设置—–结果打开方式→勾选<br>(说明：跳到新打开的页面，需要翻墙)</li>
<li>官网下架了，也有用户自行将其广告的功能废了。下载，解压，再将破解版的Neat_Bookmarks_0.8.9.crx文件拖拽到谷歌浏览器内，该插件就会自行安装了。百度云分享：<a href="http://pan.baidu.com/s/1eRDDlBW" target="_blank" rel="noopener">http://pan.baidu.com/s/1eRDDlBW</a> </li>
</ol>
<p>其它参考：<br><a href="http://guoze.me/2016/06/26/how-to-google/" target="_blank" rel="noopener">程序员的基础生存技能 – 关于搜索引擎的小贴士</a><br>[[程序员的基础生存技能：高效用Google]]<br><strong>$_PS:</strong> 上面两篇是相同的</p>
<h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>结合Vimium。</p>
<p>其它参考：<br><a href="https://www.zhihu.com/question/20827603" target="_blank" rel="noopener">Chrome浏览器如何给一个书签增加快捷键？</a><br><a href="https://jingyan.baidu.com/article/915fc414f638e251394b2022.html" target="_blank" rel="noopener">如何恢复误删的 Chrome 书签</a>   </p>
<h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><p>开发者工具 windows-safari：偏好设置—-&gt;高级—-&gt;勾选</p>
<p>参考：<br><a href>Chrome 开发者工具</a><a href="https://developers.google.cn/web/tools/chrome-devtools/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.cn/web/tools/chrome-devtools/?hl=zh-cn</a><br><a href="http://www.css88.com/doc/chrome-devtools/javascript/step-code/" target="_blank" rel="noopener">Chrome 开发者工具#如何遍历你的代码</a></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>设置，任务管理器，…  </p>
<h2 id="二-快捷键"><a href="#二-快捷键" class="headerlink" title="二 快捷键"></a>二 快捷键</h2><p><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="noopener">https://support.google.com/chrome/answer/157179?hl=zh-Hans</a>  </p>
<p>结合Vimium<br>C+ w，C+ n，  C+num,C+tab,<br>CS+ n:<br>CS+ b  : 显示/隐藏 工具栏书签<br>F6: 定位到url地址栏        </p>
<h2 id="三-扩展程序"><a href="#三-扩展程序" class="headerlink" title="三 扩展程序"></a>三 扩展程序</h2><p>qiang:<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">https://chrome.google.com/webstore/category/extensions?hl=zh-CN</a><br>可以打包/下载 安装。(包括书签)</p>
<p>crx墙内安装<br><!--
极简插件：https://chrome.zzzmh.cn/        
https://www.crx4chrome.com/        
https://crxdown.com/    
--></p>
<p>下面这些就不介绍了   </p>
<h3 id="网页工具"><a href="#网页工具" class="headerlink" title="网页工具"></a>网页工具</h3><p>Google 翻译,   JSON Viewer,~~ JSONView<del>，   Charset,  Evernote Web Clipper<br>Vue.js devtools<br>ColorZilla，</del>ColorPick Eyedropper~~<br>Restlet Client - REST API Testing ，cross-request （Yapi的插件）   </p>
<h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><p>Proxy SwitchyOmega,     TamperMonkey,    Vimium,   Web Server for Chrome,  </p>
<h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>Google 文档的离线功能    Google 绘图（可能是自己添加的）<br>幻灯片  文档  表格  </p>
<p>Symantec Extension（企业自动安装的，不能删掉）</p>
<p><strong>$_PS:</strong> 文档/表格 是不错：网页；模板；但是还是喜欢自己的模板，用软件编辑方便。<br>不需要，同步/备份。   </p>
<h3 id="特殊介绍"><a href="#特殊介绍" class="headerlink" title="特殊介绍"></a>特殊介绍</h3><p>书签+Vimium：方便打开书签<br>bookmarklet和书签的区别与联系。bookmarklet单击可以直接新标签页/其他一些脚本<br>bookmarklet和脚本/TamperMonkey的区别与联系。tampermonkey自动在符合条件的页面执行脚本     </p>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><p>Axure RP Extension for Chrome：直接改index.html，把改本地地址跳转chrome 的两处 注释掉<br>二維碼生成器 (Quick QR)6.16， <del>The QR Code Extension 0.3</del></p>
<h3 id="未使用"><a href="#未使用" class="headerlink" title="未使用"></a>未使用</h3><p>Awesome New Tab Page,OneTab<br>JSON Formatter,JSONView<br>GFW: 谷歌上网助手，谷歌访问助手（都不实用）<br>识别网页字体的，<br>webRTC相关，录制等</p>
<p>其它参考：<br><a href="http://dadoneo.iteye.com/blog/984884" target="_blank" rel="noopener">chrome五十大实用插件集合</a></p>
<!-- ## 四 其他参考 -->
<h2 id="chrome浏览器本地文件支持ajax请求"><a href="#chrome浏览器本地文件支持ajax请求" class="headerlink" title="chrome浏览器本地文件支持ajax请求"></a>chrome浏览器本地文件支持ajax请求</h2><p><a href="https://my.oschina.net/gaollg/blog/81225" target="_blank" rel="noopener">chrome浏览器本地文件支持ajax请求</a></p>
<p>给chrome加上启动参数：<br>–allow-file-access-from-files<br>或者　<br>–disable-web-security<br>如，右击谷歌浏览器快捷图标-属性–快捷方式-目标</p>
<p>C:\Users\hp\AppData\Local\Google\Chrome\Application\chrome.exe –allow-file-access-from-files</p>
<p>\ # <a href="https://www.jb51.net/article/115420.htm" target="_blank" rel="noopener">[配置Chrome支持本地（file协议）的AJAX请求]</a><br>原因很简单，浏览器（Webkit内核）的安全策略决定了file协议访问的应用无法使用XMLHttpRequest对象，错误消息中也很清楚的说明了：<br>Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource. </p>
<p>跨域请求仅支持协议：http, data, chrome, chrome-extension, https, chrome-extension-resource </p>
<p>在某些浏览器中是允许这种操作的，比如Firefox浏览器，也就是说Filefox支持file协议下的AJAX请求。</p>
<p>其它：<br># <a href="https://my.oschina.net/u/218567/blog/173417" target="_blank" rel="noopener">XMLHttpRequest cannot load file:///D:/work/ Or…</a><br>google浏览器访问jason文件出现Origin null is not allowed by Access-Control-Allow-Origin. 让chrome支持本地Ajax请求一般情况下，在chrome中运行一些含Ajax请求的界面原型时，会抛出下面错误：XMLHttpRequest cannot load file:///D:/eclipse/workspace/uiTest/WebContent/table1.html. Origin null is not allowed by Access-Control-Allow-Origin.从网上看到了解决办法，记下来以备忘：给chrome加上启动参数：–allow-file-access-from-files就可以了(需要关闭所有chrome窗口重启浏览器)。</p>
<h2 id="Safari浏览器"><a href="#Safari浏览器" class="headerlink" title="Safari浏览器"></a>Safari浏览器</h2><p>1. f12：偏好设置——高级—-勾选     </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Vscode简单使用</title>
    <url>/sum/others/vscode%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener">https://code.visualstudio.com/docs</a><br><a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a>  </p>
<p style="text-align:right">2018.4.25 星期三 17:00</p><br><a id="more"></a><br><br><br>## WHY<br>编辑器，但区别于一般的编辑器和集成工具。<br>1. 轻量，根据情况自己添加插件；插件足够满足需求<br>2. 免费，不用破解/注册。<br>3. 支持不同操作系统。<br>4. 生态成熟且不断成长。<br><br>## 基本<br>界面中菜单,侧边栏,包括资源管理器,搜索,源码管理等都可以控制是否显示<br>### 设置<br>用户设置，json文件：对象最后一个不能有<code>,</code><br>文件夹没有设置过<br><br>可以选择风格，字体大小等等<br><br>用户设置<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"editor.fontSize"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span>,</span><br><span class="line">    <span class="attr">"workbench.startupEditor"</span>: <span class="string">"newUntitledFile"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">"liveServer.settings.donotShowInfoMsg"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"liveServer.settings.port"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"php.validate.executablePath"</span>: <span class="string">"D:/Program Files/xampp/php/php.exe"</span>,</span><br><span class="line">    <span class="attr">"php.executablePath"</span>: <span class="string">"D:/Program Files/Wamp/php-7.2.0/php.exe"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">"git.path"</span>: <span class="string">"D:/Program Files/Git/bin/git.exe"</span>,</span><br><span class="line">    <span class="attr">"git.autorefresh"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"git.enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">"markdown.extension.orderedList.marker"</span>: <span class="string">"ordered"</span>,</span><br><span class="line">    <span class="attr">"markdown.extension.toc.levels"</span>: <span class="string">"1..4"</span>,  </span><br><span class="line"></span><br><span class="line">    <span class="attr">"todohighlight.isEnable"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"todohighlight.keywords"</span>: [</span><br><span class="line">        <span class="string">"ENDED:"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"MORE:"</span>,</span><br><span class="line">            <span class="attr">"color"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">            <span class="attr">"backgroundColor"</span>: <span class="string">"#3ee"</span>,</span><br><span class="line">            <span class="attr">"overviewRulerColor"</span>: <span class="string">"grey"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"text"</span>: <span class="string">"CHECK:"</span>,</span><br><span class="line">            <span class="attr">"color"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">            <span class="attr">"backgroundColor"</span>: <span class="string">"#E33"</span>,</span><br><span class="line">            <span class="attr">"overviewRulerColor"</span>: <span class="string">"grey"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"todohighlight.exclude"</span>: [</span><br><span class="line">        <span class="string">"**/node_modules/**"</span>,</span><br><span class="line">        <span class="string">"**/bower_components/**"</span>,</span><br><span class="line">        <span class="string">"**/dist/**"</span>,</span><br><span class="line">        <span class="string">"**/build/**"</span>,</span><br><span class="line">        <span class="string">"**/.vscode/**"</span>,</span><br><span class="line">        <span class="string">"**/.github/**"</span>,</span><br><span class="line">        <span class="string">"**/_output/**"</span>,</span><br><span class="line">        <span class="string">"**/*.min.*"</span>,</span><br><span class="line">        <span class="string">"..."</span>,</span><br><span class="line">        <span class="string">"**/style/**"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// "team.showWelcomeMessage": false,</span></span><br><span class="line">    <span class="comment">// "window.zoomLevel": 0,</span></span><br><span class="line">    <span class="attr">"editor.renderWhitespace"</span>: <span class="string">"all"</span>,</span><br><span class="line">    <span class="attr">"editor.renderControlCharacters"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"editor.minimap.enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"files.eol"</span>: <span class="string">"\n"</span>,</span><br><span class="line">    <span class="attr">"files.exclude"</span>: &#123;</span><br><span class="line">        <span class="attr">"**/.git"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/.svn"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/.hg"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/CVS"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/.DS_Store"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/node_modules"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"author-generator.author"</span>: <span class="string">"Yalhu"</span>,</span><br><span class="line">    <span class="attr">"author-generator.email"</span>: <span class="string">"[yalhu@mail.com]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 快捷键<br>只改了 <code>ctrl+D</code>。查找/设置方便<br><br>插件也会修改默认快捷键；比如：md-all-in-one <code>ctrl+B</code>(默认是折叠/打开侧边栏)等。<br>有时候不作用，可能是因为插件没有加载成功。<br>md-all-in-one 删除线快捷(A+s)键冲突了,重新设置就好了<br>C+S+b 中文输入法:表情选择输入; 英文:nsis 编译<br><br><br>C + P: 打开输入行<br>C + G: 跳到指定行   输入行中是 : lineNum<br>C + J : 切换控制面板<br>C + <code>: 打开/切换 终端 // 默认终端可以自定义，vscode自带默认的是powershell

F5 运行当前选择 配置项；如果没有会 自动选择 新建 
C + S + P: 打开命令行：输入行中是 &gt; cmd
    Debug: Start Without Debugging
    Debug: Select and Start Debugging
    // 如果取消注释，鼠标 hover 会有 说明
    // 添加一个新的配置，下面也会list 可配置字段
### 编辑    


### 多个编辑器/窗口
可以侧边栏/liveView。  
可以在&quot;查看--》编辑器布局中&quot;中选择设置      

查看中还可以设置：      
切换呈现空格：可以在python/markdown中编辑中显示缩进是空格还是制表符/或者空格数量——以控制换行  
    在编辑器最下面会显示当前状态，单击“空格”状态可以在编辑器命令(F1)中 选择切换/转换当前格式  
切换自动换行：  
切换小地图：    

### 工作区
不同文件夹可以放到一个工作区。   
还可以进行设置，排除文件等。    

&lt;!-- **$_PS:** 发布很快啊    --&gt;

### 搜索
支持正则模式，include/exclude   

### 索引/相关
**$_FIXME:** 在php中写的js找不到索引/相关   
&gt; php-intellisense:&lt;https://github.com/felixfbecker/vscode-php-intellisense/issues/158&gt; 


### 文本比较
插件支持:Partial Diff   

### 源代码管理
需配好git路径   
push也需要配置: \[git操作.md]#vscode 配置git/ssh

配合插件：Git History, Perforce for VS Code(不知道什么用)  
禁用: Hg， Visual Studio Team Services  （没有实用）    

### 调试
Debugger for Chrome     
TODO: attach方式都失败了，目前可以node的launch 调试js    
一些参考链接：  
https://github.com/Microsoft/vscode-chrome-debug/issues/111 
https://github.com/Microsoft/vscode-chrome-debug    
https://chromedevtools.github.io/devtools-protocol/        

https://code.visualstudio.com/Docs/editor/debugging 

chrome://inspect/#devices   

.\vscode\launch.json文件    
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以同时开启多个调试</span></span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        <span class="comment">// ## 4 node attach</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Attach by Process ID"</span>,</span><br><span class="line">            <span class="comment">// "processId": "$&#123;command:PickProcess&#125;"</span></span><br><span class="line">            <span class="attr">"processId"</span>: <span class="string">"7244"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ## 3 node launch </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch nodejs"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/app.js"</span>,</span><br><span class="line">            <span class="comment">// url/file:"",// not allowed</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 指定 运行时可执行文件（v8） 失败；还有一个可以执行的配置值是 npm,需要查看怎么使用  </span></span><br><span class="line">            <span class="comment">// "runtimeExecutable": "node"  //  加上这个配置还出错了: bad option: --inspect-brk=26759; 显然也不能指定chrome/v8</span></span><br><span class="line">            <span class="comment">// "runtimeExecutable": "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"</span></span><br><span class="line">                <span class="comment">// "userDataDir" // not allowed</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ## 2 chrome: attach</span></span><br><span class="line">            <span class="comment">/* 失败，即使设置了 `--remote-debugging-port   ` */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Attach to Chrome"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">9222</span>,</span><br><span class="line">            <span class="attr">"url"</span>:<span class="string">"http://127.0.0.1:51394/debugger.html"</span>, <span class="comment">// method 2 server ;</span></span><br><span class="line">            <span class="comment">// file // not allowed</span></span><br><span class="line">            <span class="comment">// "userDataDir": // not allowed</span></span><br><span class="line">            <span class="attr">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ## 1 chrome: launch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,  <span class="comment">// launch 每次调试都会新启动一个chrome窗口，开启调试。已经打开的不会进入调试</span></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch Chrome html"</span>,</span><br><span class="line">            </span><br><span class="line">            <span class="attr">"file"</span>:<span class="string">"$&#123;workspaceFolder&#125;/debugger.html"</span>, <span class="comment">// method 1: file</span></span><br><span class="line">            <span class="comment">// "url":"http://127.0.0.1:61475/debugger.html", // method 2 server：如果没有server是不会打开页面，进入调试的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// "url":"http://127.0.0.1:61475/", // 不正确的打开方式；debugger后打开的是根目录，没有debugger的目标</span></span><br><span class="line">            <span class="comment">// "file":"$&#123;workspaceFolder&#125;/debugger.js", // 不正确的打开方式：debugger后打开js文件（浏览器打开js的效果），也没有进入调试</span></span><br><span class="line">                <span class="comment">// 直接调试js，需要 node 非 chrome</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// "runtimeExecutable": "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", // 改成您的 Chrome 安装路径</span></span><br><span class="line">            <span class="comment">// "userDataDir": true, // 如果出现上面 runtimeExecutable 字段，这里需要配置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// "sourceMaps": true,</span></span><br><span class="line">            <span class="attr">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 插件
Date &amp; Time,Active File In StatusBar    
vscode-author-generator,File Header Comment     
TODO Hightlight     
SFTP
evermonkey      
### HCJ
用的不多(目前)   
minify, Beautify ,HTMLHint,ESlint,      
Debugger for Chrome,  
Live Server,    
Autoprefixer, css-minify, css-triggers, 


以下为现在实用     
HTML CSS Support,IntelliSense for class names in HTML,  
Auto Close Tag, Auto Rename Tag,   
Path Autocomplete,   
Image preview,  

Color Hightlight, Color Info(**$_PS:** 注释掉的才会显示,应该和某个冲突了),  

Easy LESS , Less IntelliSense,  

禁用      
Live Server Preview, Open HTML in Default Browser, open-in-browser,   
HTML Boilerplate, HTML Class Suggestions, CSS Auto Prefix, jshint    
Quokka.js    

### php
PHP IntelliSense, PHP Intelephense, PHP Debug, PHP Extension Pack,    

后面几个没有具体看干什么用的    

### JSDoc
原始功能。   
**$_NOTE:** 只有js文件中会自动添加；其他（php）是多行注释，不会自动</code>@param`等<br><br>### markdown<br>Markdown All in One,Markdown PDF,Markdown TOC<br>markdownlint没有安装<br><br>主要使用md-all-in-on<br>toc没有多余toc标签；中文没有链接；也不可以跳转。<br><br>利用md-toc能够生成可以链接/跳转的目录。<br>### 其他<br>Swig<br><br>## Issues<br>1. 有时保存出现提示。可能同时文件在其他地方更改了，关闭当前标签页再重新打开，不必重启编辑器<br>2. 有时按键失灵，比如backspce，enter。有可能是因为扩展宿主–插件 出错，因为出错重启之后就好了。或者重启编辑器。<br>    <a href="https://shiyousan.com/post/635625662454768347" target="_blank" rel="noopener">VS(Visual Studio)按键失灵无法按回车</a><br>3. 插件有时无法正确加载，比如快捷键或功能失效。(可在 帮助-&gt;切换开发人员工具 查看错误)<br>4. 搜索 inclued/exclude 按照正常的方式工作<br>    <a href="https://github.com/Microsoft/vscode/issues/46315#issuecomment-376037528" target="_blank" rel="noopener">Make files to include/exclude configurable on whether to use 1 or 2 inputs</a><br>5. vscode.exe 没有反应，重新装了一次就好了<br><br><br><!-- 
## 其它  
收藏，都没有看过   
[精选！15 个必备的 VSCode 插件](https://www.jianshu.com/p/1c178f5c029c)--([精选！15 个必备的 VSCode 插件](https://zhuanlan.zhihu.com/p/27905838))   
Open-In-Browser, Quokka, Faker,  CSS Peek, HTML Boilerplate,  Prettier, Color Info,
SVG Viewer,TODO Highlight,Icon Fonts,Minify,Change Case,Regex Previewer,Language and Framework Packs,
Themes      

[Microsoft Visual Studio Code 中文手册](https://jeasonstudio.gitbooks.io/vscode-cn-doc/)   
 --><br><p style="text-align:right">20:04</p>

<h2 id="Webstrom使用"><a href="#Webstrom使用" class="headerlink" title="Webstrom使用"></a>Webstrom使用</h2><p>1. less，只可以自动编译less文件，并不会自动补全<br>tools—file watchers 添加工具，好像自动补全设置了        </p>
<p>2. autoprefixer，自动补全兼容浏览器的写法<br>tools—external tools  添加下载的工具    </p>
<p>其它：<br><a href="https://www.zhihu.com/question/20936155" target="_blank" rel="noopener">WebStorm 有哪些过人之处？</a>    </p>
<h2 id="phpStrom使用"><a href="#phpStrom使用" class="headerlink" title="phpStrom使用"></a>phpStrom使用</h2><p>phpStrom 设置打不开：汉化有问题。重新下载/汉化  </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>编写高质量代码--Web前端开发修炼之道</title>
    <url>/pdf/opti/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81--Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>编写高质量代码：<br>网站重构、团队合作、html、css、javascript</p>
<p>附录：写在规则前、命名、分工、注释、html/css/javascript规范</p>
<p style="text-align:right">2018.4.21 六 22:52 </p><br><a id="more"></a><br><br>2010.5 第一版<br><p style="text-align:right">2017.8.28 一 23：11  .doc</p><br><p style="text-align:right">2017.9.17 日 09:00 转为.md</p>

<p><strong>$_PS:</strong> 感觉标题不够用,所以升为一级标题；也是按章节区分，升到一级加深权重</p>
<h1 id="第一章-从网站重构说起"><a href="#第一章-从网站重构说起" class="headerlink" title="第一章 从网站重构说起"></a>第一章 从网站重构说起</h1><h2 id="1-糟糕的页面实现，头疼的维护工作"><a href="#1-糟糕的页面实现，头疼的维护工作" class="headerlink" title="1 糟糕的页面实现，头疼的维护工作"></a>1 糟糕的页面实现，头疼的维护工作</h2><p>1989诞生至今。。</p>
<h2 id="2-Web标准——结构、样式和行为的分离"><a href="#2-Web标准——结构、样式和行为的分离" class="headerlink" title="2 Web标准——结构、样式和行为的分离"></a>2 Web标准——结构、样式和行为的分离</h2><p>仅仅只是开始</p>
<h2 id="3-前端的现状"><a href="#3-前端的现状" class="headerlink" title="3 前端的现状"></a>3 前端的现状</h2><p>维护难：浏览器、技术、团队合作</p>
<h2 id="4-打造高品质的前端代码，提高代码的可维护性—-精简、重用、有序"><a href="#4-打造高品质的前端代码，提高代码的可维护性—-精简、重用、有序" class="headerlink" title="4 打造高品质的前端代码，提高代码的可维护性—-精简、重用、有序"></a>4 打造高品质的前端代码，提高代码的可维护性—-精简、重用、有序</h2><p>所谓高质量的代码，在Web标准的思想指导下，在实现结构、样式和行为分离的基础，还要做到三点：</p>
<h1 id="第二章-团队合作"><a href="#第二章-团队合作" class="headerlink" title="第二章 团队合作"></a>第二章 团队合作</h1><h2 id="1-揭秘前端开发工程师"><a href="#1-揭秘前端开发工程师" class="headerlink" title="1 揭秘前端开发工程师"></a>1 揭秘前端开发工程师</h2><p>1css基本：基本兼容浏览器。2Javascript：原生，类库，Ajax；3后台语言：不需要多深，当然越深越有帮助</p>
<h2 id="2-欲精一行，必先通十行"><a href="#2-欲精一行，必先通十行" class="headerlink" title="2 欲精一行，必先通十行"></a>2 欲精一行，必先通十行</h2><p>“粗粒度”的精，专精很难—一专多能才现实，必要</p>
<h2 id="3-增加代码可读性—-注释"><a href="#3-增加代码可读性—-注释" class="headerlink" title="3 增加代码可读性—-注释"></a>3 增加代码可读性—-注释</h2><p>直接团队合作，间接团队合作  “好的代码，注释占1/3”—虽然夸张</p>
<h2 id="4-提高重用性—–公共组件和私有组件的维护-4-2和5-2（四，五章）"><a href="#4-提高重用性—–公共组件和私有组件的维护-4-2和5-2（四，五章）" class="headerlink" title="4 提高重用性—–公共组件和私有组件的维护   4.2和5.2（四，五章）"></a>4 提高重用性—–公共组件和私有组件的维护   4.2和5.2（四，五章）</h2><p>公共：只读，少数写，必要时（注释，API文档，演示Demo）</p>
<h2 id="5-冗余和精简的矛盾—-选择集中还是分散"><a href="#5-冗余和精简的矛盾—-选择集中还是分散" class="headerlink" title="5 冗余和精简的矛盾—-选择集中还是分散"></a>5 冗余和精简的矛盾—-选择集中还是分散</h2><p>一次打包：jQuery<br>小块按需加载：YUI<br>平衡点，只可能尽量减少冗余，不可能根除</p>
<h2 id="6-磨刀不误砍柴工—-前期的构思很重要"><a href="#6-磨刀不误砍柴工—-前期的构思很重要" class="headerlink" title="6 磨刀不误砍柴工—-前期的构思很重要"></a>6 磨刀不误砍柴工—-前期的构思很重要</h2><p>规范的指定、公共组件的设计、复杂功能的技术方案<br>占整个项目30%~60的时间，都算正常</p>
<h2 id="7-制定规范"><a href="#7-制定规范" class="headerlink" title="7 制定规范"></a>7 制定规范</h2><h2 id="8-团队合作的最大难度不是技术，是人"><a href="#8-团队合作的最大难度不是技术，是人" class="headerlink" title="8 团队合作的最大难度不是技术，是人"></a>8 团队合作的最大难度不是技术，是人</h2><p>自己能独立  都是小问题，     ，要学会与人相处</p>
<h1 id="第三章-高质量的HTML"><a href="#第三章-高质量的HTML" class="headerlink" title="第三章 高质量的HTML"></a>第三章 高质量的HTML</h1><h2 id="1-标签的语义"><a href="#1-标签的语义" class="headerlink" title="1 标签的语义"></a>1 标签的语义</h2><p>标签的设计都有语义，初了div，span</p>
<h2 id="2-为什么要使用语义化标签"><a href="#2-为什么要使用语义化标签" class="headerlink" title="2 为什么要使用语义化标签"></a>2 为什么要使用语义化标签</h2><p>Web标准，css只是一部分，HTML才是最重要的，结构才是重点，样式只是修饰结构<br>先确定语义的标签，再选合适的css</p>
<h2 id="3-如何确定你的标签是否语义良好"><a href="#3-如何确定你的标签是否语义良好" class="headerlink" title="3 如何确定你的标签是否语义良好"></a>3 如何确定你的标签是否语义良好</h2><p>简单方法：去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性</p>
<h2 id="4-常见模块你真的很了解吗"><a href="#4-常见模块你真的很了解吗" class="headerlink" title="4 常见模块你真的很了解吗"></a>4 常见模块你真的很了解吗</h2><h3 id="4-1-标题和内容：三个div—》一个h2包一个a，但a不是h—》用div包h2，a"><a href="#4-1-标题和内容：三个div—》一个h2包一个a，但a不是h—》用div包h2，a" class="headerlink" title="4.1 标题和内容：三个div—》一个h2包一个a，但a不是h—》用div包h2，a"></a>4.1 标题和内容：三个div—》一个h2包一个a，但a不是h—》用div包h2，a</h3><h3 id="4-2-表单-fieldset-legend-lable—for"><a href="#4-2-表单-fieldset-legend-lable—for" class="headerlink" title="4.2 表单 fieldset legend lable—for"></a>4.2 表单 fieldset legend lable—for</h3><h3 id="4-3-表格-caption-thead-tbody-tfood-th"><a href="#4-3-表格-caption-thead-tbody-tfood-th" class="headerlink" title="4.3 表格 caption thead tbody tfood th"></a>4.3 表格 caption thead tbody tfood th</h3><h3 id="4-4-其他：1尽可能少用语义div和span；2语义不明显，div，和p。尽量p，默认有上下间距，可读性更好，兼容特殊终端；3不使用纯样式标签：b，font，u等，改css。默认strong：加粗，em：斜体"><a href="#4-4-其他：1尽可能少用语义div和span；2语义不明显，div，和p。尽量p，默认有上下间距，可读性更好，兼容特殊终端；3不使用纯样式标签：b，font，u等，改css。默认strong：加粗，em：斜体" class="headerlink" title="4.4 其他：1尽可能少用语义div和span；2语义不明显，div，和p。尽量p，默认有上下间距，可读性更好，兼容特殊终端；3不使用纯样式标签：b，font，u等，改css。默认strong：加粗，em：斜体"></a>4.4 其他：1尽可能少用语义div和span；2语义不明显，div，和p。尽量p，默认有上下间距，可读性更好，兼容特殊终端；3不使用纯样式标签：b，font，u等，改css。默认strong：加粗，em：斜体</h3><h1 id="第四章-高质量的CSS"><a href="#第四章-高质量的CSS" class="headerlink" title="第四章 高质量的CSS"></a>第四章 高质量的CSS</h1><h2 id="1-怪异模式和DTD"><a href="#1-怪异模式和DTD" class="headerlink" title="1 怪异模式和DTD"></a>1 怪异模式和DTD</h2><h2 id="2-如何组织CSS"><a href="#2-如何组织CSS" class="headerlink" title="2 如何组织CSS"></a>2 如何组织CSS</h2><p>API：控制样式，对、错</p>
<p>框架：进行组织，好、比较好、很烂、非常棒   多种角度：功能、区块。。</p>
<p>Base.css：原子类，与具体UI无关-精简通用，高度可移植性，行对稳定，基本不需维护</p>
<p>Common.css：模块，组件，UI组件风格保持相同，一个或者common_form,common_images</p>
<p>Page.css：页面，page1，page2，若不多一个page文件，能用上面两尽量不用这。<br>多人，避免冲突：通常命名规则</p>
<p>（非并列，而是层叠）    </p>
<h2 id="3-推荐的base-css"><a href="#3-推荐的base-css" class="headerlink" title="3 推荐的base.css:"></a>3 推荐的base.css:</h2><p>两大类：reset 和通用原子类              一些非常巧的命名和设计———–非常的棒<br>reset,文字排版，定位，长度高度，边距</p>
<p style="text-align:right">P89 00：24</p><br><p style="text-align:right">2017.8.29 二 22：24</p>  

<h2 id="4-模块化CSS——-在CSS中引入面向对象编程思想"><a href="#4-模块化CSS——-在CSS中引入面向对象编程思想" class="headerlink" title="4 模块化CSS——-在CSS中引入面向对象编程思想"></a>4 模块化CSS——-在CSS中引入面向对象编程思想</h2><h3 id="4-1-如何划分模块—"><a href="#4-1-如何划分模块—" class="headerlink" title="4.1 如何划分模块—"></a>4.1 如何划分模块—</h3><p>单一职责：1，模块与模块之间尽量不要包含相同的部分，如果包含相同的部分，尽量将它们提取出来，拆分成一个独立的模块；<br>2，模块应在保证数量尽可能少的原则下，做到尽可能简单，以提高重用性</p>
<h3 id="4-2-CSS的命名—-命名空间的概念"><a href="#4-2-CSS的命名—-命名空间的概念" class="headerlink" title="4.2 CSS的命名—-命名空间的概念"></a>4.2 CSS的命名—-命名空间的概念</h3><p>英文，驼峰+划线（单独并不是最好的实践），：last-child ie6没有需单独加一个类名；<br>2)直接挂last—-滥用子选择符—-》不轻易使用自选择符，故timeListLastItem<br>3)但命名看不出从属，封装性不好，—》timeList-lastItem  </p>
<p>1)Base,common层公共，一人负责，不会出现冲突，page多人合作加唯一标识符<br>2)base层命名简短，common就长了，还有标识符，比起文件大小，好处还是可接受范围<br>划线—从属关系的分隔符；模块视为类，从属模块的元素视为类的属性，通过命名上的直观，得到一种“封装”。</p>
<h3 id="4-3-挂多个class还是新建class——–多用组合，少用继承"><a href="#4-3-挂多个class还是新建class——–多用组合，少用继承" class="headerlink" title="4.3 挂多个class还是新建class——–多用组合，少用继承"></a>4.3 挂多个class还是新建class——–多用组合，少用继承</h3><p>方案一：三个类——-非常冗余<br>方案二：三个类——–只是做了提取，去除了冗余；添加新的类，css修改好几处<br>方案三：提取更多粒度更小的类，通过类的组合实现；以后只需添加类  </p>
<p>偏激的工程师甚至认为继承是错误的，是造成维护性差的罪魁祸首，主张完全使用继承<br>挂多个类，让html看起来过于臃肿，固然不好看，但好处不容忽视<br><strong>$_PS:</strong>（自己认为综合项目—代码量，来考虑）</p>
<h3 id="4-4-如何处理上下margin："><a href="#4-4-如何处理上下margin：" class="headerlink" title="4.4 如何处理上下margin："></a>4.4 如何处理上下margin：</h3><p>如果不确定模块的上下margin特别稳定，最好不要将它写到某块的类里，而是使用类的组合，单独为上下margin挂用于边距的原子类（如mt10）。模块最好不要混用margin-top和margin-bottom，使用一个</p>
<h2 id="5-低权重原则——-避免滥用子选择器"><a href="#5-低权重原则——-避免滥用子选择器" class="headerlink" title="5 低权重原则——-避免滥用子选择器"></a>5 低权重原则——-避免滥用子选择器</h2><p>1，权重，就近（定义的先后顺序，而不是挂class名的先后）<br>2，为了保证样式容易被覆盖，提高可维护性，css选择符需保证权重尽可能低<br>3，少使用子选择器，就需要多添加class（方便扩展），web标准盛行初期，很多工程师认为不好，能使用子选择器就尽量使用，使用大量class的做法叫“多class症”。在经过大量实践后，作者认为多class有太大坏处，相反，与使用子选择器相比，新添class反而更有利于维护<br><strong>$_PS:</strong> 各有利弊，还是看项目代码，如果项目代码量少</p>
<h2 id="6-CSS-sprite"><a href="#6-CSS-sprite" class="headerlink" title="6 CSS sprite"></a>6 CSS sprite</h2><p>1，    初期：图片不会马上加载，空白。。合并；；后来，还可以减少http请求次数<br>2，看似简单，不易掌握：1合并只能是背景图片，img标签不可以2横向或纵向也不可以，只能竖直或水平排列。。 图片如何排列尽量紧凑，同时保证不会影响扩展性<br>3，问题：图片位置精确度要求高—测量影响开发速度；不易轻易改动，可能影响其他周边图片，降低了可维护性<br>4，最大好处：建设http请求数，减轻服务器的压力；代价：降低开发效率，增大维护难度<br>流量并不大的网站，好处并不明显，但付出代价却很大，并不划算。。所以，主要取决于网站流量</p>
<h2 id="7-CSS的常见问题"><a href="#7-CSS的常见问题" class="headerlink" title="7 CSS的常见问题"></a>7 CSS的常见问题</h2><h3 id="7-1-编码风格：多行式，一行式"><a href="#7-1-编码风格：多行式，一行式" class="headerlink" title="7.1 编码风格：多行式，一行式"></a>7.1 编码风格：多行式，一行式</h3><p>早期缺少调试工具——–主流是多行。随着，一行渐渐新主流。。。作者更推荐一行<br>（并不苟同）</p>
<h3 id="7-2-id和class：一般情况尽量使用class，少用id（我觉得作者只是针对css样式来讲的）"><a href="#7-2-id和class：一般情况尽量使用class，少用id（我觉得作者只是针对css样式来讲的）" class="headerlink" title="7.2 id和class：一般情况尽量使用class，少用id（我觉得作者只是针对css样式来讲的）"></a>7.2 id和class：一般情况尽量使用class，少用id（我觉得作者只是针对css样式来讲的）</h3><h3 id="7-3-CSS-hack"><a href="#7-3-CSS-hack" class="headerlink" title="7.3 CSS hack"></a>7.3 CSS hack</h3><p>1，IE条件注释：非ie，指定ie版本。微软官方推荐的方式，从向前兼容性方面考虑，最安全的，理论上是最好的。。。。虽然向后兼容性是最好的，缺点明显：同一css选择符样式分散到三个文件中控制，增加开发和维护成本<br>2，选择符前缀法：<em>html–ie6，</em>+html—ie7，样式集中起来，可维护性强很多。但不能保证以后的ie9，ie10不识别，向后兼容性上存在一点风险。。另外，不能用于内联样式上<br>3，样式属性前缀法：_——ie6, <em>——-ie6,7   {width:80px;</em>width:70px;_width:60px;} 。。同样向后兼容有风险。。另外，可用于内联样式  </p>
<p>总结：虽然ie条件注释，但后两流行，我们可根据需要选择使用</p>
<h3 id="7-4-解决超链接访问后hover样式不出现的问题：lvha"><a href="#7-4-解决超链接访问后hover样式不出现的问题：lvha" class="headerlink" title="7.4 解决超链接访问后hover样式不出现的问题：lvha"></a>7.4 解决超链接访问后hover样式不出现的问题：lvha</h3><p style="text-align:right">P113 00：40</p><br><p style="text-align:right">2017.8.30 三 23：16</p>

<h3 id="7-5-hasLayout"><a href="#7-5-hasLayout" class="headerlink" title="7.5 hasLayout"></a>7.5 hasLayout</h3><p>IE专有属性，用于css解析引擎。有时候一些复杂css设置解析会出现bug，可能是没有自动触发haslayout，通过技巧手动触发，就可以 解决bug。  </p>
<p>方法：1,width,height,relative。早起height:1%,（6，按min-height解析）ie7出现后，可以正常识别，就不适用了。<br>2,更好的zoom：1；（不会像height引入副作用-不用csshack）。少数特殊情况下，特别似乎使用dhtml是，会无效，用更强大的relative触发；尽管会有一些副作用。<br>设计初衷是辅助块级元素的盒模型解析。如用于行内，会引发一些特殊效果。  </p>
<h3 id="7-6-块级元素和行内元素的区别"><a href="#7-6-块级元素和行内元素的区别" class="headerlink" title="7.6 块级元素和行内元素的区别"></a>7.6 块级元素和行内元素的区别</h3><p>。。。行内元素：水平方向margin，padding有效；竖直margin无效，padding虽然增大面积，但并没有和相邻元素拉开距离。</p>
<h3 id="7-7-display-inline-block和hasLayout"><a href="#7-7-display-inline-block和hasLayout" class="headerlink" title="7.7 display:inline-block和hasLayout"></a>7.7 display:inline-block和hasLayout</h3><p>1，Ie6，7只有block，inline，none。通过触发hasLayout实现。<br>P换span，触发hasLayout并不完美，设置span，<em>vertical-align：-10px。对齐方式<br>2，问题：1只能对行内2针对ie的hack，</em>vertical-align<br>3，还是可以的：Img，button有inline-block特性  </p>
<h3 id="7-8-relative、absolute和float"><a href="#7-8-relative、absolute和float" class="headerlink" title="7.8 relative、absolute和float"></a>7.8 relative、absolute和float</h3><p>1，Relative，absolute，改变元素在文档流中的位置，可以激活left，z-index。默认都是z-index：0层—-文档流。让元素“浮”起来，z-大于0，relative会保留自己0层的占位，对其他0层的元素位置不影响；absolute完全脱离文档流，不在0层保留位置。<br>2，Float，不会“上浮”到另一个z层，仍然0层，不能top等精确控制，left“左右浮”；会改变正常的文档流排列，影响到周围元素<br>3，absolute，float隐式改变成inline-block，默认宽度并不占满父元素。显示设置display无效（float，ie6双边距，添加display：inline）  </p>
<h3 id="7-9-居中"><a href="#7-9-居中" class="headerlink" title="7.9 居中"></a>7.9 居中</h3><h4 id="1，水平居中"><a href="#1，水平居中" class="headerlink" title="1，水平居中"></a>1，水平居中</h4><p>1）文本、图片等行内元素：text-align；<br>2）确定宽度的块级元素：margin：* auto<br>3）不确定宽度的块级：1table标签；2display：inline；问题：比起块级少一些功能；3父：float：left；子：relative，left：-50%；问题：relative副作用  </p>
<h4 id="2，竖直居中"><a href="#2，竖直居中" class="headerlink" title="2，竖直居中"></a>2，竖直居中</h4><p>1）    父元素高度不确定的文本、图片，块级：父设置相同的上下边距<br>2）    父高度确定的单行文本：父line-height=父height<br>3）    父高度确定的多行文本、图片、块级：1父元素为th、td，vertical。Display：talbe-cell。Ie6，7不支持模拟表格—直接使用。无义标签和深度；2不支持ie6，7不支持table-cell，hack，给父子两层分别top：absolute，50%、relative，-50% ；hack不利于维护，relative，absolute副作用 </p>
<h3 id="7-10-网格布局"><a href="#7-10-网格布局" class="headerlink" title="7.10 网格布局"></a>7.10 网格布局</h3><p>Main内容比起sidebar更重要，无论sidebar和main在样式上谁先后，html要main在前加<br>方案一：将浮动和宽度绑定在同一个类中，会限制灵活性<br>方案二：利用组合<br>方案三：上面都是宽度固定，若不定宽：1将宽也抽象出来w25，w70；2利用子选择器.content-lr-7025 .main{f:l;w:70}.content-lr-7025 .main{f:r;w:25}.削弱了main，sidebar做为样式挂钩的能力，。。不由这两个抽象类提供，衍生类—父元素控制  。  </p>
<p>相较，子更便于修改。但是通过预设大量分支实现的，不够轻便。。<br>组合类更易于扩展，更轻便。(但扩展太好，不利于维护)对某些经常使用的功能，多人合作，统一的格式可以避免五花八门，可以站在全局角度严格控制。。。。。。。。作者认为子选择器更适合。</p>
<p>宽度百分比，可以嵌套使用，提高重用性。布局极其灵活，content-xx-xxxx是全站统一管理的，非常稳定，—》专有名词 网格布局</p>
<h3 id="7-11-z-index的相关问题以及Flash和IE6下的select元素"><a href="#7-11-z-index的相关问题以及Flash和IE6下的select元素" class="headerlink" title="7.11 z-index的相关问题以及Flash和IE6下的select元素"></a>7.11 z-index的相关问题以及Flash和IE6下的select元素</h3><h4 id="1，z-负数，单击无法弹出—被body挡住了。"><a href="#1，z-负数，单击无法弹出—被body挡住了。" class="headerlink" title="1，z-负数，单击无法弹出—被body挡住了。"></a>1，z-负数，单击无法弹出—被body挡住了。</h4><p>z-相同，html标签中后出现的在先出现的之上<br>（多元素重叠，relative，absolute激活z-index；负边距），取决于后出现的html，后浮上</p>
<h4 id="2，flash-wmode-“window，opaque，transparent”。默认window优先非窗口类，z-无效，显示在最顶端。如同属非窗口，才判断z-，设为后两个值"><a href="#2，flash-wmode-“window，opaque，transparent”。默认window优先非窗口类，z-无效，显示在最顶端。如同属非窗口，才判断z-，设为后两个值" class="headerlink" title="2，flash wmode=“window，opaque，transparent”。默认window优先非窗口类，z-无效，显示在最顶端。如同属非窗口，才判断z-，设为后两个值"></a>2，flash wmode=“window，opaque，transparent”。默认window优先非窗口类，z-无效，显示在最顶端。如同属非窗口，才判断z-，设为后两个值</h4><h4 id="3，select在ie6也是窗口，这是ie6-bug：和test同大小的iframe放在test下面，select上面，遮住select"><a href="#3，select在ie6也是窗口，这是ie6-bug：和test同大小的iframe放在test下面，select上面，遮住select" class="headerlink" title="3，select在ie6也是窗口，这是ie6 bug：和test同大小的iframe放在test下面，select上面，遮住select"></a>3，select在ie6也是窗口，这是ie6 bug：和test同大小的iframe放在test下面，select上面，遮住select</h4><h3 id="7-12-插入png图片"><a href="#7-12-插入png图片" class="headerlink" title="7.12 插入png图片"></a>7.12 插入png图片</h3><h4 id="1，Ie6对png透明支持并不好。透明地方浅蓝色。Ie私有的滤镜解决"><a href="#1，Ie6对png透明支持并不好。透明地方浅蓝色。Ie私有的滤镜解决" class="headerlink" title="1，Ie6对png透明支持并不好。透明地方浅蓝色。Ie私有的滤镜解决"></a>1，Ie6对png透明支持并不好。透明地方浅蓝色。Ie私有的滤镜解决</h4><p> –progid:DXImageTransform.Microsoft.AlphaImageLoader(src=’png图片路径’,sizingMethod=’crop’)</p>
<h4 id="2，可用代码一次解决。问题："><a href="#2，可用代码一次解决。问题：" class="headerlink" title="2，可用代码一次解决。问题："></a>2，可用代码一次解决。问题：</h4><p>全加载完之前，透明部分人浅蓝；遍历所有元素，效率不高；以背景插入，可能有position，repeat属性，而滤镜不支持，若设置，这两效果会丢失。</p>
<h3 id="7-13-多版本IE并存方案—–CSS的调试利器IETester"><a href="#7-13-多版本IE并存方案—–CSS的调试利器IETester" class="headerlink" title="7.13 多版本IE并存方案—–CSS的调试利器IETester"></a>7.13 多版本IE并存方案—–CSS的调试利器IETester</h3><p>与Mltiple IE不同（早期的时候）</p>
<p><strong>$_PS:</strong>（下午看了下大网站的css样式（网易云音乐，youtube），和这个标准差不多；youtube虽然样式名看不懂，但是感觉差不多。。。。另外这两个网站，都为移动端提供的另一套样式或者html，路径都有变化yunyinyue.com/m，m.youbute.com）</p>
<p style="text-align:right">P151 01：15</p><br><p style="text-align:right">2017.9.10 日 22:30 </p>

<h1 id="第五章-高质量的JavaScript"><a href="#第五章-高质量的JavaScript" class="headerlink" title="第五章 高质量的JavaScript"></a>第五章 高质量的JavaScript</h1><h2 id="1-养成良好的编程习惯"><a href="#1-养成良好的编程习惯" class="headerlink" title="1 养成良好的编程习惯"></a>1 养成良好的编程习惯</h2><h3 id="1-1-团队合作—如何避免js冲突"><a href="#1-1-团队合作—如何避免js冲突" class="headerlink" title="1.1    团队合作—如何避免js冲突"></a>1.1    团队合作—如何避免js冲突</h3><p>用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。<br>添加必要的注释，可以大大提高代码的可维护性，对于团队合作来说，更是十分必要的<br>让js不产生冲突，需要避免全局变量的泛滥，合理使用命名空间以及为代码添加必要的的注释。</p>
<ol>
<li>A和B，匿名函数；  </li>
<li>C用A，全局变量做桥梁；  </li>
<li>还要用A，对象类型的全局，GLOBAL；  </li>
<li>变量简单，容易相互覆盖=》不直接挂在G对象，而是此匿名函数的命名空间下（只考虑命名空间不冲突就可以了，属性名任意设置，不用担心会和哪个匿名函数里的某个G属性冲突。命名空间数量一般情况不会特别多，避免冲突相对容易====如果同一个匿名函数中的程序非常复杂，变量名很多，命名空间可进一步扩展，生成二级命名空间）。  </li>
<li>生成命名空间非常常用功能==》定义为函数  </li>
<li>可维护性不高，A改B的代码===》加注释</li>
</ol>
<h3 id="1-2-给程序一个统一的入口—-window-onload和DOMReady"><a href="#1-2-给程序一个统一的入口—-window-onload和DOMReady" class="headerlink" title="1.2    给程序一个统一的入口—-window.onload和DOMReady"></a>1.2    给程序一个统一的入口—-window.onload和DOMReady</h3><p>各自游击，纪律性没有保障==》从功能上对程序划分：框架+应用。<br>Function init(){}   选择DOMReady  为避免写DOMReay兼容，init()放在最后，<code>&lt;/body&gt;</code>前<br>实际工作，三部分  if(init){ init() }</p>
<h3 id="1-3-css放在页头，Javascript放在页尾"><a href="#1-3-css放在页头，Javascript放在页尾" class="headerlink" title="1.3    css放在页头，Javascript放在页尾"></a>1.3    css放在页头，Javascript放在页尾</h3><h3 id="1-4-引入编译的概念—–文件压缩"><a href="#1-4-引入编译的概念—–文件压缩" class="headerlink" title="1.4    引入编译的概念—–文件压缩"></a>1.4    引入编译的概念—–文件压缩</h3><p>Packer:<a href="http://dean.edwards.name/packer/" target="_blank" rel="noopener">http://dean.edwards.name/packer/</a><br>YUI Compressor:<a href="http://developer.yahoo.com/yui/compressor/" target="_blank" rel="noopener">http://developer.yahoo.com/yui/compressor/</a>   也可压css<br>    基于Javr的jar应用，先安装JDK，配环境通过命令行<br>    Java –jar yuicompressor-x.y.z.jar myfile.js –o myfile-min.js<br>反压缩：<a href="http://jsbeautifier.org/" target="_blank" rel="noopener">http://jsbeautifier.org/</a></p>
<h2 id="2-javascript的分层概念和Javascript库"><a href="#2-javascript的分层概念和Javascript库" class="headerlink" title="2 javascript的分层概念和Javascript库"></a>2 javascript的分层概念和Javascript库</h2><h3 id="2-1-Javascript如何分层-base-common-page-只有好坏，作者的经验"><a href="#2-1-Javascript如何分层-base-common-page-只有好坏，作者的经验" class="headerlink" title="2.1 Javascript如何分层   base common page (只有好坏，作者的经验)"></a>2.1 Javascript如何分层   base common page (只有好坏，作者的经验)</h3><h3 id="2-2-base层"><a href="#2-2-base层" class="headerlink" title="2.2 base层"></a>2.2 base层</h3><ol>
<li>封装不同浏览器下js的差异，提供统一的接口:childNodes,透明度，event对象，冒泡，on attachEvent和addEventListener  </li>
<li>扩展js语言底层的接口（虽然支持面向对象，但没有继承extend，类型判断，getElementByClassName）:trim,isNumber isString isBoolean …..,get   $, getElementByClassName,extend,</li>
</ol>
<p>前面5.1.2 将网页js代码分两大部分：框架级和应用。Base框架，加命名空间：dom,event,lang</p>
<h3 id="2-3-common层"><a href="#2-3-common层" class="headerlink" title="2.3 common层"></a>2.3 common层</h3><p>不是简单的接口，而是相对庞大的组件：cookie,ajsx,drag,resize,animation,tab,tree,msg,colorPicker,calendar,richTextEditor…. </p>
<p>没base通用，具体功能相关，不相关不加载；而且一个易用性，重用性，可扩展性好的组件，代码量偏高，按功能单独的文件common_cookie.js,common_drag.js,..按需加载<br>不仅依赖base，有时也依赖common其他， ，加载时注意顺序</p>
<h3 id="2-4-page层-应用层"><a href="#2-4-page层-应用层" class="headerlink" title="2.4 page层  应用层"></a>2.4 page层  应用层</h3><p>平时绝大部分工作在page层，分层后，轻松了。若前两个够丰富、稳定，精力就全在业务逻辑上了，一提高效率，另一提高代码重用率，减小网页大小</p>
<h3 id="2-5-JavaScript库"><a href="#2-5-JavaScript库" class="headerlink" title="2.5 JavaScript库"></a>2.5 JavaScript库</h3><p>Prototype,dojo,mootools,ext js,jquery,YUI</p>
<p>YUI2:三大部分：Core-b、Utilities-c、Widgets-c</p>
<p>jQuery:核心文件、jQuery UI</p>
<p>也可以自己写组件，考验工程师能力的事，高品质组件：跨浏览器兼容、组件易用、可重用、可扩展、代码组织有序，高内聚低耦合</p>
<p>长看到网上大量组件，依赖某js库。。。写好的库，。。。为什么不用呢，质，还可直接用第三方组件</p>
<pre><code>5.2代码留下等待实现  
</code></pre><p style="text-align:right">2017.9.11 一 00：41</p><br><p style="text-align:right">2017.9.11 一 22：00</p>

<h2 id="3-编程使用技巧-236"><a href="#3-编程使用技巧-236" class="headerlink" title="3 编程使用技巧  236"></a>3 编程使用技巧  236</h2><h3 id="3-1-弹性"><a href="#3-1-弹性" class="headerlink" title="3.1 弹性"></a>3.1 弹性</h3><p>Get by id,如果再加两个==》数组，byTagName，弹出4444：闭包，_index属性；content结构里可能还有Tag===》3.2by class name</p>
<h3 id="3-2-getElementById-getElementByTagName-getElementByName"><a href="#3-2-getElementById-getElementByTagName-getElementByName" class="headerlink" title="3.2 getElementById,getElementByTagName,getElementByName"></a>3.2 getElementById,getElementByTagName,getElementByName</h3><p>但因为一个页面内，相同的id只能出现一次，所以不适合获取一组有“相似功能”的dom节点。<br>用标签名获得dom节点，让程序和html结构耦合太紧。</p>
<h3 id="3-3-可复用性-这页面3个，那页面5个"><a href="#3-3-可复用性-这页面3个，那页面5个" class="headerlink" title="3.3 可复用性 这页面3个，那页面5个"></a>3.3 可复用性 这页面3个，那页面5个</h3><p>同一个页面id只能出现一次，如果你的程序需要被多处复用，一定不能用id做为JavaScript获得dom节点挂钩。<br>组件需要指定一个根节点，以保持每个组件之间的独立性。</p>
<h3 id="3-4-避免产生副作用-tab-高亮，灰底白字"><a href="#3-4-避免产生副作用-tab-高亮，灰底白字" class="headerlink" title="3.4 避免产生副作用  tab 高亮，灰底白字"></a>3.4 避免产生副作用  tab 高亮，灰底白字</h3><p>如果挂了其他样式，会冲突 ，addClass</p>
<h3 id="3-5-通过传参实现定制-第一个高亮，第二个不高亮，第三个高亮但区别"><a href="#3-5-通过传参实现定制-第一个高亮，第二个不高亮，第三个高亮但区别" class="headerlink" title="3.5 通过传参实现定制 第一个高亮，第二个不高亮，第三个高亮但区别"></a>3.5 通过传参实现定制 第一个高亮，第二个不高亮，第三个高亮但区别</h3><p>如果一个函数内某个因素很不稳定，我们可以将它从函数内部分离出来，以参数的形式传入，从而将不稳定因素和函数解耦。</p>
<h3 id="3-6-控制this关键字的指向"><a href="#3-6-控制this关键字的指向" class="headerlink" title="3.6 控制this关键字的指向"></a>3.6 控制this关键字的指向</h3><h3 id="3-7-预留回调接口-可增加tab的可扩展性"><a href="#3-7-预留回调接口-可增加tab的可扩展性" class="headerlink" title="3.7 预留回调接口   可增加tab的可扩展性"></a>3.7 预留回调接口   可增加tab的可扩展性</h3><p style="text-align:right">P231 2017.9.12 二 01：17</p><br><p style="text-align:right">2017.9.12 二 22：17</p>

<h3 id="3-8-编程中的DRY原则-auto，showItem"><a href="#3-8-编程中的DRY原则-auto，showItem" class="headerlink" title="3.8 编程中的DRY原则   auto，showItem"></a>3.8 编程中的DRY原则   auto，showItem</h3><h3 id="3-9-用hash对象传参-多余的null参数，"><a href="#3-9-用hash对象传参-多余的null参数，" class="headerlink" title="3.9 用hash对象传参  多余的null参数，"></a>3.9 用hash对象传参  多余的null参数，</h3><h2 id="4-面向对象编程"><a href="#4-面向对象编程" class="headerlink" title="4 面向对象编程"></a>4 面向对象编程</h2><h3 id="4-1-面向过程编程和面向对象编程"><a href="#4-1-面向过程编程和面向对象编程" class="headerlink" title="4.1 面向过程编程和面向对象编程"></a>4.1 面向过程编程和面向对象编程</h3><p>过程：程序：“数据”—“处理函数”</p>
<p>三方面问题：1没有直接关联，需同时关注两者；<br>2暴露在同一作用域，没有私用，公有概念，都可以互相访问，初期开发快，后期，由于耦合紧，可能关联到其他地方，牵一发动全身。<br>3典型的计算机思维方式：  。</p>
<p>对象：对象：“属性”“行为”</p>
<pre><code>只写了两个程序的代码，笔记没有做 
</code></pre><p style="text-align:right">2017.9.13 三 00：51</p><br><p style="text-align:right">北一103 2017.9.16 六 11：31</p>

<h3 id="4-2-JavaScript的面向对象编程"><a href="#4-2-JavaScript的面向对象编程" class="headerlink" title="4.2 JavaScript的面向对象编程"></a>4.2 JavaScript的面向对象编程</h3><h4 id="4-2-1-Js定义类"><a href="#4-2-1-Js定义类" class="headerlink" title="4.2.1 Js定义类"></a>4.2.1 Js定义类</h4><p>函数：普通函数，类</p>
<p>Js定义类：不使用原型，使用原型，使用原型的hash对象写法<br>一般习惯把属性放构造函数，非原型，方便从构造函数接受参数</p>
<h4 id="4-2-2-共有和私有"><a href="#4-2-2-共有和私有" class="headerlink" title="4.2.2 共有和私有"></a>4.2.2 共有和私有</h4><p>This定义共有，var私有；构造函数中的私有无法被原型中的方法访问，私有属性的作用域只在类的构造函数中  </p>
<h5 id="1-最简单方法：共有方法也写在构造函数中；问题：实例化时都会复制一份"><a href="#1-最简单方法：共有方法也写在构造函数中；问题：实例化时都会复制一份" class="headerlink" title="1.最简单方法：共有方法也写在构造函数中；问题：实例化时都会复制一份"></a>1.最简单方法：共有方法也写在构造函数中；问题：实例化时都会复制一份</h5><p>把行为写在原型可以减少内存消耗</p>
<h5 id="2-1-如果对属性和行为的私有性要求不高，常见做法是约定私有行为-siyou；"><a href="#2-1-如果对属性和行为的私有性要求不高，常见做法是约定私有行为-siyou；" class="headerlink" title="2.1 如果对属性和行为的私有性要求不高，常见做法是约定私有行为_siyou；"></a>2.1 如果对属性和行为的私有性要求不高，常见做法是约定私有行为_siyou；</h5><h5 id="2-2-1-极端主义者，直接访问类的属性不好，所有属性都是私有，通过get，set获取和设置"><a href="#2-2-1-极端主义者，直接访问类的属性不好，所有属性都是私有，通过get，set获取和设置" class="headerlink" title="2.2.1 极端主义者，直接访问类的属性不好，所有属性都是私有，通过get，set获取和设置"></a>2.2.1 极端主义者，直接访问类的属性不好，所有属性都是私有，通过get，set获取和设置</h5><p>2.2.2比较：set，get相关方法都要放在构造函数中-VS 所有方法都放在构造函数中，会占用更多内存。。但可以更好的保护属性：例如：Animal类的name只能为wangcai或xiaoqiang，type为只读<br>2.2.3 （你当然可以在编程的时候小心地注意那些属性有什么限制要求，不通过set，get方法对属性进行保护，任然使用this.xxx对属性直接读写，从而节省一点内存。<br>对于简单应用，作者推荐this.xxx来读写；更复杂的应用，对扩展性和健壮性要求很高，此时用set和get方法读取属性更合适）</p>
<p><strong>另外，如果使用set设置属性，那么就有了监听valueChange的入口。(这才是本小小节主题)</strong></p>
<p>真实世界中，我们的很多思维习惯都是状态驱动的，编程时监听属性的valueChange事件可以帮我们更接近真实世界的思维习惯</p>
<h4 id="4-2-3-继承"><a href="#4-2-3-继承" class="headerlink" title="4.2.3 继承"></a>4.2.3 继承</h4><p>Js中实例的属性和行为是由构造函数和原型两部分共同组成的。<br>Js继承要分别继承构造函数和原型中的属性和行为</p>
<p>1、继承构造函数：Animal.call(this,name);<br>2、继承原型：Bird.prototype=Animal.prototype;<br>   解决传值，传址：<br>1简单方法：遍历数组或hash对象，将复杂数据拆成简单数据，然后分别赋值。。值得一提，数组的传值还可以用数组的concat和slice方法实现<br>2另一种方法prototype传值，New SomeFunction（prototype和function的关系：用作类的function）<br>Bird.prototype=new Animal();<br>Bird.prototype.constructor=Bird;<em>因为上面的将Bird.prototype.constructor指向Animal，需纠正，重新指回Bird</em><br>3 封装上面函数 function extend(subClass,superClass)<br>extend(Bird,Animal);</p>
<h3 id="4-3-用面向对象方式重写代码"><a href="#4-3-用面向对象方式重写代码" class="headerlink" title="4.3 用面向对象方式重写代码"></a>4.3 用面向对象方式重写代码</h3><p>PhonebookManger  Tab    </p>
<p>UML语言将类描述出来  </p>
<p>面向对象和过程，优缺点 5.4.1比较过。当程序越复杂，这些优缺点会表现的越明显。早晚要跨过的一道坎</p>
<p style="text-align:right">被耽搁的星期六 2017.9.16 六 11:00</p><br><p style="text-align:right">2017.9.17 日 10:16</p>

<h2 id="5-其他问题"><a href="#5-其他问题" class="headerlink" title="5 其他问题"></a>5 其他问题</h2><h3 id="5-1-prototype和内置类"><a href="#5-1-prototype和内置类" class="headerlink" title="5.1 prototype和内置类"></a>5.1 prototype和内置类</h3><p>(5.4.2 prototype和类的关系，进一步==》)  </p>
<h4 id="1、js提供了内置类：Array、String、Function等，它们提供了js的大部分基本数据类型。有属性和方法，比如"><a href="#1、js提供了内置类：Array、String、Function等，它们提供了js的大部分基本数据类型。有属性和方法，比如" class="headerlink" title="1、js提供了内置类：Array、String、Function等，它们提供了js的大部分基本数据类型。有属性和方法，比如"></a>1、js提供了内置类：Array、String、Function等，它们提供了js的大部分基本数据类型。有属性和方法，比如</h4><p>需说明：这些内置类不一定需要new实例，平时习惯更简单的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a=new String(&quot;sdfs&quot;);//通过new实例</span><br><span class="line">var b=&quot;sdf&quot;;//通过&quot;&quot;实例 String类对象</span><br><span class="line">var d=[1,2,4];//通过[]实例 Array类对象</span><br></pre></td></tr></table></figure></p>
<h4 id="2、类就有原型，不论内置or自定义。通过修改内置类原型，让js基本对象有趣的功能：array–each-map等"><a href="#2、类就有原型，不论内置or自定义。通过修改内置类原型，让js基本对象有趣的功能：array–each-map等" class="headerlink" title="2、类就有原型，不论内置or自定义。通过修改内置类原型，让js基本对象有趣的功能：array–each,map等"></a>2、类就有原型，不论内置or自定义。通过修改内置类原型，让js基本对象有趣的功能：array–each,map等</h4><p>扩展方法中this：无论在类的构造函数还是原型，都指向实例化的对象。 </p>
<h4 id="3、除了扩展，还可以重写"><a href="#3、除了扩展，还可以重写" class="headerlink" title="3、除了扩展，还可以重写"></a>3、除了扩展，还可以重写</h4><p>alert(a),自动调用a的toString。在需要字符串时，对象会隐式调用toString，包括我们自定义的对象[object Object]  </p>
<h4 id="4、js中包括内置类和自定义类，所有类的祖先-都是Object。如果相对所有对象都扩展，可修改Object类的原型实现"><a href="#4、js中包括内置类和自定义类，所有类的祖先-都是Object。如果相对所有对象都扩展，可修改Object类的原型实现" class="headerlink" title="4、js中包括内置类和自定义类，所有类的祖先 都是Object。如果相对所有对象都扩展，可修改Object类的原型实现"></a>4、js中包括内置类和自定义类，所有类的祖先 都是Object。如果相对所有对象都扩展，可修改Object类的原型实现</h4><h4 id="5、修改内置类的原型—方便，但有人排斥—-污染，多人合作对他人造成影响，修改了游戏规则。改进myArray-自定义类，将内置类的实例做为参数传给构造函数；"><a href="#5、修改内置类的原型—方便，但有人排斥—-污染，多人合作对他人造成影响，修改了游戏规则。改进myArray-自定义类，将内置类的实例做为参数传给构造函数；" class="headerlink" title="5、修改内置类的原型—方便，但有人排斥—-污染，多人合作对他人造成影响，修改了游戏规则。改进myArray:自定义类，将内置类的实例做为参数传给构造函数；"></a>5、修改内置类的原型—方便，但有人排斥—-污染，多人合作对他人造成影响，修改了游戏规则。改进myArray:自定义类，将内置类的实例做为参数传给构造函数；</h4><p>各有优缺点：。。。。。。但需要new实例化</p>
<p>小应用，不过多考虑可维护性，用前者–直接修改；<br>大中型，考虑维护性，后者。</p>
<h3 id="5-2-标签的自定义属性"><a href="#5-2-标签的自定义属性" class="headerlink" title="5.2 标签的自定义属性"></a>5.2 标签的自定义属性</h3><p>js和html标签存在映射关系，html标签在js中作为dom节点对象存在。  </p>
<h4 id="1、获取定义在html标签属性：1、DOM节点对象的getAttribute方法；2、DOM节点对象的属性"><a href="#1、获取定义在html标签属性：1、DOM节点对象的getAttribute方法；2、DOM节点对象的属性" class="headerlink" title="1、获取定义在html标签属性：1、DOM节点对象的getAttribute方法；2、DOM节点对象的属性"></a>1、获取定义在html标签属性：1、DOM节点对象的getAttribute方法；2、DOM节点对象的属性</h4><p>ie和firefox：getA 大部分一致，某些不同；node.XXXX结果会更一致。跨浏览器兼容性更好</p>
<h4 id="2、相反在js中定义的属性，也可以映射到html标签中"><a href="#2、相反在js中定义的属性，也可以映射到html标签中" class="headerlink" title="2、相反在js中定义的属性，也可以映射到html标签中"></a>2、相反在js中定义的属性，也可以映射到html标签中</h4><h4 id="3、除了常规属性，还有自定义属性。Firefox无法node-XXXX-只能-node-getAttribute-“XXX”"><a href="#3、除了常规属性，还有自定义属性。Firefox无法node-XXXX-只能-node-getAttribute-“XXX”" class="headerlink" title="3、除了常规属性，还有自定义属性。Firefox无法node.XXXX,只能 node.getAttribute(“XXX”)"></a>3、除了常规属性，还有自定义属性。Firefox无法node.XXXX,只能 node.getAttribute(“XXX”)</h4><p>作者建议：常规node.XXX,自定义node.getAttribute(“XXX”)  </p>
<p>自定义属性很有用的技巧，不但可以保存普通字符串，还可以其他数据：数组，hash==》数据反序列化、json。  </p>
<pre><code>info=eval( &quot;(&quot;+info+&quot;)&quot; );
</code></pre><p><strong>$_PS:</strong> 个人以为这不是好方法了，现在有更好的方式了，不用eval。   </p>
<h3 id="5-3-标签的内联事件和event对象"><a href="#5-3-标签的内联事件和event对象" class="headerlink" title="5.3 标签的内联事件和event对象"></a>5.3 标签的内联事件和event对象</h3><p>event IE：window的一个属性，在全局作用域下。Firefox：事件的参数 </p>
<h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><pre><code>document.getElementById(&quot;btn&quot;).onclick=function(){
    alert(arguments.length);//ie7 0;ff:1 ..ie9:1
} 
</code></pre><h4 id="2、换成内联呢"><a href="#2、换成内联呢" class="headerlink" title="2、换成内联呢"></a>2、换成内联呢</h4><pre><code>&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;handler()&quot;&gt;
</code></pre><p>都弹出0<br>没有换成 <code>btn.onclick=handler;</code><br>而是 <code>btn.onclick=funciton(){handler();}</code></p>
<h4 id="3、内联中，arguments-0-在ff下可以访问到event对象"><a href="#3、内联中，arguments-0-在ff下可以访问到event对象" class="headerlink" title="3、内联中，arguments[0],在ff下可以访问到event对象"></a>3、内联中，arguments[0],在ff下可以访问到event对象</h4><pre><code>&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;alert(arguments[0].type)&quot;&gt;  
</code></pre><h4 id="4、不使用标签内联事件时，可以给处理函数传参，指定argumens-0-参数名"><a href="#4、不使用标签内联事件时，可以给处理函数传参，指定argumens-0-参数名" class="headerlink" title="4、不使用标签内联事件时，可以给处理函数传参，指定argumens[0]参数名"></a>4、不使用标签内联事件时，可以给处理函数传参，指定argumens[0]参数名</h4><pre><code>document.getElementById(&quot;btn&quot;).onclick=function(e){
    e=window.event||e;//兼容ie ff 
}
</code></pre><h4 id="5、标签内联事件中，没办法指定参数名，没法直接写变量在ie，ff下兼容event对象了吗？"><a href="#5、标签内联事件中，没办法指定参数名，没法直接写变量在ie，ff下兼容event对象了吗？" class="headerlink" title="5、标签内联事件中，没办法指定参数名，没法直接写变量在ie，ff下兼容event对象了吗？"></a>5、标签内联事件中，没办法指定参数名，没法直接写变量在ie，ff下兼容event对象了吗？</h4><p>否。可以用event变量名，兼容指向event对象，只能是event，其他a，b，Event都不行。  </p>
<pre><code>&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;click me&quot; onclick=&quot;alert(event.type)&quot;&gt;  
</code></pre><p>ie,ff都可以正确弹出</p>
<h4 id="6、标签内联事件中，甚至可以写注释，使用字符串"><a href="#6、标签内联事件中，甚至可以写注释，使用字符串" class="headerlink" title="6、标签内联事件中，甚至可以写注释，使用字符串"></a>6、标签内联事件中，甚至可以写注释，使用字符串</h4><h4 id="7、既用了标签内联事件，又用了DomNode-onXXX"><a href="#7、既用了标签内联事件，又用了DomNode-onXXX" class="headerlink" title="7、既用了标签内联事件，又用了DomNode.onXXX"></a>7、既用了标签内联事件，又用了DomNode.onXXX</h4><p>后面的会覆盖前面的</p>
<h4 id="8、attachEvent-addEventListener"><a href="#8、attachEvent-addEventListener" class="headerlink" title="8、attachEvent  addEventListener"></a>8、attachEvent  addEventListener</h4><p>都弹出</p>
<h3 id="5-4-利用事件冒泡机制"><a href="#5-4-利用事件冒泡机制" class="headerlink" title="5.4 利用事件冒泡机制"></a>5.4 利用事件冒泡机制</h3><pre><code>打分，星星 代码 没有写，用的是面向对象
</code></pre><h3 id="5-5-改变DOM样式的三种方式"><a href="#5-5-改变DOM样式的三种方式" class="headerlink" title="5.5 改变DOM样式的三种方式"></a>5.5 改变DOM样式的三种方式</h3><h4 id="1、简单直接node-style-color-”red”"><a href="#1、简单直接node-style-color-”red”" class="headerlink" title="1、简单直接node.style.color=”red”;"></a>1、简单直接node.style.color=”red”;</h4><p> 同时多个样式。node.style.color=”red”;node.style.backgroundColor=”red”;..</p>
<h4 id="2、node-className-”testStyle”"><a href="#2、node-className-”testStyle”" class="headerlink" title="2、node.className=”testStyle”"></a>2、node.className=”testStyle”</h4><p>多个dom呢。批量span，除了id为test的color，其他都…   </p>
<p>这两都是针对单个dom节点的操作，可以逐个设置。。都不支持批量处理==》</p>
<h4 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h4><pre><code>function addStyleNode(str){
    var styleNode=document.createElement(&quot;style&quot;);
    styleNode.type=&quot;text/css&quot;;
    if(styleNode.styleSheet){
        styleNode.styleSheet.cssText=str;
    }else{
        styleNode.innerHTML=str;
    }
}
document.getElementsByTagName(&quot;head&quot;)[0].appendChild(styleNode);
addStyleNode(&quot;sapn{color:#fff;font-...}#test{}...&quot;);
</code></pre><p>思路：创建一个 <code>&lt;style&gt;</code>标签，然后往里填入css，再把它加入到页面里。<br>ff直接innerHTML；ie，只读的，通过<code>styleSheet.cssText</code><br><strong>$_PS:</strong> 这个第三点，不是很明白</p>
<h1 id="附录A-写在规则前面的话"><a href="#附录A-写在规则前面的话" class="headerlink" title="附录A 写在规则前面的话"></a>附录A 写在规则前面的话</h1><h1 id="附录B-命名规则"><a href="#附录B-命名规则" class="headerlink" title="附录B 命名规则"></a>附录B 命名规则</h1><h1 id="附录C-分工安排"><a href="#附录C-分工安排" class="headerlink" title="附录C 分工安排"></a>附录C 分工安排</h1><h1 id="附录D-注释规则"><a href="#附录D-注释规则" class="headerlink" title="附录D 注释规则"></a>附录D 注释规则</h1><h1 id="附录E-HTML规范"><a href="#附录E-HTML规范" class="headerlink" title="附录E HTML规范"></a>附录E HTML规范</h1><h1 id="附录F-CSS规范"><a href="#附录F-CSS规范" class="headerlink" title="附录F CSS规范"></a>附录F CSS规范</h1><h1 id="附录G-Javascript规范"><a href="#附录G-Javascript规范" class="headerlink" title="附录G Javascript规范"></a>附录G Javascript规范</h1><p style="text-align:right">2017.9.17 日 12:20</p>]]></content>
      <categories>
        <category>pdf</category>
        <category>opti</category>
      </categories>
      <tags>
        <tag>opti</tag>
      </tags>
  </entry>
  <entry>
    <title>Css代码组织方法</title>
    <url>/sum/css/css%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E6%B3%95(002)/</url>
    <content><![CDATA[<p>CSS工程化演进、6种组织CSS的方法、现代CSS进化史、CSS in JS 简介  </p>
<a id="more"></a>
<p style="text-align:right">2018.4.17 二 21:41</p>


<h1 id="A-CSS工程化演进"><a href="#A-CSS工程化演进" class="headerlink" title="A [CSS工程化演进]"></a>A [CSS工程化演进]</h1><p><a href="https://zhuanlan.zhihu.com/p/32117359" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32117359</a><br>&lt;!– <a href="https://zhuanlan.zhihu.com/p/32117359" target="_blank" rel="noopener">原文</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227502&amp;idx=1&amp;sn=b71dff2959dc02219d8171501d3004e4&amp;chksm=bd495cea8a3ed5fc323e15a57c48b21f9960cc9a568eb10366a8270943669d9d82304657ed66&amp;mpshare=1&amp;scene=1&amp;srcid=12268CKNGBYjKFg5gEtB2zBY##" target="_blank" rel="noopener"><strong>$_WX</strong></a><br><a href="https://app.yinxiang.com/shard/s67/nl/18114453/1ad88040-5cb2-474e-9110-f1142c55fdbe?title=%E3%80%90%E7%AC%AC1150%E6%9C%9F%E3%80%91CSS%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%BC%94%E8%BF%9B" target="_blank" rel="noopener"><strong>$_YX</strong></a>   </p>
<p>由饿了么@cottom分享 –&gt;</p>
<h2 id="CSS-技术的演进"><a href="#CSS-技术的演进" class="headerlink" title="CSS 技术的演进"></a>CSS 技术的演进</h2><h2 id="Web开发模块化趋势"><a href="#Web开发模块化趋势" class="headerlink" title="Web开发模块化趋势"></a>Web开发模块化趋势</h2><h3 id="预处理与后处理"><a href="#预处理与后处理" class="headerlink" title="预处理与后处理"></a>预处理与后处理</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>比较流行的CSS预处理器有 Sass, Less 和 Stylus，CSS 预处理器的出现主要针对于 CSS 缺少编程语言的灵活性而生的，是引入了一些编程概念而生的 DSL，开发者编写简介的语义化 DSL 代码，由预处理器编译成 CSS。</p>
<p>以Sass为例，该预处理器支持.scss，.sass 文件类型，其语法支持变量、选择器嵌套、继承（extend）、混合（mixin）和一些逻辑语句，同时还支持跨文件的导入功能，因而使得开发者能够很好的使用编程思想书写样式。</p>
<p>从实际使用情况来看，几个预处理器各有优缺点，社区活跃度上看 Sass &gt; Less &gt; Stylus，在于<br>….</p>
<h4 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h4><p>后处理器是对原生 CSS 进行处理并最终生成 CSS 的处理器，广义上还是个预处理器，与上面不同的是，它处理的对象是标准 CSS，比较典型的后处理工具有：</p>
<ul>
<li>clean-css — 压缩 CSS</li>
<li>AutoPrefixer — 自动添加 CSS3 属性各浏览器的前缀</li>
<li>Rework — 取代 stylus 的插件化框架</li>
<li>PostCSS</li>
</ul>
<h2 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h2><p>PostCSS 一开始是从 AutoPrefixer 项目中抽象出来的框架，它本身并不对CSS做具体的业务操作，只是将CSS解析成抽象语法树（AST），样式的操作由之后运行的插件系统完成。正如其本身所言“Tra nsforming styles with JS plugins”</p>
<p>更多时候我们讨论的 PostCSS ，并不止是其解析 CSS 的核心工具，更包括它创建的插件系统，而今 PostCSS 最为吸引开发者的正是其扩展性较强的插件系统和丰富的插件支持。<br>…<br>常用的插件:</p>
<ul>
<li>autoprefixer — 自动补全CSS属性兼容性前缀</li>
<li>postcss-cssnext — 使用最新的 CSS 语法</li>
<li>postcss-modules — 组件内自动关联样式至选择器</li>
<li>stylelint — CSS 语法检查器</li>
</ul>
<h2 id="namespace-约束"><a href="#namespace-约束" class="headerlink" title="namespace 约束"></a>namespace 约束</h2><p>一方面我们需要关注技术能够带来代码上的模块化，另一方面我们又要思考如何使用一个良好的风格架构起项目中的 CSS。CSS 除了代码外，另一个很重要的就是 CSS 选择标记，但 CSS 选择器的命名空间是全局的，并没有局部的概念，因而如何利用好这个全局的空间，选择良好的结构风格，也是在开发过程中必须考虑的。</p>
<h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCS （Object-Oriented CSS）即面向对象 CSS，主要有两个核心原则</p>
<h3 id="分离结构和皮肤（separate-structure-and-skin）"><a href="#分离结构和皮肤（separate-structure-and-skin）" class="headerlink" title="分离结构和皮肤（separate structure and skin）"></a>分离结构和皮肤（separate structure and skin）</h3><p>皮肤即一些重复的视觉特征，如边框、背景、颜色，分离是为了更多的复用；结构是指元素大小特征，如高度，宽度，边距等等。</p>
<h3 id="分离容器和内容（separate-container-an-content）"><a href="#分离容器和内容（separate-container-an-content）" class="headerlink" title="分离容器和内容（separate container an content）"></a>分离容器和内容（separate container an content）</h3><p>打破容器内元素对于容器的依赖，元素样式应该独立存在。</p>
<p>从实践中看出，使用OOSCC范式，遵守了 DRY 的原则，能够大量减少重复的样式代码，提高代码复用；<br>同时，视觉元素可以意灵活组合各个类名，展示不同的效果，丰富的类名也同时使得元素有着更好的可读性；<br>另一方面，由于容器和内容的分离，CSS 完成了与 HTML 结构解耦。</p>
<p>但同时也会带来一些缺点，抽象复用会使class越来越多，极端情况会产生可能产生很多原子类，这对于那些偏向于“单一来源原则”的开发者来说并不受欢迎。</p>
<h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS(Scalable and Modular Architecture for CSS) 即模块化架构的可扩展CSS，它主要是将规则分为5类</p>
<ol>
<li>基础（Base）<br>tag select的样式，定义最基础全局样式，如CSS REST。</li>
<li>布局（Layout）<br>将页面分为各个区域的元素块</li>
<li><p>模块（Module）<br>可复用的单元。在模块中需要注意的是选择器一律选择 class selector，避免嵌套子选择器，减少权重，方便外部覆盖。</p>
<pre><code>&lt;divclass=&quot;pod pod-constrained&quot;&gt;...&lt;/div&gt;
&lt;divclass=&quot;pod pod-callout&quot;&gt;...&lt;/div&gt;
.pod { width: 100%; } .pod .pod-callout { width: 200px; } .pod .pod-constrained{}
</code></pre></li>
<li><p>状态（State）<br>状态 class 一般通过js动态挂载到元素上，可以根据状态覆盖元素上特定属性。</p>
<pre><code>.tab{background-color:purple;...}
.is-tab-active{background-color:white;}
</code></pre></li>
<li>主题（Theme）<br>可选的视觉外观。一般根据需求有颜色，字体，布局等等，实现是将这些样式单独抽出来，根据外部条件（ data 属性，媒体查询等）动态设置。</li>
</ol>
<p>SMACSS 的主要<strong>优点</strong>在于按照不同的业务逻辑，将整个 CSS 结构化分更加细致，约束好命名，最小化深度，在编写的时候，使用SMACSS规范能够更好的组织好 CSS 文件结构和 class 命名。</p>
<h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>BEM 即Block Element Modifier；类名命名规则： Block__Element—Modifier</p>
<ul>
<li>Block 所属组件名称</li>
<li>Element 组件内元素名称</li>
<li>Modifier 元素或组件修饰符</li>
</ul>
<p>其核心思想就是组件化。首先一个页面可以按层级依次划分未多个组件，其次就是单独标记这些元素。BEM通过简单的块、元素、修饰符的约束规则确保类名的唯一，同时将类选择器的语义化提升了一个新的高度。</p>
<h2 id="CSS-IN-JS"><a href="#CSS-IN-JS" class="headerlink" title="CSS IN JS"></a>CSS IN JS</h2><h2 id="CSS-modlue"><a href="#CSS-modlue" class="headerlink" title="CSS modlue"></a>CSS modlue</h2><p>CSS module 不同于 vjeux 的完全放弃 CSS，它只是选择了用 js 来管理样式与元素的关联，CSS Module 通过为每个本地定义的类名动态创建一个全局唯一类名，然后注入到UI上，实现编写样式规则的局部模块化。</p>
<p>css-loader 内置支持css-module，只需设置下查询参数，即可在JS中使用CSS文件的导入：</p>
<pre><code>import style from&apos;./Header.css&apos;
</code></pre><h2 id="styled-components"><a href="#styled-components" class="headerlink" title="styled-components"></a>styled-components</h2><p>styled-components 也是一个完全的 css-in-js 方案，先看语法：</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h1 id="B-6种组织CSS的方法"><a href="#B-6种组织CSS的方法" class="headerlink" title="B [6种组织CSS的方法]"></a>B [6种组织CSS的方法]</h1><p><a href="https://zhuanlan.zhihu.com/p/28085207" target="_blank" rel="noopener">译文</a><br><a href="https://css-tricks.com/methods-organize-css/" target="_blank" rel="noopener">原文</a><br><!-- [**$_WX**](http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226768&idx=1&sn=eb05d7a5e757c4d06ecba3f478fe71c2&chksm=bd495b148a3ed202af6ee661c1520d57c5ff426dfd33d080296730c2a4fb3d8becb17243d96e&mpshare=1&scene=1&srcid=0807zOTUtQ5l7GbY39K982F5#)   
[**$_YX**](https://app.yinxiang.com/Home.action#n=2e719345-4bc1-4c7c-a19b-bdb44e7b3e80&s=s67&b=c6633e78-2582-4902-a18a-147003fbf323&ses=4&sh=1&sds=5&)  -->  </p>
<p>Ben Frain曾经说过, 写CSS容易, 扩展和维护难. 这篇文章介绍了一些解决方案的集合, 试图解决这个问题 .</p>
<h2 id="OOCSS-面向对象-CSS"><a href="#OOCSS-面向对象-CSS" class="headerlink" title="OOCSS 面向对象 CSS"></a>OOCSS 面向对象 CSS</h2><p>OOCSS是object-oriented CSS的缩写. 主要有两个意思:结构和设计分离、容器和内容分离</p>
<h2 id="SMACSS-可扩展和模块化结构的-CSS"><a href="#SMACSS-可扩展和模块化结构的-CSS" class="headerlink" title="SMACSS 可扩展和模块化结构的 CSS"></a>SMACSS 可扩展和模块化结构的 CSS</h2><p>SMACSS是可扩展和模块化结构CSS的简称. 该方法的主要目标是减少代码量并简化代码维护.<br>Jonathan Snook把它归纳为5个部分:</p>
<h2 id="Atomic-CSS-原子-CSS"><a href="#Atomic-CSS-原子-CSS" class="headerlink" title="Atomic CSS 原子 CSS"></a>Atomic CSS 原子 CSS</h2><p>Atomic CSS是CSS架构的一种方法, 它的好处是写出基于视觉功能的小的, 单用途CSS类.</p>
<h2 id="MCSS-多层-CSS"><a href="#MCSS-多层-CSS" class="headerlink" title="MCSS 多层 CSS"></a>MCSS 多层 CSS</h2><p>MCSS指的是多层CSS(Multilayer CSS). 这种样式写法建议将样式分成多个部分, 每个部分称为层(layers).</p>
<ul>
<li>第0层或基础(Zero layer or foundation), 负责重置浏览器样式的代码(如: reset.css或者normalize.css);</li>
<li>基层(Base layer), 包括可重用元素的样式: buttons, input, hints等等.</li>
<li>项目层(Project layer), 包括单独的模块和”上下文” - 根据用户端浏览器或用于浏览的设备, 用户权限等对元素的样式进行调整.</li>
<li>装饰层(Cosmetic layer), 使用OOCSS风格来书写样式, 对元素外观做微小的调整. 建议仅留下影响外观的风格, 而不能破坏网站的布局(例如颜色和非关键缩进等).</li>
</ul>
<h2 id="AMCSS-属性模块-CSS"><a href="#AMCSS-属性模块-CSS" class="headerlink" title="AMCSS 属性模块 CSS"></a>AMCSS 属性模块 CSS</h2><pre><code>&lt;div class=&quot;button button--large button--blue&quot;&gt;Button&lt;/div&gt;
// 通过属性来为这些CSS类分组.
&lt;div button=&quot;large blue&quot;&gt;Button&lt;/div&gt;
// 为了避免属性名称冲突, 好的方式是为属性加上命名空间.
&lt;div am-button=&quot;large blue&quot;&gt;Button&lt;/div&gt;
</code></pre><p>如果您使用了验证器去检查你的代码, 并且它(验证器)不喜欢类似于am-button这样的属性名称, 你可以把属性的命名空间(am-)换成data-. 例如: data-button.</p>
<pre><code>/* CSS类选择器 */
.button { ... }
.button--large { ... }
.button--blue { ... }

/* CSS属性选择器 */
[am-button] { ... }
[am-button ~= &quot;large&quot;] { ... }
[am-button ~= &quot;blue&quot;] { ... }
</code></pre><p>如果您认为这段代码十分的不寻常, 可以尝试使用较为温和的AMCSS形式:</p>
<pre><code>&lt;div am-button am-button-large am-button-blue&gt;Button&lt;/div&gt;
</code></pre><h2 id="FUN"><a href="#FUN" class="headerlink" title="FUN"></a>FUN</h2><p>FUN代表的是”Flat hierarchy of selectors, Utility styles, Name-spaced components.”</p>
<p>每个名称前面的字母都代表着一定的原则:</p>
<ul>
<li>F, 选择器的扁平的层次结构: 建议使用CSS类选择元素(items), 避免不必要的级联, 杜绝使用id.</li>
<li>U, 实用(功能)样式: 鼓励创建原子(atomic)样式来解决典型的修正(微调)任务, 例如: w100表示width: 100%; 或者fr表示float: right;</li>
<li>N, 名称分割组件: Ben建议添加命名空间来指定特定模块元素的样式. 这种方法将避免类的中重叠.</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>正如你所看到的, 这些方法中没有哪一个是非常理想的. 因此, 并没有对所有人所有项目都适合的绝对的标准 - 你可以从这些方法中选择某一个开始, 创建某些属于你自己的东西. 亦或者完全重头开始建立一套你自己的标准 .</p>
<p># [现代CSS进化史]</p>
<p># [CSS in JS 简介]</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome控制台使用</title>
    <url>/sum/js/chrome%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BD%BF%E7%94%A8(028)/</url>
    <content><![CDATA[<!--
Title|Site|Backup|Status  
--|--|--|--  
[x] Chrome 开发者工具|<https://developers.google.com/web/tools/chrome-devtools/> | -| S3   
[v] 中文文档|<http://www.css88.com/doc/chrome-devtools/> | x|S3|   
-->
<p style="text-align:right">2018.4.15 星期日 22:18 </p>

<!-- 
资料整理
都差不多，互相补充；
A log具体介绍；后几个$,$x,keys,values等
B assert不同介绍；trace的使用；profile还需要细研究

C inspect,clear,dir等的简写；
  getEventListeners，D也有介绍
  monitorEvents和A中monitor应该是同一个方法；
D 包含chrome F12的简单介绍；过滤/设置等，选中；控制台相关的，前面基本都介绍过 
-->
<p>Chrome 开发者工具|<a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/</a></p>
<a id="more"></a>
<h1 id="A-Chrome-控制台实用指南"><a href="#A-Chrome-控制台实用指南" class="headerlink" title="A [Chrome 控制台实用指南]"></a>A [Chrome 控制台实用指南]</h1><h2 id="1-console-clear"><a href="#1-console-clear" class="headerlink" title="1 console.clear"></a>1 console.clear</h2><h2 id="2-console-log家族"><a href="#2-console-log家族" class="headerlink" title="2 console.log家族"></a>2 console.log家族</h2><ol>
<li>console.log (‘普通信息’)   </li>
<li>console.info (‘提示性信息’)   </li>
<li>console.error (‘错误信息’)   </li>
<li>console.warn (‘警示信息’)   </li>
</ol>
<h3 id="2-1-console-group-与console-groupEnd"><a href="#2-1-console-group-与console-groupEnd" class="headerlink" title="2.1 console.group 与console.groupEnd"></a>2.1 console.group 与console.groupEnd</h3><p>如果再配合console.group 与console.groupEnd，可以将这种分类管理的思想发挥到极致。这适合于在开发一个规模很大模块很多很复杂的Web APP时，将各自的log信息分组到以各自命名空间为名称的组里面。</p>
<h3 id="2-2-第一个参数可以带一些格式化指令"><a href="#2-2-第一个参数可以带一些格式化指令" class="headerlink" title="2.2 第一个参数可以带一些格式化指令"></a>2.2 第一个参数可以带一些格式化指令</h3><p>另外，console.log家族还给我们提供了一个的API：第一个参数可以带一些格式化指令，比如%c,n;看下面这个炫酷的效果：</p>
<pre><code>console.log(&apos;%chello world&apos;, &apos;background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;&apos;);
</code></pre><p><img src="http://you img base url/https://app.yinxiang.com/shard/s67/res/bc605783-f320-41bb-abde-a89e4c93404e/0.jpg?e=1585218234&token=your qiniu access key:htuexkKYHYV2RsvrM1MDcWj3-nA=" alt="hello"><br>当然，图片也是可以的，读者可以自行尝试，修改上述代码即可。</p>
<h3 id="2-3-接收不定参数，参数间用逗号分隔"><a href="#2-3-接收不定参数，参数间用逗号分隔" class="headerlink" title="2.3 接收不定参数，参数间用逗号分隔"></a>2.3 接收不定参数，参数间用逗号分隔</h3><p>另外，console.log() 接收不定参数，参数间用逗号分隔，最终会输出会将它们以空白字符连接。</p>
<pre><code>console.log(&apos;%chello&apos;,&apos;color:red&apos;,&apos;wroe&apos;,&apos;sdf&apos;)
</code></pre><p>$PS: console.log(‘befor not %c after styled,’,’color:red’,’second not %c second not’,’background:#f0f’)<br>$PS: console.log(‘befor not %c after styled,’+’second before not %c second after styled’,’color:red’,’background:blue’,’,not styled’)<br>$PS: 如果用call，绑定了this，根据this的style，会丢失颜色<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$log=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments] <span class="comment">// args=Array.from(arguments)</span></span><br><span class="line">  <span class="keyword">var</span> isForce=args[args.length<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.isDebug&amp;&amp;isForce!==<span class="literal">true</span>) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 只在前面的命名空间定义颜色/样式；不在后面的输出定义颜色/样式，看着眼花，也没有现成的颜色</span></span><br><span class="line">  <span class="comment">// console.log.call(this,'%c '+this.name+'::',this.debug.style,...arguments) // call 之后就没有颜色了</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%c'</span>+<span class="keyword">this</span>.name+<span class="string">'::'</span>,<span class="keyword">this</span>.debug.style,...arguments)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-console-table"><a href="#3-console-table" class="headerlink" title="3 console.table"></a>3 console.table</h2><pre><code>var data = {code:200,content:[{&apos;品名&apos;: &apos;杜雷斯&apos;, &apos;数量&apos;: 4}, {&apos;品名&apos;: &apos;冈本&apos;, &apos;数量&apos;: 3}]};
console.table(data.content);
</code></pre><h2 id="4-console-assert"><a href="#4-console-assert" class="headerlink" title="4 console.assert"></a>4 console.assert</h2><pre><code>var isDebug=false;
console.assert(isDebug,&apos;开发中的log信息。。。&apos;);
</code></pre><p>当你想代码满足某些条件时才输出信息到控制台，那么你大可不必写if或者三元表达式来达到目的，cosole.assert便是这样场景下一种很好的工具，它会先对传入的表达式进行断言，只有表达式为假时才输出相应信息到控制台。</p>
<h2 id="5-console-count"><a href="#5-console-count" class="headerlink" title="5 console.count"></a>5 console.count</h2><pre><code>function fun(){
    ..
    console.count(&apos;fun被执行的次数&apos;);
}
</code></pre><h2 id="6-console-dir"><a href="#6-console-dir" class="headerlink" title="6 console.dir"></a>6 console.dir</h2><p>将DOM结点以JavaScript对象的形式输出到控制台，而console.log是直接将该DOM结点以DOM树的结构进行输出，与在元素审查时看到的结构是一致的。不同的展现形式，同样的优雅，各种体位任君选择反正就是方便与体贴。</p>
<h2 id="7-console-time-amp-console-timeEnd"><a href="#7-console-time-amp-console-timeEnd" class="headerlink" title="7 console.time &amp; console.timeEnd"></a>7 console.time &amp; console.timeEnd</h2><p>…</p>
<p>当想要查看CPU使用相关的信息时，可以使用console.profile配合 console.profileEnd来完成这个需求。<br>这一功能可以通过UI界面来完成，Chrome 开发者工具里面有个tab便是Profile。使用方法和console.time基本一样，其实time开发者工具里也有个tab就是timeline。关于console.prefile博主就不做多余的介绍了。想要做更多了解的读者可以看这里。</p>
<h2 id="8"><a href="#8" class="headerlink" title="8 $"></a>8 $</h2><pre><code>2+2//回车，再
$_+1//回车得5
</code></pre><p>上面的$_需要领悟其奥义才能使用得当，而$0~$4则代表了最近5个你选择过的DOM节点。</p>
<p>另外值得一赞的是，Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节点，多么滴熟悉。</p>
<p>剥去她伪善的外衣，其实$(selector)是原生JavaScript document.querySelector() 的封装。<br>同时另一个命令$$(selector)返回的是所有满足选择条件的元素的一个集合，是对document.querySelectorAll() 的封装。    </p>
<h2 id="9-x-path"><a href="#9-x-path" class="headerlink" title="9 $x(path)"></a>9 $x(path)</h2><p>将所匹配的节点放在一个数组里返回</p>
<pre><code>$x(&quot;//p&quot;);
$x(&quot;//p[a]&quot;);
</code></pre><p>$x(“//p”)匹配所有的p节点，$x(“//p[a]”);匹配所有子节点包含a的p节点</p>
<h2 id="0-copy"><a href="#0-copy" class="headerlink" title="0 copy"></a>0 copy</h2><p>注意：他不依附于任何全局变量比如window，所以其实在JS代码里是访问不了这个copy方法的，所以从代码层面来调用复制功能也就无从谈起。但愿有天浏览器会提供相应的JS实现吧~这样我们就可以通过js代码进行复制操作而不用再依赖Flash插件了。</p>
<h2 id="1-keys-amp-values"><a href="#1-keys-amp-values" class="headerlink" title="1 keys &amp; values"></a>1 keys &amp; values</h2><pre><code>var tfboy={name:&apos;wayou&apos;,gender:&apos;unknown&apos;,hobby:&apos;opposite to the gender&apos;};
keys(tfboy);
values(tfboy);
</code></pre><h2 id="2-monitor-amp-unmonitor"><a href="#2-monitor-amp-unmonitor" class="headerlink" title="2 monitor &amp; unmonitor"></a>2 monitor &amp; unmonitor</h2><p>monitor(function)，它接收一个函数名作为参数，比如function a，每次a被执行了，都会在控制台输出一条信息，里面包含了函数的名称a及执行时所传入的参数。而unmonitor(function)便是用来停止这一监听。</p>
<pre><code>function sayHello(name){
    alert(&apos;hello,&apos;+name);
}
monitor(sayHello);
sayHello(&apos;damonare&apos;);
sayHello(&apos;tjz&apos;);
unmonitor(sayHello);
</code></pre><h2 id="3-debug-amp-undebug"><a href="#3-debug-amp-undebug" class="headerlink" title="3 debug &amp; undebug"></a>3 debug &amp; undebug</h2><p>debug同样也是接收一个函数名作为参数。当该函数执行时自动断下来以供调试，类似于在该函数的入口处打了个断点，可以通过debugger来做到，同时也可以通过在Chrome开发者工具里找到相应源码然后手动打断点。而undebug 则是解除该断点。</p>
<p>而其他还有好些命令则让人没有说的欲望，因为好些都可以通过Chrome开发者工具的UI界面来操作并且比用在控制台输入要方便。</p>
<h1 id="B-九个Console命令，让-JS-调试更简单"><a href="#B-九个Console命令，让-JS-调试更简单" class="headerlink" title="B [九个Console命令，让 JS 调试更简单]"></a>B [九个Console命令，让 JS 调试更简单]</h1><h2 id="一-显示信息的命令"><a href="#一-显示信息的命令" class="headerlink" title="一 显示信息的命令"></a>一 显示信息的命令</h2><p>最常用的就是console.log了。</p>
<h2 id="二-占位符"><a href="#二-占位符" class="headerlink" title="二 占位符"></a>二 占位符</h2><p>console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）</p>
<pre><code>console.log(&quot;%d年%d月%d日&quot;,2011,3,26);
</code></pre><h2 id="三-信息分组"><a href="#三-信息分组" class="headerlink" title="三 信息分组"></a>三 信息分组</h2><pre><code>console.group(&quot;第一组信息&quot;);
</code></pre><p>　　console.log(“第一组第一条:我的博客(<a href="http://www.ido321.com)&quot;)" target="_blank" rel="noopener">http://www.ido321.com)&quot;)</a>;<br>　　console.log(“第一组第二条:CSDN(<a href="http://blog.csdn.net/u011043843)&quot;)" target="_blank" rel="noopener">http://blog.csdn.net/u011043843)&quot;)</a>;<br>　　console.groupEnd();</p>
<h2 id="四-查看对象的信息"><a href="#四-查看对象的信息" class="headerlink" title="四 查看对象的信息"></a>四 查看对象的信息</h2><p>console.dir()可以显示一个对象所有的属性和方法。</p>
<h2 id="五-显示某个节点的内容"><a href="#五-显示某个节点的内容" class="headerlink" title="五 显示某个节点的内容"></a>五 显示某个节点的内容</h2><p>console.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。</p>
<h2 id="六-判断变量是否是真"><a href="#六-判断变量是否是真" class="headerlink" title="六 判断变量是否是真"></a>六 判断变量是否是真</h2><p>console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。</p>
<pre><code>var result = 1;
</code></pre><p>　　console.assert(result);<br>　　var year = 2014;<br>　　console.assert(year == 2018);<br>1是非0值，是真；而第二个判断是假，在控制台显示错误信息</p>
<h2 id="七-追踪函数的调用轨迹。"><a href="#七-追踪函数的调用轨迹。" class="headerlink" title="七 追踪函数的调用轨迹。"></a>七 追踪函数的调用轨迹。</h2><p>console.trace()用来追踪函数的调用轨迹。</p>
<h2 id="八-计时功能"><a href="#八-计时功能" class="headerlink" title="八 计时功能"></a>八 计时功能</h2><p>console.time()和console.timeEnd()，用来显示代码的运行时间。</p>
<h2 id="九-console-profile-的性能分析"><a href="#九-console-profile-的性能分析" class="headerlink" title="九 console.profile()的性能分析"></a>九 console.profile()的性能分析</h2><p>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()。</p>
<pre><code>function All(){
    alert(11);
</code></pre><p>　　　　 for(vari=0;i&lt;10;i++){<br>            funcA(1000);<br>        }<br>　　　　 funcB(10000);<br>　　}</p>
<p>　　function funcA(count){<br>　　　　for(vari=0;i&lt;count;i++){}<br>　　}</p>
<p>　　function funcB(count){<br>　　　　for(vari=0;i&lt;count;i++){}<br>　　}</p>
<p>　　console.profile(‘性能分析器’);<br>　　All();<br>　　console.profileEnd();<br>输出如图：<br><img src="http://you img base url/https://app.yinxiang.com/shard/s67/res/86aa664f-6a7d-46ed-8208-e83bd771b021/0.jpg?e=1585218234&token=your qiniu access key:d36qd3e9a77ntiCA3SP_jFq1PbM=" alt="&#39;性能分析器&#39;"></p>
<h1 id="C-Chrome-开发者控制台中，你可能意想不到的功能"><a href="#C-Chrome-开发者控制台中，你可能意想不到的功能" class="headerlink" title="C [Chrome 开发者控制台中，你可能意想不到的功能]"></a>C [Chrome 开发者控制台中，你可能意想不到的功能]</h1><p>Chrome 有内置的开发者工具。它拥有丰富的特性，比如元素（Elements）、网络（Network）和安全（Security）。今天，我们主要关注一下 JavaScript 控制台。</p>
<h2 id="1-选取DOM元素"><a href="#1-选取DOM元素" class="headerlink" title="1. 选取DOM元素"></a>1. 选取DOM元素</h2><p>如果你对 jQuery 很熟悉，</p>
<h2 id="2-将你的浏览器变成编辑器"><a href="#2-将你的浏览器变成编辑器" class="headerlink" title="2. 将你的浏览器变成编辑器"></a>2. 将你的浏览器变成编辑器</h2><p>曾经多次幻想是否在浏览器里面就可以编辑文本？答案是可以的，你可以把你的浏览器变成编辑器。你可以在 DOM 中任意添加或移除文本。<br>你不再需要检查元素和编辑 HTML。相反，打开开发者控制台输入下面内容：</p>
<pre><code>document.body.contentEditable=true
</code></pre><p>这将使内容变为可编辑状态。你可以编辑 DOM 里的任何东西。</p>
<h2 id="3-查找DOM中元素关联的事件"><a href="#3-查找DOM中元素关联的事件" class="headerlink" title="3. 查找DOM中元素关联的事件"></a>3. 查找DOM中元素关联的事件</h2><p>当调试时，你肯定对 DOM 中约束元素的事件监听器感兴趣。开发者控制台让你更容易找到它们。<br>你可以做以下事情来找到特定事件的监听器：</p>
<pre><code>getEventListeners($(‘selector’)).eventName[0].listener
</code></pre><p>这将展示与特定事件相关联的监听器。eventName[0] 是一个包含所有特定事件的数组。比如：</p>
<pre><code>getEventListeners($(‘firstName’)).click[0].listener
</code></pre><p>它会展示 ID 为「firstName」元素的点击事件所关联的监听器。</p>
<h2 id="4-监控事件"><a href="#4-监控事件" class="headerlink" title="4. 监控事件"></a>4. 监控事件</h2><p>如果你想在 DOM 中特定元素绑定的事件执行时监控它们，你可以通过控制台中完成。你可以使用很多不同的命令来监控部分或全部事件：<br>monitorEvents($(‘selector’)) 能够监控你所选取元素所关联的所有事件，当事件触发时，在控制台打印它们。比如 monitorEvents($(‘#firstName’)) 会打印 ID 为「firstName」的元素绑定的所有事件。<br>monitorEvents($(‘selector’),’eventName’) 将打印元素绑定的特定事件。你可以将事件名字作为参数传入函数。它将打印特定元素绑定的特定事件。比如，monitorEvents($(‘#firstName’),’click’) 会打印 ID 为「firstName」的元素绑定的点击事件。<br>monitorEvents($(‘selector’),[‘eventName1′,’eventName3’,…]) 会根据你的要求打印多个事件。传递参数包含所有事件的字符串数组，而不是单个事件名字。比如，monitorEvents($(‘#firstName’),[‘click’,’focus’]) 会打印 ID 为「firstName」的元素绑定的点击事件和焦点事件。<br>unmonitorEvents($(‘selector’)) ：这个会停止监视和在控制台打印事件。</p>
<h2 id="5-查询代码块执行时间"><a href="#5-查询代码块执行时间" class="headerlink" title="5. 查询代码块执行时间"></a>5. 查询代码块执行时间</h2><p>JavaScript 控制台有一个名为 console.time(‘labelName’) 的重要函数，它接收一个标记名作为参数，然后开启计时器。</p>
<h2 id="6-将变量里的值排列成表格"><a href="#6-将变量里的值排列成表格" class="headerlink" title="6. 将变量里的值排列成表格"></a>6. 将变量里的值排列成表格</h2><h2 id="7-检查DOM中的元素"><a href="#7-检查DOM中的元素" class="headerlink" title="7. 检查DOM中的元素"></a>7. 检查DOM中的元素</h2><p>你可以直接在控制台中检查元素：</p>
<h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>inspect($(‘selector’)) 会检查与选择器匹配的元素，并切换 Chrome 开发者工具到元素标签页。举个例子，inspect($(‘#firstName’)) 检查 ID 为「firstName」的元素，inspect($(‘a’)[3]) 检查 DOM 中第 4 个锚点元素。</p>
<h3 id="0、-1、-2"><a href="#0、-1、-2" class="headerlink" title="$0、$1、$2"></a>$0、$1、$2</h3><p>$0、$1、$2 等等能帮助你取到最近检查的元素。比如，$0 给你返回上次检查的 DOM 元素，$1 返回上上次检查的 DOM 元素。</p>
<h2 id="8-列举元素的属性"><a href="#8-列举元素的属性" class="headerlink" title="8. 列举元素的属性"></a>8. 列举元素的属性</h2><p>你可以在控制台中做以下事情来列举一个元素的所有属性。<br>dir($(‘selector’)) 返回一个对象和与其 DOM 元素关联的所有属性。你可以展开它查看细节。</p>
<h2 id="9-检索最近一个结果的值"><a href="#9-检索最近一个结果的值" class="headerlink" title="9. 检索最近一个结果的值"></a>9. 检索最近一个结果的值</h2><p>你可以把控制台当做计算器。一旦你这么做，你可能需要在计算中使用上一次的计算结</p>
<h2 id="10-清空控制台和内存"><a href="#10-清空控制台和内存" class="headerlink" title="10. 清空控制台和内存"></a>10. 清空控制台和内存</h2><p>如果你想清空控制台和内存，只需要输入：<br>clear()</p>
<h1 id="D-前端-Console-调试小技巧"><a href="#D-前端-Console-调试小技巧" class="headerlink" title="D [前端 Console 调试小技巧]"></a>D [前端 Console 调试小技巧]</h1><!-- <https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227302&idx=1&sn=895be76d6e20903166516331a96b4ff7&chksm=bd495d228a3ed4347026223f576959acbf783765c3c28712e55795e6de64b5ac516a8c494fdf&mpshare=1&scene=1&srcid=111804ofLab5nQ14tfgYnFYT##>    
**$_YX:** <https://app.yinxiang.com/Home.action#n=df7e428e-d2f4-40d5-9d17-5fd812af17bf&s=s67&b=5c8e6202-0f88-4e04-a94d-7854d9a014e2&ses=4&sh=1&sds=5&> -->
<h2 id="一-Console"><a href="#一-Console" class="headerlink" title="一 Console"></a>一 Console</h2><p>打开 Chrome 开发者工具的方法：</p>
<ul>
<li>在主菜单中选择“更多工具”菜单 &gt; 点击开发者工具。</li>
<li>在页面任何元素上右键，选择“检查”。</li>
<li>在 Mac 中，按下 Command+Option+I；在 Windows 与 Linux 中，按下 Ctrl+Shift+I。</li>
</ul>
<p>请观察 Console 选项卡中的内容。<br>第一行：    </p>
<h3 id="清空控制台"><a href="#清空控制台" class="headerlink" title="清空控制台"></a>清空控制台</h3><h3 id="上下文（context）"><a href="#上下文（context）" class="headerlink" title="上下文（context）"></a>上下文（context）</h3><p>top — 在默认状态下，Console 的上下文（context）为 top（顶级）。不过当你检查元素或使用 Chrome 插件上下文时，它会发生变化。 你可以在此更改 console 执行的上下文（页面的顶级 frame）。</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p> 对控制台的输出进行过滤。你可以根据输出严重级别、正则表达式对其进行过滤，也可以在此隐藏网络连接产生的消息。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>Hide network — 隐藏诸如 404 之类的网络错误。<br>Preserve log — 控制台将会在页面刷新或者跳转时不清空记录。<br>Selected context only — 勾上后可以根据前面 top 选择的上下文来指定控制台的日志记录范围。<br>User messages only — 隐藏浏览器产生的访问异常之类的警告。<br>Log XMLHttpRequests — 顾名思义，记录 XMLHttpRequest 产生的信息。<br>Show timestamps — 在控制台中显示时间戳信息。<br>Autocomplete from history — Chrome 会记录你曾经输入过的命令，进行自动补全。</p>
<h2 id="二-选择合适的-Console-API"><a href="#二-选择合适的-Console-API" class="headerlink" title="二 选择合适的 Console API"></a>二 选择合适的 Console API</h2><p>控制台会在你应用的上下文中运行你输入的 JS 代码。你可以轻松地通过控制台查看全局作用域中存储的东西，也可以直接输入并查看表达式的结果。例如：“null === 0”。</p>
<h3 id="console-log-—-对象引用"><a href="#console-log-—-对象引用" class="headerlink" title="console.log — 对象引用"></a>console.log — 对象引用</h3><p>根据定义，console.log 将会在控制台中打印输出内容。除此之外，你还得知道，console.log 会对你展示的对象保持引用关系。请看下面的代码：</p>
<h3 id="console-log-—-对对象属性进行排序"><a href="#console-log-—-对对象属性进行排序" class="headerlink" title="console.log — 对对象属性进行排序"></a>console.log — 对对象属性进行排序</h3><p>Chrome 按照字母表的顺序对属性进行了排序。没法说我们是否应该喜欢这种排序方式，但了解这儿发生了什么总没坏处。</p>
<h3 id="console-assert-expression-message"><a href="#console-assert-expression-message" class="headerlink" title="console.assert(expression, message)"></a>console.assert(expression, message)</h3><p>如果 expression 表达式的结果为 false，Console.assert 将会抛出错误。关键的是，assert 函数不会由于报错而停止评估之后的代码。它可以帮助你调试冗长棘手的代码，或者找到多次迭代后函数自身产生的错误。</p>
<h3 id="console-count-label"><a href="#console-count-label" class="headerlink" title="console.count(label)"></a>console.count(label)</h3><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>我们可以决定是完全展示数据内容还是只展示整个对象的某几列。这个表格是可排序的 —— 点击需要排序的列的表头，即可按此列对表格进行排序。</p>
<h3 id="console-group-console-groupEnd"><a href="#console-group-console-groupEnd" class="headerlink" title="console.group() / console.groupEnd();"></a>console.group() / console.groupEnd();</h3><h3 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace();"></a>console.trace();</h3><p>console.trace 会将调用栈打印在控制台中。如果你正在构建库或框架时，它给出的信息将十分有用。</p>
<h3 id="对比-console-log-与-console-dir"><a href="#对比-console-log-与-console-dir" class="headerlink" title="对比 console.log 与 console.dir"></a>对比 console.log 与 console.dir</h3><p>它们的实现方式取决于浏览器。在最开始的时候，规范中建议 dir 要保持对对象的引用，而 log 不需要引用。（Log 会显示一个对象的副本）。但现在，如上图所示，log 也保持了对于对象的引用。它们展示对象的方式有所不同，但我们不再加以深究。不过 dir 在调试 HTML 对象的时候会非常有用。</p>
<blockquote>
<p>译注：console.dir 会详细打印一个对象的所有属性与方法。</p>
</blockquote>
<h3 id="0-—-4"><a href="#0-—-4" class="headerlink" title="$_, $0 — $4"></a>$_, $0 — $4</h3><p>$_ 会返回最近执行表达式的值。 $0 — $4 — 分别作为近 5 此检查元素时对 HTML 元素的引用。</p>
<h3 id="getEventListeners-object"><a href="#getEventListeners-object" class="headerlink" title="getEventListeners(object)"></a>getEventListeners(object)</h3><p>返回指定 DOM 元素上注册的事件监听器。这儿还有一种更便捷的方法来设置事件监听，下次教程会介绍它。</p>
<h3 id="monitorEvents-DOMElement-events-unmonitorEvents-DOMElement"><a href="#monitorEvents-DOMElement-events-unmonitorEvents-DOMElement" class="headerlink" title="monitorEvents(DOMElement, [events]) / unmonitorEvents(DOMElement)"></a>monitorEvents(DOMElement, [events]) / unmonitorEvents(DOMElement)</h3><p>在指定 DOM 元素上触发任何事件时，都可以在控制台中看到相关信息。直到取消对相应元素的监视。</p>
<h2 id="三-在控制台中选择元素"><a href="#三-在控制台中选择元素" class="headerlink" title="三 在控制台中选择元素"></a>三 在控制台中选择元素</h2><p>在 Element 标签中按 ESC 键展开这个界面。</p>
<p>在 $ 没有另做它用的情况下：<br>$() — 相当于 document.querySelector()。它会返回匹配 CSS 选择器的第一个元素（例如 $(‘span’) 会返回第一个 span） $$() — 相当于 document.querySelectorAll()。它会以数组的形式返回所有匹配 CSS 选择器的元素。</p>
<h3 id="复制打印的数据"><a href="#复制打印的数据" class="headerlink" title="复制打印的数据"></a>复制打印的数据</h3><p>在打印出的对象上点击右键，选择 copy（复制），或选择 Store as global element（将指定元素的引用存储在全局作用域中）</p>
<h3 id="自定义控制台输出样式"><a href="#自定义控制台输出样式" class="headerlink" title="自定义控制台输出样式"></a>自定义控制台输出样式</h3><p>%d 或 %i — 整型值<br>%f — 浮点值<br>%o — 可展开的 DOM 元素<br>%O — 可展开的 JS 对象<br>%c — 使用 CSS 格式化输出</p>
<p># [14 个你可能不知道的 JavaScript 调试技巧]</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js 复制内容到剪贴板</title>
    <url>/sum/js/js%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF(007)/</url>
    <content><![CDATA[<a id="more"></a>
<!-- # Z 实际 -->
<!-- 以下两篇总结的还不错。自己做的时候，用的clipboard.js，直接借鉴已有的代码，表示很简单。   -->
<p>A：安全，execCommand，选中；<br>B: 库的使用不是很明白（没有用过）；使用过程中的坑，不错。<br>C: 还有禁止复制的时候;包括反复制。  </p>
<p style="text-align:right">2018.4.15 10:15 星期日</p>


<p># A [如何用20行JS代码实现粘贴板功能]</p>
<h2 id="一-关于剪贴板的安全"><a href="#一-关于剪贴板的安全" class="headerlink" title="一 关于剪贴板的安全"></a>一 关于剪贴板的安全</h2><p>几年前，浏览器不可能直接使用剪贴板。开发人员不得不通过Flash来实现。</p>
<p>剪贴板看起来无关紧要，但想象一下，如果浏览器能够随意查看和操作内容，会发生什么。JS脚本（包括第三方脚本）能查看剪贴板内的文本信息，并将密码，敏感信息甚至整个文档发送到远程服务器。</p>
<p>现在的剪贴板基本功能有限，有如下限制：</p>
<ol>
<li>大多数浏览器支持剪贴板，除了Safari。(译注，Safari其实已经支持)</li>
<li>支持因浏览器而异，有些功能不完整或有问题。</li>
<li>事件必须由用户必须发起，如点击鼠标或按下键盘。脚本不能自由访问剪贴板。</li>
</ol>
<h2 id="二-document-execCommand"><a href="#二-document-execCommand" class="headerlink" title="二 document.execCommand"></a>二 document.execCommand</h2><p>此方法就是实现剪贴板的关键，它可以传入cut,copy,paste三种参数。从最常用的document.execCommand（’copy’）开始介绍。</p>
<p>$_[JavaScript 复制内容到剪贴板]  </p>
<blockquote>
<p>bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)<br>方法返回一个 Boolean 值，表示操作是否成功。<br>aCommandName ：表示命令名称，比如： copy, cut 等（更多命令见命令）；<br>aShowDefaultUI：是否展示用户界面，一般情况下都是 false；<br>aValueArgument：有些命令需要额外的参数，一般用不到；</p>
</blockquote>
<p>### 1 是否支持<br>在使用之前，我们应该检查浏览器是否支持copy命令:<code>document.queryCommandSupported(&#39;copy&#39;)</code>;或<code>document.queryCommandEnabled(&#39;copy&#39;)</code>;，这两个方法效果相同。</p>
<p>但在Chrome下，尽管Chrome确实支持使用copy命名,但两个方法都返回false。所以最好是将检查代码包在一个try-catch代码块中。</p>
<p>### 2 突出显示文本<br>下一步，我们应该允许用户复制什么呢？必须突出显示文本，所有浏览器都可用select()方法选择文本input和textarea内的文本。同时Firefox和Chrome / Opera也支持document.createRange方法，该方法允许从任何元素中选择文本，如下：</p>
<pre><code>// select text in #myelement node
var myelement = document.getElementById(&apos;#myelement&apos;),
range = document.createRange();

range.selectNode(myelement);
window.getSelection().addRange(range);
</code></pre><p>但IE / Edge不支持。</p>
<h2 id="三-clipboard-js"><a href="#三-clipboard-js" class="headerlink" title="三 clipboard.js"></a>三 clipboard.js</h2><p>若你不想自己实现一个较为健壮的跨浏览器剪贴板方法的话，clipboard.js可以帮你。它有好几种设置选项的方式，如H5的data属性，设置绑定触发元素以及目标元素，如：</p>
<pre><code>&lt;input id=&quot;copyme&quot; value=&quot;text in this field will be copied&quot; /&gt;
&lt;button data-clipboard-target=&quot;#copyme&quot;&gt;copy&lt;/button&gt;
</code></pre><h2 id="四-自己动手实现"><a href="#四-自己动手实现" class="headerlink" title="四 自己动手实现"></a>四 自己动手实现</h2><p>clipboard.js大小仅2Kb，若仅实现如下的部分功能的话，那么可以在20行的代码内实现：</p>
<ol>
<li>仅部分表单元素可被复制</li>
<li>若在不支持的浏览器中（没错，就是指Safari）(译注，Safari其实已经支持)，可突出显示选中文本，并提示用户按Ctrl / Cmd + C。<br>像clipboard.js一样，先创建一个button用于触发方法，它具有一个data属性data-copytarget，指向要copy的元素(即#website)</li>
</ol>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;website&quot; value=&quot;http://www.sitepoint.com/&quot; /&gt;
&lt;button data-copytarget=&quot;#website&quot;&gt;copy&lt;/button&gt;
</code></pre><p>一个立即执行函数表达式绑定click事件的函数，该函数用于解析data-copytarget属性内容，选择对应字段的文本并执行document.execCommand(‘copy’)。若失败，文本保持选中状态，显示提示框：</p>
<pre><code>(function() {
    &apos;use strict&apos;;
    // click events
    document.body.addEventListener(&apos;click&apos;, copy, true);
    // event handler
    function copy(e) {
        // find target element
        var
            t = e.target,
            c = t.dataset.copytarget,
            inp = (c ? document.querySelector(c) : null);

        // is element selectable?
        if (inp &amp;&amp; inp.select) {
            // select text
            inp.select();
            try {
                // copy text
                document.execCommand(&apos;copy&apos;);
                inp.blur();
            }
            catch (err) {
                alert(&apos;please press Ctrl/Cmd+C to copy&apos;);
            }
        }
    }
})();
</code></pre><p>示例：虽然在上例中，算上样式和动画的代码，代码已经超过20行了，但动画和样式是可选的。</p>
<p>总结：</p>
<ol>
<li>通过.select()选择要复制的表单元素的内容</li>
<li>调用document.execCommand(“copy”)方法</li>
<li>调用.blur()方法，从表单元素中移除焦点</li>
<li>将第2、3步包在try catch块中，在不支持的浏览器下则提示</li>
</ol>
<h2 id="五-其他方式"><a href="#五-其他方式" class="headerlink" title="五 其他方式"></a>五 其他方式</h2><p>有很多新颖的剪贴板应用方式。例如Trello.com,将鼠标悬停在卡片上时，可以按Ctrl / Cmd + C 并将该卡片的链接地址复制到剪贴板。其背后实现的方式为：先创建一个包含URL的隐藏表单元素，然后选中并复制其内容。非常巧妙且实用 —— 我怀疑很少有用户知道这个功能！</p>
<p># B [JavaScript 复制内容到剪贴板]</p>
<h2 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h2><p>#### 其它地方复制<br>有的时候页面上并没有 <code>&lt;input&gt;</code> 标签，我们可能需要从一个 <code>&lt;div&gt;</code> 中复制内容，或者直接复制变量。 </p>
<p>还记得在 <code>execCommand()</code> 方法的定义中提到，它只能操作<strong>可编辑区域</strong>，也就是意味着除了 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 这样的输入域以外，是无法使用这个方法的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点我复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,() =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(input);</span><br><span class="line"> 	input.setAttribute(<span class="string">'value'</span>, <span class="string">'听说你想复制我'</span>);</span><br><span class="line">	input.select();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)) &#123;</span><br><span class="line">		<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'复制成功'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(input);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>算是曲线救国成功了吧。在使用这个方法时，遇到了几个坑。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>在Chrome下调试的时候，这个方法时完美运行的。然后到了移动端调试的时候，坑就出来了。<br>对，没错，就是你，ios。。。</p>
<ol>
<li><p>点击复制时屏幕下方会出现白屏抖动，仔细看是拉起键盘又瞬间收起<br>知道了抖动是由于什么产生的就比较好解决了。既然是拉起键盘，那就是聚焦到了输入域，那只要让输入域不可输入就好了，在代码中添加 <code>input.setAttribute(&#39;readonly&#39;, &#39;readonly&#39;);</code> 使这个 <code>&lt;input&gt;</code> 是只读的，就不会拉起键盘了。</p>
</li>
<li><p>无法复制<br>这个问题是由于 <code>input.select()</code> 在ios下并没有选中全部内容，我们需要使用另一个方法来选中内容，这个方法就是 <code>input.setSelectionRange(0, input.value.length);</code>。</p>
</li>
</ol>
<p>完整代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,() =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">    input.setAttribute(<span class="string">'readonly'</span>, <span class="string">'readonly'</span>);</span><br><span class="line">    input.setAttribute(<span class="string">'value'</span>, <span class="string">'hello world'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(input);</span><br><span class="line">	input.setSelectionRange(<span class="number">0</span>, <span class="number">9999</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)) &#123;</span><br><span class="line">		<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'复制成功'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(input);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">10：32</p>

<p># C [网页内容不能选中复制的解决方法大全]</p>
<p style="text-align:right">2018.4.16 21:22 星期一</p>

<p>防复制大全及破解办法<br><strong>$_PS:</strong> 原文就不可以正常复制</p>
<h2 id="第一部分：防止你的网站博客文章被非法复制保存或者查看的-部分源代码"><a href="#第一部分：防止你的网站博客文章被非法复制保存或者查看的-部分源代码" class="headerlink" title="第一部分：防止你的网站博客文章被非法复制保存或者查看的 部分源代码"></a>第一部分：防止你的网站博客文章被非法复制保存或者查看的 部分源代码</h2><ol>
<li><p>页面中加入如下语句，则网页将不能被保存，让网页无法 另存为：<br>在<code>&lt;body&gt;......&lt;/body&gt;</code>之间加入 <code>&lt;noscript&gt;&lt;iframe src=*&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code><br>加入上述代码后，当执行“另存为”命令时，会弹出“保存网页时出错”的对话框。</p>
</li>
<li><p>列代码放到<code>&lt;body&gt;&lt;/body&gt;</code>或者<code>&lt;head&gt;&lt;/head&gt;</code>之间，提示禁止使用右键。</p>
<pre><code>&lt;script LANGUAGE=&quot;JavaScript&quot;&gt;
    function click() { if (event.button==2){alert(&apos;你好,右键已被禁止使用&apos;); } } 
    document.onmousedown=click
&lt;/script&gt;
</code></pre></li>
<li><p>为了防止别人偷窃自己网站上的东西，运用CSS代码控制右键的复制或另存为。可以在网页制作的过程中加入以下代码：</p>
<ol>
<li>忽视右键 <code>&lt;body oncontextmenu=\&quot;return false\&quot;&gt;</code> </li>
<li>让你的网页无法另存为 <code>&lt;noscript&gt;&lt;iframe src=*&gt;&lt;/iframe&gt;&lt;/noscript&gt;</code></li>
</ol>
</li>
<li><p>彻底禁止右键快捷菜单的出现呢？代码如下：</p>
<pre><code>&lt; Script Language=javascript&gt;
    function Click(){
        alert(&apos;版权所有(C)2008 飞龙在天e000);
        window.event.returnValue=false;
    }
    document.oncontextmenu=Click;
&lt; /Script&gt;
</code></pre></li>
<li><p>一段非常简单的JS程序，这段程序应该放在主页的<code>&lt;body&gt;&lt;/body&gt;</code>中间，可以禁止察看源代码。</p>
<pre><code>&lt;SCRIPT language=javascript&gt;
    function click() {if (event.button==2) {alert(&apos;不许你偷看！&apos;);}}document.onmousedown=click
&lt;/SCRIPT&gt;
</code></pre></li>
</ol>
<h2 id="第二部分：反复制粘贴的破解办法集锦"><a href="#第二部分：反复制粘贴的破解办法集锦" class="headerlink" title="第二部分：反复制粘贴的破解办法集锦"></a>第二部分：反复制粘贴的破解办法集锦</h2><p><strong>$_PS:</strong> 都是正常流程；并不能真正完全禁止</p>
<p>1，点击工具-INTERNET选项-安全设置。把它设置为高，点确定，再刷新下网页就可复制了。不过复制了后改回原来的，不然会影响正常上网。也可以点击IE菜单栏上的”文件”-&gt;发送-&gt;电子邮件页面(跟这向导说的去做就可以拉,一路点击’下一步”)然后就可以在弹出的邮件窗口中复制你要的内容就可以了。安全级别最高的时候，一切控件和脚本均不能运行，再厉害的网页限制手段统统全部作废。</p>
<p>2，用文件菜单里的另存为</p>
<p>3，查看-源文件。</p>
<p>4，换个浏览器如GreenBrowser，如MYIE，它有一个解除右键设置的选项，你可以试试;….浏览器插件</p>
<p>5， 在页面中点击右键，当出现警告窗口时，左手按键盘上的“CTRL+F4”键关闭提示窗口（以上的方法适用于仅禁用而没有隐藏右键菜单的网页）。</p>
<p>balabala …..</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习态度</title>
    <url>/sum/others/%E5%AD%A6%E4%B9%A0%E6%80%81%E5%BA%A6/</url>
    <content><![CDATA[<p>技术快速更新的时候<br>最基础的知识一定要做到professional</p>
<p style="text-align:right">2018.3.21 星期三 07:50 </p>

<a id="more"></a>
<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-主要资源-学习路径"><a href="#一-主要资源-学习路径" class="headerlink" title="一 主要资源/学习路径"></a>一 主要资源/学习路径</h2><h3 id="1-1-w3"><a href="#1-1-w3" class="headerlink" title="1.1 w3"></a>1.1 w3</h3><p>一些流行的库/框架 官网都有文档/API<br>看几遍+实际 基本上可以理清一些思路<br>有问题，转 Github:Issues(mediasoup转了一次 google+)</p>
<h4 id="1-补充说明"><a href="#1-补充说明" class="headerlink" title="1 补充说明"></a>1 补充说明</h4><ol>
<li>可能会有不同的版本，或者不是最新的。<br>比如：angular.js的不同版本；angular最新版；video.js文档没有及时更新</li>
<li>有些可能没有中文文档，如：video.js<br>有些可以找到个人/组织的中文翻译文档，多是Gitbook，简书较为简单<br>比如：webpack的个人使用总结（官方有中文文档）；gitbook使用</li>
<li>即使是w3，中/英文 之间也有差异，还有tw<br>比如：Hexo:list_categories()</li>
<li>即使w3看明白了，参考一些个人使用总结，也是没有坏处的<br>比如：webpack和NexT 集体的用法/插件/优化</li>
</ol>
<h4 id="2-推荐w3"><a href="#2-推荐w3" class="headerlink" title="2 推荐w3"></a>2 推荐w3</h4><p>MDN 最佳/首选 ，权威/全面，还有polyfill；中/英版<br>w3school，runoob等次之</p>
<h4 id="3-lists-AFN"><a href="#3-lists-AFN" class="headerlink" title="3 lists AFN"></a>3 lists AFN</h4><ol>
<li>细<br>+：video.js,socket.io中文,codelabs:webrtc-web,webpack(V3.*),Hexo,NexT ,bootstrap(V3)<br>-：debug,iScroll,<br>0：vue.js (V2,很久了，没有实际)</li>
<li>略<br>swagger,express,pm2</li>
<li>查<br>dashjs,angular.js(V1.3.15)</li>
<li>知识点<br>MDN: canvas,webRTC相关,<br>fullscreenAPI</li>
</ol>
<h3 id="1-2-pdf"><a href="#1-2-pdf" class="headerlink" title="1.2 pdf"></a>1.2 pdf</h3><p>系统/全面学习某一个语言，书籍 是最好的<br>cause:“尽信书”<br>上文提到的 推荐w3 教材/API 非系统学习</p>
<h4 id="lists-AFN"><a href="#lists-AFN" class="headerlink" title="lists  AFN"></a>lists  AFN</h4><p>html，css，js，jquery，react,ES6(V2-ruan)<br>《sql必知必会》  </p>
<h3 id="1-3-google和社区"><a href="#1-3-google和社区" class="headerlink" title="1.3 google和社区"></a>1.3 google和社区</h3><p>余下仍有问题，google（google和baidu资源不一样）   </p>
<h4 id="社区："><a href="#社区：" class="headerlink" title="社区："></a>社区：</h4><table>
<thead>
<tr>
<th>选择</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>github issues:</td>
<td>正宗，检索没有社区方便；难题还得github issues</td>
</tr>
<tr>
<td>segmentfault：</td>
<td>多人解答，面向程序coder;还有英文版  </td>
</tr>
<tr>
<td>掘金：</td>
<td>也是coder；还有翻译</td>
</tr>
<tr>
<td>CSDN：</td>
<td>可用性强；老的社区  </td>
</tr>
<tr>
<td>简书：</td>
<td>小白教程，也有参考价值  </td>
</tr>
<tr>
<td>Google+：</td>
<td>mediasoup遇到过  </td>
</tr>
<tr>
<td>个人博客：</td>
<td>有些属于社区（CSDN,伯乐在线，），还有是个人搭建（Hexo等）  </td>
</tr>
<tr>
<td>facebook/twitter等国外网站</td>
<td>没有浏览过  （Hexo w3还提供了youtube的教程） </td>
</tr>
<tr>
<td>其他圈子：</td>
<td>比如QQ群    </td>
</tr>
<tr>
<td>知识拓展：</td>
<td>公众号，听说（听别人说）  </td>
</tr>
<tr>
<td>闲暇：</td>
<td>weibo，朋友圈等  </td>
</tr>
</tbody>
</table>
<p>收藏了一些，需消化/吸收/整理</p>
<h2 id="二-其它比较-video"><a href="#二-其它比较-video" class="headerlink" title="二 其它比较(video)"></a>二 其它比较(video)</h2><p>没有看video的偏好<br>时间较长，没有w3/pdf产出高，<br>基本教程pdf/w3 是最权威/全面的  </p>
<p>video “老师”带纯小白还能凑合，可以听到一些其他方面的知识<br>video 练项目可以，耗时（可以倍速/回看），<strong>注意总结/思考</strong></p>
<p>大会的video可以看，提升bigger(长见识)</p>
<h3 id="lists"><a href="#lists" class="headerlink" title="lists"></a>lists</h3><p>vue2：ele, 还有之前的一大堆教程(dongli,beifeng,tarena等，腾讯/网易云课堂看的不多)<br><strong>$_TODO:</strong> react native    </p>
<h2 id="三-不推荐"><a href="#三-不推荐" class="headerlink" title="三 不推荐"></a>三 不推荐</h2><p>如果是专业的，都不喜欢直接问别人，baidu一堆<br>基础问题/表达不清 </p>
<h2 id="四-最后"><a href="#四-最后" class="headerlink" title="四 最后"></a>四 最后</h2><p><strong>实际出真知</strong><br><strong>反复看</strong>，书读百遍其义自见      </p>
<p>对撸教程只是入门，包括对撸video项目；<br>只有在项目中，自己去撸代码，才会接触到问题，去解决问题；才能加深认识/理解   </p>
<p>目前，看源码不能说看不懂（几行代码还是可以看懂的）；<br>但是，整个框架怎么一步一步搭建的/整体构思 很关键</p>
<p><strong>总结</strong>帮助掌握知识（PS:md文件有点shuang），建筑知识体系<br>可以去写博客/拾人牙慧     </p>
<p style="text-align:right">3.21 10:20 </p>



<h1 id="A-更快学习-JS-的-6-个简单思维技巧"><a href="#A-更快学习-JS-的-6-个简单思维技巧" class="headerlink" title="A [更快学习 JS 的 6 个简单思维技巧]"></a>A [更快学习 JS 的 6 个简单思维技巧]</h1><!-- [*$_WX:**](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552430&idx=1&sn=cb080d60f7f3e515ef9d179546a5bef9&chksm=8025ad6fb752247978afbbd052dccd753ce87af1fd66806b6463bd08533d9cbfeca040f17983&mpshare=1&scene=1&srcid=0807KEOsuWUklb5EPAKSySfy#)    -->
<!-- [*$_YX:**](https://app.yinxiang.com/Home.action#n=124e0b06-6d9a-4d50-82d0-ec0ff85c8eb1&s=s67&b=67835be7-0476-470a-9448-0eb7e8f8a6e4&ses=4&sh=1&sds=5&) -->
<ol>
<li>不要让将来的决定阻止你进步</li>
<li>不要让自信把你骗进遗忘陷阱</li>
<li>用正确的心态进行实战练习</li>
<li>用Facebook的窍门找时间编程</li>
<li>思考地越慢，学地越快</li>
<li>先用简单语言编写复杂代码<br>结论<br>我们已经了解了快速学习 JavaScript 的几个方法，你也可以运用这些技巧去学习其他的技能。下面概括一下我们讲的内容：  </li>
</ol>
<ul>
<li>不要担心将来的决定，要潜心学习。</li>
<li>用对待玩具的心态对待新技能会让练习更加有趣。</li>
<li>就像玩 Facebook , YouTube 或者 Wikipedia 那样，用小目标的方法找时间编程。</li>
<li>慢下来，步子小一点，你会学的更快。</li>
</ul>
<h1 id="C-其它"><a href="#C-其它" class="headerlink" title="C 其它"></a>C 其它</h1><p>职业规划：一大堆</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>win+R运行程序</title>
    <url>/sum/os/win+R%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>win + R 可以运行的一些程序</p>
<a id="more"></a>
<h2 id="win-r"><a href="#win-r" class="headerlink" title="win+r"></a>win+r</h2><h3 id="1-ipconfig-（-all）"><a href="#1-ipconfig-（-all）" class="headerlink" title="1 ipconfig （-all）"></a>1 ipconfig （-all）</h3><p>命令行显示信息后，立马消失了     </p>
<h3 id="2-cmd-命令行工具"><a href="#2-cmd-命令行工具" class="headerlink" title="2 cmd  命令行工具"></a>2 cmd  命令行工具</h3><h3 id="3-regedit-注册表"><a href="#3-regedit-注册表" class="headerlink" title="3 regedit  注册表"></a>3 regedit  注册表</h3><h3 id="4-services-msc-服务"><a href="#4-services-msc-服务" class="headerlink" title="4 services.msc 服务"></a>4 services.msc 服务</h3><h3 id="4-msconfig-系统配置-5-tab"><a href="#4-msconfig-系统配置-5-tab" class="headerlink" title="4 msconfig  系统配置 5 tab"></a>4 msconfig  系统配置 5 tab</h3><ol>
<li><p>常规：启动选择：正常，诊断，有选择</p>
</li>
<li><p>引导：应该是开机引导吧，包括os的，等的</p>
</li>
<li>服务：服务</li>
<li>启动：启动项目（开机吧）</li>
<li>工具：下面有选中的命令，可以启动，包括：<br> 系统属性，internet选项，internet协议配置，性能监视器，资源监视器，任务管理器，命令提示符，注册表编辑器  <h3 id="5-mstsc-远程连接"><a href="#5-mstsc-远程连接" class="headerlink" title="5 mstsc 远程连接"></a>5 mstsc 远程连接</h3>抢远程权限：1.启动任务管理器查看用户标识(数字1，2，。。)<br>2.启动命令行(cmd)：tscon 用户标识<br>也可以在任务管理器界面直接右键连接              </li>
</ol>
<h3 id="3-control-userpasswords2-control-control-panel"><a href="#3-control-userpasswords2-control-control-panel" class="headerlink" title="-3 control userpasswords2/ control == control panel"></a>-3 control userpasswords2/ control == control panel</h3><p>用户账户&gt;用户|高级<br>$ control: 控制面板     </p>
<h3 id="2-192-168-1-81"><a href="#2-192-168-1-81" class="headerlink" title="-2 \192.168.1.81"></a>-2 \192.168.1.81</h3><h3 id="1-calc-exe-notepad-mspaint"><a href="#1-calc-exe-notepad-mspaint" class="headerlink" title="-1 calc.exe,notepad,mspaint"></a>-1 calc.exe,notepad,mspaint</h3><h2 id="cmd命令"><a href="#cmd命令" class="headerlink" title="cmd命令"></a>cmd命令</h2><h3 id="1-ipconfig-all-或者-ipconfig-all"><a href="#1-ipconfig-all-或者-ipconfig-all" class="headerlink" title="1 ipconfig [-all]或者 ipconfig [\all]"></a>1 ipconfig [-all]或者 ipconfig [\all]</h3><h3 id="2-ping"><a href="#2-ping" class="headerlink" title="2 ping"></a>2 ping</h3><p>ping 192.168.1.149<br>ping baidu.com<br># 0401&gt;0239-G<br>ICMP协议是“Internet Control Message Ptotocol”（因特网控制消息协议）的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>ping (Packet Internet Groper)，因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP；回声请求消息给目的地并报告是否收到所希望的ICMP echo （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令     </p>
<p>ping命令通常用来作为网络可用性的检查。ping命令可以对一个网络地址发送测试数据包，看该网络地址是否有响应并统计响应时间，以此测试网络。<br>ping和ICMP的关系：ping命令发送数据使用的是ICMP协议。<br><!-- ping的原理： --></p>
<h3 id="3-netstat"><a href="#3-netstat" class="headerlink" title="3 netstat"></a>3 netstat</h3><p>netstat -auto<br># 0401&gt;0239-G<br>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。<br>netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。 [1]  使用时如果不带参数，netstat显示活动的 TCP 连接。     </p>
<p>常见参数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a (all)显示所有选项，默认不显示LISTEN相关</span><br><span class="line">-t (tcp)仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-l 仅列出有在 Listen (监听) 的服務状态</span><br><span class="line"></span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">-r 显示路由信息，路由表</span><br><span class="line">-e 显示扩展信息，例如uid等</span><br><span class="line">-s 按各个协议进行统计</span><br><span class="line">-c 每隔一个固定时间，执行该netstat命令。</span><br><span class="line"></span><br><span class="line">提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到</span><br></pre></td></tr></table></figure></p>
<h2 id="查看win10-激活信息"><a href="#查看win10-激活信息" class="headerlink" title="查看win10 激活信息"></a>查看win10 激活信息</h2><p># 查看win10 激活信息<br>查看win10激活密钥需要通过注册表，具体操作步骤：<br>1、打开注册表，依次定位：HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/SoftwareProtectionPlatform。<br>2、选择右侧的“BackupProductKeyDefault”键值，后面的25位字符就是Win10激活密钥。</p>
<p>1、键盘win+R 运行输入如下命令即可查看。<br>2、Win+R===&gt;输入 slmgr.vbs -dlv 显示：：激活ID、安装ID、激活截止日期<br>3、Win+R===&gt;输入 slmgr.vbs -dli 显示：操作系统版本、部分产品密钥、许可证状态<br>4、Win+R===&gt;输入 slmgr.vbs -xpr 显示：是否彻底激活<br>5、Win+R===&gt;输入 Winver 显示：windows版本信息<br>“win+X”选命令提示符（管理员）， 输入sfc /scannow 修复一下系统。如果是伪激活，重启后会显示未激活。</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>开机自启动</title>
    <url>/sum/os/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p style="text-align:right">2018.3.20 星期二 8:48</p>

<p>把chrome添加到开机自启动。<br>禁止可以在资源管理器-&gt;启动中禁止，再次启动。</p>
<a id="more"></a>
<h1 id="A-Windows手动添加开机启动项"><a href="#A-Windows手动添加开机启动项" class="headerlink" title="A Windows手动添加开机启动项"></a>A Windows手动添加开机启动项</h1><p>2011年09月14日 22:43:36 标签：windows /microsoft /menu /user /c </p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1."></a>方法1.</h2><p>添加程序完整路径到注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run下<br>或者添加到HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run下</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2."></a>方法2.</h2><p>将一个.lnk文件添加到C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup目录下</p>
<h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3."></a>方法3.</h2><p>使用命令行命令如以下格式（此例为添加TTPlayer.exe为开机启动项）：</p>
<p>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v TTplayerLaunch /t REG_EXPAND_SZ /d “D:\Program Files\TTPlayer\TTPlayer.exe”</p>
<p>可以将上面内容保存成.bat或.cmd文件直接双击运行。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="方法1-启动项对应的目录是系统目录"><a href="#方法1-启动项对应的目录是系统目录" class="headerlink" title="方法1 启动项对应的目录是系统目录"></a>方法1 启动项对应的目录是系统目录</h2><p>把第2步应用程序快捷方式剪切（或者复制）并粘贴到<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 目录中</p>
<h2 id="方法2-启动项对应的目录是个人目录"><a href="#方法2-启动项对应的目录是个人目录" class="headerlink" title="方法2 启动项对应的目录是个人目录"></a>方法2 启动项对应的目录是个人目录</h2><p>在打开的运行窗口中输入命令shell:startup，然后点击确定按钮<br>这时就可以打开Windows10系统的启动项目文件夹，把要添加的程序快捷方式拖到该文件夹下就可以了。</p>
<h1 id="z-实际"><a href="#z-实际" class="headerlink" title="z 实际"></a>z 实际</h1><p>chrome: 在注册表项 添加字符串</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>常用快捷键</title>
    <url>/sum/os/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>win+e, win+b, win+x<br>win+d,win+r，winl,<br>a+t/a+s+t,c+t/c+s+t,win+t,<br>c+w,a+F4,<br>win+down,a+backspace,<br>doc+v+d,    </p>
<p>win+r-&gt;cmd,   s+鼠标右键/bash 鼠标右键<br>拖动文件过程中同时按住 shift/ctrl:移动/复制<br>右键点击删除的同时按住shift：永久删除<br>资源管理器 地址栏中直接输入文件的路径，会用默认的程序打开文件。比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\dev\git\bin\client\Release\config\version.ini    </span><br><span class="line">C:\dev\git\loadbuild\build.bat    </span><br><span class="line">\\192.168.1.6\Loads\yalhu\hello.xml</span><br></pre></td></tr></table></figure></p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><!-- [Chrome 键盘快捷键](https://support.google.com/chrome/answer/157179?hl=zh-Hans) --->
<p>c+w/c+F4/a+F4,c+s+t,c+num<br>c+num,F6/c+l/a+d,c+k/a+e,<br>c+s+j/F12,<br>c+b,c+s+o,c+s+b,<br>c+h,c+s+t,  </p>
<p>backspace/s+backspace,</p>
<p>### 插件vim</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>大段选中：光标定位在开头，按住shift+ctrl的同时，鼠标点击结束的位置<br>多个光标：按住al的同时，鼠标点击需要出现光标的位置  </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>注册表百科</title>
    <url>/sum/os/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%99%BE%E7%A7%91/</url>
    <content><![CDATA[<p>注册表的简单介绍</p>
<a id="more"></a>
<h1 id="A-注册表"><a href="#A-注册表" class="headerlink" title="A 注册表"></a>A 注册表</h1><p>（参考：维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%B3%A8%E5%86%8C%E8%A1%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B3%A8%E5%86%8C%E8%A1%A8</a>） </p>
<p>是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。</p>
<h2 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一 数据结构"></a>一 数据结构</h2><p>注册表由键（key，或称“项”）、子键（subkey，子项）和值项（value）构成。<br><strong>数据类型</strong></p>
<h2 id="二-分支结构"><a href="#二-分支结构" class="headerlink" title="二 分支结构"></a>二 分支结构</h2><p>注册表有五个一级分支，下面是这五个分支的名称及作用：  </p>
<p>HKEY_CLASSES_ROOT 存储Windows可识别的文件类型的详细列表，以及相关联的程序。<br>HKEY_CURRENT_USER  存储当前用户设置的信息。<br>HKEY_LOCAL_MACHINE    包括安装在计算机上的硬件和软件的信息。<br>HKEY_USERS    包含使用计算机的用户的信息。<br>HKEY_CURRENT_CONFIG    这个分支包含计算机当前的硬件配置信息。  </p>
<h2 id="三-存储方式"><a href="#三-存储方式" class="headerlink" title="三 存储方式"></a>三 存储方式</h2><h2 id="四-编辑"><a href="#四-编辑" class="headerlink" title="四 编辑"></a>四 编辑</h2><ol>
<li><p>注册表编辑器 regedit.exe（Windows XP及以后的操作系统）</p>
</li>
<li><p>脚本  支持VBScript和JavaScript两种脚本语言<br>某些病毒就利用这一点通过修改注册表进行传播。</p>
</li>
<li>第三方或自行编写的软件<br>访问注册表的系统功能对编程人员是开放的，因此有许多软件都有读写注册表的功能。事实上，Windows平台下开发的软件几乎都在不同程度上修改注册表，以便保存一些在程序多次运行之间需要保留的信息，以及让软件可以通过某种特定方式（例如，右键菜单）启动。也有一些软件是专门开发出来对注册表进行优化和设置的。</li>
<li>reg文件  （和ini文件是什么关系）</li>
</ol>
<h2 id="五-后面还有几项…"><a href="#五-后面还有几项…" class="headerlink" title="五 后面还有几项…"></a>五 后面还有几项…</h2><!-- $end:wiki   -->
<h1 id="B-注册表和-ini文件"><a href="#B-注册表和-ini文件" class="headerlink" title="B 注册表和 .ini文件"></a>B 注册表和 .ini文件</h1><p>(参考链接: <a href="https://zhidao.baidu.com/question/1633028.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1633028.html</a>)  </p>
<h2 id="一、注册表的由来"><a href="#一、注册表的由来" class="headerlink" title="一、注册表的由来"></a>一、注册表的由来</h2><p>PC机及其操作系统的一个特点就是允许用户按照自己的要求对计算机系统的硬件和软件进行各种各样的配置。早期的图形操作系统，如Win3.x中，对软硬件工作环境的配置是通过对扩展名为.ini的文件进行修改来完成的，但INI文件管理起来很不方便，因为每种设备或应用程序都得有自己的INI文件，并且在网络上难以实现远程访问。</p>
<p>为了克服上述这些问题，在Windows 95及其后继版本中，采用了一种叫做“注册表”的数据库来统一进行管理，将各种信息资源集中起来并存储各种配置信息。按照这一原则，Windows各版本中都采用了将应用程序和计算机系统全部配置信息容纳在一起的注册表，用来管理应用程序和文件的关联、硬件设备说明、状态属性以及各种状态信息和数据等。<br>与INI文件不同的是：</p>
<h2 id="二、使用注册表"><a href="#二、使用注册表" class="headerlink" title="二、使用注册表"></a>二、使用注册表</h2><ol>
<li>大家可以在开始菜单中的运行里输入regedit</li>
<li>也可以在DOS下输入regedit<h2 id="三、注册表根键说明"><a href="#三、注册表根键说明" class="headerlink" title="三、注册表根键说明"></a>三、注册表根键说明</h2>hkey_classes_root 包含注册的所有OLE信息和文档类型，是从 hkey_local_machine\software\classes复制的。<br>hkey_current_user 包含登录的用户配置信息，是从hkey_users\当前用户子树复制的。<br>hkey_local_machine 包含本机的配置信息。其中config子树是显示器打印机信息； enum子树是即插即用设备信息；system子树是设备驱动程序和服务参数的控制集合；software子树是应用程序专用设置。<br>hkey_users 所有登录用户信息。<br>hkey_current_config 包含常被用户改变的部分硬件软件配置，如字体设置、显示器类型、打印机设置等。是从hkey_local_machine\config复制的。<br>hkey_dyn_data 包含现在计算机内存中保存的系统信息。</li>
</ol>
<h1 id="Z-使用"><a href="#Z-使用" class="headerlink" title="Z 使用"></a>Z 使用</h1><h2 id="acuconsole-9-ini文件和注册表"><a href="#acuconsole-9-ini文件和注册表" class="headerlink" title="acuconsole 9 ini文件和注册表"></a>acuconsole 9 ini文件和注册表</h2><p><a href="/acuconsole9的ini文件和注册表">acuconsole9的ini文件和注册表</a></p>
<h2 id="右键快捷方式"><a href="#右键快捷方式" class="headerlink" title="右键快捷方式"></a>右键快捷方式</h2><p>右键快捷方式也是在hkey_classes_root，下新建项—-新建command—–添加程序地址<br>记事本、beyondCompare、haoZip、…<br><a href="http://blog.chinaunix.net/uid-24118190-id-3900445.html" target="_blank" rel="noopener">Beyond Compare3 添加到右键菜单</a><br><strong>$_YX:</strong> <a href>Beyond Compare3 添加到右键菜单</a>  </p>
<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p><a href="/sum/os/开机自启动">开机自启动</a><br>chrome、… </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>Canvas教程-MDN</title>
    <url>/w3/js/canvas%E6%95%99%E7%A8%8B-MDN/</url>
    <content><![CDATA[<p>toc and abstract.<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p>
<a id="more"></a>
<p></p><p style="text-aling:right">2018.3.12 星期一 8:24</p><p></p>
<h2 id="一-基本用法"><a href="#一-基本用法" class="headerlink" title="一 基本用法"></a>一 基本用法</h2><pre><code>var canvas = document.getElementById(&apos;canvas&apos;);
var ctx = canvas.getContext(&apos;2d&apos;);

ctx.fillStyle = &apos;green&apos;;
ctx.fillRect(10, 10, 100, 100);
</code></pre><h2 id="二-绘制形状"><a href="#二-绘制形状" class="headerlink" title="二 绘制形状"></a>二 绘制形状</h2><h3 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h3><p>在我们开始画图之前，我们需要了解一下画布栅格（canvas grid）以及坐标空间。</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><pre><code>fillRect(x, y, width, height)
strokeRect(x, y, width, height)
clearRect(x, y, width, height)
</code></pre><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。</p>
<pre><code>beginPath()
closePath()
stroke()
fill() 
</code></pre><h4 id="绘制一个三角形"><a href="#绘制一个三角形" class="headerlink" title="绘制一个三角形"></a>绘制一个三角形</h4><h4 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h4><pre><code>moveTo(x, y)
</code></pre><h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><pre><code>lineTo(x, y)
</code></pre><h4 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h4><p>绘制圆弧或者圆，我们使用arc()方法。当然可以使用arcTo()，不过这个的实现并不是那么的可靠，所以我们这里不作介绍。</p>
<pre><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)
arcTo(x1, y1, x2, y2, radius)
</code></pre><h4 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h4><pre><code>quadraticCurveTo(cp1x, cp1y, x, y)
bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
</code></pre><p>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p>
<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><pre><code>rect(x, y, width, height)
</code></pre><p>当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标。</p>
<h4 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h4><h3 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h3><ol>
<li><p>Path2D()<br>Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。</p>
<p> new Path2D();     // 空的Path对象<br> new Path2D(path); // 克隆Path对象<br> new Path2D(d);    // 从SVG建立Path对象</p>
</li>
<li>Path2D.addPath(path [, transform])​<br>添加了一条路径到当前路径（可能添加了一个变换矩阵）。</li>
</ol>
<h4 id="使用-SVG-paths"><a href="#使用-SVG-paths" class="headerlink" title="使用 SVG paths"></a>使用 SVG paths</h4><pre><code>var p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;);
</code></pre><p>这条路径将先移动到点 (M10 10) 然后再水平移动80个单位(h 80)，然后下移80个单位 (v 80)，接着左移80个单位 (h -80)，再回到起点处 (z)。</p>
<p></p><p style="text-aling:right">8:34</p><p></p>
<h2 id="三-添加样式和颜色"><a href="#三-添加样式和颜色" class="headerlink" title="三 添加样式和颜色"></a>三 添加样式和颜色</h2><h3 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h3><h3 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h3><h3 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h3><h3 id="渐变-Gradients"><a href="#渐变-Gradients" class="headerlink" title="渐变 Gradients"></a>渐变 Gradients</h3><h3 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h3><h3 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h3><h3 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h3><h2 id="四-绘制文本"><a href="#四-绘制文本" class="headerlink" title="四 绘制文本"></a>四 绘制文本</h2><h2 id="五-使用图片"><a href="#五-使用图片" class="headerlink" title="五 使用图片"></a>五 使用图片</h2><h2 id="六-变形"><a href="#六-变形" class="headerlink" title="六 变形"></a>六 变形</h2><h2 id="七-合成与裁剪"><a href="#七-合成与裁剪" class="headerlink" title="七 合成与裁剪"></a>七 合成与裁剪</h2><h2 id="八-基本动画"><a href="#八-基本动画" class="headerlink" title="八 基本动画"></a>八 基本动画</h2><h2 id="九-高级动画"><a href="#九-高级动画" class="headerlink" title="九 高级动画"></a>九 高级动画</h2><h2 id="零-像素操作"><a href="#零-像素操作" class="headerlink" title="零 像素操作"></a>零 像素操作</h2><h2 id="一-点击区域和无障碍访问"><a href="#一-点击区域和无障碍访问" class="headerlink" title="一 点击区域和无障碍访问"></a>一 点击区域和无障碍访问</h2><h2 id="二-canvas-的优化"><a href="#二-canvas-的优化" class="headerlink" title="二 canvas 的优化"></a>二 canvas 的优化</h2><h2 id="三-终极"><a href="#三-终极" class="headerlink" title="三 终极"></a>三 终极</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Angularjs权威教程</title>
    <url>/pdf/jslib/AngularJS%E6%9D%83%E5%A8%81%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>needTime<br>前十章：简单内容；后几章，还没有记录   </p>
<p style="text-align:right">2018.3.8 四 20:19 天#13</p>

<a id="more"></a>
<p>全书 35 章，由浅入深地讲解了AngularJS 的基本概念和基本功能，包括<br> 模块、作用域、控制器、表达式、指令、路由、依赖注入等，</p>
<p>后半部分深入到 AngularJS 应用开发，系统地讨论了服务器通信、事件、架构、动画、本地化、安全、缓存、移动应用等主题。<br>本书适合各个层次的 AngularJS 开发人员学习，无论是出于工作需要，还是好奇心的驱使，只要你想彻底理解 AngularJS，本书都会让你满载而归。</p>
<p>著　　　　[美] Ari Lerner<br>译　　　　赵望野　徐　飞　何鹏飞</p>
<p>人民邮电出版社出版发行　　<br>字数：760千字<br>2014年 8 月第 1 版<br>2014年 8 月北京第 1 次印刷</p>
<p>AngularJS提供了一系列健壮的功能，以及将代码隔离成模块的方法，<br>这对提高可复用性、可维护性和可测试性都是非常有益的。它的核心功能包括DOM操作、动画、<br>模板、双向数据绑定、路由、历史管理、Ajax和测试，等等。</p>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>2.3 数据绑定的最佳实践<br>由于JavaScript自身的特点，以及它在传递值和引用时的不同处理方式，<br>    通常认为，在视图中通过对象的属性而非对象本身来进行引用绑定，是Angular中的最佳实践。 </p>
<h2 id="第三章-模块"><a href="#第三章-模块" class="headerlink" title="第三章 模块"></a>第三章 模块</h2><p>3.1.2 requires（字符串数组）<br>requires包含了一个字符串变量组成的列表，每个元素都是一个模块名称，本模块依赖于这<br>些模块，依赖需要在本模块加载之前由注入器进行预加载。 </p>
<h2 id="第四章-作用域"><a href="#第四章-作用域" class="headerlink" title="第四章 作用域"></a>第四章 作用域</h2><p>应用的作用域是和应用的数据模型相关联的， 同时作用域也是表达式执行的上下文。 $scope<br>对象是定义应用业务逻辑、控制器方法和视图属性的地方。</p>
<p>$rootScope是AngularJS中最接近全局作用域的对象。在$rootScope上附加太多业<br>务逻并不是好主意，这与污染JavaScript的全局作用域是一样的。</p>
<p>angular.module(‘myApp’, [])<br>  .run(function($rootScope) {<br>    $rootScope.name = “World”;<br>}); </p>
<h2 id="第五章-控制器"><a href="#第五章-控制器" class="headerlink" title="第五章 控制器"></a>第五章 控制器</h2><p>function FirstController($scope) {<br>  $scope.message = “hello”;<br>}<br> 将控制器命名为[Name]Controller而不是[Name]Ctrl是一个最佳实践。</p>
<p>正如我们看到的那样，AngularJS会在创建作用域时调用控制器方法。<br>细心的读者会发现，我们是在全局作用域中创建的这个函数。这样做并不合适，因为会污染全局命名空间。更合理的方式是创建一个模块，然后在模块中创建控制器，</p>
<p>控制器可以将与一个独立视图相关的业务逻辑封装在一个独立的容器中。 尽可能地精简控制器是很好的做法。作为AngularJS开发者，使用依赖注入来访问服务可以实现这个目的。 </p>
<p>AngularJS同其他JavaScript框架最主要的一个区别就是，控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作。它只是视图和$scope之间的桥梁。 </p>
<h2 id="第六章-表达式"><a href="#第六章-表达式" class="headerlink" title="第六章 表达式"></a>第六章 表达式</h2><h3 id="6-1-解析-AngularJS-表达式"><a href="#6-1-解析-AngularJS-表达式" class="headerlink" title="6.1 解析 AngularJS 表达式"></a>6.1 解析 AngularJS 表达式</h3><pre><code>angular.module(&quot;myApp&quot;, []) 
.controller(&apos;MyController&apos;,  
function($scope,$parse) { 
$scope.$watch(&apos;expr&apos;, function(newVal, oldVal, scope) { 
    if (newVal !== oldVal) { 
    // 用该表达式设置parseFun 
    var parseFun = $parse(newVal); 
    // 获取经过解析后表达式的值 
    $scope.parsedValue = parseFun(scope); 
    } 
}); 
}); 
</code></pre><h3 id="6-2-插值字符串"><a href="#6-2-插值字符串" class="headerlink" title="6.2 插值字符串"></a>6.2 插值字符串</h3><pre><code>angular.module(&apos;myApp&apos;, []) 
.controller(&apos;MyController&apos;, function($scope, $interpolate) { 
    // 设置监听 
    $scope.$watch(&apos;emailBody&apos;, function(body) { 
    if (body) { 
        var template = $interpolate(body); 
        $scope.previewText =  
        template({to: $scope.to}); 
    } 
    }; 
}); 
</code></pre><p><strong>$_MORE:</strong> P42-44 自定义及注入服务<br>如果要修改这两个符号的设置，需要在创建新模块时将$interpolateProvider注入进去。<br>下面我们来创建一个服务，第14章会对服务进行深入讨论。 </p>
<h2 id="第七章-过滤器"><a href="#第七章-过滤器" class="headerlink" title="第七章 过滤器"></a>第七章 过滤器</h2><p>也可以用自定义函数进行过滤（在这个例子中函数定义在$scope上）:<br><code>{\{ [&quot;Ari&quot;,&quot;likes&quot;,&quot;to&quot;,&quot;travel&quot;] | filter:isCapitalized }}</code>   </p>
<p>isCapitalized函数的功能是根据首字母是否为大写返回true或false，具体如下所示：</p>
<pre><code>$scope.isCapitalized = function(str) { 
    return str[0] == str[0].toUpperCase(); 
}; 
</code></pre><p>我们也可以给filter过滤器传入第二个参数，用来指定预期值同实际值进行比较的方式。</p>
<pre><code>| filter:{&apos;favorite food&apos;: &apos;Pizza&apos;} }} 
</code></pre><ol start="4">
<li><code>{\{ {&#39;name&#39;: &#39;Ari&#39;, &#39;City&#39;: &#39;SanFrancisco&#39;} | json }}</code></li>
<li><code>{\{ San Francisco is very cloudy | limitTo:-6 }}</code></li>
<li><code>| orderBy:&#39;name&#39;:true }}</code> </li>
</ol>
<p><strong>$_PS:</strong> 没有` 和 \ hexo 编不过去</p>
<h3 id="7-1-自定义过滤器"><a href="#7-1-自定义过滤器" class="headerlink" title="7.1 自定义过滤器"></a>7.1 自定义过滤器</h3><pre><code>angular.module(&apos;myApp.filters&apos;, []) 
.filter(&apos;capitalize&apos;, function() { 
    return function(input) { 
        // input是我们传入的字符串 
        if (input) { 
        return input[0].toUpperCase() + input.slice(1); 
    } 
});
</code></pre><h3 id="7-2-表单验证"><a href="#7-2-表单验证" class="headerlink" title="7.2 表单验证"></a>7.2 表单验证</h3><ol start="8">
<li>自定义验证<br>在AngularJS中自定义指令是非常容易的。鉴于目前还没有介绍到指令的相关内容，第10章再深入研究如何创建自定义验证。目前先来看一下如何通过向后端服务器发送请求，并通过响应的结果来将输入字段设置为合法或不合法，以确保输入字段中的内容是唯一的。</li>
</ol>
<ol start="9">
<li><p>在表单中控制变量<br>formName.inputFieldName.$pristine/$dirty  .$valid/$invalid   .$error<br><strong>$_MORE:</strong> 实际什么时候要，自定义验证</p>
</li>
<li><p>一些有用的CSS样式<br>AngularJS处理表单时，会根据表单当前的状态添加一些CSS类（例如当前是合法的、未发生<br>变化的，等等） ，这些CSS类的命名和前面介绍的属性很相似。<br>它们包括：<br>.ng-pristine {}<br>.ng-dirty {}<br>.ng-valid {}<br>.ng-invalid {} </p>
</li>
<li><p>组合实例<br>下面开始定义表单：</p>
</li>
</ol>
<p>ngMessages(1.3+)<br>很多时候这些信息相互之间非常相似。我们可以将它们保存到模板中从而减少麻烦，而不是重新输入每个字段的错误信息。<br>有时，你可能希望为不同的字段自定义错误信息。没问题，你可以在这个指令内简单地插入一个自定义错误信息。</p>
<p>此外，甚至还可以为自定义验证创建自定义消息。可以通过修改模型的 $parsers链做到这<br>一点。 </p>
<p><strong>$_PS:</strong> 表单验证这一章，需要好好实践 验证</p>
<h2 id="第八章-指令简介"><a href="#第八章-指令简介" class="headerlink" title="第八章 指令简介"></a>第八章 指令简介</h2><h3 id="8-1-指令：自定义-HTML-元素和属性"><a href="#8-1-指令：自定义-HTML-元素和属性" class="headerlink" title="8.1 指令：自定义 HTML 元素和属性"></a>8.1 指令：自定义 HTML 元素和属性</h3><p>注意，还有其他内置指令（比如ng-include和ng-view）也会创建新的子作用域，这意味着它们在被调用时行为和ng-controller类似。我们在构造自定义指令时也可以创建新的子作用域。  </p>
<ol start="4">
<li>表达式<br>由于指令可以用属性的形式调用，我们可能会好奇如果给属性赋值会发生什么： <ul>
<li>用表达式来声明指令<br>  我们知道声明指令时既可以使用表达式，也可以不使用表达式。下面回顾一下几种合法的表达式声明：  </li>
<li>当前作用域介绍    </li>
</ul>
</li>
</ol>
<p>注意，还有其他内置指令（比如ng-include和ng-view）也会创建新的子作用域，这意味着它们在被调用时行为和ng-controller类似。我们在构造自定义指令时也可以创建新的子作用域</p>
<h3 id="8-2-向指令中传递数据"><a href="#8-2-向指令中传递数据" class="headerlink" title="8.2 向指令中传递数据"></a>8.2 向指令中传递数据</h3><p>有好几种途径可以设置指令内部作用域中属性的值。 最简单的方法就是使用由所属控制器提供的已经存在的作用域。 </p>
<p>尽管简单，共享状态会导致很多其他问题。如果控制器被移除，或者在控制器的作用域中也定义了一个叫myUrl的属性，我们就被迫要修改代码，这是成本很高且让人沮丧的事情。<br>AngularJS允许通过创建新的子作用域或者隔离作用域来解决这个常见问题。</p>
<p>目前为止，我们一直忽略了一个细节。实际上不能像上面的例子那样，在作用域对象内部直接设置someProperty属性。<br>scope: {<br>    // 这样行不通<br>    someProperty: ‘needs to be set’<br>}<br>实际上要在DOM中像之前提到过的那样，像给函数传递参数一样，通过属性来设置值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div my-directive </span><br><span class="line">    some-property=&quot;someProperty with @ binding&quot;&gt; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们在作用域对象内部把someProperty值设置为@这个绑定策略。这个绑定策略告诉AngularJS将DOM中some-property属性的值复制给新作用域对象中的someProperty属性：<br>scope: {<br>    someProperty: ‘@’<br>}<br>注意，默认情况下someProperty在DOM中的映射是some-property属性。如果我们想显式指定绑定的属性名，可以用如下方式：<br>scope: {<br>    someProperty: ‘@someAttr’<br>} </p>
<p><strong>$_MORE:</strong> P71–下一章<br>自定义指令：独立作用域需要实践，包括显示指定绑定的属性名</p>
<h2 id="第九章-内置指令"><a href="#第九章-内置指令" class="headerlink" title="第九章 内置指令"></a>第九章 内置指令</h2><p>其中一些指令重载了原生的HTML元素，比如<code>&lt;form&gt;</code>和<code>&lt;a&gt;</code>标签，当在HTML中使用标签时，并不一定能明确看出是否在使用指令。</p>
<ol start="2">
<li>ng-controller<br>由于原型继承的关系，修改父级对象中的someBareValue会同时修改子对象中的值，但反之则不行。<br>如果将模型对象的某个属性设置为字符串， 它会通过引用进行共享， 因此在子$scope中修改属性也会修改父$scope中的这个属性。下面的例子展示了正确的做法：</li>
</ol>
<p><strong>$_MORE:</strong> P80最后–该小节结束<br>实践上面两句话</p>
<p style="text-align:right">P82 22：30</p><br><p style="text-align:right">2018.3.10 六 10:02 天#13</p>


<ol start="3">
<li>ng-include </li>
</ol>
<h2 id="第十章-指令详解"><a href="#第十章-指令详解" class="headerlink" title="第十章 指令详解"></a>第十章 指令详解</h2><h3 id="10-1-指令定义"><a href="#10-1-指令定义" class="headerlink" title="10.1 指令定义"></a>10.1 指令定义</h3><ol start="2">
<li>factory_function （函数）<br>这个函数返回一个对象， 其中定义了指令的全部行为。 $compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。<br>angular.application(‘myApp’, [])<br>.directive(‘myDirective’, function() {<br> // 一个指令定义对象<br> return { <pre><code>// 通过设置项来定义指令，在这里进行覆写 
</code></pre> };<br>});<br>我们也可以返回一个函数代替对象来定义指令，但是像上面的例子一样，通过对象来定义是最佳的方式。<br>当返回一个函数时，这个函数通常被称作链接传递（postLink）函数，利用它我们可以定义指令的链接（link）功能。由于返回函数而不是对象会限制定义指令时的自由度，因此只在构造简单的指令时才比较有用。</li>
</ol>
<p>10.2.2 隔离作用域 </p>
<h3 id="10-3-绑定策略"><a href="#10-3-绑定策略" class="headerlink" title="10.3 绑定策略"></a>10.3 绑定策略</h3><h3 id="10-4-AngularJS-的生命周期"><a href="#10-4-AngularJS-的生命周期" class="headerlink" title="10.4 AngularJS 的生命周期"></a>10.4 AngularJS 的生命周期</h3><h3 id="10-5-ngModel"><a href="#10-5-ngModel" class="headerlink" title="10.5 ngModel"></a>10.5 ngModel</h3><p style="text-align:right">10:54</p><br><p style="text-align:right">2018 </p>


<h2 id="第一章-AngularJS模块加载"><a href="#第一章-AngularJS模块加载" class="headerlink" title="第一章 AngularJS模块加载"></a>第一章 AngularJS模块加载</h2><h2 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h2><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h2 id="第章"><a href="#第章" class="headerlink" title="第章"></a>第章</h2><p style="text-align:right"> </p><br><p style="text-align:right">2018 </p>


]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
      </categories>
      <tags>
        <tag>angular.js</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo+NexT的博客搭建指导</title>
    <url>/sum/others/%E5%9F%BA%E4%BA%8EHexo+NexT%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%AF%BC/</url>
    <content><![CDATA[<script src=/js/crypto-js.js></script>
<script>
function doDecrypt (pwd, onError) {
	console.log('in doDecrypt');
	const txt = document.getElementById('enc_content').innerHTML;
	let plantext;
	try {
		const bytes = CryptoJS.AES.decrypt(txt, pwd);
		var plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {
			onError(err);
		}
		return;
	}
	document.getElementById('enc_content').innerHTML = plaintext;
	document.getElementById('enc_content').style.display = 'block';
	document.getElementById('enc_passwd').style.display = 'none';
	if(typeof MathJax !== 'undefined') {
		MathJax.Hub.Queue(
			['resetEquationNumbers', MathJax.InputJax.TeX],
			['PreProcess', MathJax.Hub],
			['Reprocess', MathJax.Hub]
		);
	}
}
</script>
<div id="enc_content" style="display:none">U2FsdGVkX1/INL4yMDidlAxRAOShglKR2kH9BGkUM5VhpaFUTnzvjdNFg7OBsXMVNUU+9BzQdBP6eGrhCIj/vhuXKKSdJb7o44tBBSC67lliQdYPR/Dk1k1/RWxf87hLJfQjoYZIVq2z+4anD7KOS78OHTN3m3KTuom/6Hm3MCMbXcL/bAzuY0u/uBkH2Rmpl3MszDWAd0sJXvFYM0Y52cKtApJ5k1Q74hp+1wMv3xJEiq+wc/8jiXwYvwDsOeDXBQGpWas2nu98sZrU2v3/teB46PO7K8EZ/z25VDmeaa2KgkrSgcSnfAExuLmkWtqRRnaWAAfbbpkpwGzrxudXniwYKPsfwfcGji6lyH96R9sBrc7yHDgg3j7XJnPDT+wcjMfeSK1JhAuk41Q+HqTBgj8TQgCyC+1vaV0hZ6NVGyxCWIHB8qrTIFDWTmEzurDO/jhyujtk3xtOAOBDccpvpGh7cgDBxie7NBk7ccIsaS3nKGKQbSRcExOViEWJn/583Yr9aoCWJ9OPQ2zLZ6OEKvkMQjC5/SirQMV57vTYtYQo2fq1dyr7tQV3M5mbZ+DMO7qEODTtGc9U2eZF9qZtIkxgJ8NnMPaUqvurPBN5Z5tIU7UguImOQWSQONg7roC2ULPWvOGjnKBJdjJzn7bvcY3751wWfeyhYFJx9aBtHx9auNN2zNHDArMn7YNYDDjPdgvw2gb/3RYwcqxOACTgxed+aj1u8SenroIDs5nyeThKoRcjASxPq8eE4EwDXruF8GhbYGY8GU0mG74eHPlGxdbwDGEpQjr6wNzuBSUaviqx6S6frHCLB7Lz7t8xDi0/O7tVm1HFiPkYdtEq4gawZ83zSKW5RLyZbUyagA+Ev9WJoMlyzKspISVPlOSDQ+FllR1Fi3B8ztVQJUc7Kb6j8Qf08InRUHWQk3AENaAi08Rr3haeeLgWHRvd6EhxVVMdrY42J/J1MwqhLtB1xIsmd5hXKVreVz3DZTikV1wElOtbttbRPK0Zf3CdQN02t7zdU034Xi5WzfKY8DQEBIyCm5REIFQmx/6uA/DK2bJHvehAKJ1KQlAWFWuHQUp7aUtm2iQEgBcQ9oFPQ8wuD/co1e9EDg6oWyip7eAwlxE8ia1TOWnkMTH6slb1kzFXPKMsJouf+YbpP67AYUU5298p/NxdG/ncGvGxlZJK2xtVmpHoNqeTr7t0v+uEuhtDC8QunJcIeolc2ds6AqA4rzv+LXYxrxg41OEw0Tap3PiAA0NFIzhPxtGsVZBOPXn1X0P6TCgmKnQG9LNd9G2tOusPZ64dh8/Hn9Wb+8iE2dblEGrbKzFkfmz5tjG9NUyA8GF+QftNPFbxYh0hcDyU1mtxV+ka7txVRrpH2YyZ4egpnMepGnPPoa8Z/P/8nvjxdf8O6rbeanC9Et3+7gV21CVIFGfBMec4qwTyS3Icf12k4wFDgbM2nPcFe4FLMC4jYok+BOCf/IJtyHTpBMNjf5HWwrJabru/NkKA9kDezeLeqT/GlHOhO0TIrKufXYdb5oBF+hhJ9cBh7hFkkTtfq2Q/Tcyou+WJQAnFB/UWv3+4qb2O7UMRGNgYxNyN7p8MdedifRuEpOnP7LatvWQNulhfrmenh6+aBaiJkwSRAz3WF+Bj43OqAtiIwG8BXkGm4JdASxfCHzuTcVBySTEnuTkAfqmSxhSksSwtWECFpIR/Q/1Vxnyl0J51yI8MYVBB5s2ku4ZOSkIQ0fruo+i4yJhIS/P4EKR1HkFrMbYqd3yHSUPS+D7QyhPwGmS3yY4Os/J+CGeOvQEuhH0JvS8AnfAPCBgCx87Yx17AAP1sTBAE6wnW4SH6ILgClZ+qE+bDK3Gr0DXwQaH1RPWRp791ST1QJhf7ilGBkgW8++4Z+znXZwYBXbdRF8oRcGh9rtX0/+GX9tWoOz+qzamdsqY59Ad26F90wxU5Iy05Q21kpWjIJ4sbWs/gyP7FASx63Ljzydly8T+PjMLJk6j6SJq4i/3ouzfjtGskgPBTBhqczPAzg0RMqTrVEOOpoOtxYfCZg0ceX/gpcP4nHg+0tkLMKw2HWHx03iBowKLPaR/GvRe5XNv36d5HZgb1QpTEe3aRozFVjoTY9QWp5rz6eMOuvRHPxddrZWsELzP/iu2GZqsjvVkKzVda40UIrK9tv7TGi1JIsyYcsNCIuRLk9uQA5hDa0mj0IIC6c0SqPcuZHQFmkLVUrjP99CUOj8wicUrlLH+maEWNNbUD74URtY7mQOr+FO9k6p7oPxIHC23f3Xhn+vBcAo4nX9NjlpBrc1JwiJ7YH3mjcOwsyYr7XceeeHbJLzHXtxMw/r7gTUp+C8xbfxWBNRk5JvHnJHaSC2TG+YYqD7+fY8xMiz+qiaWRu0xGKgxWOpKkpf3EL2BcsarZ3kH8sHbi3EsraZ4HG/yyT9VOjHZl0ZyPPcVy1m293wta2RDgG9s02VSxbgacFlzOZs+4bqdeW0868hNgJwY3erBl4xZuqZPsNZA8hHLzzIuEwBJZEjzCKfbE3Po635uvPkrdbaJGXw+g82XsltYZEIqhnBueUaC26LbKyFlwAs7Jxqge9D3QInhHnTy+CqjSzJ6jFKGHINVaH2vaU0wY0i1RxqpdhpiDp6VkwKoJajVRMrZa2KGncol+t5dYPEcHAo97hg+t1kgvsvCzqDsAFJLRECDetgk3q0YGzBgY2xS5FtHp/8ha+A+gIKbseFu5n5DzIuZP5C8LFs1z9hgz/ctYNEDgy//cBhAiCwZgktFlspoFkmroWEpDQ588d2L1l3e0ZVZnQk9OSVcGR5QfUshb1QnMtqMhDWDjRu7kKDzACVXY65i4P5Cgm5O5gtg1LFIPpozMTCB2uUaGoVvsl4n+IoiqNzSTtCvAQz8JQgSKuApzSFBpHezZ4JidohwLn9klbz9D5pz2c860+dw8wV9BZg/U/1JCazJ2IPMMe5TFC3WWLIu5Llhj9+wO/DHAN4r9c6UOlLkglvUojCK4isYSSDpsI6Yz8FDpki8h1o12ASBHEChXmcfK1YwgAetXTleQ0rExI27enJw4G0hNLoAYwxOutYq9EPqx8ebnmIOhWcqF4i22W1ph0vQD362gyCIDhkV7FrH+xmb2xgIxyN4SV7+PIQd4BBoBa0K92bWGELqZL2mhQ0OKtYPUVsQdkkBOCVNqXmuha5gu2h72EtJ+qt6Fl1nPSgHLO8YRrqF5FxW/SLkOkON1CRAdy6ltV2hB2uHrG0cBPgLBsN4PogZLvr8YpX4ykC7IuMPdqY8Rmz6FH3UpxR9dEscGjFTBk+Mzpue5cG+ROiyiLUTRL6CRr7ly1FvCNRIyQYqJQrGEpQr6eUFvAK0Pjjq9G4ev3ZkKQ2C+7ROoO5+DgBFrPH9lgx9k5F3AKN/DAb8ekyI4yxHIlCx0Ik3R7nKk+PnjCRqyI4WVlg52uVV/g2EteLs6s0qhGl3u/DF3JQnFnm3P5mtp7Fzk4D+mYmSP2BocQKio3yc0pLvxGYVE6unTJ3EtWbFjSRG+HZerqMZYsaKFruGDG+yX/uWspDP/f9sLXNFgi2irGmGmExlx/Bl9w1auzezFsUUA9iC3inqaWuyqDtXg+IYaYQMXxJHyKHHA52JyGs2KK4vOWn49j+kwixWHgG/MV/Tt5GMN1/3jdOsqANXCwhTzxh2aGgmJsZBVukN3pbVM/AuFEcQBe8xPHohkld3kYakCjU7Wpsf8e6i8RDa56aQ2MR6mJWWwAoBNNULTsuRGG1CIk4TcSlyMaFGwtuLVpT+jHZBj0U87D4M1+TrY+VHa2sQZj3gM3fbX5Z8gWEeSzJNDsIp90CtKooSWkQKVQhgh9Kptyzj+yjSj7qdFforrVqRBdT48KjJcYE4wYE+hWjtnJxZjQ7XWYnNposLtQaYmtwJPTurcQeE+mfGNJv/F+6SpMEH8yDLjV00ZK5+4+0Jrqp2TIPK9bwMio+f1rn7BtjumrfR6jAQZl7Axvg6gXUqWTb9Jp0yb4Hh7pQ3vIF3zZ4IqnNv26BUOp866l1hTivIfxDuoJKcDbplhELsyc7idLnCgEfZ6cYD8CWpmtlTAc3KkmXOci39SfO1wgyayqnYKGf0B5sOnT/ZHo7vCsO8j0tSTHEd2HmEwo8WVzxecL1jvJQp3l3uAzKe6qEEoR3pNLndmpnCsmHRgj6evPpSA+U1h4fEaLFrzk5RIJF3F9Ktt6UkPwPtYXw9vcFN6so81pKfFfOFxXSNANZABMs0ZYs3rmxuYliZZwEW6aprLSUW6txahUcPXnt98tzL6T1ZpCHoOdsf7S0FW5hvaXqdYcbIPMZpcZ5NPGrvAxuzV7ElxQC5C75mnSF57uJ1XAIlTd0A0NTW43xGSuTzFqTrp3mHfHYYbB6ZLtTXeEzf9dtO1i49qyUCYamNmA8L+Qa7AdOmE6y0btccBNRwiniK6wrzj6u0095i85587lp946BsdxHgjPNDDv3kOdH5f+03fqqRQQDhMTaAGXO47o+56BJLKe/x69iBtmftPXNdDVwW8Zzb+2gvDgF6c3FQgZvyjqjicg1+CLgCyI8mS0cAshqK+5E1zwy+OvPUOSbcf/60/dSQzK1ptqA4m62HwDpR5Mvs1GR1Cg9RgquN83bV7D8f/Tm3u+VH8gF5ay9iTblw7lnly+ZN9jv0fkJBiyIyIAiSPD0yK/hqXf6GWMGlUNRfFjEKsU6RDjy/G4/4yo+duuYbTn4NF83JFPHcstsbfhsqKaGbPE2mQ2x/7W/JIBnhkiFOFMDNYatS8GQFJGhI9gcP8CSF71RWZhIFU3BOcp7eO/n7xAX7FI82cssH5uhDFNeTPwSAQOVe6GIesHZ0JnPNXx8gygzCdVRy6P/Pg+OH9Mz9u/ib5V+SCMANt514fcd/uSnhKgGbRRhk+iEsfe+l2mZKJYRr07IBY8RGw33hFFDbdQYGivA4HXN28vuDw+/6+yMcb5ixl7WiEgCNoR+tgYqnJe7rOREs2BMhpFQVm4YjWWN8A/lXWp7TLLqD/NkOvfxl/ZekZVU4pzXa/qt3LooLA8L05taOW/sXj5cPnDYUFnbUIkVdyov2QNS7fjA5I7qL8hgZQ8AvvbnG/wogQ/TAgoldlDAfZiMOvLTRf3fpOu5LmhztQ3mV2NaGTKfNIaVSQMO8Lkl3yyvamW/t38oFWRpJbmwyk5AicYYVVtz07bs4QUiIKQeBF3EgXziYwpM+7OCONloINCLw1104ghIxr3/EzGuGy2dXaoBvvZNMcaC386V4oJex8k/KH48gh0oDFkPyTYS0Vv3C1PwT2b3ckm9e70RxPoR5pHFQ8YpWYFqfriOunQhCswHwrQzWOGDx8Z8CkUQj5ZnAHQccM3gnQ8VhUl+QFVjS2AC0yLlO0ui8jVcTbOpeh0VWigDYl2yrSy6nRApOeS1OzZKXjVypW7Gr0UOo6gRH656uY6DMMrI7ApVHH01cqUYE+Gj0L+jhbFY6r45Ao22N16RO1ZTBv36OVUjtW2IXTSIhLSdzhP7pecd6FnZYIlKhSJP0uNPyi2I5aR60cU+gUeiWflSQco+lx/OisrWhcMokqJl5mwoh3UnU4zf4Xnt3lA3S5smkAu45/SkvWYrmgAmc3OKOzV1SN1uv+yRiECkzLT/J5FTyUMRx5bDvHFj2p39OjGb2+zT+jDl3dIp+ERGzbq4uJSWOdVdyw2fIBpwgQ6sDggVO7wexKoYTgieAMrTBH4ykqbUR8eiY6AonGrv5KGjGat89odzvEiSkPMdFe4lTItn0I/4k0I5ODGix1JGKpz768gPJf+sxROtmxqJdgCEEzSI6sYI2ksZAqgkmj3Kzx0Dl/BaFqjMpE/D1JgMzO75gN3yuu3Ejv2cVCupvCko6KtvYIgTIerL2KMqJsP4zF5GJte7+0wyUgJJRSV9sc0i0WbVf6tzK6gdBBq1HzYgS1tzsUek+wZb5yxhoPM/7OSJaa+dUSaoLNZyW/0qZl07S27Ih75n+hVW/mWmUR1WGSMsaebeuZf6VbY5JmGtEceO1Vodr4hT/wOnOPgl1zainUMlSyZVYINn1OaqnXBlaJ296F6vRFjm0x7K3b2p8aecoQ+HqEQ10KBOu2jG9A/MiFvQNJJhVNez2/+dKyPMznBgS4tKm2RI65RZ47ZVOx8XhvYe7jQgr0jZkX/OguEEW6GpwVjMajN6pCREPVNSuwNFC9P3RBz0LVAqDVTztSZ0Cp0aDroNw74RFdyj852KkXVHCxVriL1qoFYCbJC8vdsL97eeLxWe7I1VUXSnPDQ3h0kCbtoUqMPOojAdNwLdexo/qqieowjYpLLgX5nkb4svhyN+6+jfgx4bzFhDRYk7H1DueIfksisy3eneAxd7wiYapAe40yEbg3pC89OcSnVMwnsu6niAyNQAuRnYQzRDpqf8fEWtoZtOJF4FgA9QUWtneRktStlwLMS5KM4NQO/GNHPnzm86L7yNPn8spbeoeEB6k60r67WsFnEhXjR21k5it8Vu7restslEGzBIKK2gO/BOSdtPz7ur3UPbQhtaS8yINlK7nh9FSImZGBDM8MrwJqEJAKYQ3zrQ4hR2GMTclbk5I4WkX1702D/aa3CInFhafN6Gk5c9Yardx7Ione5/4bZG/vaHaykC1OPzs0aJXZxK16eyOpa/oYDpCkcQXJS/fVP6ypozYDRifpbkR1Pc18P//iDAQtC4sltOLj4TRH4aCehMzDC+CAh7X7LMcSWV/kmmYVJ0a5xHC5z7SdoRggJK/P2ZoTiZgJRxdZYXW5CZIKUhn1fjqEyJ0/zDMIBFLsLrEh0w3EnbNYllzEZxHVhjgzJrxLPlLgDgqMkUOv74Es1PmQDcqnrrx4dx9PNL+Bc92s9YaqTuiyq63UWDvgz1ejSj3IXZM5FZIlI35mmRMNgqe3PkyJ/wTqA6QZnuXhxpHPpY7F9CdLs1uaRIj9svmJVrl1StD9j9lLJ51CEa0xhbvYKsz67vIP2eX3fGPgLJF5TuC11Nve+vLPZRuhwfy9vwZXKIlxZkhacUZci2NrqS38/9yytakn8SJRC5DSZgRkaufBcn1gvhrf85hZl5k+0iGoEO4y5nbv2ClreTZM/CzlcZhowpdKx9vb59Y85R2lHzZzoy9IhA0Xzxm5901lipKaxRC4Rjgc+wBKA48cSP/OXUB+/eevqWrWxrqlKWg7JBVLSXlpsYe3jT6hxK8lYmhoA9S/EN8wcoOmHbxWFvIdA3q/yLhrc4OoSgSCw4/SHEFBV4sV84P6YB61fS1GH+3S/plM9/+c08QNiAS07/edBeUqea95wgUlZqSLJHrFsLzVXtXcygizGHtAP77pt+0HAU5juIZiiOhSkLXbVvlTlR1ZVtIkl5b6veghfxLIyzaHELe2F4aP0lnNkcwWJYoNbCoIMt+IwtK1SoV9eFFkLnKPNVmGBKwbEkXKTYqLVU9hJlxVTxRGn/TQhQo3t/DZxJuoODQORAqlih8YaZvK/ojQQH69SptBHNVElkosnsn31IB4QV3UfsisH9Z5hrGsKPjXY3mz08WOVLMnCaZoQ7YGRE1O9vDB9LVsP12zJ/FLU9bBbYHZg1S1jqXK7i1s/smlEjMyeWFoCSwBpDDdbixVGyxrr1mQffMTAQUbqhKht3cpSNOm3gmLPUHRmwdPNj59x4qY2SD1TDqWxv7cHXksyjh2M2KZ8uMfgqxRFBVT/TV9IARZxTqbkhhJzpYb/fRkiSG3pq88twCZhmUAFEFLIvEmVYrRm83zgSf4hnvoucJFS5h7mvbGyIu7c9q/knOK78fYG0QMWEsu0vn0nsOvO1Lh8N8KKB3KEPeZ3qnKBK3hAwMSeMQQAURktZzTFno/nrYz/mcYbhg2lGMK6+2UOzbq/GGeyHhtp4ftAJG5lRVN9c+rdUYmrV/1jl/Qwd9Zag9Gr5+0ijGd1SVOJ8UGNODpP/6UkBADLamVLcY0DnCZ1hIAseOaLjsMf7FZKl5K9dtrzteRwk3le/UW2X9Wq0v5+My2Lrax9CuRV8SimN7kuPxmydqvtU8BQAYmBVhYMkt0FxOEy768W6D+4n+QBTCzPUFKXOEbpOeJtfEVRhOjivNqPqA1u+Cp76NSgb7VnPQs0bCeWAyBau+TOBSy4pIH2ES20x5/RwjTjgDoQZEcvfMF2VHugKFk/3mdq0HFHgTf8O8XNibRPxVpQiiYZavPFzyR8CmgEZjgXwAayqU0mm/Srlh3/n7HeWwQ0/rv6bK5kBTI2yf4u/hEYCsko7UgUi2aa6aF63sSc1tyOtl9mfLKCNBjfpRwJZHaA16K5Yy6CCdVsyOJ4xGoqUbkggZVbr29HbpRg13B9H/KLlZxmGPcQb95TeCa1KDnql7gq8A+rbpnY2HOFxkIpC1bVv5ik7hdKyyBA3fpCIIooHolSIkMY3hmZalM++N0pLNvL86icWjzEWu/9tvahhYYk8rbzigY2NepCjmQIuboEQZeDl2LuSYWxbtfleVDg5qTaN0R4nAQacPt8QE+sugXQvohqSTlrWJY6PQRsfUx6u2nSy8jl1fKkSh6+ku4rNcilzJr4TO4x+yuppe8fzR6I+bLz+Liqu+Kj6SYIMkYCkG3DJiLO9pwXnB0TygyHYcykqmzIceTsJ7rqLDEgIzG8jjQ/Po3f4PdliOJOykQzzdXdY/066E5YhaDye0e7NY4kbzDOQLP0xnlhKRyyxcf2xIAbAOjjCQyQVEtCaHFqHUqmVDyCRc/JPyHMeKEr2869MgMVknfwji/S5t4KzRdmSeb/KdvVEeYlZPdnUr+zDstVmJUVtXywze6483RycMc8lPy2tMPwwEsZB7pdONE1qXwjrrGOSettQnvb7OSCgLH/mC2P7nvOAy147R+4LfXhZe7UP+5H8GTXYrfUIIsGDU38lwrEBiLS1ytR8auhI6O3iZuQAJ2q9tFinLu35bwR+cfiPTYG0xxnQVPvg+93y+BheGAOnhRAdo4cDkCWd/wEr8upvkiOE1fe4sVLCbPw7FeNOM5Pl1xHRnHPowfjXjG9kBY2UgL1SuE4NjVj/PYYkD5isdPGgFhsqtd7SVwMVs7wWIb7A3BlU3xhPSdL9hW2zLK7xCmeAohJeKBHBTTKTXqJueXSWXI0ZzlqCah2/bMAhjVmJd+tWXioAZO9Jl45hFAs1xjHS+74HgvOpf+dI0rYTS2G4U5qzyGxF3+3o7R78xXA6VMcquikVIxvmUDkz1PVjqZfyVlPRN88u6A5gsaOxYKpa32n3hqCyUkdIZCTb793VQxi370zHiJrt6NzN3lagW9Urem5Jwj5DFWZXoFFKfovC2udRD2im/4wDls6bjH/1jDeGgso57ma7sRiV19JKxspXvsDPOJqvBQxH06nPGJLaB1c4t8GBe2dpU6st0rxC3WBynI2pS6aYavxdJNEZYEOcxZ3/L+CYzIf747JNRBh3rLvcwDND6PgVVPbh79zjBUcoyssnLzqJVYnsZmo0FmH0pxbQLcUy81ynuhmuiqRozVmIh6jv6lu4knaboVdPQAesJfnHS7snSW5PjqeCLMH/eMIzY45KyQllRgSXx35b67LkSk0GSjT9h5poyP5dS/JKIHOMJgRLOrceJ1Nfs06Nj/3jtWsS68ncDJ83zAGsTOFNLJ7qnB8AVjS4u4ZbLhVNccGDUpsU3JdG6IWt7JWryXgrSapm2PREm1govhk0i7gsTa+cWAlk04jFS8oorLVrVUsTxkvvONO9viaSl76NNOUlMCWLsHAboIdbqfQV1Ve1xXU8H/h7sUkr1qocjTg1qYKnf8brldn8Tw+8JPGNvn9B71ISGh0mrnqQlJmt0Rh9kr/a5Ib7l8cNOhqUe/uxsA242JbUW6s9WZQsJahbSTL7HLgWTX3gZWq0DvWlxcOC2lkbN3zAF+X0hosgPCYTGXI+8lYvXHf+W0Pydq8WT/FX+SSpp0HkQfKslsbpA3UqzM7f3PhnLGpqP49vwS1ZVG2W3/fivfv+huP/lRBGGg+Xamnu1aaDjfKqwlmQTVi52rwEpaFBpjoVmtCwDasPolX/pRXgkV/vKz1t/CdN8KGfUiGjRLMh/o9WbluAtMVCNCwkJAuZAF01sXJi0Xp32zq83dO4d6hTq0jDXXGk44yd5WUwHHEPSvtBC1GgF7G0YkT9aPYKM47aRWlRbqHxksq6ZLGgyfdeYW90iOx4Q30ukuF+mxz1lB52CX3drw3zL1PtheAN2IBuMoa6s742NlE/umiLZCxGIjeZAu4UwVMzBHfZVJZHwkRsdmQm0riYpejbmZM/JExQeV+lxeCLkD+CFJZcpwZ6/Cm8TL9NyRdJSaLl8tTe3Eqd/zMBSXIafT+Vg6TMbMWNh0TJ1C77P4UAv/5FnfVn8kdXdwxJy/XHP565+rdukUg/kTYW8eZ3IagqkfOj+YUEA1dMadZN1I1ywNlSHon4fo9RLDYAZgqg2c7uutaKR25lozHMx3YTy9PXEcj5CR2qVL4mHBrqLq1/p6lCY2+0yO8SLCYtyZ/yrrOadNMQ3GCHv5wT9dJt40bsQnwDcAchwWz0/ve20fIMjSmE6csYUmDcexfqXemnbHZtYX2C6iOEGHwQBRjBOROo4gWNeU2bFKVf61BOtTmU51kIs6pvPdmT86/GJnlKpEMedtZEiVanTB4R6nr5N1RJHZYW8CsUgpA16mfK1nMIVDDkHIoDQuccqw0y2sU6FwTDV/r5zqLLQGvTpJoPgJb/QVp75E10GIXsAcCslRwXQQ2uY0f28RzyKdetlRzInrq11+YN2Lsv0CikWtOvHB3mE5xJto/2bQc5yGLEmq5qrjyZFu4LuYJ87jkoAc+BqJRD9+bXBvz2UT+aqAlB980yFbp70nr8SI+wCbmZCECun5drFk9WhaqY57ItcwCAC4QBZLlDZTHhJa9GkEwtQrVKhz7CuqOZFnhorioHRCiOLWlriKRCWTp2R0SlEnU9NLAjVOPPGJrUGkCoTu1DFME7XfutorYXu9daXQ0cl8n3rFoCQbMyKFhCbYZXk84IR6vvwYy3fchm0YNFZHuhAnrLmaVFHpwl8agJHZ9u25+IWdVRU7n+kBbXMjTLTFv+fzQShMBZ4MdIubpzLb9ChW2uU9yZ+u2do/32LHCtD60zoQqTnkknkhER0Cz0KY/J7aIQrCbfuOEWrdNmWPpmaARgE+cHnNrcLoTR8e6lnpDSBdARzDtaObrJNNrbzKjfgO4q8y6GvBEttQVy6ISjIKLrdeqUxHoJuLAKtewqu6F80WQHZCg0tSsLNjurHWxjERHmxi/JrW8ONNQ+ZRcfsdBZVVqdnBVe0sbvihl1+S8PahVh5Xit4x6M7oIv9upRpFmzt+3ttTqKyrz35FemVIqLXhn67IndeMc1vXfQBrTAzKgY83heuCS0u/z3FyJ8Z84QhsjgJoSxmlo4RF/hn7t2TBCurX8x3Ia7YRJkY3D37vSa38i08Uucd1oVvXbULBkFMJMVdLzwPxYEUfMjxTpga/ZJmxJjg1gK7QsjjpGWAv9/t1BSlOsfmnnqnLS2sEvFDPXRFrvSo4IlF0EgvJW1iuXLQoQej9hr0no5/0jN9tCXiG2jNiRbOQO9we34R5x1Yw0dgwY00YoMoL3NUOxuRGZK9iYETQKnIZJWwicyjinAYFhFR+av+M9KtvCJigMU08JGjVbp1/SufF6FV1P/e4Myy/pWdOkEkJ4PXaQAchJBsefRkC9g3TDeWfbuP2GTt+0ZMOW5AMWdzbLlyUbCaOSDyqpSi9BaZPQBb8MvOkGZItfnTkKzqaWLbxCvS6Mxqi0s+fbTxAjMM/JxilzJ8653n1FlHKcHS+mJVu5TyFfWMcn2YGqSiZQviIo6+fC0iKNzUSfHEiqWPATa2cIdHW1fFA2EXkl0YinuOx3ma0rOzP3ZMZzOHPicimw1aX8Z/BU3VEK/lvlIU8C5sjRlnOafUmrs070DT+0S0nILcnloIgzy15ZKnpk7H66vGTRNekRd2S5FLGPqdnFSVLVL3BdnZ+Cw/SqegChsTGOyKGw+MyKmAnun/xnO3dsRJcTSlDeSNEKMEWj6YodXSJfZrwu4QYTS6jcn/1+oR/ye4+/cHQ0YyNOzJ3tSYHKqVMXCZnUovl9Fh+t24Z7M1BvnjK8htQ4dziG0OqAYMy7/Dk6wzisZGantdXD3WNKVYJkmXio1g6J3+ukw3hbPPcSlE6wnXts1GWgf6Js2F38PJBxmpZd8Iqhb3F8lqs5UKPGwKw/j9ylhqw5bOK7ks2iV5ZWRybWp72fnR+I3gICH7wpQ494mObnaC5/txUaJThXLEuuwzls/r33b47Hmu2Me0uwlTDft0HoXBCG0X02SS73kJrBkuBkA17QN/RmEdsI/5PAAjU+sTDUWXuKP1u3Z3Rdh8GIV3BHIinWkcUoVHzoduUuHVi0mnWTQUvxZqbv+TQROJuaesh6QVIIy+Kts5e4pA2mohKfgnfs6I4uOQKxSCWP46+JVcj/R/T4rWdwI2Erzo09LVmygY4SJ7i9pRcklSiTymoEh0J9wPEcIUnUZzAs7CI3tR1/qlhcjjo7Wp9HmxyCpGHVuxLCBOZDWwb6JLS24pA1g8qQK3XtZCON4t2dcnweLq0snYiBKGEk7aXF8+CM5XVywweNFW6Hmg+p0k4kAMLFoD+c8Z/+GjwzLVRd4nJQ4XqJPUEi6y+X9NhlF5lNAMMj6LONWwWBLlzlQtrfxxsatXp5WYHJjAcvtHD17gYYmn0bxblx8HX9ovh/e+ncMRIgyKyEN3GgxiIDVhZZ8B3rn7qcg5J/ebtcZDUdXvElQ8T8DuDQHfYTRZ36j67n+i9ckTSJ6oASZ9t9Nb7lMIXuUR7DF3bb/PYsvVd1Dxq16wvzZowpyS1AEIM1fA1DO7EqN1WLGFINy3v12QwObwBLFNvEuucpy50NFQujxFRQtiH2gzwVud63Z6CKoGMpP367ENLW1MSZg+TXxK6ceoQHExcD/RaCfNgEPXIIDkybnkynD63iOqBFV6Y55Dk5D6IMjdCVY4P2buN+jXVXwj4xs+2MCiw3+ntIQCmxzPjjHWWTkPmzBHlCJw5Ps7IHF/VVk21JaVcCXwBsmUtvFBxeStGGjJuS+cPFkYOUitqTNaLaBeAymEHJDyG3s5e9Dq1XNh8vAXKUyKcEhN3MyXMKXoeoz/3gzP/WJ9kJD7EvE2qE+0uUAoAkEtfLrfnkgTlrrNnWhpbuk9gFCGOYoZfSbI4az3lHNGERTpK1ms6mFHZOWaaP120fiTKA3Y76UPcyQZ83mPlgFkVFya2RsOF+JW/03A3WNAbk1SoEMbGKDlioaxam1MK2XJGhUMOa4KM6d5+R1dZsmCO01eZQ5gP9G+HHtTX8kqGOSo03vp/lIztqB1lm5Oz18VtiQtwXwbDvpLHz6LSoBtD54lETA9fu4q70fhYbks8kaklNzFH0EntZudMw4FcAvkGTIUn6iwIh59c8/PVTTloEsE55U9aWA/5IMhuTsI+tiz8hFZq87d30O/U8dwgpIQUeRIMM6T4etsZ6qbzSpWSgslUJ0BRuSZaNZdtMt67WIZ5+EAFqv8oEtNhPTpaH94m+TxV5H5qQ0AuLlATAgqR8zPUTEUloKfnXRGtsX1XZV4pHPIgNuTTA9DxbJLmZmr9pa6F0aCkKiOSWh1u+bcgZUd8AQJC7PYjudKkkhZzvLLuhcUXnY1ZjT4RSFLdNRb5kvdGs/YDj6QnlszHKTH0vP2n4RXMuCDxlJurClt+/vnaP2QTBaxCQ1NVS9wyvc5zw/lbNWVREfMg5h4liiEMNwpGg3CaOxCV+0PJSA4woHtrnrJiyHB71ArR5cB07wQmbNnE9KzrjuXx2kj3uba49m0QYbvErYUD/7MDKiVV7RMlL8GdPgkggjs8KsAEZCOmEGrvUfDBSUFYU/9XH86xXcYt6FEThBQmqKrQr/a9kWFKTayzPXa3GoDfnGC1kocPcrWwO+NTC4W5dDcXHs5r9B/Rnln4EBuHL4CAjbii04Ra0gKm4WHfeY6JAdtMNzqDLl7BdvvcrHZQ6Vtfmh7e+nSqZyMaThtdeEldswTgVxRvWfXOn8QKlzBl90mhN3sxkV7k3kJvDPxwsC05rDV1CeuEWWZaxuJ884eZ6Y+6WFxIVKVLpE466bRDOFFLwGb9KnpD2tEBnDjPh8lrVXhCXGK3oqu71X2sjK10A8N7Sb7WivtjvkHTZ3q6UA0SvNfvO+wMgmEG8z2nn9IRv84tsCMD90nAHtKZ564NHcJZqoq4A7h73oG6nkjDuKLn4xKOJNtPth36QUjbRaHPy/LlUyoIRj/1cd5v+zHRsMunui3At43Dvj7Z3Yb8TDROHERx7WANIrOqdh0XJ+VA6HjOkPASuUM9QpwXKphDexIW0vpTA+fd5aouQmbtr8kM5VOO0FTIVEiWRYDLjmRmmWKks0yIpV7azgx3Yl3aPimuNJjapv8zq9AUS5XRk0pWtcK+v3GkrTyXbWzqgEQemPZ7l945857pck4E5v0C5IGKHRwvOTznssESBwbZjerQli1gPOmw4YOEUvkVQPil0ms4By6gQ5mzsB7VxshKpaI9H36gcnX1fbCNuToY+gQgQqy9DtwfXbkNPvhCUGxZLyNZYXFkxaLjdPbNd8IbrvF+9QrVxFoB7wgK6E4NmfPa9BHMk+VWfPW5qsgBqcunOW3ZIKRxu9b115BcRUk5nD/aoN3/D30GIlgW2zjGX0s3wCCW/+jss6EzEs9qTeIdfneeV849XUg3paTAz2Uj/pztTlbSCcVp31Jyep2EtW0xxyWDcDQPnuY3zJRoxhclwAoxFzMa8d/RYTKh5Gva5lkKAr54uMENDjGqnhyk7hTc3lK/1FNesxQMf1s+CBjeEpw7NI1XnzhtBq7VrKJPfJOeEESPu9F9UQsy1bvJqkkGcquONlLyByXFWAnuKWDFshdKcTQnZlIkB5xXsWIo0DtegMHbngR5tE6v3lnZwO9jEH96piRfxrkpaOkF3kfdlakEW7pWQaSfnbu175rVR5aQDzI6YGYhsxwVC1FJamS0XO+5/QUFHzLmncV0XQeO1nyT/2Jl9/8u9G0bdKdpEsEkpd/f88l6w4ylntoBk4eDXBmwoOmqMxWYiUhhdU+tuR9lekyWtMV9bzO++DzR5k25D8JIZ5vBjfT7DjZll9GP5jx6WI7FvWfwKscBlBJz6t0KU0pQNgdom81IpUbeX0vA3rGKGK7MrkE3zVuAOkjH/eqfZNF6nCfY+AYbaNCiz2h7LTseiGdY3E372oe0ptY4HzodcaCDBD5Yz6s1jrYgh71NuBDqRtY5eU9oviDrAZkpUVmmldyNP7nBRPN5Apg3AINUckphEyEjDy/88jvC7HsqjlgJ4IWrv+r4h+/LjQaEWj+frZ5LVUUS0mENVvxEBT8Bu+UKrslHXSjWKijAm6kITm6Qqo0MO1RDTvaROG5P/NSus+mzXX6NurjHjjjGqdeYn3jcvM6ZheqpbqjMPvSw70krlGKuhZ5wH1ASs3ovFDb/RclgTJCR+MaXTiwDbNHWT3DsimhdXtNRumjJEiVA3smxi8spAyC/76gKWdNuakicw3d79ilphtLntURViEmoA3gVITca9Zi1wyjxpsasxtIH3U8cft5qUhzLW2OviXP22bKGlX+BjmCCDY3kWny2ZAKWjzrusF+Q0osRjqYhoSjtr22cfBbRqEG4/7xS4ph0kbvwQAOMcf2MbytCFUxc2yLqEZM0dlwEw1hvciaSe/uvqCSmN7h8VxOfLjefMJfjQ0xsh8fotM72ctVhk0EJA9V3Z6cZEO5ZtbeAg7fAVGFRwK5C6VKWv6SX5fvqydwrIelgsc0VAb2s/89ipwOAcU0WL/U5aO9leauH509o93AtyN+E9gwg8u4osqXsNdOZD4BRA+LjiHCEvTkLJ40exqcsrnWeA9P7Snugmgti0A10PWHiP8Ar0/sIhnkyuNb40FULVvnk0ICgC8Q5EvuXnpRfJ0mQ6qOcemPYUTsAok1tzs4AL4NfXKP83+p5mIc/qs/QnC0D5F0LMTuDxjlrKi7oZTNzu1koEZ3X2aZ6CrlmLzen1Wu33+syN/TrWbwEnof9l482aoEjjtCE/WsPLbeevzAjHeOSjI3/gGyENfnmev4m/gn8xVAZzKFNg7J7cB7yRvnJ1b7zZvCzyOk/7uRjqXVacAgeiQzrx0LT5zHKlb89vER2HoAndTqn0mvCcUQlveiNJzGx6e1dqkaS4ONti1y3LVIv69X1ROunGKaUhwPNIDdWIRQOWywAnBiOvXDZzh34SP2xT/MSctli1zqlns7YFIWvLFN+7ZguRWO+E+zc6uGJZCrMR025q67K83iE0Qopb6HqSir/wUMYzYkeC1doivU+SOJn6kHpdPt3ZHn5qKLFSpZVE5xjqpLRP/wFgbrhIClwSgamZ8qy7lKIZ/90WzS2g5OmeBo+yPDJQMRORqM1u/mry+03MsJYLmh+bBpIATOkQ86Dzr89LjUnXyWbt0hX2O1Wfcy8dS2iXlDEYOcfMaP0DfXeWuovo0++Yg7zh9tWrW89LLovF+6rGY8xQFsCt2HaIgkULAV5/Xq8ipdVbny2W9aazDBZKdX1M6DdkPNuqwqThPqap/LVvGPgL4uJmuLhalDYe6Ppu0qsH2bEb2sRNEBZW2SWnVx+RTKVQqyiHtiy76xbxW/36HWxZWgbhkLhL5uzo0f+uUAFE4YBFvXq1qNx7jw18W8BtvjosBhcY3dH1p26yCvmMILIRsfRwIilE3/BKMAr7TJ6vDSwMZcz7b68ICj5qbFFxjN1i+g/bngub3b1WKtbnf3LhXJtu1fw+qwiXhLZJeTTtaHPHKaZB3O1Uxv7IuozYvQEIx3jZCjm9jLlVbCHNa/D4LYkcJp/68fy+RWmZJO4E4MI9If8ioyxx1riuJPRTkbaEr3s/xMqdHkEeUWOXF5zEC8dDBMg4eI//TlOXuNNpegvwUN5zp5F4LUDmKNpz0pVIikQXXlkOnwDCErtJhKBDXL0CFpSmEOfGgtJIvN5xhH52BdBNEwowIOgfEhykDUl7GVKgXWvB+cFWStOCwXaMBTcQuupyiFOARJtYLKjfKvCpyqYY1Ibx7qS+99De7DaUfUpLbc1PK8m912ALZRBDV0Tp+l62OzzeCMFeIJ7llmxDOpkJFYXjE43ZOxNBv47bcqiartToDc4ZVndgdjvp+eeZhcJSQpvxpnDVZHeaHijMvU24/N2aiFthTC2u4oRTBjjCVBauv6WYgSU2vdKq9pmZ1hVmwGIVCzg8xuF9Qpju+vIw25j9wlj5XNbmDDZfbSw7IlXCa4rwjf8p/Z6OFDf2zSna9SZ3t0M71yr76KPcdj7X4etKJ8+weZxlPR2wpXfy4DpqMFqT+IC5e5HA0ntZdL4OfoAO99TduCnAH7qvYHVR8Qg81PcgQQuLLLCGEN7ctI16q8nDwJvianeiRZEk7J6dI5lvtFkmNLI+adGqFlWfFmFvP02fYkfW9qf6Q03lj6LRLS58OxhO1inAhAcZ+I1kDy1Zy9il5XJoSv8AI+bd6v6/KJDt9sTKM6Eoup67BmYkQct3pOYJtvfHFS7GV15tWJkOehbDODb19cLNQ4351m8y57rbEHQHUvP/xsx8YosxKcvVDcX9Nsl5BQhLCeALsJgUuUF/vZaF1Fe/sCr+r6oQBebvmVYzJc+d/O4MwRrDIOTvQBGSufQDnr0GiZwPhvO9FyLkfdBGFbx0n/VyeCRb0+gghHbAwFPeNA3vkMdc1p/HH02YRlWAmmUWMm9ILhfkTmS/ImE3Mq6hQQSg7asgq1o8SxXqu0Uklyu3cvfJc9ah8qqo9AQWZUxu1TYzHmWWJQ1OtKs/Ri94ofRw5HxO7UewZCsxxsAoFHPoIxsPxCs9VgyrQTri8Vcc4tENa0KjlFu4aEFlVNROV5HiwEgH0KdV+80Fi946l1CTjubfoFlNppzoH3861jYczxoR1UvAQNkpCygSsFYoFIHvlIxsvExuKWQFEU76QuiuMQ8DSWU9WBgw/LCg/SecGUzbb3wTjCYi3W/rNLhFcJDnc5ZRusPMv+x4waoEK8XjyxNbQSi9Tr8RyzacB8/VwaoY0gJ2muiHyHIBceiyMnwijfmuffbIk8lRcg4DULdpj/fFjUw0yeGdTCoXFlt7O7wXoIHN6C8AD3hxc5vBb5eCyRodop7ECZZqwbvtKqqjTm63cY4/E6L1jNlTyx4MvMrWTnExLllD+XruiEnmP6V0XasFm5fpqA+Un4WqplNXlzSyvW5+Kwa2I0YPZYr/3Psc5Tl6rpfyaczJ5xW0hpL4iLbbMBcyuE1FlVR6MWNPyy1eI1AiEdKqbxZ3OELlo7VsjFN/8xH/5VFUzpR2sNx1vvAvvssgsh6LqMpUn4fLgyRzd8ugv4U5anYOFeeAfxXBTcpAsFz0tx6Adct1jx8DHVWLgExUdCBvrW/07Oafxw003WOY1ugMDQJaSC7+Jiyryn0eJhoVlEA7PJTyGlgRB+b6+7xsWE0CNA7AS8E0vJ8RhKasArfYSeo5FOYj7DSXmIkgpKGeg18PByPhrY1lHNfEAdl0fc2g1fZQY8MmIwWOiiSBu+qCSD7LavjJeVWYJ8hB+XOy4uWY7b/QCZ1t/B7s8HmGmUf8tiEgkADtI91/icdYT325cDL9WXeE70wQGjW634u5ixB90EIH/UyrYD66qP4MNNsjL0Nndm2TCv2wF4tKIKP4A8f4N6CJIqbmPho2tzxF+YGSAG63dpNY9s5+IUmr1xSaEI3rfzYCusgH002ol80y/iUpFOCgZwc3nZJNUJTQWzZJm5lrjP4OTaOCkNwsPfE0mSUVvmiY9nQgeY4JGBMNbNLvP/AUB8GdExIni4ujjiotfarUDY66jM4w8tOJ0CALgCvUH218QHja4jTNbbtBrouSUBgOniyCGd68jVvmbPpAWpYQEa2WiHg2ZvxB0VGu1Saq2kHfb/Qx02zAehpLImyQKPMJlpP6NM7ORKNHaUdCQKEvDr0nWChS4Q9bCBxE0T29AKuvsEtBEFMaCcCGf6b6dqUq5rxGJWp3uh0ifMQSXWfPGkHelTUtEjLDiEjHDou5Co54Ey7Xt1hvmbPFNx8VqvWiB8MjKciyOG8YWV1Az+utSjjbsLBrv5aBROxK3Xk0o0Rlq6AnYFhMRyJgJ6dkvwqyZtSuncCqxbl7i5S0m/KaQRXUZN1cwF+QZddh32Ox+uiLLB4AI9S5cei0QVEWiknzq4m17Qp8HLPddgJycC5FJPVd2UnHj8Q+5pibDMo45hAU9aP2fUUE1Ki3QaQGL+Zl2VX4JGmVzYjzEBue/KSHiq2iMBrYJAvg5dwcTrRU5Vy5qiOjlrPdKmERXhtU1nv9K1RQhiq+OP/ui4sx6SUgk77Pg/ovdl7s0xenGOJRTUVBg/gsdMsxJDdR8pkMYkVN0mplX+aEbkw5MDOnbnhsMvf6FOBAIw5doc8YO6+pGiTwKA8WV4rYVGFelKk3YDVK+UnLkUpJRWe63XGCv1S94fwKKVI15+7X69bPYtzzy0IFfVnUlptI9WKDBL5sbT475OZjJYEb905iolOyaY+ju4/t3DlOfjmSwvZUo6U2tAuEmqUo8W0vWD6qAjdH50TdO2uW/SMrOF8ozRnqeOI3y6c4/jq7T/f7Of3DKrRmPG4r2AQLiLSo5CP+UbI/OPo2cE6rwuDlkF6mCZRp939QSg5LULw3sDcdIkS7XB3TMIuQR5O2RoPD/u9yNhVG43u0bk14mG+wMOwT/R3C4ZRzN4z95ZdX8ziD6BctlUzuN7mycwO+hfPR+tehfPeznT8sHP4Nq2JJPsnYg2OUudnozxDzplNeaHBJuPsUOVPyr7b/JW1gyKsH+Xow0BjbzpHdYUx5JjwzLIuLv2SVRp8FQCgoh3CLiMVBRYYUMDY1M0xMvtdqk7TdfU1E+doD3bdQY8n6MK4K5Zj1md6xRDIxOt1iDkbs+w/u3X2Ux18L6PUHoJ1RKMd3D7nFn2w8ClDfDLcwf6Ofc5pzXP5WkKPogZQJzlcA+jlXfFhA5PCKSUjqARNLmtbRv20bvWf8AJD3lB5NTEVx/80yi8BnhZGXSKfKtg11LsVXjK9qI9padIbsRf1OMzQw7JcPtJ2oHLyRkRFi+jVwmiWzFGYZX0UKWfiH+pwiNSqBFtradiZ1iR5oT/v+Ya6ddf2pzHc+h+7yKGQlSKQ/JzCW0e1Nksk2WgS7NNnQQxzgdSN6lGrpEoD8BbB3ERgQgadFN6/4GXNMUsfuxifwv20fcjVNM/zn36DcoxooptOHCNrd2hS5D50INQs/rtwoJubVnmFmpZP68ONLeLtRrH987BfdnoBZa4RotrrWYOxgWO9ABx/++OxvmzLFGcM6XQ0scOHgDpblCqk4m0IqzS5fB7gB/1eLcMH3p6bfHGv5A5uqS4fChCi2nYEl+jkhmm/jv4GUQZ5u5IgMSF9egJh7Hra4WRSswVO24NgGxJ3NYNUXkyhqsLrlWcYwWmAgxzwgqnM8QyYOLMpn7uRxVUjAjTZCW0G1pnH1vlykXoVliAdeXXQAhs8wXai5hY46HBu5eKRtOXL4w/o/Q0IZK2RsZoqJXX2/vpGXQeaJwWR2WXgyUbE4Rk6epmtSJ9kPRsZrC4J+iGJ/uaN3Nt13/jYgfF77cYD8lJJSBDynwqoeiE6G3LogRojQtlmpnaND82gxCft/JdH7mgzLrXz74GFeuPovNt39k6NjqDVFmGoQgkjkgiKlr6U4/pC95xPUB04coE+bcT4n7fFzeoAsjpwoEcosSwgHk9yZ5/BYhSMsK836AaCthpMfj0xMrWbZNF1ALTGKYq3tBEETYCqGlulOSuk1o2+vGdwOkkzGZcv3O2EropYlJdBfGahhKkoIkxAJdVBlBWzlsVyz0xtGaLPqhsLceWIPNNb5OnjNOU3MkKCSL/evPn2OSXvC4MHQTo6g3JskEuJWx8WXhpTdTZwr8mDcXYjUdz+t+DvzfqPf//MxtLx+OZf4mn6hABNjykTjD01GTOaJYVGLAHFznHSWhJhkuldPCpzZ3wzD8gJPyngxSilHpNajKwT+PZfncpf8gp46JQmsT38uplLpXNIj8NXT7J455yOh9m89b14HPFTkGPoGADEmiCexzfB7nqqWMIU1cpG4sNfMyf0fj8ED2v9JB5jfbrqC364yz79sOMKCl45G8sLVLBaZfqJtxHo7Jt/a5+ihdL8DUI961bivVFBkAQ6ezGQZmvTi/NWf5dIGkaZZ+hK61HAzbp+9dqXUkle0Ad4Jl07timIjbmy/xJSVx3rpNoNtBwuN1TAQm8/fMMX/vj17VEFvaZZXHfhpI+N+EzlNVIMaIUqmWk1iqUyedYMJyAyj9mtv6rzLmSZdY5MM0NzuTexoHy1ALfEGlovOba+9tC+sVO09eRYAxeBUyLQd1YbgqJXIYAUslWtYRMae7ZfKL4uu9mu1IFBPZDmEbFBKaZHukQsGBIbMtKm9f0wjYcQ6+dy8HxW2W002yTRqwTvv3q0y6r6dqP/DYnblMbIgo546Wa7eiF+pqVrIlsAdbPiaaGLJN5tWo+0dWmP4oiVTvwfr56q3jCn72UIQ/GX1LC0+arhJsMywIoeNVE7+TlORsagJjYcnUIBCfaw57Va0Xsm3tweKDue6RJukVnzgZesa+kX8waduZcpPaG9v+Eygmf6y6B91e9y1TE9BPTGq6PU2dXvkJ0J/g6XZYjGgSzrS+6RgMJiJm2s77MSYTgw6EFHPKobqsng6lhjB714X8kCg777PhGnghxNZea/QfzwQYUjj4fpNKazjg/jFmR1DEJodfKkXwsWRmVbnMVExh8tGJtCzxaLDPlU+ksRsg7aW5JymhD1TLSNirJAsVWdjvCiO3gzGgglLKqJjhdwAUnZSvzz8xUG8wFUOc8qmwoe7PrDk+uChrW+MlRkyMXwz5h/ajvoLK3zt2ca96h9GRXeFpJr3HP4DweJWst6gTYwjzShMwpCXg98vfoFhjQik9tAe+FOxNaGSLrBXSmodZIxH8U2a6aj8MdPOuHZBF3u21kcwmBoMqsy7791XYI9eZb9CWdIw1CVG8CNg8K4o13ddYnLGelbNWxD+Hij0wQoVgT4wOfiELJqaZOjMH02XKLO+Pi57yaZDR5eq3E7oI5PSagzw0Tmq4y27LFoEXG2qqHO53hHNxyq89qCN4WEg6viJB+nyaAYYK4gPiTDkppuOU03Id/v1DEd4KWNK8tbKKxDDwgRs9q4k/a3BvCW83Ko70AWHOgKc6CyYj7VLpEys100ZZCfXNHJUIbxvdU0C7u5DrDFBy7jAXBd0cCZBfS29qfeOr7fOWFrXGPIQbVyIv9X4u6B4pXJmV2UipuwzuJXfy89IsczZDTWLIUQBgU+1O52heFI35NTds+RS+w4z5NnGMumDAW5mKHAPAxp+KW2FWtsgZCoI4J6ZStK9ju27soQ9BPNjL6KHHXpxtc4neV2g1xkKetr7NaB2N/1wn5NdJ+GSl6TGofcPjnWhDYMXyj7cK2cGkhTEoyj4MCusMx/FRFIRnoUYF3D/4FlaUiIwZM7nUYNEVJ9/sb0scYwYJ6lVyVjYr18skCUjeR8Gu7wlrWYeKalmlX9RM59kis2IQ4zWfAgBaQ9vM6HGvzQMVfJxQ/vr9sa7L2Oec1l8r3TAm8Z6Rh3AaDSnlvxk+4P2fpnaV35PH7GD72V5gBz5nzPxyDJ+dI2re3HV6u1IRkg4A+bkGyGNFoubviJcjmNwA3zlOYSprpmxeJsbduzIcChbKP/YMvmlnsz6gKxM00ni6p99DomO4ilUcrXjJr4Q87WKjM7ZFgyvKw3IHooVmgktocDdVyTzlGogqjMu0BXoKOhW6G2ltNocP2YrUuYIP2Z+Zjn0zUDROWI4a2a3+Ktz8UsbTntc+nXjVrOqxhIwNUokcAkHvu1QwyXAcu9u0rMnrQM0ays2/Uao9kvExGeMEI8kaIaEk3nQ2tRf6Lry7lzFWm7omsBv7DYkSNxw5Kpu6U58SFC6iOn60dQFpOKwzTiMkcDOePlK2M/1I0bHuRJ7Fvv/4TnAQp0OYf4ncVlb1eI1CVnw3g7DidpsaiOpN1iTu0/6Sb02YTCRnXE/9jXNYMFtQdWlNv0NxTpfRZmk6Y5ZB+M2LyXw9/O0jKKKNCPZuF8vmYoZuHzd//bGccUYGrZgwBoffOszCAobbf1UxPNnO6Jd1xpgkoT1ofP5wELPvn8/jY1fwgQXHeoDdJNq1tPkqUDnDSaGU7azF5wi6fNL3cHrNXbfQgyX9aJGhUK90i9z+JTswBqUL3V/f8GHAQCvBS6S5T+6qb0jhbXIxw3tbJErHTK/I4L3crZYVYcPoZ+WZHiZjn2euzSzTpmA1GO0id3Qg9XKNumeghTRPhAGQ2FlVU4pBJqLMlfXj0Q5V3H+5dCk9Zvg/gxg78s5unbhlmFr9hzVOB6xhOUB1UpB2jnwS7lp8VCFQiCRePyjp4jR8vj1lzjdE2b2jXrGSd539uSGOKaDmOKK33+ld5aAarSEuQ7L0dhX2wdza0r0K1q+Ua4jrnHmwAsWlZHj0OcNUU2CwnFh9wPfJFCUJIGvTWZttc2nxQq2NqTvxTmK7qY0H8pXHFtmoMhQOzGfLhEgBTMDoXWOTemGNtznQK1r6r+OfefgpNvQiNc09MnOYyJj+XxeUecX3nLeHhRszYg/XPOz1c1nPwYk0hZh3LRgJIvu47FnMVQY8jSACO/lzdSZSjB9c8YNLdYmP5oYPih13NGqRi2aPUHmbKxVgujk9BWIvINupEFUIoJkHdDRk82P8qwD+UZDmUcNiZql8DzS6Ps1aZrbXN3rbf392AWKp7jhqjGmxPr/QA2mWj4HBRhOok3KEGkFWcuUuE2Wx2T229jxSHzp/2VmSydigMq5JTKQdgkeiIpAY9+ertS4vzTvbKVDmRkez1VL3fdhFoD6tmw7nkL1unniXYdflhpzc8AbJMQYFEq/LFCHfr1GDy7T3OCRjHAchp3vDNDVtFb7AO71TELkzlc1Bb89XDZSP6LmFZrhZexUbEEHfqAOk0/t5L9P3tTcRI9FkH7I+8n4p8oXsN9l1SJPAiumVb/IchtkdZ5s6duwjo3aMQEXo7msG6TnlNNU4H46SzPbQpQW6BRxDze7Y/jhAj35n7A4i+gkGjKviNMiH2teQax5GDeEw4i4Pmafht2XZD6QLqKb+Gs0trBwf9j2vJXhPjT5IoR/5q7/pC6LaQltZmD7J/7ctNgFHvWyo93pg3z29FOes96Yoa6eeq3Vq+RikWrTEuEF9mZJ0xtDVjuVo5yHMJFUDCDXJ0sOHZrr2U5acm2jK8XwEg/gufLwWvJfBh/5nz7Ef2xpOZu0xvyTdSC5djk3pARv97T0IfU0riCCZm0X1nh0TnPW/fEYwdkr5kJduiDBGD/Tz3hxZZx4TMb1NTTzp5zUvvm4AOhK7+Wczd4xXLuuX0clYg+PabcfVYFL6MeesRnan2CJEUAi32/aRfMIZ9pj9Of341fWDQuabzLlP8KB2HPD1kMfecp/Aw3sAiiJ21tnfXbHbQovInYAlac2o2I6lNanMziklmwiG838v9vj430BY38OpGoOaldbJeXAZ4duiHb5HorzbRhTa0g82GwpABsyqZ2mhrYHTR+gOtHCvzff6p6x9lwOnqTKniV1PRkzCXfAzmpgMgne5R1oy72wqe+9Yb3Hk4uYBSeOZki0UN7FVJsYMPi/+NO6a9L3nYIuVMYBXds4JqCk/w3jAIr7w5rm4zDuo7agQoickG0VsGQPN8IFL8/lXshJiQrEH12IctSu4MhJoNpwctUwtolwLLDbpyyLwwi/FQO8xHXcyq8UC6QUw2/x+PbJbkmCNk4Q5syGXesMqUK5wFcUiHIvQdGCBk4f6T+2BfVXLbVKZNnOsUpyLbX9ILQlwZGN4O6GxxvpEUbYzW1jQxQfnyq/5zRma8zXBDer62ZC8rfwYpc+OSQrnIwvbFvsVNtmxN9RPk0KCwcKOh7j4aOssYko1ev556RZg6cCw+SXuZ588AZSLjzUilM6uCDlm6/IJAamSkfbf4SU8htIh2VtCnYukcTX+Sk8sDa3XOoF5FSpNW7DIfalfHnt8VndWhUaqrHctKy04F+kb4rROAriod2z2+A1NOzeFbx7lbyg5B01ghDjpa7Nxvs7K3hANzUnGBfCroKxMtNf/T+trzZK+LbJZYABzOz5zAwGwi0I0kWm3A+i+cAGheBn1tPuzSklqH+MnQjpwTE5Bgzd0Fzo1yT5GP6IUuC+XPNQlcaiAVgNUlhlgDsf4K9oPd08vHzIOIqPVcXzwdyEU+3CoMipmOZleH1JLxezQm/B/07GtHgSLZ2MD3bcRQuib8vA0fMYC2y13UT76XcHAjwCm/6Spm9BcQy76YOUBIOg0xNfXzL0cHBCJdK93NlP7PHZFKwutsXRxmPlTK9DqNIT2VhF6srWTQcrlUxMAJiUrxZcXIIF5xcFbc1oumZyB7XuGS7PU5Al/mDI1A5D63tL95J7UoOhLNfYeatz8tQXvkVPEvd72/rXrDK3ydOnjLvybBDB2Auaooz3QbTekzcS+3JQiD247JJ7UHaegddS6dmNRnECmbcHhjIt+acecTk1dbnbQqONq73VsiGrGuPu86O4J817ro1oKaTbOg70Xc0/ibAo9QWyo3lhb3ExH58RwPDhXDMlAO1nzh+3UlFDbsJaqWPaSc9G75hDmXHB4GuIzKpjchosqzJe+Xgm8iUajG3BnWXWQWnTaB8A8pLHiXXTQ4ehRqx/0Vj9+DmeTBykH7ylKKhtMW+Up/WU0fSaX1PMfD9YMVZR7ykBydiqz75xFwyQGn2vBY6m6dTIZ2+amMAjpLqZ0ia8gZJmOenAF4MTMUwNEenGB492GBdkdyuCOkU7TUsAgn281srTA4ZS0sdYSRVSHUbtTViCUqcpZVuXfZFzYcjm1/NaYFTMAWR9VOL1HmvZuACIGxaZ0AM5CU4cGxLa4WGKFStZGezCuo9XBN90x9wtW20ZdeUUJSDH8O9HwaINyQvZDQjSxCf3+PnIvbr94zocR0j3Os3PWPeMOahvyuKKVD2393kO+k6Fq+z05zsJSyDUoPslwQ2In4dQjsNxifYKgDMlxehhyNEnVFWKg0NPK/bzSg9Jw1UNXYToCzOpF8hyR7WBequZcmEbzkctuczZAyJLfJ8MFWhHr5kZyZ9xQx+Ci/+wcEgKi+mTKnl+U/3guzYJpAAWbEG/b2F/FRe6PWMos6mnNpvDQaBDwuu5Mm3h9TMhwbncd6Ggn74WFTnp38h+4l1VHZ5Kr6/NjLKrIsGBi1HO2DYbgoY5apurHt1JxVN+/nxWT3wBG+eNkC7jMnxsobNIK2zepiXnkNNSDdAc70zlObpldCCk23g91zTXZM+0dLVqHpqe0E1JhhHQIgSoxzHNg9ulI0XmWutIyVRxMngUu5lUDo4Iv41wePpgTOhEHM8EzijPwDO065YKosvcGbcwAgzmM5zXcmQ0Oi/sXU+3WDoDUqIC2zIvwdF8i2eCkUbqNZtxBx++EcbGAW/o3R2I16NcsxrJfGHuupErqeylxBDEsK9GMDjYVZHgrZjjctp71cmvcG4SMPr/6YHyodTWuXbo2ZYbZrvHWbKEJEALNMaBnGl5P2iJTgTIGyVciToo/t/g4fXMOA/0UC4er5WMRNhX1zju5ovGaZq8gGH9IBD0CFuD9Dm3sWy0WZfJ2qaBNTXS7gPw49Zj31imP7p7ZoxtYOK/xpEjjAOhpbBtbyO1jxeiZ+ENrKFQFL8jleEsNPIfKCoA8aok6trgAieX6PjuBJJ9fngOFW1e8JnIoAJua083ByGKLpJjNoz13SchRHNB+f05Y1tivul9X8uLdtCwXosqO2XWL/5TGotFRT0YL/YAjzMxloikQ2MI6oUAMGK8efdJgjfPnYm/zU+EuqBYucxkgShxGgZIJQ0TJ+AAWimVEHQb2W6uU+gQy2UsvNno9FoRp0qi9TRyN6iPVdcWicIH08fNUwYHCRPuXS3oXGuWbdl80kZucyPIieQ/9AnKIIl6FemMa5FpaL5ROoSUswuh4OaUqERb8SpJK5Ngs8jtjEJrt/1ZwuZA9l4DMBPlbOo9IOyTCZ+DHeQnUN8cc2Rr+aQHVYTmpGE/iWa91/f/v8awp/0gDRUEJLAJ9aqIZ0DOxWMUo+VlYh0j1mlxSlYHZMIRLHrEZGiysY1PTxjiOtCDCbNxIasVdL4nYUEcDX00okoQ4qL7DUs5G6NQHCspnoHQxobsttx8CiwA+5I54Xc0fzs/+do/7+TZiaoiquA4B1YZU8/ATchOHxaN3PTKbvjsc6zKTRaMPTPGg0rkEafp1NGZwubBEDlpkqk16N28Qv78rJ5w3CpBp0A/+0zE5hlez7zGGnqbzhkssFXNK0qAyiuHhxtY9FchmkFHqXC//Kf7pbsyAyJ5DQNmQBSN0dhBSB8naNF7shDHdj58NR25t/jg2G08dLkYJnNnJSWgP2FLVifGRzkD9YK/R32uQK5whtDJQ+Kgj17vwXi+QttgsqjwPgKQ40A2gQT/k0LqnBuQx9+DJA9a8flRXbme9IA0eJU6XdrZYK4T4uFU+N9TvQII0sm5LtIQmzWmPYW0QVKSfKmK1JpsQAP1H5ASdKTSvnY45SFjrVlUbwgtINnLM/+ZnLBIokkT3jqeHUkRwTpiEv28K2KXEA+z80jCkNTWtVDZx/Bv6VjE7xg74FTMHPhyg2cLZtL7d0KzKlv5LXasS80V+YbAX+IVTn/WnwwbATp7JAPY6act/5bZlopWfRmXIvVcnK6YbDGIZger2Jtqdtn5cQVkosE2HM/yzpnBlvchh3Pvep3G4IvgYWVcn1kftVe+q3+ofXkUl2lPoVlVpXfO/aH1E+kJsjQqM6Q0yzAlmaFDYEvfZbF+kZrRyEkSQpedUVIQTfYsO5SQFdJGgrTLlMvpsNBJoDNLm0YRx5jUu2hej40krRYiR6Hh0/4uxu4cuTg5rU2eEvtnNOoIZgswUg2ZYAoS6Ds0npuIPEpbaRoB/p2tK/mmPHxJympEw+cxhY5wlJEDtPJ68um/bhGZnISIcP+dsrQrYiO8eDtRMy8x1axBRm1jAb+3PINk60WIEeExy8o6ci+NY8hdknMAc0amJXjzf15mq0drTRvsNOVlTxUz91gju7iMqPq7oqyOd5kRa/BHgEiEZyj8rvVdJIz4sBtakptRofpoejIUB/0Zu7OkkfUFfFQcXDMAhdHIyHZt23ZRzUZwsVYL92NiprfL57UIckZK7I7tngPRwQ7D0BqtvHRxoBVnVlmr3OBFOVh9/wC023bRwet0JIOeINjk6lAdS4uddhV1MkP0J4nm7P32W8x8Yl5OH+xGtYxCnFSNWboBE7pCUkMqz8d4wqnaHSNLjbKxsrIcQIeJhFx9k/bvBLVgypNtdQzC72x55cXCCNcg5u0+0xWdj0xHGZIZmroG9HcCtL4hgfoHaeUxeIvFrsKXgHQ0xo8zHP1w6ZZ7LxfRDa113a0L7il5DFPM+561o6zY/11OaibX6kdnXjtX0XjbeW0GKOMhRpP31ml9hpjp0KmUYwRlzoT6cB+IdRhH8p3oLIPHq7vrCOXQzZ9UFnyR1nnYYNBTn/GJVG9xPKjlacdmgNKgfPczFRHHX0zkmFRf4ZM++ZwepDi92H+iW+aia9KF1E9GT9pUBM3qT7qotp5TsiQWAfHPtTja1I7GC9qJipzmcO/H1RXXZTJ8dS7SwbRg+ga4MDGuoDmp03MLkI8G5Y8y1N+VUTYN16VyM/Eq00IaZdiAuACc/Us+NJMz6BGhDLXa2/gjxrh7MPgWHrNVREgBctjshPIjl3p72SYvS3r2JKYvZZU6+Xi3ve0zC/UyumvrZV/Tv6WyLpjdb3ccvTb+rvyfEI8FvW3cE6iHjHd1ciPpl94FO26XRtpHdi3VJ9lgt0Jcjm1WK2AtCrrL3q1+7DMeyvQnu4FhqhdNNwwKRlcxgrqgnGxrSLdSuQ5vXizqGD1cemc5TkjGoQwRfqUcIz82PMMt1cWyK5Oa0rqGMDqgR0KmhNPCP9Gsj0VQrHtKsMaGG9LaGQODv3XmTrYOLOj0STQOUymPVTeZ5wJcWaQn2x10GK7088ouMttuh9xA958QeeEdjFYoHYhJsLpwIGnQXUWxDED8TbhuD7GVZ70+Qk/TtAjzp8i0rVPdzR66vHruDydfvdiMvv1BjRarmhXMsEMUV2X5hxqI4PnRrS1xzfNTt1EsBcS7eDyRQ7PXYgc/4Waq/Ywx0RJmwH6y9va6ewnGKBB1A9qoaK9eZGTcnX28O4AF6IN3VConn/V5xcALgw2qCjSc/05Wqi4YHcTdaE/aUYoY6vA5/LKW2wZYXi6Gqwf9zgSugYZR7wWIRTX5cLy/IkXfL6t51huobD7wPoowmxlHWV9DI4x7aibMWGzVCFn1sEBpHE9bIcOUl6nyUD689rr7rsX3PIiysm1FHBmruBZjK1C68hdskgbPp4QpluT8sq53US31JTAybpi+OmbAwystGBlDBKhy790cpBKS3MopZn7yciEPUeb66hDzJYaxZhvqi5E8F1SWy9DB0//CGR0QxLOFMYwRESFztE7DgZrHPhhP+GT1Pz+60Y5KuMW+RUDDx55JkXQH2HgCowKgzXqpMDF5EX8dBfpINMeBJIL2y7S1yfztZuCnjIgR70fZG6s58q7Lzt63Jgr5/oa6C5o9/idlX4weqg8zXbIHjRreMNOyCFGYzIdhbnK8OI+p3fJBwsh070F7CnSghsFtyenN1oaWiE4fLEJ/bhkWUWbV9cqWvCIFpXPrvMfigPJMYUzQocwy/Fy4YiL8Ava/gbry5aAb2XWUS5NxcBc2LmW2FlMYHAn6cKzKADgr9+bHoTjKkQBUH6GQGpIBn6nPy42V4wMdMa6qWAE4WI8JJkHSfmlGNhHB2mL/4VVgj6QAIHQ1HQ6FMnUVe11yQEEuogzEIoDHGnKp/gh3yCunoEoeDqAkdauTE740veYVjA5IV+jhbgO75ppYR/o29M6WU+iV2YBIB5UABCMHDxAN8rK1CXEbMEuicoDTkOW4LDES2KHYXxqWt/LJKIjoB0xquAIJiPXX28d/pSFStnYolveLtWRQWUjl9b2AU2YUkgm+VRRUsac7ss1q56Y5DUw5pL1YNfSC/jzBsrNQpOfFSilRU63XAT+lHiSIF8oAkaOFcp4mkUL5R8785n+D0JQ0l0NJto80rxaEbDfnvv8VKSGVkTp6yf05jY5Lma27p/S+81KjGP5HuVCfEpVe1i/pFnjsX5GTP9fEG8MXEzqabcv8JtJ+Xcax27TO0qoH6DG3TJlZ8y/9I5u9ZsEyvG8CpUjdtn3IB1K3sVkuWeXGn3s5BcpOhLC4qcRuiPPvLxLpAXgv/WRbwFSormcbEf23jtqPfGjCFPgOKEFQEjKmlSgb1En6aKA/fCT5ue2CJ/tqaajY0ZMEOfL1hOEotyAmlVrTRSRVX4RcdYG6M5D8RNgbCmQi7HNPqwXG2LcCFilA78Nv1Ck7t7o4eTBBxXZyMyMoGk0d5VXvQX/xxSK8eFeayvrJAeaMhJi7WeTbtwKIFfElQ/bNg7/fwsGkJDa/zO4NB1+ZpnPJGPdEbPSXGFzRf7+P78Q7ELlIxP+ZDe102uZ92Kgb5Am+XSue/GOBMzSu7ZLNpb3tJVUSEcd3oD/NcwO4ghJj9gdZKNd/tRevel3Z32a/rMU5C3+fOhjf5z9gV5jEnnbRrW3cOzRdnz2dCmsWkRixhfmt3CqN1iTji26N5Sa9tTTSAZvg5S0Mo2jrLXcOLn84AojOJOehCLOgv94mMC5BQhiq4B+h5p+sEh7kFsyAzMcxgJP7cJFeYrsXfJ6qHZ6HLDVr8UM4h724cgv/lF7ukatwji1R6PV+TPukbXQoZovvNcfI5bHExvy8lzeCrUReYOi7BGs33d1aecbrzJsE2bLqePMSSZJJnGp9ex+EjJd471nn1o7wJsYriJHf5ylIcwPUm/2vNEMVUma5HJPVPP7Z1ZbTbpBMsRTX/bFq1YZsDDUzU1oEPUxwO4A6pTtlN40k3Prb9BmUEsX+Tmxwo/vvTBmBxJJZqwkrxKADUH9Kip7XaTz7gkTDOgEUqDeKDMQr5nR/1XuHI1z+kQuzsoVFyV57VFAYomFIe1kATalcb8NuCRfoL8T/Q977f/6dBWQ1lOUN7DQDTcpt4tp1EYbE16vDpHoUJ6itpD1Jff3wVDqeKockcsHyII3PhwyJYuO6cvogCzgThMYln25KknJjAX1ZGtqDUuEXia38YgV3QmzhjClD/9traIOnHbbM66E39B0jNoJKOUNirEP+XQUkIFkVP3jNbAczHYs/zQ6rZqN1pkyDduwJEdbE0RQuXlOgqPrkPRGO1sGqJU4fUrPX6YWgZSZTdFdnSedE9Zprwh7CoOW5NTNNDzfeRztJKnh/jc92L3ta4Gp6cM9/9K4Iue2FNgih7pdVo+7exGqf88OXEwrNHmqZ0w6PzVyAoM0pDvVP4CYKLN2dWszhSh5tEH/gQK3IH2OK3WZPnsMpDinqMZb53w92q9LJo2O7eGh7dpXy5SjoAOHG3W1fyevSCSpQpJv1aLOkvjYci8PIw+1U7h4f5VcRjp2KkL5C1sO9QYp8dTYCUuyXmEXHqJBHBQ9P5uG3E4wAUVPo541XHnuV91b9oSyx2BWd9wXPIxYhWWCshsFJ01KrQXg4ePw9MFIv0vsffmaXGDoRZgEYT4/iuCknwBX6lgbI55VrQ856MAqOoBA9j2RwsucJHVqv4tplhOsm1NWLwQHtmDz1ku8QumMLRm9noZyzG6Ta89/kzNQHY266pyOUs04ko7Nh4wB1qqbpxRW0f8agBxDe1rB+PMpDMCAwMY6cGnVkLaXAo42nM0+86bZ4cUO8gKWO2i+lAM5LFAzFi1MT/+c0KkTDQdDMhVyO0MT8WhRCUa95PzcH7NMv+/veneZIKx1n85LgfAGLctP+EMdswsdU/rb4qV5RiRKY4hnPK1SQBdFevdIwrCgRAGUMivFHCykvAzd6YHx7K5uelKMfV5KpcYJNCjnJxhmyofPdSg5Bs3jL1Mv7tCJV2fpzStnEra9fAT2OYwAqqyNiESq+CwHVXKgbFeIBYfA36psM4pDXguEqgDRvayWl/0mT0O4x9u/cM+T1SJCWPw46s8uNwET0JFXAFAR7qZqGDovugXnuyxzvTXYPvEvVscvO/KFGrvCmQuxcolcOaIrb2ewV2ChxP5D6qixJpN2stp3SqgIEV8nic2sq4bdUoeW6dQP7CgpGSs8zOAeDQVswRNVKCFTLkADWlBMWASRhmYfT7T4iNrEcl8faS7wmFlv6ajfaVTJOQYp1T8vMW1oqyEgUme6ed861d3IpqpPCKfVQSp4/G1S8NszxNgB1nLn/fRmG3swKS/xv3RFeSkECyeJP/RvIi9ThCQIAhrkdPkPB5lg0yBgQTdULs3sjTqe6qO7RMn+RoztlWngJXlq0+xIh3yKureDpT1YZN0JGQvqtWwSV5vpoOP+MD9+u2DP7Byiy2U2IgEctueT4KSQkSKKiTirdBDH4vgfmfr9WaTPag8s7NJfV/6S9xZuhDDGkwa205/4XW0qAxFgS+kevnH5vGzlsi4XVI4BWZA0TWRGqW+CwrF/NtQD2uCZGbmSI2rg4b4c29yGJL7AyHfXU0vcRaSdUzhmfwRKIA457RTj0R27M0P1jKMIIT8wMRWJ2OjBKBRy6rzClt9IaQwdmmdUOAIRpEZ1HCUoJ9qJfpAB/HSdh3238iPdtVRDR+cYnJpHJ+1/ZFuNmABpyyfh7mzK1pI5Y3ds3gNfbPSwe4GaeKbDc7+sfgJpyOMpDtUv5SqdA55sgaCWiA81sgfVNi9bLZFxj4cWKwtcz6UVsfGzh0M7iIFORrNk4CPlFT6MqQwErbqn6V2lgKsWEPVHtRZAJ+oEsTZpQ7bY6m1N9hf85SKOxSnJQuDKtZ+uGCBTjHvGuMq3UTVgc5LEIK6qNCRwRLXqUeLhtfRxjCh/It57tNZNns1E9Xit20RnrGhf7sybKJpbreFcL/c6KVpmklMSnQS5Q8kZ1w1csjVUV9b4cLFpJGTxW0gizpDfhNDxYpBJrp1AzLp1gdwfbPTHLD4t9/RpVTlhgNdTMIelP9vGzHrE9Fxx5B25SblfzPMS17D135v0AzuuMbonZRhWOBnie5BaY1YW5pgDFbdT2TJ44SHcS3CVb7pgeisNjhI9j7JaxTfCvteeAgPpvn0EyyhNGs/zG5Mqjhd446g5NFL3J1oTjw9XjUAhhub96V9ZaAP0p/k=</div>
<div id="enc_passwd"> <input type="text" style=" border-radius: 5px; border-style: groove; height: 30px; width: 50%; cursor: auto; font-size: 102%; color: currentColor; outline: none; text-overflow: initial; padding-left: 5px;">   <input type="submit" value="decrypt" onclick="decrypt()" style=" width: 58px; height: 34px; border-radius: 5px; background-color: white; border-style: solid; color: currentColor; ">  <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "></div> <script>  var onError = function(error) {  $("#enc_error")[0].innerHTML = "password error!";  };  function decrypt() {  var passwd = $("#enc_passwd input")[0].value;  console.log(passwd);  doDecrypt(passwd, onError);  }  </script></div>]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>AngularJS 教程</title>
    <url>/w3/jslib/angularjs%E4%B8%AD%E6%96%87%E7%BD%91_1-tutorial/</url>
    <content><![CDATA[<p>toc only.  </p>
<p></p><p style="text-align:right">2018.3.4 星期日 09:10</p><p></p>
<p>中文教程：<a href="http://www.angularjs.net.cn/tutorial/" target="_blank" rel="noopener">http://www.angularjs.net.cn/tutorial/</a><br>1.x : <a href="https://angularjs.org/" target="_blank" rel="noopener">https://angularjs.org/</a><br>latest: <a href="https://angular.io/" target="_blank" rel="noopener">https://angular.io/</a></p>
<a id="more"></a>
<p>AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。<br>学习AngularJS</p>
<ol>
<li>快速过一遍<br>如果你想迅速熟悉AngularJS的工作流程，你可以先参考官方给出的开发示例。<br>学习PhoneCat</li>
<li>查看AngularJS Api<br>AngularJS提供了很多功能丰富的组件，处理核心的ng组件外，还扩展了很多常用的功能组件，如ngRoute(路由)，ngAnimate(动画)，ngTouch(移动端操作)等，只需要引入相应的头文件，并依赖注入你的工作模块，则可使用。<br>ng<br>ngRoute<br>ngAnimate<br>ngAria<br>ngResource<br>ngCookies<br>ngTouch<br>ngSanitize<br>ngMock</li>
</ol>
<h2 id="简介（Introduction）"><a href="#简介（Introduction）" class="headerlink" title="简介（Introduction）"></a>简介（Introduction）</h2><h2 id="引导程序（Bootstrap）"><a href="#引导程序（Bootstrap）" class="headerlink" title="引导程序（Bootstrap）"></a>引导程序（Bootstrap）</h2><h2 id="概念概述-Conceptual-Overview"><a href="#概念概述-Conceptual-Overview" class="headerlink" title="概念概述(Conceptual Overview)"></a>概念概述(Conceptual Overview)</h2><h2 id="Html编译（HTML-Compiler）"><a href="#Html编译（HTML-Compiler）" class="headerlink" title="Html编译（HTML Compiler）"></a>Html编译（HTML Compiler）</h2><h2 id="数据绑定（Data-Binding）"><a href="#数据绑定（Data-Binding）" class="headerlink" title="数据绑定（Data Binding）"></a>数据绑定（Data Binding）</h2><h2 id="控制器-Controllers"><a href="#控制器-Controllers" class="headerlink" title="控制器(Controllers)"></a>控制器(Controllers)</h2><h2 id="服务（Services）"><a href="#服务（Services）" class="headerlink" title="服务（Services）"></a>服务（Services）</h2><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h2 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入(Dependency Injection)"></a>依赖注入(Dependency Injection)</h2><h2 id="模板（Templates）"><a href="#模板（Templates）" class="headerlink" title="模板（Templates）"></a>模板（Templates）</h2><h2 id="使用css-Working-With-CSS"><a href="#使用css-Working-With-CSS" class="headerlink" title="使用css(Working With CSS)"></a>使用css(Working With CSS)</h2><h2 id="过滤器（Filters）"><a href="#过滤器（Filters）" class="headerlink" title="过滤器（Filters）"></a>过滤器（Filters）</h2><h2 id="表单-Forms"><a href="#表单-Forms" class="headerlink" title="表单(Forms)"></a>表单(Forms)</h2><h2 id="指令-Directives"><a href="#指令-Directives" class="headerlink" title="指令(Directives)"></a>指令(Directives)</h2><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><h2 id="Component-Router"><a href="#Component-Router" class="headerlink" title="Component Router"></a>Component Router</h2><h2 id="动画-Animations"><a href="#动画-Animations" class="headerlink" title="动画(Animations)"></a>动画(Animations)</h2><h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h2><h2 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式(Expressions)"></a>表达式(Expressions)</h2><h2 id="供应者（Providers）"><a href="#供应者（Providers）" class="headerlink" title="供应者（Providers）"></a>供应者（Providers）</h2><h2 id="location"><a href="#location" class="headerlink" title="$location"></a>$location</h2><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="端对端测试"><a href="#端对端测试" class="headerlink" title="端对端测试"></a>端对端测试</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap 文档</title>
    <url>/w3/csslib/bootstrap/bootstrap/</url>
    <content><![CDATA[<p>toc only.<br><a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></p>
<a id="more"></a>
<p>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</p>
<h1 id="A-起步"><a href="#A-起步" class="headerlink" title="A 起步"></a>A 起步</h1><h1 id="B-全局CSS样式"><a href="#B-全局CSS样式" class="headerlink" title="B 全局CSS样式"></a>B 全局CSS样式</h1><h1 id="C-组件"><a href="#C-组件" class="headerlink" title="C 组件"></a>C 组件</h1><h1 id="D-Javascript插件"><a href="#D-Javascript插件" class="headerlink" title="D Javascript插件"></a>D Javascript插件</h1><h1 id="E-定制"><a href="#E-定制" class="headerlink" title="E 定制"></a>E 定制</h1><h1 id="F-网站实例"><a href="#F-网站实例" class="headerlink" title="F 网站实例"></a>F 网站实例</h1>]]></content>
      <categories>
        <category>w3</category>
        <category>csslib</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap文档-起步</title>
    <url>/w3/csslib/bootstrap/bootstrap_1-gettingStrat/</url>
    <content><![CDATA[<p>简要介绍 Bootstrap，以及如何下载、使用，还有基本模版和案例，等等。<br><a href="https://v3.bootcss.com/getting-started/" target="_blank" rel="noopener">https://v3.bootcss.com/getting-started/</a></p>
<p></p><p style="text-align:right">2018.3.3 星期六 09:08</p><p></p>
<a id="more"></a>
<p>学习总结：</p>
<ol>
<li>多种下载/安装，使用方式，最好定制</li>
<li>文件结构，及使用 </li>
<li>源码less，也有sass</li>
<li>grunt编译</li>
<li>一些简单的模版，实例，帮助理解Bootstarp</li>
<li>Bootlint 工具，帮助检测页面</li>
<li>禁止响应式布局</li>
<li>浏览器和设备支持（开发中再查），还有浏览器bug列表</li>
<li>第三方组件支持，比如：google地图</li>
<li>可访问性，针对屏幕阅读器</li>
<li>版本迁移，社区，许可证等未实现</li>
</ol>
<h2 id="一-下载"><a href="#一-下载" class="headerlink" title="一 下载"></a>一 下载</h2><p>用于生产环境的 Bootstrap<br>编译并压缩后的 CSS、JavaScript 和字体文件。不包含文档和源码文件。</p>
<p>Bootstrap 源码<br>Less、JavaScript 和 字体文件的源码，并且带有文档。需要 Less 编译器和一些设置工作。</p>
<p>Sass<br>这是 Bootstrap 从 Less 到 Sass 的源码移植项目，用于快速地在 Rails、Compass 或 只针对 Sass 的项目中引入。</p>
<p>使用 BootCDN 提供的免费 CDN 加速服务（同时支持 http 和 https 协议）<br>通过 Bower 进行安装<br>通过 npm 进行安装<br>通过 npm 进行安装<br>编译 Less/Sass 源码需要注意的事项</p>
<h2 id="二-包含的内容"><a href="#二-包含的内容" class="headerlink" title="二 包含的内容"></a>二 包含的内容</h2><blockquote>
<p>Bootstrap 插件全部依赖 jQuery<br>请注意，Bootstrap 的所有 JavaScript 插件都依赖 jQuery，因此 jQuery 必须在 Bootstrap 之前引入，就像在基本模版中所展示的一样。在 bower.json 文件中 列出了 Bootstrap 所支持的 jQuery 版本。</p>
</blockquote>
<h2 id="三-编译-CSS-和-JavaScript-文件"><a href="#三-编译-CSS-和-JavaScript-文件" class="headerlink" title="三 编译 CSS 和 JavaScript 文件"></a>三 编译 CSS 和 JavaScript 文件</h2><h3 id="预编译版"><a href="#预编译版" class="headerlink" title="预编译版"></a>预编译版</h3><p>bootstrap/<br>├── css/<br>│   ├── bootstrap.css<br>│   ├── bootstrap.css.map<br>│   ├── bootstrap.min.css<br>│   ├── bootstrap.min.css.map<br>│   ├── bootstrap-theme.css<br>│   ├── bootstrap-theme.css.map<br>│   ├── bootstrap-theme.min.css<br>│   └── bootstrap-theme.min.css.map<br>├── js/<br>│   ├── bootstrap.js<br>│   └── bootstrap.min.js<br>└── fonts/<br>    ├── glyphicons-halflings-regular.eot<br>    ├── glyphicons-halflings-regular.svg<br>    ├── glyphicons-halflings-regular.ttf<br>    ├── glyphicons-halflings-regular.woff<br>    └── glyphicons-halflings-regular.woff2</p>
<h3 id="Bootstrap-源码"><a href="#Bootstrap-源码" class="headerlink" title="Bootstrap 源码"></a>Bootstrap 源码</h3><p>bootstrap/<br>├── less/<br>├── js/<br>├── fonts/<br>├── dist/<br>│   ├── css/<br>│   ├── js/<br>│   └── fonts/<br>└── docs/<br>    └── examples/<br>除了这些，其他文件还包含 Bootstrap 安装包的定义文件、许可证文件和编译脚本等。   </p>
<h3 id="编译-CSS-和-JavaScript-文件"><a href="#编译-CSS-和-JavaScript-文件" class="headerlink" title="编译 CSS 和 JavaScript 文件"></a>编译 CSS 和 JavaScript 文件</h3><p>Bootstrap 使用 Grunt 作为编译系统，并且对外提供了一些方便的方法用于编译整个框架。<br>下面讲解的就是如何编译源码、运行测试用例等内容。</p>
<h2 id="四-基本模板"><a href="#四-基本模板" class="headerlink" title="四 基本模板"></a>四 基本模板</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="五-实例精选"><a href="#五-实例精选" class="headerlink" title="五 实例精选"></a>五 实例精选</h2><p>以下实例全部基于前面所讲的基本模板并配合 Bootstrap 的众多组件开发而成。<br><strong>我们鼓励你根据自身项目的需要对 Bootstrap 进行定制和修改。</strong></p>
<h3 id="Bootstrap-框架的基本用法"><a href="#Bootstrap-框架的基本用法" class="headerlink" title="Bootstrap 框架的基本用法"></a>Bootstrap 框架的基本用法</h3><ol>
<li>入门级模板<br>只有基本的东西：引入了预编译版的 CSS 和 JavaScript 文件，页面只包含了一个 container 元素。</li>
<li>Bootstrap 主题<br>加载可选的 Bootstrap 主题，获得增强的视觉体验。</li>
<li>栅格<br>多个关于栅格布局方面的实例，涉及到层级（tier）、嵌套（nesting）等等。</li>
<li>Jumbotron ($_self:超大屏幕)<br>Build around the jumbotron with a navbar and some basic grid columns.</li>
<li>Narrow jumbotron  ($_self:狭窄的壮观)<br>Build a more custom page by narrowing the default container and jumbotron.<h3 id="导航条实例"><a href="#导航条实例" class="headerlink" title="导航条实例"></a>导航条实例</h3></li>
<li>导航条<br>包含导航条和一起附加内容的超级基础的模板。</li>
<li>静态导航条<br>包含一个静态导航条以及一些附加内容的超级基础的模板。</li>
<li>固定位置的导航条<br>这是一个超简单的页面，拥有一个固定在顶部的导航条和一些演示内容。<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3></li>
<li>封面图<br>一个简单、漂亮的首页。</li>
<li>Carousel<br>Customize the navbar and carousel, then add some new components.</li>
<li>博客页面<br>简单的两列式博客布局，还包含了自定义的导航、页头、分类等元素。</li>
<li>控制台<br>包含基本结构的后台管理模板，还有固定的侧边栏和导航条。</li>
<li>登录页<br>自定义的表单布局以及经过简单设计的登录表单。</li>
<li>Justified nav<br>Create a custom navbar with justified links. Heads up! Not too Safari friendly.</li>
<li>Sticky footer<br>Attach a footer to the bottom of the viewport when the content is shorter than it.</li>
<li>Sticky footer with navbar<br>Attach a footer to the bottom of the viewport with a fixed navbar at the top.<h3 id="Experiments（实现性案例）"><a href="#Experiments（实现性案例）" class="headerlink" title="Experiments（实现性案例）"></a>Experiments（实现性案例）</h3></li>
<li>非响应式 Bootstrap 布局<br>Easily disable the responsiveness of Bootstrap per our docs.</li>
<li>Offcanvas<br>Build a toggleable off-canvas navigation menu for use with Bootstrap.</li>
</ol>
<h2 id="六-工具"><a href="#六-工具" class="headerlink" title="六 工具"></a>六 工具</h2><h3 id="Bootlint"><a href="#Bootlint" class="headerlink" title="Bootlint"></a>Bootlint</h3><p>Bootlint 是 Bootstrap 官方所支持的 HTML 检测工具。在使用了 Bootstrap 的页面上（没有对 Bootstrap 做修改和扩展的情况下），它能自动检查某些常见的 HTML 错误。纯粹的 Bootstrap 组件需要固定的 DOM 结构。Bootlint 就能检测你的页面上的这些“纯粹”的 Bootstrap 组件是否符合 Bootstrap 的 HTML 结构规则。建议将 Bootlint 加入到你的开发工具中，这样就能帮你在项目开发中避免一些简单的错误影响你的开发进度。</p>
<h2 id="七-社区"><a href="#七-社区" class="headerlink" title="七 社区"></a>七 社区</h2><h2 id="八-禁止响应式布局"><a href="#八-禁止响应式布局" class="headerlink" title="八 禁止响应式布局"></a>八 禁止响应式布局</h2><h3 id="禁止响应式布局有如下几步："><a href="#禁止响应式布局有如下几步：" class="headerlink" title="禁止响应式布局有如下几步："></a>禁止响应式布局有如下几步：</h3><ol>
<li>移除 此 CSS 文档中提到的设置浏览器视口（viewport）的标签：<meta>。</li>
<li>通过为 .container 类设置一个 width 值从而覆盖框架的默认 width 设置，例如 width: 970px !important; 。请确保这些设置全部放在默认的 Bootstrap CSS 文件的后面。注意，如果你把它放到媒体查询中，也可以略去 !important 。</li>
<li>如果使用了导航条，需要移除所有导航条的折叠和展开行为。</li>
<li>对于栅格布局，额外增加 .col-xs-<em> 类或替换掉 .col-md-</em> 和 .col-lg-*。 不要担心，针对超小屏幕设备的栅格系统能够在所有分辨率的环境下展开。</li>
</ol>
<p>针对 IE8 仍然需要额外引入 Respond.js 文件（由于仍然利用了浏览器对媒体查询（media query）的支持，因此还需要做处理）。这样就禁用了 Bootstrap 对移动设备的响应式支持。</p>
<h3 id="禁止响应式特性的-Bootstrap-模版"><a href="#禁止响应式特性的-Bootstrap-模版" class="headerlink" title="禁止响应式特性的 Bootstrap 模版"></a>禁止响应式特性的 Bootstrap 模版</h3><p>我们已经按照上面的步骤制作了一份案例。仔细阅读其源码并对照上面的步骤实践一下吧。</p>
<h2 id="九-从-2-x-版本升级到-3-0-版本"><a href="#九-从-2-x-版本升级到-3-0-版本" class="headerlink" title="九 从 2.x 版本升级到 3.0 版本"></a>九 从 2.x 版本升级到 3.0 版本</h2><p><a href="https://v3.bootcss.com/migration/" target="_blank" rel="noopener">https://v3.bootcss.com/migration/</a></p>
<h2 id="十-对浏览器和设备的支持情况"><a href="#十-对浏览器和设备的支持情况" class="headerlink" title="十 对浏览器和设备的支持情况"></a>十 对浏览器和设备的支持情况</h2><p>Bootstrap 的目标是在最新的桌面和移动浏览器上有最佳的表现，也就是说，在较老旧的浏览器上可能会导致某些组件表现出的样式有些不同，但是功能是完整的。</p>
<h3 id="被支持的浏览器"><a href="#被支持的浏览器" class="headerlink" title="被支持的浏览器"></a>被支持的浏览器</h3><p>特别注意，我们坚决支持这些浏览器的最新版本。</p>
<h4 id="Mobile-devices"><a href="#Mobile-devices" class="headerlink" title="Mobile devices"></a>Mobile devices</h4><table>
<thead>
<tr>
<th>Chrome</th>
<th>Firefox</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android</td>
<td>Supported</td>
<td>Supported</td>
<td>N/A</td>
</tr>
<tr>
<td>iOS</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
</tr>
</tbody>
</table>
<h4 id="Desktop-browsers"><a href="#Desktop-browsers" class="headerlink" title="Desktop browsers"></a>Desktop browsers</h4><table>
<thead>
<tr>
<th>Chrome</th>
<th>Firefox</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mac</td>
<td>Supported</td>
<td>Supported</td>
<td>N/A</td>
<td>Supported</td>
<td>Supported</td>
</tr>
<tr>
<td>Windows</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
<td>Supported</td>
<td>Not supported</td>
</tr>
</tbody>
</table>
<p>On Windows, we support Internet Explorer 8-11.</p>
<p>For Firefox, in addition to the latest normal stable release, we also support the latest Extended Support Release (ESR) version of Firefox.</p>
<p>Unofficially, Bootstrap should look and behave well enough in Chromium and Chrome for Linux, Firefox for Linux, and Internet Explorer 7, as well as Microsoft Edge, though they are not officially supported.</p>
<p><a href="https://v3.bootcss.com/browser-bugs/" target="_blank" rel="noopener">浏览器 bug 列表</a>中列出了影响 Bootstrap 正常功能的浏览器 bug。</p>
<h3 id="Internet-Explorer-8-9"><a href="#Internet-Explorer-8-9" class="headerlink" title="Internet Explorer 8-9"></a>Internet Explorer 8-9</h3><p>Internet Explorer 8 和 9 是被支持的，然而，你要知道，很多 CSS3 属性和 HTML5 元素 – 例如，圆角矩形和投影 – 是肯定不被支持的。<br>另外， Internet Explorer 8 需要 Respond.js 配合才能实现对媒体查询（media query）的支持。</p>
<h4 id="Internet-Explorer-8-与-Respond-js"><a href="#Internet-Explorer-8-与-Respond-js" class="headerlink" title="Internet Explorer 8 与 Respond.js"></a>Internet Explorer 8 与 Respond.js</h4><p>在开发环境和生产（线上）环境需要支持 Internet Explorer 8 时，请务必注意下面给出的警告。</p>
<h4 id="Respond-js-与-跨域（cross-domain）-CSS-的问题"><a href="#Respond-js-与-跨域（cross-domain）-CSS-的问题" class="headerlink" title="Respond.js 与 跨域（cross-domain） CSS 的问题"></a>Respond.js 与 跨域（cross-domain） CSS 的问题</h4><p>如果 Respond.js 和 CSS 文件被放在不同的域名或子域名下面（例如，使用CDN）时需要一些额外的设置。请参考 Respond.js 文档 获取详细信息。</p>
<h4 id="Respond-js-与-file-协议"><a href="#Respond-js-与-file-协议" class="headerlink" title="Respond.js 与 file:// 协议"></a>Respond.js 与 file:// 协议</h4><p>由于浏览器的安全机制，Respond.js 不能在通过 file:// 协议（打开本地HTML文件所用的协议）访问的页面上发挥正常的功能。如果需要测试 IE8 下面的响应式特性，务必通过 http 协议访问页面（例如搭建 apache、nginx 等）。请参考 Respond.js 文档获取更多信息。</p>
<h4 id="Respond-js-与-import-指令"><a href="#Respond-js-与-import-指令" class="headerlink" title="Respond.js 与 @import 指令"></a>Respond.js 与 @import 指令</h4><p>Respond.js 不支持通过 @import 指令所引入的 CSS 文件。例如，Drupal 一般被配置为通过 @import 指令引入CSS文件，Respond.js 对其将无法起到作用。请参考 Respond.js 文档获取更多信息。</p>
<h3 id="IE8-与-box-sizing-属性"><a href="#IE8-与-box-sizing-属性" class="headerlink" title="IE8 与 box-sizing 属性"></a>IE8 与 box-sizing 属性</h3><p>当 box-sizing: border-box; 与 min-width、max-width、min-height 或 max-height 一同使用时，IE8 不能完全支持 box-sizing 属性。由于此原因，从 Bootstrap v3.0.1 版本开始，我们不再为 .container 赋予 max-width 属性。</p>
<h3 id="IE8-and-font-face"><a href="#IE8-and-font-face" class="headerlink" title="IE8 and @font-face"></a>IE8 and @font-face</h3><p>当 @font-face 与 :before 在 IE8 下共同使用时会出现问题。由于 Bootstrap 对 Glyphicons 的样式设置使用了这一组合方式，如果某个页面被浏览器缓存了，并且此页面不是通过点击“刷新”按钮或通过 iframe 加载的，那么就会导致字体文件尚未加载的情况下就开始绘制此页面。当鼠标滑过页面（body）时，页面上的某些图标就会显现，鼠标滑过其他没有显现的图标时，这些图标就能显示出来了。请参考 (issue #13863](<a href="https://github.com/twbs/bootstrap/issues/13863" target="_blank" rel="noopener">https://github.com/twbs/bootstrap/issues/13863</a>) 了解详细信息。</p>
<h3 id="IE-兼容模式"><a href="#IE-兼容模式" class="headerlink" title="IE 兼容模式"></a>IE 兼容模式</h3><p>Bootstrap 不支持 IE 古老的兼容模式。为了让 IE 浏览器运行最新的渲染模式下，建议将此 \<meta> 标签加入到你的页面中：</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
</code></pre><h3 id="国产浏览器高速模式"><a href="#国产浏览器高速模式" class="headerlink" title="国产浏览器高速模式"></a>国产浏览器高速模式</h3><p>国内浏览器厂商一般都支持兼容模式（即 IE 内核）和高速模式（即 webkit 内核），不幸的是，所有国产浏览器都是默认使用兼容模式，这就造成由于低版本 IE （IE8 及以下）内核让基于 Bootstrap 构建的网站展现效果很糟糕的情况。幸运的是，国内浏览器厂商逐渐意识到了这一点，某些厂商已经开始有所作为了！</p>
<p>将下面的 \<meta> 标签加入到页面中，可以让部分国产浏览器默认采用高速模式渲染页面：</p>
<pre><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
</code></pre><p>目前只有360浏览器支持此 <meta> 标签。希望更多国内浏览器尽快采取行动、尽快进入高速时代！</p>
<h3 id="IE10-和-Windows-Phone-8"><a href="#IE10-和-Windows-Phone-8" class="headerlink" title="IE10 和 Windows (Phone) 8"></a>IE10 和 Windows (Phone) 8</h3><p>Internet Explorer 10 并没有对 屏幕的宽度 和 视口（viewport）的宽度 进行区分，这就导致 Bootstrap 中的媒体查询并不能很好的发挥作用。为了解决这个问题，你可以引入下面列出的这段 CSS 代码暂时修复此问题：</p>
<pre><code>@-ms-viewport       { width: device-width; }
</code></pre><p>然而，这样做并不能对 Windows Phone 8 Update 3 (a.k.a. GDR3) 版本之前的设备起作用，由</p>
<h3 id="Safari-对百分比数字凑整的问题"><a href="#Safari-对百分比数字凑整的问题" class="headerlink" title="Safari 对百分比数字凑整的问题"></a>Safari 对百分比数字凑整的问题</h3><h3 id="模态框、导航条和虚拟键盘"><a href="#模态框、导航条和虚拟键盘" class="headerlink" title="模态框、导航条和虚拟键盘"></a>模态框、导航条和虚拟键盘</h3><h4 id="超出范围和滚动"><a href="#超出范围和滚动" class="headerlink" title="超出范围和滚动"></a>超出范围和滚动</h4><p>\<body> 元素在 iOS 和 Android 上对 overflow: hidden 的支持很有限。结果就是，在这两种设备上的浏览器中，当你滚动屏幕超过模态框的顶部或底部时，\<body> 中的内容将开始随着滚动。See Chrome bug #175502 (fixed in Chrome v40) and WebKit bug #153852.</body></body></p>
<h4 id="iOS-text-fields-and-scrolling"><a href="#iOS-text-fields-and-scrolling" class="headerlink" title="iOS text fields and scrolling"></a>iOS text fields and scrolling</h4><h4 id="虚拟键盘"><a href="#虚拟键盘" class="headerlink" title="虚拟键盘"></a>虚拟键盘</h4><p>还有，如果你正在使用 fixed 定位的导航条或在模态框上面使用输入框，还会遇到 iOS 在页面绘制上的 bug，当触发虚拟键盘之后，其不会更新 fixed 定位的元素的位置。这里有几种解决方案，包括将 fixed 定位转变为 position: absolute 定位，或者启动一个定时器手工修正组件的位置。这些没有加入 Bootstrap 中，因此，需要由你自己选择最好的解决方案并加入到你的应用中。</p>
<h4 id="导航条上的下拉菜单"><a href="#导航条上的下拉菜单" class="headerlink" title="导航条上的下拉菜单"></a>导航条上的下拉菜单</h4><h3 id="浏览器的缩放功能"><a href="#浏览器的缩放功能" class="headerlink" title="浏览器的缩放功能"></a>浏览器的缩放功能</h3><h3 id="Sticky-hover-focus-on-mobile-移动设备上应用-hover-focus"><a href="#Sticky-hover-focus-on-mobile-移动设备上应用-hover-focus" class="headerlink" title="Sticky :hover/:focus on mobile (移动设备上应用 :hover/:focus)"></a>Sticky :hover/:focus on mobile (移动设备上应用 :hover/:focus)</h3><p>尽管在大多数触摸屏上没有真正的悬停状态，大部分移动设备浏览器模拟了悬停（hover）状态并让 :hover 状态”多展现一会儿”。<br>换句话说，轻触元素后开始应用 :hover 样式，并且在用户轻触其他的元素之后停止应用 :hover 样式。<br>在这些浏览器中，Bootstrap 的 :hover 状态可能不是你所预期的。某些移动浏览器中的 :focus 状态也存在同样的问题。</p>
<p>对于这些问题，除了完全清除这些样式，目前还没有简单的解决方法。</p>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>即便是在某些很现代的浏览器中，打印页面功能也还是存在很多陷阱。</p>
<p>举个例子，从 Chrome v32 开始，打印一个支持媒体查询的页面时，</p>
<h3 id="Android-stock-browser-Android-系统默认浏览器"><a href="#Android-stock-browser-Android-系统默认浏览器" class="headerlink" title="Android stock browser (Android 系统默认浏览器)"></a>Android stock browser (Android 系统默认浏览器)</h3><p>Android 4.1 （甚至某些较新版本）系统的默认浏览器被设置为默认打开页面的应用程序（不同于 Chrome）。不幸的是， 一般情况下，这些浏览器有很多bug以及和CSS标准不一致的地方。</p>
<h4 id="选项菜单"><a href="#选项菜单" class="headerlink" title="选项菜单"></a>选项菜单</h4><h3 id="Validators-W3C-页面源码校验"><a href="#Validators-W3C-页面源码校验" class="headerlink" title="Validators (W3C 页面源码校验)"></a>Validators (W3C 页面源码校验)</h3><h2 id="一-对第三方组件的支持"><a href="#一-对第三方组件的支持" class="headerlink" title="一 对第三方组件的支持"></a>一 对第三方组件的支持</h2><p>虽然我们并不官方支持任何第三方插件，我们还是提供一些建议，帮你避免可能在你的项目中会出现的问题。</p>
<h3 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h3><p>某些第三方软件，包括 Google 地图和 Google 定制搜索引擎都会由于 * { box-sizing: border-box; } 的设置而产生冲突，这一设置使 padding 不影响页面元素最终宽度的计算。更多信息请参考 盒模型与尺寸计算 - CSS Tricks。</p>
<p>根据不同情况，你可能需要根据情况覆盖（第1种选择）或为所有区域设置（第2种选择）。</p>
<h2 id="二-可访问性"><a href="#二-可访问性" class="headerlink" title="二 可访问性"></a>二 可访问性</h2><p>Bootstrap 遵循统一的 web 标准，另外，通过做一些少量的修改，还可以让使用 辅助设备（AT - ASSISTIVE TECHNOLOGY）上网的人群访问你的站点。</p>
<h3 id="跳过导航区"><a href="#跳过导航区" class="headerlink" title="跳过导航区"></a>跳过导航区</h3><p>如果你的导航部分包含很多链接，并且在 DOM 结构上也是排在主内容之前，那么，建议在导航前面添加一个 Skip to main content（直接进入主内容区） 的链接（这篇文章 A11Y Project article on skip navigation links给了简要的解释）。 通过使用 .sr-only 类可以让 “Skip to main content（直接进入主内容区）” 链接在视觉上是不可见的，而 .sr-only-focusable 类可以让这个链接在获得焦点的时候变为可见（对于使用键盘导航的用户）。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#content"</span> <span class="attr">class</span>=<span class="string">"sr-only sr-only-focusable"</span>&gt;</span>Skip to main content<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">id</span>=<span class="string">"content"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The main page content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="标题嵌套"><a href="#标题嵌套" class="headerlink" title="标题嵌套"></a>标题嵌套</h3><p>当标题嵌套时 (</p><h1> - <h6>)，你的文档的主标题应该是 <h1> 标签。随后的标题逻辑上就应该使用 <h2> - <h6> ，这样，屏幕阅读器就可以构造出页面的内容列表了。<p></p>
<h3 id="色彩对比"><a href="#色彩对比" class="headerlink" title="色彩对比"></a>色彩对比</h3><p>当前，Bootstrap 使用的默认颜色组合的对比度（例如各种 styled button 类；一些 基本代码块高亮代码所用的颜色；.bg-primary 上下文背景色 辅助类；和白色背景下默认的链接颜色）都比较低（低于 推荐比例 4.5:1）。</p>
<p>这会导致视力低下和色盲用户在使用时产生困难。这些默认颜色可能需要进行修改，以增强对比度和清晰度。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><h2 id="三-许可证-FAQ"><a href="#三-许可证-FAQ" class="headerlink" title="三 许可证 FAQ"></a>三 许可证 FAQ</h2><p>Bootstrap 遵守 MIT 许可证进行发布，2018 Twitter 版权所有。归结为以下几点：</p>
<p></p><p style="text-align:right">10:23</p><p></p>
<h1 id="B-全局CSS样式"><a href="#B-全局CSS样式" class="headerlink" title="B 全局CSS样式"></a>B 全局CSS样式</h1><h1 id="C-组件"><a href="#C-组件" class="headerlink" title="C 组件"></a>C 组件</h1><h1 id="D-Javascript插件"><a href="#D-Javascript插件" class="headerlink" title="D Javascript插件"></a>D Javascript插件</h1><h1 id="E-定制"><a href="#E-定制" class="headerlink" title="E 定制"></a>E 定制</h1><h1 id="F-网站实例"><a href="#F-网站实例" class="headerlink" title="F 网站实例"></a>F 网站实例</h1></h6></h2></h1></h6></h1>]]></content>
      <categories>
        <category>w3</category>
        <category>csslib</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap文档-全局Css</title>
    <url>/w3/csslib/bootstrap/bootstrap_2-css/</url>
    <content><![CDATA[<p>设置全局 CSS 样式；基本的 HTML 元素均可以通过 class 设置样式并得到增强效果；还有先进的栅格系统。<br><a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">https://v3.bootcss.com/css/</a></p>
<p></p><p style="text-align:right">2018.3.3 星期六 10:25</p><p></p>
<a id="more"></a>
<p>学习总结：</p>
<ol>
<li>html5,移动优先，normalize； container，排版与链接</li>
<li>栅格系统：.container,.container-fluid,.row,.col-md-3,.col-md-offset-4,.col-md-pull-3</li>
<li>排版：一些页面元素，和文本相关的</li>
<li>代码，表格，表单，按钮，图片</li>
<li>辅助类，响应式工具</li>
<li>less：编译，变量，厂商mixin，实用mixin；sass（略过）</li>
</ol>
<h1 id="A-起步"><a href="#A-起步" class="headerlink" title="A 起步"></a>A 起步</h1><h1 id="B-全局CSS样式"><a href="#B-全局CSS样式" class="headerlink" title="B 全局CSS样式"></a>B 全局CSS样式</h1><h2 id="一-概览"><a href="#一-概览" class="headerlink" title="一 概览"></a>一 概览</h2><p>深入了解 Bootstrap 底层结构的关键部分，包括我们让 web 开发变得更好、更快、更强壮的最佳实践。</p>
<h3 id="HTML5-文档类型"><a href="#HTML5-文档类型" class="headerlink" title="HTML5 文档类型"></a>HTML5 文档类型</h3><h3 id="移动设备优先"><a href="#移动设备优先" class="headerlink" title="移动设备优先"></a>移动设备优先</h3><p>为了确保适当的绘制和触屏缩放，需要在 <head><meta name="generator" content="Hexo 3.9.0"> 之中添加 viewport 元数据标签。</head></p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
</code></pre><p>在移动设备浏览器上，通过为视口（viewport）设置 meta 属性为 user-scalable=no 可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。注意，这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
</code></pre><h3 id="排版与链接"><a href="#排版与链接" class="headerlink" title="排版与链接"></a>排版与链接</h3><p>Bootstrap 排版、链接样式设置了基本的全局样式。分别是：</p>
<ol>
<li>为 body 元素设置 background-color: #fff;</li>
<li>使用 @font-family-base、@font-size-base 和 @line-height-base 变量作为排版的基本参数</li>
<li>为所有链接设置了基本颜色 @link-color ，并且当链接处于 :hover 状态时才添加下划线<br>这些样式都能在 scaffolding.less 文件中找到对应的源码。<h3 id="Normalize-css"><a href="#Normalize-css" class="headerlink" title="Normalize.css"></a>Normalize.css</h3><h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。我们提供了两个作此用处的类。注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。</li>
</ol>
<p>.container 类用于固定宽度并支持响应式布局的容器。<br>.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。</p>
<h2 id="二-栅格系统"><a href="#二-栅格系统" class="headerlink" title="二 栅格系统"></a>二 栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：</p>
<ol>
<li>“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</li>
<li>通过“行（row）”在水平方向创建一组“列（column）”。</li>
<li>你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。<br>类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也1. 可以用来创建语义化的布局。</li>
<li>通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。</li>
<li>负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。</li>
<li>如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。</li>
<li><p>栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-<em> 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-</em> 不存在， 也影响大屏幕设备。</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p> /<em> 超小屏幕（手机，小于 768px） </em>/<br> /<em> 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） </em>/</p>
<p> /<em> 小屏幕（平板，大于等于 768px） </em>/<br> @media (min-width: @screen-sm-min) { … }</p>
<p> /<em> 中等屏幕（桌面显示器，大于等于 992px） </em>/<br> @media (min-width: @screen-md-min) { … }</p>
<p> /<em> 大屏幕（大桌面显示器，大于等于 1200px） </em>/<br> @media (min-width: @screen-lg-min) { … }<br>我们偶尔也会在媒体查询代码中包含 max-width 从而将 CSS 的影响限制在更小范围的屏幕大小之内。    </p>
<h3 id="栅格参数"><a href="#栅格参数" class="headerlink" title="栅格参数"></a>栅格参数</h3><p>s|超小屏幕 手机 (&lt;768px)|    小屏幕 平板 (≥768px)|    中等屏幕 桌面显示器 (≥992px)|    大屏幕 大桌面显示器 (≥1200px)<br>–|–|–|–|–<br>栅格系统行为|    总是水平排列|    开始是堆叠在一起的，当大于这些阈值时将变为水平排列C|..|..|..<br>.container 最大宽度|None （自动）|    750px|    970px|    1170px</p>
<h3 id="实例：从堆叠到水平排列"><a href="#实例：从堆叠到水平排列" class="headerlink" title="实例：从堆叠到水平排列"></a>实例：从堆叠到水平排列</h3><p>使用单一的一组 .col-md-* 栅格类，就可以创建一个基本的栅格系统，在手机和平板设备上一开始是堆叠在一起的（超小屏幕到小屏幕这一范围），在桌面（中等）屏幕设备上变为水平排列。所有“列（column）必须放在 ” .row 内。</p>
<h3 id="实例：流式布局容器"><a href="#实例：流式布局容器" class="headerlink" title="实例：流式布局容器"></a>实例：流式布局容器</h3><p>将最外面的布局元素 .container 修改为 .container-fluid，就可以将固定宽度的栅格布局转换为 100% 宽度的布局。</p>
<h3 id="实例：移动设备和桌面屏幕"><a href="#实例：移动设备和桌面屏幕" class="headerlink" title="实例：移动设备和桌面屏幕"></a>实例：移动设备和桌面屏幕</h3><p>是否不希望在小屏幕设备上所有列都堆叠在一起？那就使用针对超小屏幕和中等屏幕设备所定义的类吧，即 .col-xs-<em> 和 .col-md-</em>。请看下面的实例，研究一下这些是如何工作的。</p>
<h3 id="实例：手机、平板、桌面"><a href="#实例：手机、平板、桌面" class="headerlink" title="实例：手机、平板、桌面"></a>实例：手机、平板、桌面</h3></li>
</ol>
<h3 id="实例：多余的列（column）将另起一行排列"><a href="#实例：多余的列（column）将另起一行排列" class="headerlink" title="实例：多余的列（column）将另起一行排列"></a>实例：多余的列（column）将另起一行排列</h3><h3 id="Responsive-column-resets-响应式列重置"><a href="#Responsive-column-resets-响应式列重置" class="headerlink" title="Responsive column resets (响应式列重置)"></a>Responsive column resets (响应式列重置)</h3><p>即便有上面给出的四组栅格class，你也不免会碰到一些问题，例如，在某些阈值时，某些列可能会出现比别的列高的情况。为了克服这一问题，建议联合使用 .clearfix 和 响应式工具类。</p>
<p>除了列在分界点清除响应， 您可能需要 重置偏移, 后推或前拉某个列。请看此栅格实例。<br><strong>$_PS:</strong> 没有读懂啊</p>
<h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><h3 id="嵌套列"><a href="#嵌套列" class="headerlink" title="嵌套列"></a>嵌套列</h3><h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><p><strong>$_PS:</strong> push和pull的后面的数字，有没有要求，如果pull的数字，和md的数字之和大于12 ；或者给后面的元素留下的位置不够（加起来超12）呢</p>
<h3 id="Less-mixin-和变量"><a href="#Less-mixin-和变量" class="headerlink" title="Less mixin 和变量"></a>Less mixin 和变量</h3><p>除了用于快速布局的预定义栅格类，Bootstrap 还包含了一组 Less 变量和 mixin 用于帮你生成简单、语义化的布局。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>通过变量来定义列数、槽（gutter）宽、媒体查询阈值（用于确定合适让列浮动）。我们使用这些变量生成预定义的栅格类，如上所示，还有如下所示的定制 mixin。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@grid-columns:</span>              <span class="number">12</span>;</span><br><span class="line"><span class="variable">@grid-gutter-width:</span>         <span class="number">30px</span>;</span><br><span class="line"><span class="variable">@grid-float-breakpoint:</span>     <span class="number">768px</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>mixin 用来和栅格变量一同使用，为每个列（column）生成语义化的 CSS 代码。<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates a wrapper for a series of columns</span></span><br><span class="line"><span class="selector-class">.make-row</span>(<span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="comment">// Then clear the floated columns</span></span><br><span class="line">  <span class="selector-class">.clearfix</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:  (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">margin-right</span>: (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Negative margin nested rows out to align the content of columns</span></span><br><span class="line">  <span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:  (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">margin-right</span>: (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the extra small columns</span></span><br><span class="line"><span class="selector-class">.make-xs-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="comment">// Prevent columns from collapsing when empty</span></span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="comment">// Inner gutter via padding</span></span><br><span class="line">  <span class="attribute">padding-left</span>:  (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate width based on number of columns available</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@grid-float-breakpoint</span>) &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the small columns</span></span><br><span class="line"><span class="selector-class">.make-sm-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the large column offsets</span></span><br><span class="line"><span class="selector-class">.make-lg-column-offset</span>(<span class="variable">@columns</span>) &#123;</span><br></pre></td></tr></table></figure></p>
<h4 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h4><p>你可以重新修改这些变量的值，或者用默认值调用这些 mixin。下面就是一个利用默认设置生成两列布局（列之间有间隔）的案例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  .make-row();</span><br><span class="line">&#125;</span><br><span class="line">.content-main &#123;</span><br><span class="line">  .make-lg-column(8);</span><br><span class="line">&#125;</span><br><span class="line">.content-secondary &#123;</span><br><span class="line">  .make-lg-column(3);</span><br><span class="line">  .make-lg-column-offset(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-main"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-secondary"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="三-排版"><a href="#三-排版" class="headerlink" title="三 排版"></a>三 排版</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>还提供了 .h1 到 .h6 类，为的是给内联（inline）属性的文本赋予标题的样式。<br>在标题内还可以包含 <code>&lt;small&gt;</code> 标签或赋予 .small 类的元素，可以用来标记副标题。</p>
<h3 id="页面主体"><a href="#页面主体" class="headerlink" title="页面主体"></a>页面主体</h3><p>Bootstrap 将全局 font-size 设置为 14px，line-height 设置为 1.428。这些属性直接赋予 <code>&lt;body&gt;</code> 元素和所有段落元素。另外，<code>&lt;p&gt;</code> （段落）元素还被设置了等于 1/2 行高（即 10px）的底部外边距（margin）。</p>
<h4 id="中心内容"><a href="#中心内容" class="headerlink" title="中心内容"></a>中心内容</h4><p>通过添加 .lead 类可以让段落突出显示。</p>
<h4 id="使用-Less-工具构建"><a href="#使用-Less-工具构建" class="headerlink" title="使用 Less 工具构建"></a>使用 Less 工具构建</h4><p>variables.less 文件中定义的两个 Less 变量决定了排版尺寸：@font-size-base 和 @line-height-base。第一个变量定义了全局 font-size 基准，第二个变量是 line-height 基准。我们使用这些变量和一些简单的公式计算出其它所有页面元素的 margin、 padding 和 line-height。自定义这些变量即可改变 Bootstrap 的默认样式。</p>
<h3 id="内联文本元素"><a href="#内联文本元素" class="headerlink" title="内联文本元素"></a>内联文本元素</h3><ol>
<li>Marked text<br>For highlighting a run of text due to its relevance in another context, use the <code>&lt;mark&gt;</code> tag.</li>
<li>被删除的文本<br>对于被删除的文本使用 <code>&lt;del&gt;</code> 标签。</li>
<li>无用文本<br>对于没用的文本使用 <code>&lt;s&gt;</code> 标签。</li>
<li>插入文本<br>额外插入的文本使用 <code>&lt;ins&gt;</code> 标签。</li>
<li>带下划线的文本<br>为文本添加下划线，使用 <code>&lt;u&gt;</code> 标签。<br>利用 HTML 自带的表示强调意味的标签来为文本增添少量样式。</li>
<li><p>小号文本<br>对于不需要强调的inline或block类型的文本，使用 <code>&lt;small&gt;</code> 标签包裹，其内的文本将被设置为父容器字体大小的 85%。标题元素中嵌套的 <code>&lt;small&gt;</code> 元素被设置不同的 font-size 。<br>你还可以为行内元素赋予 .small 类以代替任何 <code>&lt;small&gt;</code> 元素。</p>
</li>
<li><p>着重<br>通过增加 font-weight 值强调一段文本。<code>&lt;strong&gt;</code></p>
</li>
<li><p>斜体<br>用斜体强调一段文本。<code>&lt;em&gt;</code></p>
<blockquote>
<p>Alternate elements<br>在 HTML5 中可以放心使用 <b> 和 <i> 标签。<b> 用于高亮单词或短语，不带有任何着重的意味；而 <i> 标签主要用于发言、技术词汇等。</i></b></i></b></p>
</blockquote>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p> </p><p class="text-left">Left aligned text.</p><br> <p class="text-center">Center aligned text.</p><br> <p class="text-right">Right aligned text.</p><br> <p class="text-justify">Justified text.</p><br> <p class="text-nowrap">No wrap text.</p><p></p>
<h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><p> </p><p class="text-lowercase">Lowercased text.</p><br> <p class="text-uppercase">Uppercased text.</p><br> <p class="text-capitalize">Capitalized text.</p><p></p>
<h3 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h3><p>当鼠标悬停在缩写和缩写词上时就会显示完整内容，Bootstrap 实现了对 HTML 的 <code>&lt;abbr&gt;</code> 元素的增强样式。缩略语元素带有 title 属性，外观表现为带有较浅的虚线框，鼠标移至上面时会变成带有“问号”的指针。如想看完整的内容可把鼠标悬停在缩略语上（对使用辅助技术的用户也可见）, 但需要包含 title 属性。</p>
<h4 id="基本缩略语"><a href="#基本缩略语" class="headerlink" title="基本缩略语"></a>基本缩略语</h4><h4 id="首字母缩略语"><a href="#首字母缩略语" class="headerlink" title="首字母缩略语"></a>首字母缩略语</h4><p>为缩略语添加 .initialism 类，可以让 font-size 变得稍微小些。</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>让联系信息以最接近日常使用的格式呈现。在每行结尾添加 <code>&lt;br&gt;</code> 可以保留需要的样式。</p>
 <address><br>     <strong>Twitter, Inc.</strong><br><br>     1355 Market Street, Suite 900<br><br>     San Francisco, CA 94103<br><br>     <abbr title="Phone">P:</abbr> (123) 456-7890<br> </address>

<p> <address></address></p>
<pre><code>&lt;strong&gt;Full Name&lt;/strong&gt;&lt;br&gt;
&lt;a href=&quot;mailto:#&quot;&gt;first.last@example.com&lt;/a&gt;
</code></pre><p> </p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="默认样式的引用"><a href="#默认样式的引用" class="headerlink" title="默认样式的引用"></a>默认样式的引用</h4><p>将任何 HTML 元素包裹在 <code>&lt;blockquote&gt;</code> 中即可表现为引用样式。对于直接引用，我们建议用 <code>&lt;p&gt;</code> 标签。</p>
<h4 id="多种引用样式"><a href="#多种引用样式" class="headerlink" title="多种引用样式"></a>多种引用样式</h4><p>对于标准样式的 <code>&lt;blockquote&gt;</code>，可以通过几个简单的变体就能改变风格和内容。</p>
</li>
<li>命名来源<br>添加 <code>&lt;footer&gt;</code> 用于标明引用来源。来源的名称可以包裹进 <code>&lt;cite&gt;</code>标签中。</li>
<li><p>另一种展示风格<br>通过赋予 .blockquote-reverse 类可以让引用呈现内容右对齐的效果。</p>
<p> <blockquote class="blockquote-reverse"></blockquote></p>
<pre><code>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt;
&lt;footer&gt;Someone famous in &lt;cite title=&quot;Source Title&quot;&gt;Source Title&lt;/cite&gt;&lt;/footer&gt;
</code></pre><p> </p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><h4 id="无样式列表"><a href="#无样式列表" class="headerlink" title="无样式列表"></a>无样式列表</h4><p><code>&lt;ul class=&quot;list-unstyled&quot;&gt;</code><br>移除了默认的 list-style 样式和左侧外边距的一组元素（只针对直接子元素）。<br>这是针对直接子元素的，也就是说，你需要对所有嵌套的列表都添加这个类才能具有同样的样式。</p>
<h4 id="内联列表"><a href="#内联列表" class="headerlink" title="内联列表"></a>内联列表</h4><p><code>&lt;ul class=&quot;list-inline&quot;&gt;</code><br>通过设置 display: inline-block; 并添加少量的内补（padding），将所有元素放置于同一行。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>带有描述的短语列表。</p>
</li>
<li>水平排列的描述<br>.dl-horizontal 可以让 <code>&lt;dl&gt;</code> 内的短语及其描述排在一行。开始是像 <code>&lt;dl&gt;</code> 的默认样式堆叠在一起，随着导航条逐渐展开而排列在一行。<blockquote>
<p>自动截断<br>通过 text-overflow 属性，水平排列的描述列表将会截断左侧太长的短语。在较窄的视口（viewport）内，列表将变为默认堆叠排列的布局方式。</p>
</blockquote>
</li>
</ol>
<h2 id="四-代码"><a href="#四-代码" class="headerlink" title="四 代码"></a>四 代码</h2><h3 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h3><p>通过 <code>&lt;code&gt;</code> 标签包裹内联样式的代码片段。</p>
<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>通过 <code>&lt;kbd&gt;</code> 标签标记用户通过键盘输入的内容。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>多行代码可以使用 <code>&lt;pre&gt;</code> 标签。为了正确的展示代码，注意将尖括号做转义处理</p>
<pre><code>&lt;p&gt;Sample text here...&lt;/p&gt;
&lt;pre&gt;&amp;lt;p&amp;gt;Sample text here...&amp;lt;/p&amp;gt;&lt;/pre&gt;
</code></pre><p>还可以使用 .pre-scrollable 类，其作用是设置 max-height 为 350px ，并在垂直方向展示滚动条。</p>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p>通过 <code>&lt;var&gt;</code> 标签标记变量。</p>
<h3 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h3><p>通过 <code>&lt;samp&gt;</code> 标签来标记程序输出的内容。</p>
<h2 id="五-表格"><a href="#五-表格" class="headerlink" title="五 表格"></a>五 表格</h2><h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p>为任意 <code>&lt;table&gt;</code> 标签添加 .table 类可以为其赋予基本的样式 — 少量的内补（padding）和水平方向的分隔线。<br>这种方式看起来很多余！？但是我们觉得，表格元素使用的很广泛，如果我们为其赋予默认样式可能会影响例如日历和日期选择之类的插件，所以我们选择将此样式独立出来。</p>
<h2 id="条纹状表格"><a href="#条纹状表格" class="headerlink" title="条纹状表格"></a>条纹状表格</h2><p>通过 .table-striped 类可以给 <tbody> 之内的每一行增加斑马条纹样式。</tbody></p>
<blockquote>
<p>跨浏览器兼容性<br>条纹状表格是依赖 :nth-child CSS 选择器实现的，而这一功能不被 Internet Explorer 8 支持。</p>
</blockquote>
<h2 id="带边框的表格"><a href="#带边框的表格" class="headerlink" title="带边框的表格"></a>带边框的表格</h2><p>添加 .table-bordered 类为表格和其中的每个单元格增加边框。</p>
<h2 id="鼠标悬停"><a href="#鼠标悬停" class="headerlink" title="鼠标悬停"></a>鼠标悬停</h2><p>通过添加 .table-hover 类可以让 <tbody> 中的每一行对鼠标悬停状态作出响应。</tbody></p>
<h2 id="紧缩表格"><a href="#紧缩表格" class="headerlink" title="紧缩表格"></a>紧缩表格</h2><p>通过添加 .table-condensed 类可以让表格更加紧凑，单元格中的内补（padding）均会减半。</p>
<h2 id="状态类"><a href="#状态类" class="headerlink" title="状态类"></a>状态类</h2><p>.active     .success    .info    .warning    .danger    </p>
<blockquote>
<p>向使用辅助技术的用户传达用意<br>通过为表格中的一行或一个单元格添加颜色而赋予不同的意义只是提供了一种视觉上的表现，并不能为使用辅助技术 – 例如屏幕阅读器 – 浏览网页的用户提供更多信息。因此，请确保通过颜色而赋予的不同意义可以通过内容本身来表达（即在相应行或单元格中的可见的文本内容）；或者通过包含额外的方式 – 例如应用了 .sr-only 类而隐藏的文本 – 来表达出来。</p>
</blockquote>
<h2 id="响应式表格"><a href="#响应式表格" class="headerlink" title="响应式表格"></a>响应式表格</h2><p>将任何 .table 元素包裹在 .table-responsive 元素内，即可创建响应式表格，其会在小屏幕设备上（小于768px）水平滚动。当屏幕大于 768px 宽度时，水平滚动条消失。</p>
<blockquote>
<p>垂直方向的内容截断<br>响应式表格使用了 overflow-y: hidden 属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件。<br><strong>$_PS</strong> 不明白<br>Firefox 和 fieldset 元素<br>Firefox 浏览器对 fieldset 元素设置了一些影响 width 属性的样式，导致响应式表格出现问题。可以使用下面提供的针对 Firefox 的 hack 代码解决，但是以下代码并未集成在 Bootstrap 中：</p>
<pre><code>@-moz-document url-prefix() {
     fieldset { display: table-cell; }
}
</code></pre></blockquote>
<h2 id="六-表单"><a href="#六-表单" class="headerlink" title="六 表单"></a>六 表单</h2><h3 id="基本实例-1"><a href="#基本实例-1" class="headerlink" title="基本实例"></a>基本实例</h3><p>单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 元素都将被默认设置宽度属性为 width: 100%;。 将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。</p>
<blockquote>
<p>不要将表单组和输入框组混合使用<br>不要将表单组直接和输入框组混合使用。建议将输入框组嵌套到表单组中使用。</p>
</blockquote>
<h3 id="内联表单"><a href="#内联表单" class="headerlink" title="内联表单"></a>内联表单</h3><p>为 <code>&lt;form&gt;</code> 元素添加 .form-inline 类可使其内容左对齐并且表现为 inline-block 级别的控件。只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）。</p>
<blockquote>
<p>可能需要手动设置宽度<br>在 Bootstrap 中，输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为 width: auto;，因此，多个控件可以排列在同一行。根据你的布局需求，可能需要一些额外的定制化组件。</p>
</blockquote>
<blockquote>
<p>一定要添加 label 标签<br>如果你没有为每个输入控件设置 label 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 label 设置 .sr-only 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 aria-label、aria-labelledby 或 title 属性。如果这些都不存在，屏幕阅读器可能会采取使用 placeholder 属性，如果存在的话，使用占位符来替代其他的标记，但要注意，这种方法是不妥当的。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">for</span>=<span class="string">"exampleInputEmail3"</span>&gt;</span>Email address<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"exampleInputEmail3"</span> <span class="attr">placeholder</span>=<span class="string">"Email"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">for</span>=<span class="string">"exampleInputPassword3"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"exampleInputPassword3"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span> Remember me</span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="水平排列的表单"><a href="#水平排列的表单" class="headerlink" title="水平排列的表单"></a>水平排列的表单</h3><p>通过为表单添加 .form-horizontal 类，并联合使用 Bootstrap 预置的栅格类，可以将 label 标签和控件组水平并排布局。这样做将改变 .form-group 的行为，使其表现为栅格系统中的行（row），因此就无需再额外添加 .row 了。<br><strong>$_PS:</strong> 三者区分</p>
<ol start="0">
<li>默认 .form label一行，表单控件一行</li>
<li>.form-inline:display:inline-block;表现为一行（小屏还会折叠） </li>
<li>.form-horizontal      一个 lable和控件一行；默认的是全部都占一行；inline，全部都是行内</li>
<li>.form-control 控件添加的，width:100%</li>
<li>.form-group 包含表单控件，标签的div</li>
</ol>
<h3 id="被支持的控件"><a href="#被支持的控件" class="headerlink" title="被支持的控件"></a>被支持的控件</h3><p>表单布局实例中展示了其所支持的标准表单控件。</p>
<h4 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h4><p>包括大部分表单控件、文本输入域控件，还支持所有 HTML5 类型的输入控件： text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel 和 color。</p>
<blockquote>
<p>必须添加类型声明<br>只有正确设置了 type 属性的输入控件才能被赋予正确的样式。</p>
</blockquote>
<h4 id="输入控件组"><a href="#输入控件组" class="headerlink" title="输入控件组"></a>输入控件组</h4><p>如需在文本输入域 <code>&lt;input&gt;</code> 前面或后面添加文本内容或按钮控件，请参考输入控件组。</p>
<h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>支持多行文本的表单控件。可根据需要改变 rows 属性。</p>
<h4 id="多选和单选框"><a href="#多选和单选框" class="headerlink" title="多选和单选框"></a>多选和单选框</h4><p>多选框（checkbox）用于选择列表中的一个或多个选项，而单选框（radio）用于从多个选项中只选择一个。</p>
<ol>
<li>默认外观（堆叠在一起）</li>
<li>内联单选和多选框<br>通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。</li>
<li>不带label文本的Checkbox 和 radio<br>如果需要 <code>&lt;label&gt;</code> 内没有文字，输入框（input）正是你所期望的。 目前只适用于非内联的 checkbox 和 radio。 请记住，仍然需要为使用辅助技术的用户提供某种形式的 label（例如，使用 aria-label）。<h4 id="下拉列表（select）"><a href="#下拉列表（select）" class="headerlink" title="下拉列表（select）"></a>下拉列表（select）</h4>注意，很多原生选择菜单 - 即在 Safari 和 Chrome 中 - 的圆角是无法通过修改 border-radius 属性来改变的。</li>
</ol>
<h3 id="静态控件"><a href="#静态控件" class="headerlink" title="静态控件"></a>静态控件</h3><p>如果需要在表单中将一行纯文本和 label 元素放置于同一行，为 <code>&lt;p&gt;</code> 元素添加 .form-control-static 类即可。</p>
<h3 id="焦点状态"><a href="#焦点状态" class="headerlink" title="焦点状态"></a>焦点状态</h3><p>我们将某些表单控件的默认 outline 样式移除，然后对 :focus 状态赋予 box-shadow 属性。</p>
<h3 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h3><p>为输入框设置 disabled 属性可以禁止其与用户有任何交互（焦点、输入等）。<br>被禁用的输入框颜色更浅，并且还添加了 not-allowed 鼠标状态。</p>
<h4 id="被禁用的-fieldset"><a href="#被禁用的-fieldset" class="headerlink" title="被禁用的 fieldset"></a>被禁用的 fieldset</h4><p>为<code>&lt;fieldset&gt;</code> 设置 disabled 属性,可以禁用 <code>&lt;fieldset&gt;</code> 中包含的所有控件。</p>
<blockquote>
<p><code>&lt;a&gt;</code> 标签的链接功能不受影响<br>默认情况下，浏览器会将 <code>&lt;fieldset disabled&gt;</code> 内所有的原生的表单控件（<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code> 元素）设置为禁用状态，防止键盘和鼠标与他们交互。然而，如果表单中还包含 <code>&lt;a ... class=&quot;btn btn-*&quot;&gt;</code> 元素，这些元素将只被赋予 pointer-events: none 属性。正如在关于 禁用状态的按钮 章节中（尤其是关于锚点元素的子章节中）所描述的那样，该 CSS 属性尚不规范，并且在 Opera 18 及更低版本的浏览器或 Internet Explorer 11 总没有得到全面支持，并且不会阻止键盘用户能够获取焦点或激活这些链接。所以为了安全起见，建议使用自定义 JavaScript 来禁用这些链接。<br><strong>$_PS:</strong> 不明白</p>
</blockquote>
<blockquote>
<p>跨浏览器兼容性<br>虽然 Bootstrap 会将这些样式应用到所有浏览器上，Internet Explorer 11 及以下浏览器中的 <code>&lt;fieldset&gt;</code> 元素并不完全支持 disabled 属性。因此建议在这些浏览器上通过 JavaScript 代码来禁用 <code>&lt;fieldset&gt;</code>。</p>
</blockquote>
<h3 id="只读状态"><a href="#只读状态" class="headerlink" title="只读状态"></a>只读状态</h3><h3 id="Help-text"><a href="#Help-text" class="headerlink" title="Help text"></a>Help text</h3><pre><code>&lt;label class=&quot;sr-only&quot; for=&quot;inputHelpBlock&quot;&gt;Input with help text&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;inputHelpBlock&quot; class=&quot;form-control&quot; aria-describedby=&quot;helpBlock&quot;&gt;
...
&lt;span id=&quot;helpBlock&quot; class=&quot;help-block&quot;&gt;A block of help text that breaks onto a new line and may extend beyond one line.&lt;/span&gt;
</code></pre><p></p><p style="text-align:right">13:23</p><p></p>
<p></p><p style="text-align:right">16:14</p><p></p>
<h3 id="校验状态"><a href="#校验状态" class="headerlink" title="校验状态"></a>校验状态</h3><p>Bootstrap 对表单控件的校验状态，如 error、warning 和 success 状态，都定义了样式。使用时，添加 .has-warning、.has-error 或 .has-success 类到这些控件的父元素即可。任何包含在此元素之内的 .control-label、.form-control 和 .help-block 元素都将接受这些校验状态的样式。</p>
<blockquote>
<p>将验证状态传达给辅助设备和盲人用户<br>使用这些校验样式只是为表单控件提供一个可视的、基于色彩的提示，但是并不能将这种提示信息传达给使用辅助设备的用户 - 例如屏幕阅读器 - 或者色盲用户。</p>
<p>为了确保所有用户都能获取正确信息，Bootstrap 还提供了另一种提示方式。例如，你可以在表单控件的 <code>&lt;label&gt;</code> 标签上以文本的形式显示提示信息（就像下面代码中所展示的）；包含一个 Glyphicon 字体图标 （还有赋予 .sr-only 类的文本信息 - 参考Glyphicon 字体图标实例）；或者提供一个额外的 辅助信息 块。另外，对于使用辅助设备的用户，无效的表单控件还可以赋予一个 aria-invalid=”true” 属性。</p>
</blockquote>
<h4 id="添加额外的图标"><a href="#添加额外的图标" class="headerlink" title="添加额外的图标"></a>添加额外的图标</h4><p>你还可以针对校验状态为输入框添加额外的图标。只需设置相应的 .has-feedback 类并添加正确的图标即可。<br>反馈图标（feedback icon）只能使用在文本输入框 <code>&lt;input class=&quot;form-control&quot;&gt;</code> 元素上。</p>
<blockquote>
<p>图标、label 和输入控件组<br>对于不带有 label 标签的输入框以及右侧带有附加组件的输入框组，需要手动为其图标定位。为了让所有用户都能访问你的网站，我们强烈建议为所有输入框添加 label 标签。如果你不希望将 label 标签展示出来，可以通过添加 .sr-only 类来实现。如果的确不能添加 label 标签，请调整图标的 top 值。对于输入框组，请根据你的实际情况调整 right 值。</p>
</blockquote>
<blockquote>
<p>向辅助技术设备传递图标的含义<br>为了确保辅助技术- 如屏幕阅读器 - 正确传达一个图标的含义，额外的隐藏的文本应包含在 .sr-only 类中，并明确关联使用了 aria-describedby 的表单控件。或者，以某些其他形式（例如，文本输入字段有一个特定的警告信息）传达含义，例如改变与表单控件实际相关联的 <code>&lt;label&gt;</code> 的文本。</p>
<p>虽然下面的例子已经提到各自表单控件本身的 <code>&lt;label&gt;</code> 文本的验证状态，上述技术（使用 .sr-only 文本 和 aria-describedby) ）已经包括了需要说明的目的。</p>
</blockquote>
<ol>
<li>为水平排列的表单和内联表单设置可选的图标</li>
<li>可选的图标与设置 .sr-only 类的 label<br>如果你使用 .sr-only 类来隐藏表单控件的 <code>&lt;label&gt;</code> （而不是使用其它标签选项，如 aria-label 属性）， 一旦它被添加，Bootstrap 会自动调整图标的位置。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-horizontal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group has-success has-feedback"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"control-label col-sm-3"</span> <span class="attr">for</span>=<span class="string">"inputSuccess3"</span>&gt;</span>Input with success<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-9"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputSuccess3"</span> <span class="attr">aria-describedby</span>=<span class="string">"inputSuccess3Status"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-ok form-control-feedback"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inputSuccess3Status"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(success)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group has-success has-feedback"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"control-label col-sm-3"</span> <span class="attr">for</span>=<span class="string">"inputGroupSuccess2"</span>&gt;</span>Input group with success<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-9"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span>@<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputGroupSuccess2"</span> <span class="attr">aria-describedby</span>=<span class="string">"inputGroupSuccess2Status"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-ok form-control-feedback"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inputGroupSuccess2Status"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(success)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="控件尺寸"><a href="#控件尺寸" class="headerlink" title="控件尺寸"></a>控件尺寸</h3><p>通过 .input-lg 类似的类可以为控件设置高度，通过 .col-lg-* 类似的类可以为控件设置宽度。</p>
<h4 id="高度尺寸"><a href="#高度尺寸" class="headerlink" title="高度尺寸"></a>高度尺寸</h4><h4 id="水平排列的表单组的尺寸"><a href="#水平排列的表单组的尺寸" class="headerlink" title="水平排列的表单组的尺寸"></a>水平排列的表单组的尺寸</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-horizontal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group form-group-lg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span> <span class="attr">for</span>=<span class="string">"formGroupInputLarge"</span>&gt;</span>Large label<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"formGroupInputLarge"</span> <span class="attr">placeholder</span>=<span class="string">"Large input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group form-group-sm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span> <span class="attr">for</span>=<span class="string">"formGroupInputSmall"</span>&gt;</span>Small label<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"formGroupInputSmall"</span> <span class="attr">placeholder</span>=<span class="string">"Small input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="调整列（column）尺寸"><a href="#调整列（column）尺寸" class="headerlink" title="调整列（column）尺寸"></a>调整列（column）尺寸</h4><p>用栅格系统中的列（column）包裹输入框或其任何父元素，都可很容易的为其设置宽度。</p>
<h2 id="七-按钮"><a href="#七-按钮" class="headerlink" title="七 按钮"></a>七 按钮</h2><h3 id="可作为按钮使用的标签或元素"><a href="#可作为按钮使用的标签或元素" class="headerlink" title="可作为按钮使用的标签或元素"></a>可作为按钮使用的标签或元素</h3><p>为 <code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code> 元素添加按钮类（button class）即可使用 Bootstrap 提供的样式。</p>
<blockquote>
<p>针对组件的注意事项<br>虽然按钮类可以应用到 <code>&lt;a&gt;</code> 和 <code>&lt;button&gt;</code> 元素上，但是，导航和导航条组件只支持 <code>&lt;button&gt;</code> 元素。</p>
</blockquote>
<blockquote>
<p>链接被作为按钮使用时的注意事项<br>如果 <code>&lt;a&gt;</code> 元素被作为按钮使用 – 并用于在当前页面触发某些功能 – 而不是用于链接其他页面或链接当前页面中的其他部分，那么，务必为其设置 role=”button” 属性。</p>
</blockquote>
<blockquote>
<p>跨浏览器展现<br>我们总结的最佳实践是：强烈建议尽可能使用 <code>&lt;button&gt;</code> 元素来获得在各个浏览器上获得相匹配的绘制效果。</p>
<p>另外，我们还发现了 Firefox &lt;30 版本的浏览器上出现的一个 bug，其表现是：阻止我们为基于 <code>&lt;input&gt;</code> 元素所创建的按钮设置 line-height 属性，这就导致在 Firefox 浏览器上不能完全和其他按钮保持一致的高度。</p>
</blockquote>
<h3 id="预定义样式"><a href="#预定义样式" class="headerlink" title="预定义样式"></a>预定义样式</h3><p>（首选项）Primary  （成功）Success  （一般信息）Info （警告）Warning  （危险）Danger  （链接）Link</p>
<blockquote>
<p>Conveying meaning to assistive technologies<br>为按钮添加不同的颜色只是一种视觉上的信息表达方式，但是，对于使用辅助技术 – 例如屏幕阅读器 – 的用户来说，颜色是不可见的。建议，确保通过颜色表达的信息或者通过内容自身表达出来（按钮上的文字），或者通过其他方式 – 例如通过 .sr-only 类隐藏的额外文本 – 表达出来。</p>
</blockquote>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>需要让按钮具有不同尺寸吗？使用 .btn-lg、.btn-sm 或 .btn-xs 就可以获得不同尺寸的按钮。<br>通过给按钮添加 .btn-block 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素。</p>
<h3 id="激活状态"><a href="#激活状态" class="headerlink" title="激活状态"></a>激活状态</h3><p>当按钮处于激活状态时，其表现为被按压下去（底色更深、边框夜色更深、向内投射阴影）。<br>对于 <code>&lt;button&gt;</code> 元素，是通过 :active 状态实现的。<br>对于 <code>&lt;a&gt;</code> 元素，是通过 .active 类实现的。然而，你还可以将 .active 应用到 <code>&lt;button&gt;</code> 上（包含 aria-pressed=”true” 属性)），并通过编程的方式使其处于激活状态。</p>
<h3 id="禁用状态-1"><a href="#禁用状态-1" class="headerlink" title="禁用状态"></a>禁用状态</h3><p>通过为按钮的背景设置 opacity 属性就可以呈现出无法点击的效果。</p>
<ol>
<li>button 元素<br>为 <code>&lt;button&gt;</code> 元素添加 disabled 属性，使其表现出禁用状态。<blockquote>
<p>跨浏览器兼容性<br>如果为 <code>&lt;button&gt;</code> 元素添加 disabled 属性，Internet Explorer 9 及更低版本的浏览器将会把按钮中的文本绘制为灰色，并带有恶心的阴影，目前我们还没有解决办法。</p>
</blockquote>
</li>
<li>链接元素<br>为基于 <code>&lt;a&gt;</code> 元素创建的按钮添加 .disabled 类。</li>
</ol>
<p>我们把 .disabled 作为工具类使用，就像 .active 类一样，因此不需要增加前缀。</p>
<blockquote>
<p>链接的原始功能不受影响<br>上面提到的类只是通过设置 pointer-events: none 来禁止 <code>&lt;a&gt;</code> 元素作为链接的原始功能，但是，这一 CSS 属性并没有被标准化，并且 Opera 18 及更低版本的浏览器并没有完全支持这一属性，同样，Internet Explorer 11 也不支持。In addition, even in browsers that do support pointer-events: none, keyboard navigation remains unaffected, meaning that sighted keyboard users and users of assistive technologies will still be able to activate these links. 因此，为了安全起见，建议通过 JavaScript 代码来禁止链接的原始功能。</p>
</blockquote>
<p><strong>$_PS:</strong> 总结，都用button就ok了</p>
<h2 id="八-图片"><a href="#八-图片" class="headerlink" title="八 图片"></a>八 图片</h2><h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3><p>在 Bootstrap 版本 3 中，通过为图片添加 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。</p>
<p>如果需要让使用了 .img-responsive 类的图片水平居中，请使用 .center-block 类，不要用 .text-center。 请参考助手类章节 了解更多关于 .center-block 的用法。</p>
<blockquote>
<p>SVG 图像和 IE 8-10<br>在 Internet Explorer 8-10 中，设置为 .img-responsive 的 SVG 图像显示出的尺寸不匀称。为了解决这个问题，在出问题的地方添加 width: 100% \9; 即可。Bootstrap 并没有自动为所有图像元素设置这一属性，因为这会导致其他图像格式出现错乱。</p>
</blockquote>
<h3 id="图片形状"><a href="#图片形状" class="headerlink" title="图片形状"></a>图片形状</h3><p>img-rounded img-circle img-thumbnail</p>
<blockquote>
<p>跨浏览器兼容性<br>请时刻牢记：Internet Explorer 8 不支持 CSS3 中的圆角属性。</p>
</blockquote>
<h2 id="九-辅助类"><a href="#九-辅助类" class="headerlink" title="九 辅助类"></a>九 辅助类</h2><h3 id="情境文本颜色"><a href="#情境文本颜色" class="headerlink" title="情境文本颜色"></a>情境文本颜色</h3><pre><code>&lt;p class=&quot;text-muted&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;text-primary&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;text-success&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;text-info&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;text-warning&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;text-danger&quot;&gt;...&lt;/p&gt;
</code></pre><h3 id="情境背景色"><a href="#情境背景色" class="headerlink" title="情境背景色"></a>情境背景色</h3><pre><code>&lt;p class=&quot;bg-primary&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;bg-success&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;bg-info&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;bg-warning&quot;&gt;...&lt;/p&gt;
&lt;p class=&quot;bg-danger&quot;&gt;...&lt;/p&gt;
</code></pre><h3 id="关闭按钮"><a href="#关闭按钮" class="headerlink" title="关闭按钮"></a>关闭按钮</h3><pre><code>&lt;button type=&quot;button&quot; class=&quot;close&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
</code></pre><p><strong>$_PS:</strong> todo    </p>
<h3 id="三角符号"><a href="#三角符号" class="headerlink" title="三角符号"></a>三角符号</h3><pre><code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
</code></pre><p>通过使用三角符号可以指示某个元素具有下拉菜单的功能。注意，向上弹出式菜单中的三角符号是反方向的。   </p>
<h3 id="快速浮动"><a href="#快速浮动" class="headerlink" title="快速浮动"></a>快速浮动</h3><pre><code>// Classes
.pull-left {
    float: left !important;
}
.pull-right {
    float: right !important;
}

// Usage as mixins
.element {
    .pull-left();
}
.another-element {
    .pull-right();
}
</code></pre><blockquote>
<p>不能用于导航条组件中<br>排列导航条中的组件时可以使用这些工具类：.navbar-left 或 .navbar-right 。 参见导航条文档以获取更多信息。    </p>
</blockquote>
<h3 id="让内容块居中"><a href="#让内容块居中" class="headerlink" title="让内容块居中"></a>让内容块居中</h3><pre><code>// Class
.center-block {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

// Usage as a mixin
.element {
    .center-block();
}
</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>通过为父元素添加 .clearfix 类可以很容易地清除浮动（float）。这里所使用的是 Nicolas Gallagher 创造的 micro clearfix 方式。此类还可以作为 mixin 使用。</p>
<pre><code>// Mixin itself
.clearfix() {
    &amp;:before,
    &amp;:after {
        content: &quot; &quot;;
        display: table;
    }
    &amp;:after {
        clear: both;
    }
}

// Usage as a mixin
.element {
    .clearfix();
}
</code></pre><h3 id="显示或隐藏内容"><a href="#显示或隐藏内容" class="headerlink" title="显示或隐藏内容"></a>显示或隐藏内容</h3><p>.show 和 .hidden 类可以强制任意元素显示或隐藏(对于屏幕阅读器也能起效)。这些类通过 !important 来避免 CSS 样式优先级问题，就像 quick floats 一样的做法。注意，这些类只对块级元素起作用，另外，还可以作为 mixin 使用。</p>
<p>.hide 类仍然可用，但是它不能对屏幕阅读器起作用，并且从 v3.0.1 版本开始就不建议使用了。请使用 .hidden 或 .sr-only 。</p>
<p>另外，.invisible 类可以被用来仅仅影响元素的可见性，也就是说，元素的 display 属性不被改变，并且这个元素仍然能够影响文档流的排布。</p>
<h3 id="屏幕阅读器和键盘导航"><a href="#屏幕阅读器和键盘导航" class="headerlink" title="屏幕阅读器和键盘导航"></a>屏幕阅读器和键盘导航</h3><p>.sr-only 类可以对屏幕阅读器以外的设备隐藏内容。.sr-only 和 .sr-only-focusable 联合使用的话可以在元素有焦点的时候再次显示出来（例如，使用键盘导航的用户）。对于遵循 可访问性的最佳实践 很有必要。这个类也可以作为 mixin 使用。</p>
<h3 id="图片替换"><a href="#图片替换" class="headerlink" title="图片替换"></a>图片替换</h3><p>使用 .text-hide 类或对应的 mixin 可以用来将元素的文本内容替换为一张背景图。</p>
<h2 id="十-响应式工具"><a href="#十-响应式工具" class="headerlink" title="十 响应式工具"></a>十 响应式工具</h2><h3 id="可用的类"><a href="#可用的类" class="headerlink" title="可用的类"></a>可用的类</h3><p>.visible-lg-*    .hidden-xs</p>
<p>从 v3.2.0 版本起，形如 .visible-<em>-</em> 的类针对每种屏幕大小都有了三种变体，每个针对 CSS 中不同的 display 属性，列表如下：</p>
<p>因此，以超小屏幕（xs）为例，可用的 .visible-<em>-</em> 类是：.visible-xs-block、.visible-xs-inline 和 .visible-xs-inline-block。</p>
<p>.visible-xs、.visible-sm、.visible-md 和 .visible-lg 类也同时存在。但是从 v3.2.0 版本开始不再建议使用。除了 <table> 相关的元素的特殊情况外，它们与 .visible-*-block 大体相同。</table></p>
<h3 id="打印类"><a href="#打印类" class="headerlink" title="打印类"></a>打印类</h3><p>.visible-print-block  .visible-print-inline  .visible-print-inline-block<br>.hidden-print    </p>
<p>.visible-print 类也是存在的，但是从 v3.2.0 版本开始不建议使用。它与 .visible-print-block 类大致相同，除了 <table> 相关元素的特殊情况外。</table></p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><h2 id="一-使用-Less"><a href="#一-使用-Less" class="headerlink" title="一 使用 Less"></a>一 使用 Less</h2><p>Bootstrap 的 CSS 文件是通过 Less 源码编译而来的。<br>Less 是一门预处理语言，支持变量、mixin、函数等额外功能。<br>对于希望使用 Less 源码而非编译而来的 CSS 文件的用户，Bootstrap 框架中包含的大量变量、mixin 将非常有价值。</p>
<h3 id="编译-Bootstrap"><a href="#编译-Bootstrap" class="headerlink" title="编译 Bootstrap"></a>编译 Bootstrap</h3><h3 id="变量-2"><a href="#变量-2" class="headerlink" title="变量"></a>变量</h3><p>整个 Bootstrap 项目中使用了大量的变量，这些变量被用来代表颜色、空白（内部、边距）、字体等。详细内容请参考定制工具。</p>
<ol>
<li>颜色<br>Bootstrap 使用了两种颜色模式：灰度颜色和语义颜色。灰度颜色用于快速获取常用的黑色色调；语义颜色包含了各种赋予语义的颜色值。</li>
<li>Scaffolding</li>
<li>链接</li>
<li>排版</li>
<li>图标</li>
<li>组件</li>
</ol>
<h3 id="针对特定厂商的-mixin"><a href="#针对特定厂商的-mixin" class="headerlink" title="针对特定厂商的 mixin"></a>针对特定厂商的 mixin</h3><h4 id="Box-sizing"><a href="#Box-sizing" class="headerlink" title="Box-sizing"></a>Box-sizing</h4><p>通过这一个 mixin 来为所有组件设置盒模型。请参考这篇 来自 Mozilla 的文章。</p>
<p>此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。</p>
<pre><code>.box-sizing(@box-model) {
    -webkit-box-sizing: @box-model; // Safari &lt;= 5
        -moz-box-sizing: @box-model; // Firefox &lt;= 19
            box-sizing: @box-model;
}
</code></pre><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p>现在，所有现代浏览器都支持不带厂商前缀的 border-radius 属性了。有鉴于此，我们没有提供 .border-radius() mixin，但是，Bootstrap does 提供了用于快速设置同一侧圆角的 mixin 。</p>
<pre><code>.border-top-radius(@radius) {
    border-top-right-radius: @radius;
    border-top-left-radius: @radius;
}
.border-right-radius(@radius) {
    border-bottom-right-radius: @radius;
        border-top-right-radius: @radius;
}
.border-bottom-radius(@radius) {
    border-bottom-right-radius: @radius;
    border-bottom-left-radius: @radius;
}
.border-left-radius(@radius) {
    border-bottom-left-radius: @radius;
        border-top-left-radius: @radius;
}
</code></pre><h4 id="Box-Drop-隐形"><a href="#Box-Drop-隐形" class="headerlink" title="Box (Drop) 隐形"></a>Box (Drop) 隐形</h4><p>如果你的目标用户使用的是最新版本和更高级的浏览器和设备，只需单独使用 box-shadow 属性即可。如果你需要兼容较老的 Android (低于 v4) 和 iOS 设备 (低于 iOS 5)，可以使用下面这个 不建议使用 的 mixin，便于帮你添加 -webkit 前缀。</p>
<p>由于 Bootstrap 并未官方提供对过时（不支持标准属性）平台的支持，此 mixin 从 v3.1.0 版本期就 不建议使用 了。为了保持向后兼容，Bootstrap 将继续在内部使用此 mixin， 直到 Bootstrap v4。</p>
<p>在设置 box 阴影时务必使用 rgba() 颜色，这样可以使他们尽可能地与背景无缝融入。</p>
<pre><code>.box-shadow(@shadow: 0 1px 3px rgba(0,0,0,.25)) {
    -webkit-box-shadow: @shadow; // iOS &lt;4.3 &amp; Android &lt;4.1
            box-shadow: @shadow;
}
</code></pre><h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><p>有多个 mixin 供你灵活使用。可以一次性设置所有的过渡效果的属性，或者根据需要只是指定延时和持续时间。</p>
<p>此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.transition(@transition) &#123;</span><br><span class="line">  -webkit-transition: @transition;</span><br><span class="line">          transition: @transition;</span><br><span class="line">&#125;</span><br><span class="line">.transition-property(@transition-property) &#123;</span><br><span class="line">  -webkit-transition-property: @transition-property;</span><br><span class="line">          transition-property: @transition-property;</span><br><span class="line">&#125;</span><br><span class="line">.transition-timing-function(@timing-function) &#123;</span><br><span class="line">  -webkit-transition-timing-function: @timing-function;</span><br><span class="line">          transition-timing-function: @timing-function;</span><br><span class="line">&#125;</span><br><span class="line">.transition-transform(@transition) &#123;</span><br><span class="line">  -webkit-transition: -webkit-transform @transition;</span><br><span class="line">     -moz-transition: -moz-transform @transition;</span><br><span class="line">       -o-transition: -o-transform @transition;</span><br><span class="line">          transition: transform @transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>旋转、缩放、平移（移动）或倾斜任何对象。</p>
<p>此 mixin 从 v3.2.0 版本开始就被列为 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.rotate(@degrees) &#123;</span><br><span class="line">  -webkit-transform: rotate(@degrees);</span><br><span class="line">      -ms-transform: rotate(@degrees); // IE9 only</span><br><span class="line">          transform: rotate(@degrees);</span><br><span class="line">&#125;</span><br><span class="line">.scale(@ratio; @ratio-y...) &#123;</span><br><span class="line">  -webkit-transform: scale(@ratio, @ratio-y);</span><br><span class="line">      -ms-transform: scale(@ratio, @ratio-y); // IE9 only</span><br><span class="line">          transform: scale(@ratio, @ratio-y);</span><br><span class="line">&#125;</span><br><span class="line">.translate(@x; @y) &#123;</span><br><span class="line">  -webkit-transform: translate(@x, @y);</span><br><span class="line">      -ms-transform: translate(@x, @y); // IE9 only</span><br><span class="line">          transform: translate(@x, @y);</span><br><span class="line">&#125;</span><br><span class="line">.skew(@x; @y) &#123;</span><br><span class="line">  -webkit-transform: skew(@x, @y);</span><br><span class="line">      -ms-transform: skewX(@x) skewY(@y); // See https://github.com/twbs/bootstrap/issues/4885; IE9+</span><br><span class="line">          transform: skew(@x, @y);</span><br><span class="line">&#125;</span><br><span class="line">.translate3d(@x; @y; @z) &#123;</span><br><span class="line">  -webkit-transform: translate3d(@x, @y, @z);</span><br><span class="line">          transform: translate3d(@x, @y, @z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotateX(@degrees) &#123;</span><br><span class="line">  -webkit-transform: rotateX(@degrees);</span><br><span class="line">      -ms-transform: rotateX(@degrees); // IE9 only</span><br><span class="line">          transform: rotateX(@degrees);</span><br><span class="line">&#125;</span><br><span class="line">.rotateY(@degrees) &#123;</span><br><span class="line">  -webkit-transform: rotateY(@degrees);</span><br><span class="line">      -ms-transform: rotateY(@degrees); // IE9 only</span><br><span class="line">          transform: rotateY(@degrees);</span><br><span class="line">&#125;</span><br><span class="line">.perspective(@perspective) &#123;</span><br><span class="line">  -webkit-perspective: @perspective;</span><br><span class="line">     -moz-perspective: @perspective;</span><br><span class="line">          perspective: @perspective;</span><br><span class="line">&#125;</span><br><span class="line">.perspective-origin(@perspective) &#123;</span><br><span class="line">  -webkit-perspective-origin: @perspective;</span><br><span class="line">     -moz-perspective-origin: @perspective;</span><br><span class="line">          perspective-origin: @perspective;</span><br><span class="line">&#125;</span><br><span class="line">.transform-origin(@origin) &#123;</span><br><span class="line">  -webkit-transform-origin: @origin;</span><br><span class="line">     -moz-transform-origin: @origin;</span><br><span class="line">      -ms-transform-origin: @origin; // IE9 only</span><br><span class="line">          transform-origin: @origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>仅适用一个 mixin 就可以在一个声明中使用所有 CSS3 所提供的动画属性，其他 mixin 用于设置单个属性。</p>
<p>T此 mixin 从 v3.2.0 版本开始就 不建议使用 了，取而代之的是使用 Autoprefixer。为了保持向后兼容，在 v4 版本之前，Bootstrap 将在内部继续使用这些 mixin。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.animation(@animation) &#123;</span><br><span class="line">  -webkit-animation: @animation;</span><br><span class="line">          animation: @animation;</span><br><span class="line">&#125;</span><br><span class="line">.animation-name(@name) &#123;</span><br><span class="line">  -webkit-animation-name: @name;</span><br><span class="line">          animation-name: @name;</span><br><span class="line">&#125;</span><br><span class="line">.animation-duration(@duration) &#123;</span><br><span class="line">  -webkit-animation-duration: @duration;</span><br><span class="line">          animation-duration: @duration;</span><br><span class="line">&#125;</span><br><span class="line">.animation-timing-function(@timing-function) &#123;</span><br><span class="line">  -webkit-animation-timing-function: @timing-function;</span><br><span class="line">          animation-timing-function: @timing-function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h4><p>为所有浏览器设置透明度，并为IE8提供 filter 备用滤镜。</p>
<pre><code>.opacity(@opacity) {
    opacity: @opacity;
    // IE8 filter
    @opacity-ie: (@opacity * 100);
    filter: ~&quot;alpha(opacity=@{opacity-ie})&quot;;
}
</code></pre><h4 id="占位符文本"><a href="#占位符文本" class="headerlink" title="占位符文本"></a>占位符文本</h4><p>为表单控件中每个文本域提供占位符（Placeholder）文本的颜色。</p>
<pre><code>.placeholder(@color: @input-color-placeholder) {
    &amp;::-moz-placeholder           { color: @color; } // Firefox
    &amp;:-ms-input-placeholder       { color: @color; } // Internet Explorer 10+
    &amp;::-webkit-input-placeholder  { color: @color; } // Safari and Chrome
}
</code></pre><h4 id="列"><a href="#列" class="headerlink" title="列"></a>列</h4><p>通过CSS在一个单独的元素中生成列。</p>
<pre><code>.content-columns(@width; @count; @gap) {
    -webkit-column-width: @width;
        -moz-column-width: @width;
            column-width: @width;
    -webkit-column-count: @count;
        -moz-column-count: @count;
            column-count: @count;
    -webkit-column-gap: @gap;
        -moz-column-gap: @gap;
            column-gap: @gap;
}
</code></pre><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>便于把任何两种颜色变成背景渐变色。想要使他更高级些，可以设置一个direction（方向），使用三种颜色，也可以使用径向（radial）渐变。使用一个mixin（混入），你就可以得到所有需要的前缀语法。</p>
<pre><code>#gradient &gt; .vertical(#333; #000);
#gradient &gt; .horizontal(#333; #000);
#gradient &gt; .radial(#333; #000);
</code></pre><p>你也可以为标准的里两颜色线性渐变指定角度：</p>
<pre><code>#gradient &gt; .directional(#333; #000; 45deg);
</code></pre><p>如果你需要一个条纹风格的渐变，这也很容易。只要指定一个颜色，我们将该颜色半透明的条纹覆盖其上。</p>
<pre><code>#gradient &gt; .striped(#333; 45deg);
</code></pre><p>再来试试三种颜色。利用此 mixin ，并为其设置第一种颜色、第二种颜色、第二种颜色的色标（例如 25%），还有第三种颜色：</p>
<pre><code>#gradient &gt; .vertical-three-colors(#777; #333; 25%; #000);
#gradient &gt; .horizontal-three-colors(#777; #333; 25%; #000);
</code></pre><p>当心！ 如果你想删除某个渐变，确保将你所添加的针对 IE 的 filter 一并删除。你可以通过使用 .reset-filter() mixin 和 background-image: none; 达到目的。</p>
<h3 id="实用工具-mixin"><a href="#实用工具-mixin" class="headerlink" title="实用工具 mixin"></a>实用工具 mixin</h3><p>实用工具 mixin 用于与不相关的 CSS 结合以达到特定目的或任务。</p>
<h4 id="Clearfix-–-清除浮动"><a href="#Clearfix-–-清除浮动" class="headerlink" title="Clearfix – 清除浮动"></a>Clearfix – 清除浮动</h4><p>建议为需要清除浮动的元素使用 .clearfix() mixin ，尽量不要直接添加 class=”clearfix” 类。基于 Nicolas Gallagher 的 micro clearfix 代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy</span><br><span class="line">// Mixin</span><br><span class="line">.clearfix() &#123;</span><br><span class="line">  &amp;:before,</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    display: table;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><p>让元素在其父元素中水平居中。需要设置 width 或 max-width 属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Mixin</span><br><span class="line">.center-block() &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-left: auto;</span><br><span class="line">  margin-right: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">.container &#123;</span><br><span class="line">  width: 940px;</span><br><span class="line">  .center-block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="尺寸助手-mixin"><a href="#尺寸助手-mixin" class="headerlink" title="尺寸助手 mixin"></a>尺寸助手 mixin</h4><p>用于方便的指定对象的尺寸。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Mixins</span><br><span class="line">.size(@width; @height) &#123;</span><br><span class="line">  width: @width;</span><br><span class="line">  height: @height;</span><br><span class="line">&#125;</span><br><span class="line">.square(@size) &#123;</span><br><span class="line">  .size(@size; @size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">.image &#123; .size(400px; 300px); &#125;</span><br><span class="line">.avatar &#123; .square(48px); &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="可调整大小的文本域"><a href="#可调整大小的文本域" class="headerlink" title="可调整大小的文本域"></a>可调整大小的文本域</h4><p>方便设置任何文本域或其他元素的尺寸可调整。默认依循浏览器默认行为 (both)，即垂直、水平都可以调整。</p>
<pre><code>.resizable(@direction: both) {
    // Options: horizontal, vertical, both
    resize: @direction;
    // Safari fix
    overflow: auto;
}
</code></pre><h4 id="截断文本"><a href="#截断文本" class="headerlink" title="截断文本"></a>截断文本</h4><p>此 mixin 用来以省略号代替被截断的文本。元素必须是 block 或 inline-block 级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Mixin</span><br><span class="line">.text-overflow() &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">.branch-name &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  max-width: 200px;</span><br><span class="line">  .text-overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="视网膜屏幕（Retina）下的图片"><a href="#视网膜屏幕（Retina）下的图片" class="headerlink" title="视网膜屏幕（Retina）下的图片"></a>视网膜屏幕（Retina）下的图片</h4><p>通过指定两个图片路径和 @1x 图片尺寸，Bootstrap 还提供了对 @2x 媒体查询的支持。 如果你的页面上有很多图片，建议在一个单独的媒体查询中手工编写针对视网膜屏幕的 CSS 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.img-retina(@file-1x; @file-2x; @width-1x; @height-1x) &#123;</span><br><span class="line">  background-image: url(&quot;@&#123;file-1x&#125;&quot;);</span><br><span class="line"></span><br><span class="line">  @media</span><br><span class="line">  only screen and (-webkit-min-device-pixel-ratio: 2),</span><br><span class="line">  only screen and (   min--moz-device-pixel-ratio: 2),</span><br><span class="line">  only screen and (     -o-min-device-pixel-ratio: 2/1),</span><br><span class="line">  only screen and (        min-device-pixel-ratio: 2),</span><br><span class="line">  only screen and (                min-resolution: 192dpi),</span><br><span class="line">  only screen and (                min-resolution: 2dppx) &#123;</span><br><span class="line">    background-image: url(&quot;@&#123;file-2x&#125;&quot;);</span><br><span class="line">    background-size: @width-1x @height-1x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">.jumbotron &#123;</span><br><span class="line">  .img-retina(&quot;/img/bg-1x.png&quot;, &quot;/img/bg-2x.png&quot;, 100px, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-使用-Sass"><a href="#二-使用-Sass" class="headerlink" title="二 使用 Sass"></a>二 使用 Sass</h2><p>虽然 Bootstrap 是基于 Less 构建的，我们还提供了一套官方支持的 Sass 移植版代码。我们将这个版本放在单独的 GitHub 仓库中进行维护，并通过脚本处理源码更新。</p>
<h3 id="包含的内容"><a href="#包含的内容" class="headerlink" title="包含的内容"></a>包含的内容</h3><p>由于 Sass 移植版存放于单独的仓库，并针对不同的使用群体，这个项目中的内容与 Bootstrap 主项目有很大不同。这也是为了保证 Sass 移植版与更多基于 Sass 的系统相兼容。</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lib/</td>
<td>Ruby gem code (Sass configuration, Rails and Compass integrations)</td>
</tr>
<tr>
<td>tasks/</td>
<td>Converter scripts (turning upstream Less to Sass)</td>
</tr>
<tr>
<td>test/</td>
<td>Compilation tests</td>
</tr>
<tr>
<td>templates/</td>
<td>Compass package manifest</td>
</tr>
<tr>
<td>vendor/assets/</td>
<td>Sass, JavaScript, and font files</td>
</tr>
<tr>
<td>Rakefile</td>
<td>Internal tasks, such as rake and convert</td>
</tr>
</tbody>
</table>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p></p><p style="text-align:right">17:43</p><p></p>
<h1 id="C-组件"><a href="#C-组件" class="headerlink" title="C 组件"></a>C 组件</h1><h1 id="D-Javascript插件"><a href="#D-Javascript插件" class="headerlink" title="D Javascript插件"></a>D Javascript插件</h1><h1 id="E-定制"><a href="#E-定制" class="headerlink" title="E 定制"></a>E 定制</h1><h1 id="F-网站实例"><a href="#F-网站实例" class="headerlink" title="F 网站实例"></a>F 网站实例</h1>]]></content>
      <categories>
        <category>w3</category>
        <category>csslib</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap文档-Javascript插件</title>
    <url>/w3/csslib/bootstrap/bootstrap_4-javascript/</url>
    <content><![CDATA[<p>toc only.</p>
<p><a href="https://v3.bootcss.com/javascript/" target="_blank" rel="noopener">https://v3.bootcss.com/javascript/</a></p>
<a id="more"></a>
<p>读书总结：<br>概览<br>过渡效果、<br>模态框、下拉菜单、<br>滚动监听、<br>标签页、<br>工具提示、弹出框、警告框、按钮、<br>Collapse、Carousel、Affix （这三没有翻译啊）</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="单个还是全部引入"><a href="#单个还是全部引入" class="headerlink" title="单个还是全部引入"></a>单个还是全部引入</h3><p>JavaScript 插件可以单个引入（使用 Bootstrap 提供的单个 *.js 文件），或者一次性全部引入（使用 bootstrap.js 或压缩版的 bootstrap.min.js）。</p>
<blockquote>
<p>建议使用压缩版的 JavaScript 文件<br>bootstrap.js 和 bootstrap.min.js 都包含了所有插件，你在使用时，只需选择一个引入页面就可以了。</p>
</blockquote>
<blockquote>
<p>插件之间的依赖关系<br>某些插件和 CSS 组件依赖于其它插件。如果你是单个引入每个插件的，请确保在文档中检查插件之间的依赖关系。注意，所有插件都依赖 jQuery （也就是说，jQuery必须在所有插件之前引入页面）。 bower.json 文件中列出了 Bootstrap 所支持的 jQuery 版本。</p>
</blockquote>
<h2 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h2><h2 id="模态框"><a href="#模态框" class="headerlink" title="模态框"></a>模态框</h2><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><h2 id="滚动监听"><a href="#滚动监听" class="headerlink" title="滚动监听"></a>滚动监听</h2><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><h2 id="工具提示"><a href="#工具提示" class="headerlink" title="工具提示"></a>工具提示</h2><h2 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h2><h2 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="Collapse"><a href="#Collapse" class="headerlink" title="Collapse"></a>Collapse</h2><h2 id="Carousel"><a href="#Carousel" class="headerlink" title="Carousel"></a>Carousel</h2><h2 id="Affix"><a href="#Affix" class="headerlink" title="Affix"></a>Affix</h2><h2 id="返回顶部"><a href="#返回顶部" class="headerlink" title="返回顶部"></a>返回顶部</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>csslib</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap文档-组件</title>
    <url>/w3/csslib/bootstrap/bootstrap_3-components/</url>
    <content><![CDATA[<p>toc only.<br>无数可复用的组件，包括字体图标、下拉菜单、导航、警告框、弹出框等更多功能。<br><a href="https://v3.bootcss.com/components/" target="_blank" rel="noopener">https://v3.bootcss.com/components/</a></p>
<p></p><p style="text-align:right">2018.3.3 星期六</p><p></p>
<a id="more"></a>
<p>读书总结：<br>Glyphicons 字体图标、<br>下拉菜单、按钮组、按钮式下拉菜单、<br>输入框组、<br>导航、导航条、路径导航、<br>分页、标签、徽章、巨幕、<br>页头、缩略图、<br>警告框、进度条、<br>媒体对象、列表组、面板、<br>具有响应式特性的嵌入内容、Well</p>
<h2 id="Glyphicons-字体图标"><a href="#Glyphicons-字体图标" class="headerlink" title="Glyphicons 字体图标"></a>Glyphicons 字体图标</h2><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><h2 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h2><h2 id="按钮式下拉菜单"><a href="#按钮式下拉菜单" class="headerlink" title="按钮式下拉菜单"></a>按钮式下拉菜单</h2><h2 id="输入框组"><a href="#输入框组" class="headerlink" title="输入框组"></a>输入框组</h2><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h2 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h2><h2 id="路径导航"><a href="#路径导航" class="headerlink" title="路径导航"></a>路径导航</h2><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="徽章"><a href="#徽章" class="headerlink" title="徽章"></a>徽章</h2><h2 id="巨幕"><a href="#巨幕" class="headerlink" title="巨幕"></a>巨幕</h2><h2 id="页头"><a href="#页头" class="headerlink" title="页头"></a>页头</h2><h2 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h2><h2 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h2><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><h2 id="媒体对象"><a href="#媒体对象" class="headerlink" title="媒体对象"></a>媒体对象</h2><h2 id="列表组"><a href="#列表组" class="headerlink" title="列表组"></a>列表组</h2><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><h2 id="具有响应式特性的嵌入内容"><a href="#具有响应式特性的嵌入内容" class="headerlink" title="具有响应式特性的嵌入内容"></a>具有响应式特性的嵌入内容</h2><h2 id="Well"><a href="#Well" class="headerlink" title="Well"></a>Well</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>csslib</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 文档</title>
    <url>/w3/hexo/hexo%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>abstract.</p>
<p><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs</a></p>
<p style="text-align:right">2018.2</p>

<a id="more"></a>
<p>/开始使用/</p>
<h2 id="二-建站"><a href="#二-建站" class="headerlink" title="二 建站"></a>二 建站</h2><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>
<h3 id="2-3-scaffolds"><a href="#2-3-scaffolds" class="headerlink" title="2.3 scaffolds"></a>2.3 scaffolds</h3><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="2-4-source"><a href="#2-4-source" class="headerlink" title="2.4 source"></a>2.4 source</h3><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="2-5-themes"><a href="#2-5-themes" class="headerlink" title="2.5 themes"></a>2.5 themes</h3><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="四-命令"><a href="#四-命令" class="headerlink" title="四 命令"></a>四 命令</h2><ol>
<li>$ hexo init [folder]</li>
<li>$ hexo new [layout] \<title><br>新建一篇文章。如果没有设置 layout 的话，默认使用<br>_config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</title></li>
<li><p>$ hexo generate</p>
</li>
<li><p>$ hexo publish [layout] <filename></filename></p>
</li>
<li><p>$ hexo deploy</p>
</li>
<li><p>$ hexo clean</p>
</li>
<li>$ hexo server</li>
<li>$ hexo list <type></type></li>
<li>$ hexo version</li>
<li>$ hexo render <file1> [file2] …<br>..</file1></li>
</ol>
<p>/基本操作/</p>
<h2 id="一-写作"><a href="#一-写作" class="headerlink" title="一 写作"></a>一 写作</h2><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>
<h3 id="1-1-布局（Layout）"><a href="#1-1-布局（Layout）" class="headerlink" title="1.1 布局（Layout）"></a>1.1 布局（Layout）</h3><p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p>
<h3 id="2-模版（Scaffold）"><a href="#2-模版（Scaffold）" class="headerlink" title="2 模版（Scaffold）"></a>2 模版（Scaffold）</h3><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p>
<pre><code>$ hexo new photo &quot;My Gallery&quot;
</code></pre><p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：<code>layout,title,date</code></p>
<p>/自定义/</p>
<h2 id="一-永久链接（Permalinks）"><a href="#一-永久链接（Permalinks）" class="headerlink" title="一 永久链接（Permalinks）"></a>一 永久链接（Permalinks）</h2><h2 id="三-模版"><a href="#三-模版" class="headerlink" title="三 模版"></a>三 模版</h2><p>模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>用途</th>
<th>回调</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>首页</td>
<td></td>
</tr>
<tr>
<td>post</td>
<td>文章</td>
<td>index</td>
</tr>
<tr>
<td>page</td>
<td>分页</td>
<td>index</td>
</tr>
<tr>
<td>archive</td>
<td>归档</td>
<td>index</td>
</tr>
<tr>
<td>category</td>
<td>分类归档</td>
<td>archive</td>
</tr>
<tr>
<td>tag</td>
<td>标签归档</td>
<td>archive</td>
</tr>
</tbody>
</table>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3>]]></content>
      <categories>
        <category>w3</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT 文档</title>
    <url>/w3/hexo/next%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>toc only.</p>
<p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>  </p>
<p style="text-align:right">2018.2</p>

<a id="more"></a>
<h2 id="一-开始使用"><a href="#一-开始使用" class="headerlink" title="一 开始使用"></a>一 开始使用</h2><h3 id="安装-NexT"><a href="#安装-NexT" class="headerlink" title="安装 NexT"></a>安装 NexT</h3><p>下载 NexT 主题<br>启用 NexT 主题<br>验证是否正确启用</p>
<h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><ol>
<li>选择「Scheme」</li>
<li>设置「界面语言」</li>
<li>设置「菜单」</li>
<li>设置「侧栏」</li>
<li>设置「头像」</li>
<li>设置「作者昵称」</li>
<li>设置「站点描述」<h3 id="集成第三方服务"><a href="#集成第三方服务" class="headerlink" title="集成第三方服务"></a>集成第三方服务</h3></li>
</ol>
<h2 id="二-主题配置"><a href="#二-主题配置" class="headerlink" title="二 主题配置"></a>二 主题配置</h2><ol>
<li>设置「RSS」</li>
<li>添加「标签」页面</li>
<li>添加「分类」页面</li>
<li>设置「字体」</li>
<li>设置「代码高亮主题」</li>
<li>侧边栏社交链接</li>
<li>开启打赏功能</li>
<li>设置友情链接</li>
<li>腾讯公益404页面</li>
<li>站点建立时间</li>
<li>订阅微信公众号</li>
<li>设置「动画效果」</li>
<li>设置「背景动画」</li>
</ol>
<h2 id="三-第三方服务"><a href="#三-第三方服务" class="headerlink" title="三 第三方服务"></a>三 第三方服务</h2><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><ol>
<li>Disqus</li>
<li>Facebook Comments</li>
<li>HyperComments</li>
<li>网易云跟帖</li>
<li>来必力<h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3>百度统计<br>Google 分析<br>腾讯分析<br>CNZZ 统计<br>不蒜子统计<br>腾讯移动分析<h3 id="内容分享服务"><a href="#内容分享服务" class="headerlink" title="内容分享服务"></a>内容分享服务</h3><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3>Swiftype<br>微搜索<br>Local Search<br>Algolia<h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3>MathJax<br>Facebook SDK<br>Google Webmaster tools</li>
</ol>
<h2 id="四-内建标签"><a href="#四-内建标签" class="headerlink" title="四 内建标签"></a>四 内建标签</h2><h2 id="五-进阶设定"><a href="#五-进阶设定" class="headerlink" title="五 进阶设定"></a>五 进阶设定</h2><h2 id="六-常见问题"><a href="#六-常见问题" class="headerlink" title="六 常见问题"></a>六 常见问题</h2><h2 id="七-其他平台"><a href="#七-其他平台" class="headerlink" title="七 其他平台"></a>七 其他平台</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建技术研究</title>
    <url>/sum/others/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>搭建博客的时候做了一些google</p>
<a id="more"></a> 
<p style="text-align:right">2018.2.23 星期五 17:48</p>

<h1 id="A-搭建个人博客，你需要知道这些"><a href="#A-搭建个人博客，你需要知道这些" class="headerlink" title="A 搭建个人博客，你需要知道这些"></a>A 搭建个人博客，你需要知道这些</h1><p><a href="http://blog.coderclock.com/2017/03/12/web/搭建个人博客，你需要知道这些/" target="_blank" rel="noopener">http://blog.coderclock.com/2017/03/12/web/搭建个人博客，你需要知道这些/</a><br>2017-03-12  WEB<br><strong>$_YX:</strong> <a href="https://app.yinxiang.com/shard/s67/nl/18114453/cd27205b-c39e-488e-950b-0a08c90c01c7?title=%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s67/nl/18114453/cd27205b-c39e-488e-950b-0a08c90c01c7?title=%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B</a></p>
<ol>
<li>博客生成器</li>
<li>Web服务器</li>
<li>图床服务器</li>
<li>域名和备案</li>
<li>DNS解析</li>
<li>界面美化</li>
<li>评论功能</li>
<li>流量统计</li>
<li>总结</li>
</ol>
<h1 id="B-怎么选择和快速搭建个人博客"><a href="#B-怎么选择和快速搭建个人博客" class="headerlink" title="B 怎么选择和快速搭建个人博客"></a>B 怎么选择和快速搭建个人博客</h1><p><a href="https://segmentfault.com/a/1190000011661576" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011661576</a><br> blog  hexo  hugo  wordpress  github-pages  ONEGEE 2017年10月22日发布<br><strong>$_YX:</strong> <a href="https://app.yinxiang.com/shard/s67/nl/18114453/ed37ffa4-01c9-4e0c-bf9e-a297937aeedf?title=%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%92%8C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20%E4%B8%AA%E4%BA%BA%E6%96%87%E7%AB%A0%20-%20SegmentFault%20%E6%80%9D%E5%90%A6" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s67/nl/18114453/ed37ffa4-01c9-4e0c-bf9e-a297937aeedf?title=%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%92%8C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20-%20%E4%B8%AA%E4%BA%BA%E6%96%87%E7%AB%A0%20-%20SegmentFault%20%E6%80%9D%E5%90%A6</a></p>
<p>….</p>
<h2 id="怎么面对博客"><a href="#怎么面对博客" class="headerlink" title="怎么面对博客"></a>怎么面对博客</h2><ol>
<li>博客不像微博，有一定的含金量，而不是走马灯的宣言（拿微博治国的人不代表大多数</li>
<li>写作的过程其实就是思考的字面化，梳理知识体系的同时反思知识的内化程度，分清楚哪些是“知道了”，哪些是“掌握了”</li>
<li>通过博客的形式分享是学习的一种技巧（费曼技巧，让小孩子明白你要讲述的内容），内化知识的同时也从分享中得到快乐</li>
<li>用写作来记录成长的过程，保持这种习惯能让你听到意志力成长的声音（zi…</li>
<li><p>同时博客也是一种无形的资产，量变的积累过程兴许会带来许多隐形的机会（接广告，出书啊等等知乎上忽悠的），总之多写总没错</p>
<h2 id="怎么把博客放到网上"><a href="#怎么把博客放到网上" class="headerlink" title="怎么把博客放到网上"></a>怎么把博客放到网上</h2><p>目前比较流行的博客实现可以分为三种方式，各有不同程度的技术门槛、功能支持、主题颜值等。接下来将会通过实例展示不同的博客形式。</p>
</li>
<li><p>个人主页注册。指的是在现有的博客网站、论坛或社区上注册个人主页</p>
</li>
<li>静态网站生成。通常是由jekyll、hugo或hexo等技术生成静态网站，然后通过git上传到Github Pages、Coding Pages等托管平台免费展示</li>
<li>内容管理系统。带有后台管理的博客系统，需要配置空间（服务器）、数据库以及域名等，然后安装成熟的WordPress、ghost等内容管理系统</li>
</ol>
<p>一) 个人主页注册<br>二) 静态网站生成技术<br>三) 内容管理系统</p>
<h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>新手村指南。如果你是新手，对于以上的技术门槛一窍不通，但是又想要主题精美的个人博客网站，建议从Markdown语言开始学起（半天入门，一天出师），之后只需要了解一些基本的命令行知识和git操作，就可以跟随各种教程，从生成静态网站入门快速搭建博客，完全不花钱。</p>
<h3 id="个人推荐（良心推荐不收钱）"><a href="#个人推荐（良心推荐不收钱）" class="headerlink" title="个人推荐（良心推荐不收钱）"></a>个人推荐（良心推荐不收钱）</h3><p>thumbsup 首推hexo。性价比最高，中文友好，快速上线，贴心配置，免费高颜值<br>thumbsup 其次WordPress。满足多人维护的需求，资料繁多等需求，可以一劳永逸，虽然门槛高一点，体量大了点，还要花钱，但是很稳定，很有安全感。<br>个人博客最终选择了hugo + Gihub + Netlify，可以丢鸡蛋 onegee.space<br>审美强迫症友情提示：hugo的颜值高于hexo，可以低成本无痛迁移；ghost颜值甩WordPress，为了美需要舍弃一些功能</p>
<p>clap 最后1毛钱，内容高于形式，入坑需谨慎 ：）</p>
<h1 id="C-技术博客对比"><a href="#C-技术博客对比" class="headerlink" title="C 技术博客对比"></a>C 技术博客对比</h1><p><a href="https://www.jianshu.com/p/c635e62cb4f4" target="_blank" rel="noopener">https://www.jianshu.com/p/c635e62cb4f4</a><br>96  brookfish 关注<br>2017.03.17 12:11* 字数 322 阅读 18评论 0喜欢 0  </p>
<p>博客</p>
<h2 id="知名博客"><a href="#知名博客" class="headerlink" title="知名博客"></a>知名博客</h2><ol>
<li>优秀的团队博客<br><a href="http://www.infoq.com/cn/articles/20-outstanding-enterprise-technology-blog" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/20-outstanding-enterprise-technology-blog</a></li>
<li>优秀的个人技术博客<br><a href="https://www.zhihu.com/question/19934502" target="_blank" rel="noopener">https://www.zhihu.com/question/19934502</a></li>
</ol>
<h2 id="建议的创建博客方法"><a href="#建议的创建博客方法" class="headerlink" title="建议的创建博客方法"></a>建议的创建博客方法</h2><p>hexo+ 域名 +github 搭建方法  <a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">http://www.jianshu.com/p/465830080ea9</a><br>Jekyll+ 域名 + github搭建方法  <a href="http://baixin.io/2016/10/jekyll_tutorials1/" target="_blank" rel="noopener">http://baixin.io/2016/10/jekyll_tutorials1/</a><br><a href="http://typecho.org/开源博客系统" target="_blank" rel="noopener">http://typecho.org/开源博客系统</a>  +域名 + 空间  </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>博客类型</th>
<th>使用情况</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>博客园</td>
<td>较多</td>
</tr>
<tr>
<td>2</td>
<td>自建wordpress + 域名 + 空间（新浪云）</td>
<td>很多</td>
</tr>
<tr>
<td>3</td>
<td>自己写得博客系统 +域名 + 空间</td>
<td>较少</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td><a href="https://hexo.io/+" target="_blank" rel="noopener">https://hexo.io/+</a> 域名 + github</td>
<td>较少</td>
<td>建议使用，免费使用，免费SEO，github权重较高，较容易被搜索引擎抓取,易于传播</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Jekyll+ 域名 + github</td>
<td>较少</td>
<td>建议使用，免费使用，免费SEO，github权重较高，较容易被搜索引擎抓取，易于传播</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>CSDN，慕课，稀土掘金，简书</td>
<td>较少</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>团队技术博客<a href="http://mogu.io/蘑菇街用的http://typecho.org/开元系统" target="_blank" rel="noopener">http://mogu.io/蘑菇街用的http://typecho.org/开元系统</a></td>
<td>较少</td>
<td>建议使用，独立域名，开源系统，方便更改</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>美团技术博客<a href="http://tech.meituan.com/techsalon自建" target="_blank" rel="noopener">http://tech.meituan.com/techsalon自建</a></td>
<td>较少</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>七牛技术团队<a href="http://blog.qiniu.com/" target="_blank" rel="noopener">http://blog.qiniu.com/</a></td>
</tr>
<tr>
<td>0</td>
<td>wordpress + 域名 + 空间</td>
<td>较少</td>
</tr>
</tbody>
</table>
<h1 id="D-搭建一个免费的，无限流量的Blog—-github-Pages和Jekyll入门"><a href="#D-搭建一个免费的，无限流量的Blog—-github-Pages和Jekyll入门" class="headerlink" title="D 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门"></a>D 搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门</h1><p><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html</a><br>作者： 阮一峰<br>日期： 2012年8月25日</p>
<p>喜欢写Blog的人，会经历三个阶段。  </p>
<ol>
<li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li>
<li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li>
<li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li>
</ol>
<p>大多数Blog作者，都停留在第一和第二阶段，因为第三阶段不太容易到达：你很难找到俯首听命、愿意为你管理服务器的人。</p>
<p>但是两年前，情况出现变化，一些程序员开始在ｇithub网站上搭建blog。他们既拥有绝对管理权，又享受github带来的便利—-不管何时何地，只要向主机提交commit，就能发布新文章。更妙的是，这一切还是免费的，github提供无限流量，世界各地都有理想的访问速度。</p>
<p>今天，我就来示范如何在github上搭建Blog，你可以从中掌握github的Pages功能，以及Jekyll软件的基本用法。更重要的是，你会体会到一种建立网站的全新思路。</p>
<h2 id="一-Github-Pages-是什么？"><a href="#一-Github-Pages-是什么？" class="headerlink" title="一 Github Pages 是什么？"></a>一 Github Pages 是什么？</h2><p>如果你对编程有所了解，就一定听说过github。它号称程序员的Facebook，有着极高的人气，许多重要的项目都托管在上面。</p>
<p>简单说，它是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。</p>
<p>但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p>
<p>github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。</p>
<h2 id="二-Jekyll是什么？"><a href="#二-Jekyll是什么？" class="headerlink" title="二 Jekyll是什么？"></a>二 Jekyll是什么？</h2><p>Jekyll（发音/‘dʒiːk əl/，”杰克尔”）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站。<br>整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。</p>
<p>这种做法的好处是：</p>
<ol>
<li>免费，无限流量。</li>
<li>享受git的版本管理功能，不用担心文章遗失。</li>
<li>你只要用自己喜欢的编辑器写文章就可以了，其他事情一概不用操心，都由github处理。</li>
</ol>
<p>它的缺点是：</p>
<ol>
<li>有一定技术门槛，你必须要懂一点git和网页开发。</li>
<li>它生成的是静态网页，添加动态功能必须使用外部服务，比如评论功能就只能用disqus。</li>
<li>它不适合大型网站，因为没有用到数据库，每运行一次都必须遍历全部的文本文件，网站越大，生成时间越长。<br>但是，综合来看，它不失为搭建中小型Blog或项目主页的最佳选项之一。</li>
</ol>
<h2 id="三-一个实例"><a href="#三-一个实例" class="headerlink" title="三 一个实例"></a>三 一个实例</h2><p>..</p>
<h1 id="E-准备自己建一个个人博客，有什么好的框架推荐？"><a href="#E-准备自己建一个个人博客，有什么好的框架推荐？" class="headerlink" title="E 准备自己建一个个人博客，有什么好的框架推荐？"></a>E 准备自己建一个个人博客，有什么好的框架推荐？</h1><p><a href="https://www.zhihu.com/question/24179143" target="_blank" rel="noopener">https://www.zhihu.com/question/24179143</a></p>
<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-资料整理"><a href="#一-资料整理" class="headerlink" title="一 资料整理"></a>一 资料整理</h2><ol>
<li>A、B基础概念，已YX</li>
<li>C 补充</li>
<li>D 扩展：三阶段，以后可尝试其他，包括Jekyll</li>
<li>E 参考</li>
</ol>
<h2 id="二-选择"><a href="#二-选择" class="headerlink" title="二 选择"></a>二 选择</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h3><ol>
<li>hexo：Hello World已有(2017.6.10)</li>
<li>不喜社区：杂，不是说不好</li>
<li>自己md文件，不依赖社区</li>
<li>简单，优雅，没有wordpress等数据库或者的要求</li>
<li>不需要服务器，也没有域名</li>
<li>学习等总结、记录</li>
<li>(前端)多在用，友好，就不多做研究，直接使用hexo+next</li>
</ol>
<h3 id="2-2-结果"><a href="#2-2-结果" class="headerlink" title="2.2 结果"></a>2.2 结果</h3><p>hexo+主题、扩展</p>
<p style="text-align:right">18:18 </p><br><p style="text-align:right">2018.2.26 星期一 长_天_ 08:48</p>

<h3 id="2-3-实施"><a href="#2-3-实施" class="headerlink" title="2.3 实施"></a>2.3 实施</h3><h4 id="1-目标"><a href="#1-目标" class="headerlink" title="1 目标"></a>1 目标</h4><ol>
<li>准备多终端，需建立分支；优点：方便备份；弊端：开源<br>自动化，后面考虑</li>
<li>有的内容不会发布，或者暂时不发布</li>
<li>分类和标签<ol>
<li>分类：pdf，w3，gsc，英语，其他（感想-随笔）；还需建立二级分类 </li>
<li>添加标签（和资源池不完全一样）：html,css,js,canvas,jquery,angular,webrtc,videojs</li>
<li>归档，已经是按日期了</li>
</ol>
</li>
<li>资源文件的工作目录  </li>
<li><del>模板文档的建立</del> 新建文章的模版，不算hexo的模版；使用的时候直接复制<br>用到的情况不多。也就是看看有哪些front matter 设置</li>
<li>目前，不做百度站点，SEO，评论等，统计，google可以试一下</li>
<li>优化：侧边社交链接，打赏，友情，公益404，建立时间，订阅公众号。<br>不做：动画，背景动画（臃，而不实用）<br>next主题的配置，主要考虑文章怎么发布，即目录，模板的建立</li>
</ol>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h4><ol>
<li>直接在_post文件夹下发布文章</li>
<li>新建立文件夹，方便分类/管理；发布的时候public也会有目前结构<br>同时，permalinks使用分类，可以添加多语言（zhuangbi失败）  </li>
<li>对于不方便开源，或者不发布的文章用 _命名，同时在.gitignore中忽略，就不会提交（意味着，没有备份）<br>同时在文章Front-matter中，也可以标明<code>layout:false</code>，防止错误发布博文</li>
<li>所以不需要建立scaffolds，也不用publish或者new等命令，只generate，deploy</li>
</ol>
<h2 id="三-成果"><a href="#三-成果" class="headerlink" title="三 成果"></a>三 成果</h2><p><a href="https://yalhu.github.io" target="_blank" rel="noopener">作者博客</a><br><a href="/sum/others/基于Hexo+NexT的博客搭建指导/">基于Hexo+NexT的博客搭建指导</a></p>
<h1 id="Z0-课后-github-issues博客"><a href="#Z0-课后-github-issues博客" class="headerlink" title="Z0 课后 github issues博客"></a>Z0 课后 github issues博客</h1><p>又见到了github issues建立博客的，也不错。<br>文档可以直接在issues上写，同时也是备份；<br>不是自己提的issues/博客，可以关闭；<br>issues自带评论功能；<br>issues可以建立标签；<br>利用project可以分类/状态管理；</p>
<p>issues中别人是不可以cc自己源码md文件的；但是<a href="https://github.com/axuebin/articles" target="_blank" rel="noopener">该作者</a>的仓库中，有归档文件夹（2017/2018），可以cc到md文件，还直接用了图片地址（别人引用，打开能不能显示没有实践）；</p>
<p># Z1 Hexo文档<br><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs</a><br><strong>$_BLOB:</strong> <a href="/w3/hexo/hexo文档/">Hexo 文档</a>  </p>
<p># Z2 Next文档<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br><strong>$_BLOB:</strong> <a href="/w3/hexo/next文档/">Hexo 文档</a></p>
<p style="text-align:right">15:14</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas库研究--非图表类</title>
    <url>/sum/jsplus/canvas%E5%BA%93%E7%A0%94%E7%A9%B6--%E9%9D%9E%E5%9B%BE%E8%A1%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>准备做annotation/board，做了一些google。<br>尽管原生基本功能已经完成；选择库，功能会更强壮</p>
<a id="more"></a>
<p style="text-align:right">2018.2.22 四 14:50</p>

<h1 id="A-译-知名Html5-Canvas-Javascript库对比"><a href="#A-译-知名Html5-Canvas-Javascript库对比" class="headerlink" title="A [译]知名Html5 Canvas Javascript库对比"></a>A [译]知名Html5 Canvas Javascript库对比</h1><!-- 1.24及之前仔细看过，现记    -->
<p>2013.06.24 BY 十年灯·6条评论<br>声明：<br>原文链接：<a href="http://www.softr.li/blog/2012/06/20/which-html5-canvas-javascript-library-should-i-use" target="_blank" rel="noopener">http://www.softr.li/blog/2012/06/20/which-html5-canvas-javascript-library-should-i-use</a><br>本译文地址：<a href="http://jo2.org/html5-canvas-libary-introduction/" target="_blank" rel="noopener">http://jo2.org/html5-canvas-libary-introduction/</a><br>印象：  </p>
<p>#《我应该选哪个Canvas库？》译文（以下的“我”是指原作者）</p>
<p>我一直在找一个Html5 canvas库，可以让我创建可交互的、带动画的UI界面。我的要求是：</p>
<ul>
<li>良好的文档，支持与维护，因为我想在以后的项目里还能重用它</li>
<li>可以轻松的创造复杂的图形对象（我的工程比较复杂，可不是一个简单的按钮那样的活儿），最好能支持分组和多层</li>
<li>能帮我处理用户交互</li>
<li>支持触摸设备</li>
<li>提供用于作动态图形的工具<br>我搜了一些适合的库，想和你分享我的搜索成果。在可用的库的名单后面，我调查了这些库：EaselJS,fabric.js,Paper.js,processing.js和Kinetic.js，希望能帮你做出你自己的选择。</li>
</ul>
<h2 id="一-我找到的库"><a href="#一-我找到的库" class="headerlink" title="一 我找到的库"></a>一 我找到的库</h2><p>这儿是一些迄今为止看起来还有人维护的Canvas库：<br>CAAT<br>EaselJS<br>Fabric.js<br>Gury<br>JcanvaScript<br>Kinetic.js<br>oCanvas<br>Paper.js<br>processing.js</p>
<p>这儿还有一些我没有研究过的库，因为他们没有架在Github上，或者看起来没人更新了：<br>cakejs<br>Doodle-js<br>CanvasToolkit<br>Mootools Canvas lib</p>
<h2 id="二-在Github上的对比"><a href="#二-在Github上的对比" class="headerlink" title="二 在Github上的对比"></a>二 在Github上的对比</h2><table>
<thead>
<tr>
<th>库</th>
<th>关注</th>
<th>分支</th>
<th>问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAAT</td>
<td>336</td>
<td>42</td>
<td>17</td>
</tr>
<tr>
<td>EaselJS</td>
<td></td>
<td>1,440</td>
<td>203</td>
<td>90</td>
</tr>
<tr>
<td>fabric.js</td>
<td>1,059</td>
<td>101    38</td>
</tr>
<tr>
<td>gury</td>
<td>348</td>
<td>19</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>jCanvaScript</td>
<td>80</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>Kinetic.js</td>
<td>267</td>
<td>41</td>
<td>7</td>
</tr>
<tr>
<td>oCanvas</td>
<td>194</td>
<td>20</td>
<td>6</td>
</tr>
<tr>
<td>Paper.js</td>
<td>1,706</td>
<td>111</td>
<td>30</td>
</tr>
<tr>
<td>processing.js</td>
<td>1,276</td>
<td>206</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<h2 id="三-最小体积对比"><a href="#三-最小体积对比" class="headerlink" title="三 最小体积对比"></a>三 最小体积对比</h2><table>
<thead>
<tr>
<th>库</th>
<th>代码量 (kb)</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAAT</td>
<td>210</td>
</tr>
<tr>
<td>EaselJS</td>
<td>44</td>
</tr>
<tr>
<td>fabric.js</td>
<td>133</td>
</tr>
<tr>
<td>gury</td>
<td>11</td>
</tr>
<tr>
<td>Kinetic.js</td>
<td>53</td>
</tr>
<tr>
<td>oCanvas</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>不过jCanvaScript,Paper.js和processing.js在Github是没有压缩版</p>
<h2 id="四-在Stackoverflow的比较"><a href="#四-在Stackoverflow的比较" class="headerlink" title="四 在Stackoverflow的比较"></a>四 在Stackoverflow的比较</h2><p>搜索词    标签    # 被标记的问题    # 搜索到的问题<br>CAAT    N/A    N/A    5<br>EaselJS    easeljs    30    79<br>fabric.js    fabricjs    43    78<br>jCanvaScript    N/A    N/A    6<br>Kinetic.js    kineticjs    74    30<br>oCanvas    N/A    N/A    19<br>Paper.js    paperjs    9    49<br>processing.js    processing.js    117    289<br>gury库在stackoverflow上没找到，我用N/A标识了没找到的。</p>
<h2 id="五-对文档，教程和其他资源的研究"><a href="#五-对文档，教程和其他资源的研究" class="headerlink" title="五 对文档，教程和其他资源的研究"></a>五 对文档，教程和其他资源的研究</h2><p>在选择框架时，我更看重Github的比较。他能提供库的开发状态概览以及正在用这个库的社区。在我并不想变成某领域的专家时，我希望能依靠社区（解决问题）。</p>
<p>但是，StackOverflow(SO)太有用了，尤其在已经有人问了比较问题的时候，比如：Current state of Javascript canvas libraries</p>
<h2 id="六-深入评论"><a href="#六-深入评论" class="headerlink" title="六 深入评论"></a>六 深入评论</h2><p>于是，我打算就文档，教程和其他资源，给出一个深入的评论。对比：EaselJS, fabric.js, Paper.js, processing.js 以及这个外来者：Kinetic.js,来做个选择。</p>
<h3 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0 摘要"></a>0 摘要</h3><p>EaselJS, fabric.js, Paper.js, processing.js可以看作是4个领头者，他们有很明确的庞大用户社区，也架设在Github上，文档完善，大量的引用（就是在SO上的问题，以及论坛），更好的是，根据SO上他们之前的问题，他们是有单元测试的。</p>
<p>Kinetic.js是个后来者，最近才上线Github，还有很多变数，但受到了kangax的（Fabric.js的作者）热烈欢迎。</p>
<p>这4个库都有Github地址，都基于MIT许可发布。</p>
<h3 id="1-EaselJS"><a href="#1-EaselJS" class="headerlink" title="1 EaselJS"></a>1 EaselJS</h3><p>这个库是CreateJS 套件的一部分，是一个全功能的用来创建先进html5交互与动画图形库。</p>
<p>特别的是，结合动画库（TweenJS），可以创建很复杂的动画！如果你打算开发游戏，你还可以用SoundJS库和资源预载入库（PreloadJS）搞定。</p>
<p>这个网站提供了一些漂亮的示例，源码可以和Github宝库上找到。</p>
<p>这个库看起来也能和其他库协同工作，比如Box2d和TexturePacker.</p>
<p>内置对触摸设备的支持</p>
<h3 id="2-fabric-js"><a href="#2-fabric-js" class="headerlink" title="2 fabric.js"></a>2 fabric.js</h3><p>查看官网发现，此库貌似偏向建立“矢量图形编辑工具”。主要特色有：</p>
<ul>
<li>创建和操作（移动，缩放，旋转…）矢量图形和文本对象</li>
<li>导入/导出成SVG或反过来<br>总结起来就是“一个在canvas上的可交互对象模型”。<br>如果你的目的是建立复杂场景，动态对象，在我看来他不是正确选择。</li>
</ul>
<h3 id="3-Paper-js"><a href="#3-Paper-js" class="headerlink" title="3 Paper.js"></a>3 Paper.js</h3><p>这个库是Scriptographer库的一部分。他有个特长是其Paperscript语言，基于一个提供了对点和图形精妙进行精妙数学操作的Javascript扩展——但是，他仍然没有文档。</p>
<p>这个库的强大在于，他在建立复杂矢量对象和管理鼠标交互上出类拔萃。然而，他没有实现对移动设备的支持，而且其动画能力貌似被 onFrame() 这个方法限制了——每秒被调用60次，也允许你改变canvas的内容。</p>
<h3 id="4-processing-js"><a href="#4-processing-js" class="headerlink" title="4 processing.js"></a>4 processing.js</h3><p>这个库的核心目标是建立可视化交互</p>
<p>这个库有个独特的历史——他是著名的Processing库的一个接口。我说著名，不是因为我自己知道，而是因为他在多媒体艺术社区非常知名，用来进行交互式艺术创造。</p>
<p>请看这第一个示例,看起来此库打算降低在canvas上创建交互式图形动画的学习曲线。他提供了易用的循环，和一个 draw() 方法，你可以简单的建立你的可视化交互。</p>
<p>我认为，因为其学习曲线低，对没有开发能力的艺术家们是完美的，但并不是建立面向对象组件的最佳工具。</p>
<h3 id="5-Kinetic-js"><a href="#5-Kinetic-js" class="headerlink" title="5 Kinetic.js"></a>5 Kinetic.js</h3><p>Kinetic.js本是这次比较的门外汉，因为在他的Github上看起来，他离最多人使用的那个还很远。然而，如果搜索”canvas library”的话，他的html5教程是排在第一位的，而且，他在SO上也有很多不错的提问。</p>
<p>这个名字是个很好的线索，但这个库在处理大量对象的时候蛮快的，因为使用了多canvas技术。</p>
<p>他提供了很好的文档讲解和教程，包括系统的html5 canvas应用，详细的Kinetic.js和Three.js文档。他也提供了些好用的小提示——不是针对这个库的，有的是对于canvas。</p>
<h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h3><p>基于本篇评论，我认为我应该用EaselJS或Kinetic.js。Paper.js也不错但是不支持触摸设备，我敢肯定要集成这个功能并不复杂，但我更喜欢库中本来就有的。</p>
<p>最后，我决定用Kinetic.js，因为：</p>
<ol>
<li>我觉得示例代码不错</li>
<li>作者本身写了一个优秀的系列教程</li>
<li>文档和例子都很清晰易懂</li>
<li>我要的库里都有了（我并不觉得在我做到20%的时候却需要引进另一个大1. 库比如TweenJS来解决个小问题会让我高兴）<br>请不吝分享你的评论，或者我没提到的库，谢谢。</li>
</ol>
<p>—————————————————-</p>
<h2 id="七-译者的总结："><a href="#七-译者的总结：" class="headerlink" title="七 译者的总结："></a>七 译者的总结：</h2><p>翻译完了觉得这文章有点像Kinetic.js的软广告。不过，上面的所有库功能都是非常强大的，日常应用毫无问题。Kinetic.js是综合来讲比较合理的一个——功能中等，体积中等。</p>
<p>个人觉得fabric.js最强大，体积也最大；Paper.js其次。</p>
<p>另外，在对比了国外的教程和我写的教程后，不知道我写的教程还有人看吗？——虽然，我也是完全原创的，但我的技术可比不上外国作者，唉</p>
<h1 id="B-有哪些值得推荐的开源-JavaScript-Canvas-库，分别有哪些优势和劣势？"><a href="#B-有哪些值得推荐的开源-JavaScript-Canvas-库，分别有哪些优势和劣势？" class="headerlink" title="B 有哪些值得推荐的开源 JavaScript Canvas 库，分别有哪些优势和劣势？"></a>B 有哪些值得推荐的开源 JavaScript Canvas 库，分别有哪些优势和劣势？</h1><p><a href="https://www.zhihu.com/question/19796641" target="_blank" rel="noopener">https://www.zhihu.com/question/19796641</a><br>作者：rambo<br>我个人认为 在初学的时候,可以选择jcanvasscript进行辅助了解canvas . 等学会了 有必要再去掌握别的时候,原理明白了 也就只有一些语法不同而已</p>
<p>作者：吴立志<br>链接：<a href="https://www.zhihu.com/question/19796641/answer/131856479" target="_blank" rel="noopener">https://www.zhihu.com/question/19796641/answer/131856479</a></p>
<h2 id="Processing-js"><a href="#Processing-js" class="headerlink" title="Processing.js"></a>Processing.js</h2><p>Processing.js是一个开放的编程语言，在不使用Flash或Java小程序的前提下，可以实现程序图像、动画和互动的应用。Processing.js是轻量，易于了解掌握的理想工具，可用于可视化的数据，创建用户界面和开发基于Web的游戏。</p>
<h2 id="FABRIC-JS"><a href="#FABRIC-JS" class="headerlink" title="FABRIC.JS"></a>FABRIC.JS</h2><p>FABRIC.JS是一款简单而强大的JavaScript Canvas 库，提供了互动的对象模型，同时还包含 Canvas-to-SVG 解析器。</p>
<h2 id="oCanvas"><a href="#oCanvas" class="headerlink" title="oCanvas"></a>oCanvas</h2><p>oCanvas是一个JavaScript框架，用于简化HTML5 Canvas标签的使用，可以利用对象来代替像素。 oCanvas 可以帮助你很容易的在 HTML5 的 Canvas 标签上创建对象，并且创建这些对象的动画。</p>
<h2 id="jCanvas"><a href="#jCanvas" class="headerlink" title="jCanvas"></a>jCanvas</h2><p>jCanvas 就是一个 jQuery 的绘图插件，它封装了一些绘制图形的方法，只需编写几行代码即可生成图形。</p>
<h2 id="RGraph"><a href="#RGraph" class="headerlink" title="RGraph"></a>RGraph</h2><p>RGraph是一个使用HTML5 Canvas标签实现的图表制作Library。利用该Library生成的Chart具有可交互性，当鼠标点击或移过时会显示相应的信息，可以动态加载Chart或对特殊点进行缩放。</p>
<h2 id="Two-js"><a href="#Two-js" class="headerlink" title="Two.js"></a>Two.js</h2><p>Two.js 是面向现代 Web 浏览器的一个二维绘图 API。Two.js 可以用于多个场合：SVG，Canvas 和 WebGL，旨在使平面形状和动画的创建更方便，更简洁。</p>
<h2 id="Paper-js"><a href="#Paper-js" class="headerlink" title="Paper.js"></a>Paper.js</h2><p>Paper.js是一款开源的矢量图形脚本框架，基于 HTML5 Canvas 开发，提供清晰的场景图、DOM和大量强大的功能用来创建各种向量图和贝塞尔曲线。</p>
<h2 id="EaselJS"><a href="#EaselJS" class="headerlink" title="EaselJS"></a>EaselJS</h2><p>EaselJS 是一个封装了 HTML5 画布(Canvas) 元素的 JavaScript 库。</p>
<h2 id="Kinetic-JS"><a href="#Kinetic-JS" class="headerlink" title="Kinetic.JS"></a>Kinetic.JS</h2><p>Kinetic.JS 是一个封装了 HTML5 Canvas的JavaScript 库，能为桌面和移动应用提供高性能动画，转场效果，节点嵌套，分层，滤镜，缓存，事件处理以及更多功能。</p>
<h2 id="Pixi-js"><a href="#Pixi-js" class="headerlink" title="Pixi.js"></a>Pixi.js</h2><p>Pixi.js 是一个 2D webGL 渲染器，提供无缝 Canvas 回退，支持主流浏览器，包括桌面和移动。人生很短暂，过着过着你就没了，明白吗？JS攻城师你若有前端干货，欢迎前来投稿，一起执笔分享思考—-前端范。<a href="http://weixin.qq.com/r/UHWwqHbEnCvjrTLL9yBC" target="_blank" rel="noopener">http://weixin.qq.com/r/UHWwqHbEnCvjrTLL9yBC</a><br>公众号：js_gcs代码也是一种思考艺术编辑于 2016-11-18</p>
<h1 id="C-Fabric-js-–-简单而强大的-JavaScript-Canvas-库"><a href="#C-Fabric-js-–-简单而强大的-JavaScript-Canvas-库" class="headerlink" title="C Fabric.js – 简单而强大的 JavaScript Canvas 库"></a>C Fabric.js – 简单而强大的 JavaScript Canvas 库</h1><p><a href="http://www.cnblogs.com/lhb25/archive/2013/03/14/fabric-js-canvas-library.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/archive/2013/03/14/fabric-js-canvas-library.html</a>   </p>
<p>Fabric.js 是一个简单而强大的 JavaScript Canvas 库，在 HTML5 Canvas 元素之上提供了互动的对象模型，同时还包含 Canvas-to-SVG 解析器。</p>
<p>使用 Fabric.js 你可以创建和填充画布上的对象，从简单的几何图形到成百上千路径组成的复杂图形。你可以通过鼠标轻松的移动、缩放和旋转这些对象，修改它们的属性（颜色、透明度，层叠顺序）等等。</p>
<p>/图表类库/</p>
<h1 id="D-20-个最棒的-JavaScript-图表库"><a href="#D-20-个最棒的-JavaScript-图表库" class="headerlink" title="D 20 个最棒的 JavaScript 图表库"></a>D 20 个最棒的 JavaScript 图表库</h1><p><a href="http://www.imooc.com/article/1427" target="_blank" rel="noopener">http://www.imooc.com/article/1427</a><br>2015-08-26 10:33:36<br><strong>$_YX:</strong> <a href="https://app.yinxiang.com/shard/s67/nl/18114453/8f5e4997-b58a-4864-9e6e-6c5819ef4780?title=20%20%E4%B8%AA%E6%9C%80%E6%A3%92%E7%9A%84%20JavaScript%20%E5%9B%BE%E8%A1%A8%E5%BA%93_%E6%85%95%E8%AF%BE%E6%89%8B%E8%AE%B0" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s67/nl/18114453/8f5e4997-b58a-4864-9e6e-6c5819ef4780?title=20%20%E4%B8%AA%E6%9C%80%E6%A3%92%E7%9A%84%20JavaScript%20%E5%9B%BE%E8%A1%A8%E5%BA%93_%E6%85%95%E8%AF%BE%E6%89%8B%E8%AE%B0</a></p>
<h1 id="E-Boarder成熟作品"><a href="#E-Boarder成熟作品" class="headerlink" title="E Boarder成熟作品"></a>E Boarder成熟作品</h1><h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><ol>
<li>不用成熟作品</li>
<li>原生canvas已成熟，欠面向对象，移动，旋转等操作</li>
<li>利用库，仅oCanvas重写就可以了：体积小，文档全，操作简单，适合本（小）项目。（没必要使用那么大的库）</li>
<li>原生没有做移动设备，希望oCanvas可以处理</li>
</ol>
<p style="text-align:right">15:33 </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>文档注释生成库调研</title>
    <url>/sum/jsplus/%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E7%94%9F%E6%88%90%E5%BA%93%E8%B0%83%E7%A0%94(011)/</url>
    <content><![CDATA[<p>为mediasoup准备，或者其他后来的可能性；接触了好些文档了<br>仍然没有使用经验；不过，md经验不少，除了没有写过一些公式/流程图等</p>
<p style="text-align:right">2018.2.22 四 17:10</p>

<a id="more"></a> 
<!-- 1.24及之前有研究过，现记    -->
<h1 id="A-Javascript自动化文档工具：YUI-Doc-JSDoc-3-JSDuck等比较"><a href="#A-Javascript自动化文档工具：YUI-Doc-JSDoc-3-JSDuck等比较" class="headerlink" title="A [Javascript自动化文档工具：YUI Doc, JSDoc 3, JSDuck等比较]"></a>A [Javascript自动化文档工具：YUI Doc, JSDoc 3, JSDuck等比较]</h1><p>jsduck  yuidoc  jsdoc-3  文档生成  javascript  yeelan0319 2015年03月05日发布<br><a href="https://segmentfault.com/a/1190000002579067" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002579067</a></p>
<h2 id="文中涉及的工具"><a href="#文中涉及的工具" class="headerlink" title="文中涉及的工具"></a>文中涉及的工具</h2><p>JSDoc 3、YUIDoc、Dox、Docco、JSDuck</p>
<h2 id="比较标准"><a href="#比较标准" class="headerlink" title="比较标准"></a>比较标准</h2><ul>
<li>生成文档的易读性</li>
<li>工具的可扩展性</li>
<li>注释语法标准</li>
<li>注释语义的丰富程度</li>
</ul>
<h2 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h2><p>对没有兴趣了解细节比较的你，可以快速浏览下面的总结来了解这些工具。</p>
<ol>
<li><p>YUIDoc是YUI的附属项目。YUI团队希望这个文档工具不仅仅可以支持Javascript，而是更多的脚本语言，因此它并不考虑实际的代码实施细节，而只是对注释部分进行了扫描。从好的一面来说，如果你同时使用了Ruby/PHP/Python等等，YUI或许是一个比较适合的工具。从反面来说，因为它没有考虑实施细节，你需要额外的变量声明、同时生成的文档有可能会和实际的实施细节不吻合。</p>
</li>
<li><p>JSDoc 3的前身是JSDoc Toolkit。它会对代码的具体实施进行扫描，因此你如果不按照符合JSDoc的注释语法来进行注释的话，可能生成的文档一个字也没有。虽然它的学习曲线很高，但是一旦掌握了之后，由于它提供了完整的模版开发，事件触发等等接口，其灵活性也是不容小觑的。</p>
</li>
<li><p>Dox是一个非常轻量级和可以定制化的工具，它使用和JSDoc 3兼容的注释语法标准，并将其转化成JSON格式。因此在呈现方式上具有比JSDoc 3更强的可定制性，当然也意味着你初期的麻烦会比较多。</p>
</li>
<li><p>Docco是一种行间注释的方式。比起API注释，它更适合于注释代码的实施逻辑，以便于后期程序员能够快速捕捉到原作者在此处的实施意图。应该说是非常适合开源项目、多个作者共同维护的一个文档工具。比如最经典的Backbone Annotated Source就是使用Docco进行注释的。</p>
</li>
<li><p>JSDuck由Sencha开发，因此对于自家extJS具有非常强大的支持功能，包括令人咋舌的实时代码修改。但即使你不是使用extJS进行开发，JSDuck仍然是一个非常强大的工具，一方面它的语法非常灵活，描述支持Markdown语法，上手难度远远低于JSDoc 3；另一方面它生成的文档可读性堪比YUIDoc，同时支持源码的对照，学习起来也非常的容易。要说JSDuck有什么不好的地方，估计就是它把一切都Handle太完美了以致于没有给你提供什么可以自己定制的余地。</p>
</li>
</ol>
<p>最后我选择了JSDuck作为文档生成的工具。从目的上说，我需要生成的是提供给Q&amp;A和其他团队成员参考的API文档，考虑到毕竟写代码才是我们的主要工作，注释和文档越简单能够表达意思越好用，而JSDuck恰好十分符合我的需求。但是你选择使用哪种工具还需要根据使用场景来具体考虑，还请参考下面的细节比较</p>
<h2 id="细节比较（JSDoc-3-YUI-JSDuck）"><a href="#细节比较（JSDoc-3-YUI-JSDuck）" class="headerlink" title="细节比较（JSDoc 3, YUI, JSDuck）"></a>细节比较（JSDoc 3, YUI, JSDuck）</h2><h3 id="1-生成文档的易读性（YUIDoc、JSDuck）"><a href="#1-生成文档的易读性（YUIDoc、JSDuck）" class="headerlink" title="1 生成文档的易读性（YUIDoc、JSDuck）"></a>1 生成文档的易读性（YUIDoc、JSDuck）</h3><p>。。。</p>
<p># B [给 Web 开发人员推荐的文档生成工具]<br>阅读 1492 收藏 112 2017-09-22 原文链接：my.oschina.net<br><a href="https://juejin.im/entry/59c47ad7f265da065e323334" target="_blank" rel="noopener">https://juejin.im/entry/59c47ad7f265da065e323334</a>  </p>
<h1 id="C-告别手写-API文档生成工具推荐"><a href="#C-告别手写-API文档生成工具推荐" class="headerlink" title="C 告别手写 API文档生成工具推荐"></a>C 告别手写 API文档生成工具推荐</h1><p><a href="http://www.csdn.net/article/2013-02-20/2814189-API_DOC_TOOLS" target="_blank" rel="noopener">http://www.csdn.net/article/2013-02-20/2814189-API_DOC_TOOLS</a><br>发表于2013-02-20 10:19| 次阅读| 来源CSDN| 0 条评论| 作者张红月<br>APIAPI文档工具开放平台</p>
<blockquote>
<p>摘要：随着API的迅速发展，如何编写出更加规范的API文档说明则显的尤为重要。你是否还通过手写的方式来生成和编写这些文档呢？那么你就OUT啦！话说工欲善其事必先利其器，本文分享8款非常好的API文档生成工具给大家。</p>
</blockquote>
<p>随着API的发展以及需求的日益增加，对API文本文档的需求与随之而来。相信许多开发人员都遇到过编写API文档方面的问题及烦恼。<br>你是否还通过手写的方式来生成和编写这些文档呢？那么你就OUT啦！话说工欲善其事必先利其器，本文分享8款非常好的API文档生成工具给大家。</p>
<p>Web API文档工具列表</p>
<ol>
<li><p>Swagger ——Swagger框架可以通过代码生成漂亮的在线API，甚至可以提供运行示例。支持Scala、Java、Javascript、Ruby、PHP甚至 Actionscript 3。在线 Demo 。</p>
</li>
<li><p>I/O Docs ——I/O Docs是一个用于RESTful Web APIs的交互式文档系统。使用 JSON 模型根据资源、方法和参数定义 APIs。I/O Docs 将生成 JavaScript 客户端接口，可通过这些接口来调用系统。服务器端基于 Node.js 开发。在线Demo</p>
</li>
<li><p>apiary.io ——能够快速启动和运行文档，包括GitHub集成和I/O验证——更多建议可以前往Reddit查看上关于 Siyfion讨论。</p>
</li>
<li><p>Docco ——Docco是一个快速而随意、hundred-line-long、迭代程序风格的文档生成器。它会以HTML的方式显示评论和代码。</p>
</li>
<li><p>Dexy ——非常灵活的一款文档工具，支持任何语言编写的API。</p>
</li>
<li><p>Doxygen ——Doxgen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。对于未归档的源文件，也可以通过配置Doxygen来提取代码结构。 更多建议可以前往Reddi上查看 gkumar007相关讨论。</p>
</li>
<li><p>TurnAPI ——是一款付费的文档API工具。里面包含了智能WIKI编辑器、基于标准的Markdown、文档分支、还可以与Git、SVN、Mercurial同步、整洁的主题、友好的界面。</p>
</li>
</ol>
<p>以上仅是作者在实践中发现的一些很好的工具，如果你有更好的建议或工具推荐，欢迎与我们分享。<br>来自：<a href="!http://www.mattsilverman.com/2013/02/tools-to-generate-beautiful-api-documentation.html">MATTSILVERMAN</a></p>
<p># D JavaScript 文档生成工具<br>2014-01-22 JavaScript<br><a href="http://blog.inching.org/JavaScript/2014-01-22-javascript-document.html" target="_blank" rel="noopener">http://blog.inching.org/JavaScript/2014-01-22-javascript-document.html</a></p>
<p>=================<br># E 利用 Gitbook 生成文档中心站点<br>2016-02-17<br><a href="http://blog.bugtags.com/2016/02/17/gitbook-docs/" target="_blank" rel="noopener">http://blog.bugtags.com/2016/02/17/gitbook-docs/</a></p>
<p>====================<br># F [JSDoc中文文档]<br><a href="http://www.css88.com/doc/jsdoc/index.html" target="_blank" rel="noopener">http://www.css88.com/doc/jsdoc/index.html</a><br>## 使用Markdown插件</p>
<p># G APIDOC<br><a href="http://apidocjs.com/" target="_blank" rel="noopener">http://apidocjs.com/</a></p>
<p># H 使用Swagger构建Node.js API文档与Mock Server<br>Erum 关注 2017.10.27 17:52* 字数 1257 阅读 282评论 0喜欢 0赞赏 2<br><a href="https://www.jianshu.com/p/50446a0513f8" target="_blank" rel="noopener">https://www.jianshu.com/p/50446a0513f8</a></p>
<p># I dox, 使用 Markdown 和jsdoc的节点的JavaScript文档生成器<br><a href="https://www.helplib.com/GitHub/article_58201" target="_blank" rel="noopener">https://www.helplib.com/GitHub/article_58201</a></p>
<p>==============================<br># A Documentation generator for JS client? #2079<br><a href="https://github.com/swagger-api/swagger-codegen/issues/2079" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-codegen/issues/2079</a><br># B swagger-api/swagger-js<br><a href="https://github.com/swagger-api/swagger-js" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-js</a><br>Javascript library to connect to swagger-enabled APIs via browser or nodejs <a href="http://swagger.io" target="_blank" rel="noopener">http://swagger.io</a><br># C Surnet/swagger-jsdoc<br><a href="https://github.com/Surnet/swagger-jsdoc" target="_blank" rel="noopener">https://github.com/Surnet/swagger-jsdoc</a><br>Generates swagger doc based on JSDoc.<br># D wisdomtool/rest-client<br><a href="https://github.com/wisdomtool/rest-client" target="_blank" rel="noopener">https://github.com/wisdomtool/rest-client</a><br>A tool for automated testing REST API, generating exquisite testing report and REST API documentation.<br># E JacksonTian/doxmate<br><a href="https://github.com/JacksonTian/doxmate" target="_blank" rel="noopener">https://github.com/JacksonTian/doxmate</a><br>文档伴侣 <a href="http://html5ify.com/doxmate" target="_blank" rel="noopener">http://html5ify.com/doxmate</a></p>
<p>============================</p>
<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-资料整理"><a href="#一-资料整理" class="headerlink" title="一 资料整理"></a>一 资料整理</h2><ol>
<li>就前三篇分析比较，文档生成工具</li>
<li>第五篇 是利用 Gitbook生成文档中心站点：和文档还有点不同，取可取</li>
<li>F和G 是jsdoc第三方文档，官网</li>
<li>H是swagger的应用，和工作文档同（restfull api）</li>
<li>后面基本都是一些工具类</li>
<li>C 可以写swagger注释，生产swagger的风格</li>
<li>D 估计是利用swagger生成的产品</li>
<li>最后 Doxmate，风格不错，有模板</li>
</ol>
<p>好像还有esdoc</p>
<h2 id="二-选择"><a href="#二-选择" class="headerlink" title="二 选择"></a>二 选择</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1 分析"></a>2.1 分析</h3><ol>
<li>JSDoc 3还不错，虽然样式丑，但自主开发性高，已有一些不错的模板，而且见到几个文档也是JSDoc，比如video.js,debugger.js等npm包</li>
<li>上述基本都是基于前端的，生成md文件，然后可以再用插件生成网站；对前端友好<br>而非，swagger的json，yaml格式。</li>
<li>实际有swagger和php生成的restful api，样式做restful api还不错</li>
<li>swagger好像比JSDOC等文档注释要丰富一点，<br>好在，swagger有插件可以写基于JSDOC注释，写swagger风格样式</li>
<li>文档注释，JSDOC适中一点，没有swagger复杂，也不那么随意</li>
<li>JSDOC的文档相对其他几个好一些（swagger文档也不错）</li>
<li>基于前端的几个，Dox可以使用和JSDoc 3兼容的注释语法标准，并将其转化成JSON格式（考虑可以向swagger转）<br>E doxmate差不多就是dox</li>
</ol>
<h3 id="2-2-结果"><a href="#2-2-结果" class="headerlink" title="2.2 结果"></a>2.2 结果</h3><p>从分析，可知识JSDoc（名字上也和JS有联系，天生的喜感；用的也多，简单，稳定，可扩展）</p>
<p style="text-align:right">18:10 </p>

<h2 id="三-补充"><a href="#三-补充" class="headerlink" title="三 补充"></a>三 补充</h2><ol>
<li>上述是从代码文件中，提取注释，生成md或者静态html文件，从而生成文档API网页</li>
<li>swagger是json或者YAML格式的文件，生成文档API网页；也可以从代码注释中提取<br>单独的JSDOc 不知道不能生成文档文件</li>
<li>也可以直接写md文件，生成文档API，可以利用gitbook等其他方式生成网站。（hexo搭建的博客系统，也可以生成网页）</li>
<li>也可以直接写html等格式文件，自定义样式</li>
<li>restfullAPI，php中应用的swagger注释，可提取出json或YAML格式文件产生网页；<br>该网页可交互：用户提交（符合格式的）请求，可以返回相应的结果</li>
</ol>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack文档</title>
    <url>/w3/pkg/webpack-v3.10.0/</url>
    <content><![CDATA[<p>toc only.   </p>
<p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/</a></p>
<p style="text-align:right">2018.2.9 星期五 15:30</p>

<a id="more"></a>
<p><a href="https://doc.webpack-china.org/" target="_blank" rel="noopener">https://doc.webpack-china.org/</a></p>
<h1 id="A-概念"><a href="#A-概念" class="headerlink" title="A 概念"></a>A 概念</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h2><h3 id="1-1-入口-entry"><a href="#1-1-入口-entry" class="headerlink" title="1.1 入口(entry)"></a>1.1 入口(entry)</h3><h3 id="1-2-出口-output"><a href="#1-2-出口-output" class="headerlink" title="1.2 出口(output)"></a>1.2 出口(output)</h3><h3 id="1-3-loader"><a href="#1-3-loader" class="headerlink" title="1.3 loader"></a>1.3 loader</h3><h3 id="1-4-插件-plugins"><a href="#1-4-插件-plugins" class="headerlink" title="1.4 插件(plugins)"></a>1.4 插件(plugins)</h3><h2 id="二-入口起点-Entry-Points"><a href="#二-入口起点-Entry-Points" class="headerlink" title="二 入口起点(Entry Points)"></a>二 入口起点(Entry Points)</h2><h3 id="2-1-单个入口（简写）语法"><a href="#2-1-单个入口（简写）语法" class="headerlink" title="2.1 单个入口（简写）语法"></a>2.1 单个入口（简写）语法</h3><h3 id="2-2-对象语法"><a href="#2-2-对象语法" class="headerlink" title="2.2 对象语法"></a>2.2 对象语法</h3><h3 id="2-3-常见场景"><a href="#2-3-常见场景" class="headerlink" title="2.3 常见场景"></a>2.3 常见场景</h3><h4 id="1-分离应用程序"><a href="#1-分离应用程序" class="headerlink" title="1 分离应用程序"></a>1 分离应用程序</h4><h4 id="2-多页面应用程序"><a href="#2-多页面应用程序" class="headerlink" title="2 多页面应用程序"></a>2 多页面应用程序</h4><h2 id="三-输出-Output"><a href="#三-输出-Output" class="headerlink" title="三 输出(Output)"></a>三 输出(Output)</h2><h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h3><h3 id="3-2-多个入口起点"><a href="#3-2-多个入口起点" class="headerlink" title="3.2 多个入口起点"></a>3.2 多个入口起点</h3><h3 id="3-3-高级进阶"><a href="#3-3-高级进阶" class="headerlink" title="3.3 高级进阶"></a>3.3 高级进阶</h3><h2 id="四-Loader"><a href="#四-Loader" class="headerlink" title="四 Loader"></a>四 Loader</h2><h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><h3 id="4-2-使用Loader"><a href="#4-2-使用Loader" class="headerlink" title="4.2 使用Loader"></a>4.2 使用Loader</h3><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h4><h4 id="2-内联"><a href="#2-内联" class="headerlink" title="2 内联"></a>2 内联</h4><h4 id="3-CLI"><a href="#3-CLI" class="headerlink" title="3 CLI"></a>3 CLI</h4><h3 id="4-3-Loader特性"><a href="#4-3-Loader特性" class="headerlink" title="4.3 Loader特性"></a>4.3 Loader特性</h3><h3 id="4-4-解析Loader"><a href="#4-4-解析Loader" class="headerlink" title="4.4 解析Loader"></a>4.4 解析Loader</h3><h2 id="五-插件-Plugins"><a href="#五-插件-Plugins" class="headerlink" title="五 插件(Plugins)"></a>五 插件(Plugins)</h2><h3 id="5-1-剖析"><a href="#5-1-剖析" class="headerlink" title="5.1 剖析"></a>5.1 剖析</h3><h3 id="5-2-用法"><a href="#5-2-用法" class="headerlink" title="5.2 用法"></a>5.2 用法</h3><h3 id="5-3-配置"><a href="#5-3-配置" class="headerlink" title="5.3 配置"></a>5.3 配置</h3><h3 id="5-4-Node-API"><a href="#5-4-Node-API" class="headerlink" title="5.4 Node API"></a>5.4 Node API</h3><h2 id="六-配置-Configuration"><a href="#六-配置-Configuration" class="headerlink" title="六 配置(Configuration)"></a>六 配置(Configuration)</h2><h3 id="6-1-最简单的配置"><a href="#6-1-最简单的配置" class="headerlink" title="6.1 最简单的配置"></a>6.1 最简单的配置</h3><h3 id="6-2-多个Target"><a href="#6-2-多个Target" class="headerlink" title="6.2 多个Target"></a>6.2 多个Target</h3><h3 id="6-3-使用其他配置语言"><a href="#6-3-使用其他配置语言" class="headerlink" title="6.3 使用其他配置语言"></a>6.3 使用其他配置语言</h3><h2 id="七-模块-Modules"><a href="#七-模块-Modules" class="headerlink" title="七 模块(Modules)"></a>七 模块(Modules)</h2><h3 id="7-1-什么是webpack模块"><a href="#7-1-什么是webpack模块" class="headerlink" title="7.1 什么是webpack模块"></a>7.1 什么是webpack模块</h3><h3 id="7-2-支持的模块类型"><a href="#7-2-支持的模块类型" class="headerlink" title="7.2 支持的模块类型"></a>7.2 支持的模块类型</h3><h2 id="八-模块解析-Module-Resolution"><a href="#八-模块解析-Module-Resolution" class="headerlink" title="八 模块解析(Module Resolution)"></a>八 模块解析(Module Resolution)</h2><h3 id="8-1-webpack中的解析规则"><a href="#8-1-webpack中的解析规则" class="headerlink" title="8.1 webpack中的解析规则"></a>8.1 webpack中的解析规则</h3><h4 id="1-绝对路径"><a href="#1-绝对路径" class="headerlink" title="1 绝对路径"></a>1 绝对路径</h4><h4 id="2-相对路径"><a href="#2-相对路径" class="headerlink" title="2 相对路径"></a>2 相对路径</h4><h4 id="3-模块路径"><a href="#3-模块路径" class="headerlink" title="3 模块路径"></a>3 模块路径</h4><h3 id="8-2-解析Loader-Resolving-Loader"><a href="#8-2-解析Loader-Resolving-Loader" class="headerlink" title="8.2 解析Loader(Resolving Loader)"></a>8.2 解析Loader(Resolving Loader)</h3><h3 id="8-3-缓存"><a href="#8-3-缓存" class="headerlink" title="8.3 缓存"></a>8.3 缓存</h3><h2 id="九-依赖图-Dependency-Graph"><a href="#九-依赖图-Dependency-Graph" class="headerlink" title="九 依赖图(Dependency Graph)"></a>九 依赖图(Dependency Graph)</h2><h2 id="零-构建目标-Targets"><a href="#零-构建目标-Targets" class="headerlink" title="零 构建目标(Targets)"></a>零 构建目标(Targets)</h2><h3 id="0-1-用法"><a href="#0-1-用法" class="headerlink" title="0.1 用法"></a>0.1 用法</h3><h3 id="0-2-多个Target"><a href="#0-2-多个Target" class="headerlink" title="0.2 多个Target"></a>0.2 多个Target</h3><h3 id="0-3-资源"><a href="#0-3-资源" class="headerlink" title="0.3 资源"></a>0.3 资源</h3><h2 id="一-Manifest"><a href="#一-Manifest" class="headerlink" title="一 Manifest"></a>一 Manifest</h2><h3 id="1-1-Runtime"><a href="#1-1-Runtime" class="headerlink" title="1.1 Runtime"></a>1.1 Runtime</h3><h3 id="1-2-Manifest"><a href="#1-2-Manifest" class="headerlink" title="1.2 Manifest"></a>1.2 Manifest</h3><h3 id="1-3-问题"><a href="#1-3-问题" class="headerlink" title="1.3 问题"></a>1.3 问题</h3><h2 id="二-模块热替换-Hot-Module-Replace"><a href="#二-模块热替换-Hot-Module-Replace" class="headerlink" title="二 模块热替换(Hot Module Replace)"></a>二 模块热替换(Hot Module Replace)</h2><h3 id="2-1-这一切是如何运行的？"><a href="#2-1-这一切是如何运行的？" class="headerlink" title="2.1 这一切是如何运行的？"></a>2.1 这一切是如何运行的？</h3><h3 id="2-2-在应用程序中"><a href="#2-2-在应用程序中" class="headerlink" title="2.2 在应用程序中"></a>2.2 在应用程序中</h3><h3 id="2-3-在编译器中"><a href="#2-3-在编译器中" class="headerlink" title="2.3 在编译器中"></a>2.3 在编译器中</h3><h3 id="2-4-在HMT-Runtime中"><a href="#2-4-在HMT-Runtime中" class="headerlink" title="2.4 在HMT Runtime中"></a>2.4 在HMT Runtime中</h3><h3 id="2-5-入门"><a href="#2-5-入门" class="headerlink" title="2.5 入门"></a>2.5 入门</h3><p>==========================</p>
<h1 id="B-配置"><a href="#B-配置" class="headerlink" title="B 配置"></a>B 配置</h1><p style="text-align:right">2018.2.8 星期四 19:02</p>

<h2 id="一-配置"><a href="#一-配置" class="headerlink" title="一 配置"></a>一 配置</h2><h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1 选项"></a>1.1 选项</h3><h2 id="二-使用不同语言进行配置"><a href="#二-使用不同语言进行配置" class="headerlink" title="二 使用不同语言进行配置"></a>二 使用不同语言进行配置</h2><h3 id="2-1-TypeScript"><a href="#2-1-TypeScript" class="headerlink" title="2.1 TypeScript"></a>2.1 TypeScript</h3><h3 id="2-2-CoffeeScript"><a href="#2-2-CoffeeScript" class="headerlink" title="2.2 CoffeeScript"></a>2.2 CoffeeScript</h3><h3 id="2-3-Babel-and-JSX"><a href="#2-3-Babel-and-JSX" class="headerlink" title="2.3 Babel and JSX"></a>2.3 Babel and JSX</h3><h2 id="三-多种配置类型"><a href="#三-多种配置类型" class="headerlink" title="三 多种配置类型"></a>三 多种配置类型</h2><h3 id="3-1-导出一个函数"><a href="#3-1-导出一个函数" class="headerlink" title="3.1 导出一个函数"></a>3.1 导出一个函数</h3><h3 id="3-2-导出一个Promise"><a href="#3-2-导出一个Promise" class="headerlink" title="3.2 导出一个Promise"></a>3.2 导出一个Promise</h3><h3 id="3-3-导出多个配置对象"><a href="#3-3-导出多个配置对象" class="headerlink" title="3.3 导出多个配置对象"></a>3.3 导出多个配置对象</h3><h2 id="四-入口和上下文"><a href="#四-入口和上下文" class="headerlink" title="四 入口和上下文"></a>四 入口和上下文</h2><h3 id="4-1-context"><a href="#4-1-context" class="headerlink" title="4.1 context"></a>4.1 context</h3><h3 id="4-2-entry"><a href="#4-2-entry" class="headerlink" title="4.2 entry"></a>4.2 entry</h3><h3 id="4-3-命名"><a href="#4-3-命名" class="headerlink" title="4.3 命名"></a>4.3 命名</h3><h3 id="4-4-动态入口"><a href="#4-4-动态入口" class="headerlink" title="4.4 动态入口"></a>4.4 动态入口</h3><h2 id="五-输出"><a href="#五-输出" class="headerlink" title="五 输出"></a>五 输出</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><h2 id="六-模块-Module"><a href="#六-模块-Module" class="headerlink" title="六 模块(Module)"></a>六 模块(Module)</h2><h3 id="6-1-module-noParse"><a href="#6-1-module-noParse" class="headerlink" title="6.1 module.noParse"></a>6.1 module.noParse</h3><h3 id="6-2-module-rules"><a href="#6-2-module-rules" class="headerlink" title="6.2 module.rules"></a>6.2 module.rules</h3><h3 id="6-3-Rule"><a href="#6-3-Rule" class="headerlink" title="6.3 Rule"></a>6.3 Rule</h3><h4 id="1-Rule条件"><a href="#1-Rule条件" class="headerlink" title="1 Rule条件"></a>1 Rule条件</h4><h4 id="2-Rule-结果"><a href="#2-Rule-结果" class="headerlink" title="2 Rule 结果"></a>2 Rule 结果</h4><h4 id="3-嵌套的-Rule"><a href="#3-嵌套的-Rule" class="headerlink" title="3 嵌套的 Rule"></a>3 嵌套的 Rule</h4><h3 id="6-4-Rule-enforce"><a href="#6-4-Rule-enforce" class="headerlink" title="6.4 Rule.enforce"></a>6.4 Rule.enforce</h3><h3 id="6-5-Rule-exclude"><a href="#6-5-Rule-exclude" class="headerlink" title="6.5 Rule.exclude"></a>6.5 Rule.exclude</h3><h3 id="6-6-Rule-include"><a href="#6-6-Rule-include" class="headerlink" title="6.6 Rule.include"></a>6.6 Rule.include</h3><h3 id="6-7-Rule-issuer"><a href="#6-7-Rule-issuer" class="headerlink" title="6.7 Rule.issuer"></a>6.7 Rule.issuer</h3><h3 id="6-8-Rule-loader"><a href="#6-8-Rule-loader" class="headerlink" title="6.8 Rule.loader"></a>6.8 Rule.loader</h3><h3 id="6-9-Rule-loaders"><a href="#6-9-Rule-loaders" class="headerlink" title="6.9 Rule.loaders"></a>6.9 <del>Rule.loaders</del></h3><h3 id="6-0-Rule-oneOf"><a href="#6-0-Rule-oneOf" class="headerlink" title="6.0 Rule.oneOf"></a>6.0 Rule.oneOf</h3><h3 id="6-1-Rule-options-Rule-query"><a href="#6-1-Rule-options-Rule-query" class="headerlink" title="6.1 Rule.options/Rule.query"></a>6.1 <del>Rule.options/Rule.query</del></h3><h3 id="6-2-Rule-parser"><a href="#6-2-Rule-parser" class="headerlink" title="6.2 Rule.parser"></a>6.2 Rule.parser</h3><h3 id="6-3-Rule-resource"><a href="#6-3-Rule-resource" class="headerlink" title="6.3 Rule.resource"></a>6.3 Rule.resource</h3><h3 id="6-4-Rule-resourceQuery"><a href="#6-4-Rule-resourceQuery" class="headerlink" title="6.4 Rule.resourceQuery"></a>6.4 Rule.resourceQuery</h3><h3 id="6-5-Rule-rules"><a href="#6-5-Rule-rules" class="headerlink" title="6.5 Rule.rules"></a>6.5 Rule.rules</h3><h3 id="6-6-Rule-test"><a href="#6-6-Rule-test" class="headerlink" title="6.6 Rule.test"></a>6.6 Rule.test</h3><h3 id="6-7-Rule-use"><a href="#6-7-Rule-use" class="headerlink" title="6.7 Rule.use"></a>6.7 Rule.use</h3><h3 id="6-8-条件"><a href="#6-8-条件" class="headerlink" title="6.8 条件"></a>6.8 条件</h3><h3 id="6-9-UseEntry"><a href="#6-9-UseEntry" class="headerlink" title="6.9 UseEntry"></a>6.9 UseEntry</h3><h3 id="6-0-模块上下文"><a href="#6-0-模块上下文" class="headerlink" title="6.0 模块上下文"></a>6.0 模块上下文</h3><h2 id="七-解析"><a href="#七-解析" class="headerlink" title="七 解析"></a>七 解析</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h3><h3 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八 插件"></a>八 插件</h2><h3 id="8-1-plugins"><a href="#8-1-plugins" class="headerlink" title="8.1 plugins"></a>8.1 plugins</h3><h2 id="九-开发中Server-DevServer"><a href="#九-开发中Server-DevServer" class="headerlink" title="九 开发中Server(DevServer)"></a>九 开发中Server(DevServer)</h2><h3 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h3><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><h3 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h3><h3 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h3><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><h2 id="零-Devtool"><a href="#零-Devtool" class="headerlink" title="零 Devtool"></a>零 Devtool</h2><h3 id="0-1-devtool"><a href="#0-1-devtool" class="headerlink" title="0.1 devtool"></a>0.1 devtool</h3><h3 id="0-2-Qualities"><a href="#0-2-Qualities" class="headerlink" title="0.2 Qualities"></a>0.2 Qualities</h3><h3 id="0-3-Development"><a href="#0-3-Development" class="headerlink" title="0.3 Development"></a>0.3 Development</h3><h3 id="0-4-Special-cases"><a href="#0-4-Special-cases" class="headerlink" title="0.4 Special cases"></a>0.4 Special cases</h3><h3 id="0-5-Production"><a href="#0-5-Production" class="headerlink" title="0.5 Production"></a>0.5 Production</h3><h2 id="一-构建目标"><a href="#一-构建目标" class="headerlink" title="一 构建目标"></a>一 构建目标</h2><h3 id="1-1-target"><a href="#1-1-target" class="headerlink" title="1.1 target"></a>1.1 target</h3><h3 id="1-2-string"><a href="#1-2-string" class="headerlink" title="1.2 string"></a>1.2 string</h3><h3 id="1-3-function"><a href="#1-3-function" class="headerlink" title="1.3 function"></a>1.3 function</h3><h2 id="二-Watch和WatchOptions"><a href="#二-Watch和WatchOptions" class="headerlink" title="二 Watch和WatchOptions"></a>二 Watch和WatchOptions</h2><h3 id="2-1-watch"><a href="#2-1-watch" class="headerlink" title="2.1 watch"></a>2.1 watch</h3><h3 id="2-2-watchOptions"><a href="#2-2-watchOptions" class="headerlink" title="2.2 watchOptions"></a>2.2 watchOptions</h3><h3 id="2-3-watchOptions-aggregated"><a href="#2-3-watchOptions-aggregated" class="headerlink" title="2.3 watchOptions.aggregated"></a>2.3 watchOptions.aggregated</h3><h3 id="2-4-watchOptions-ignored"><a href="#2-4-watchOptions-ignored" class="headerlink" title="2.4 watchOptions.ignored"></a>2.4 watchOptions.ignored</h3><h3 id="2-5-watchOptions-poll"><a href="#2-5-watchOptions-poll" class="headerlink" title="2.5 watchOptions.poll"></a>2.5 watchOptions.poll</h3><h2 id="三-外部扩展-Externals"><a href="#三-外部扩展-Externals" class="headerlink" title="三 外部扩展(Externals)"></a>三 外部扩展(Externals)</h2><h3 id="3-1-externals"><a href="#3-1-externals" class="headerlink" title="3.1 externals"></a>3.1 externals</h3><h4 id="1-string"><a href="#1-string" class="headerlink" title="1 string"></a>1 string</h4><h4 id="2-array"><a href="#2-array" class="headerlink" title="2 array"></a>2 array</h4><h4 id="3-object"><a href="#3-object" class="headerlink" title="3 object"></a>3 object</h4><h4 id="4-funciton"><a href="#4-funciton" class="headerlink" title="4 funciton"></a>4 funciton</h4><h4 id="5-regex"><a href="#5-regex" class="headerlink" title="5 regex"></a>5 regex</h4><h2 id="四-性能-Performance"><a href="#四-性能-Performance" class="headerlink" title="四 性能(Performance)"></a>四 性能(Performance)</h2><h3 id="4-1-performance"><a href="#4-1-performance" class="headerlink" title="4.1 performance"></a>4.1 performance</h3><h3 id="4-2-performance-hints"><a href="#4-2-performance-hints" class="headerlink" title="4.2 performance.hints"></a>4.2 performance.hints</h3><h3 id="4-3-performanc-emaxEntry"><a href="#4-3-performanc-emaxEntry" class="headerlink" title="4.3 performanc.emaxEntry"></a>4.3 performanc.emaxEntry</h3><h3 id="4-4-performanc"><a href="#4-4-performanc" class="headerlink" title="4.4 performanc."></a>4.4 performanc.</h3><h3 id="4-5-performanc"><a href="#4-5-performanc" class="headerlink" title="4.5 performanc."></a>4.5 performanc.</h3><h2 id="五-Node"><a href="#五-Node" class="headerlink" title="五 Node"></a>五 Node</h2><h3 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4-1"><a href="#5-4-1" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5-1"><a href="#5-5-1" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h3><h2 id="六-统计-Stats"><a href="#六-统计-Stats" class="headerlink" title="六 统计(Stats)"></a>六 统计(Stats)</h2><h3 id="6-1-stats"><a href="#6-1-stats" class="headerlink" title="6.1 stats"></a>6.1 stats</h3><h2 id="七-其它选项"><a href="#七-其它选项" class="headerlink" title="七 其它选项"></a>七 其它选项</h2><h3 id="7-1-amd"><a href="#7-1-amd" class="headerlink" title="7.1 amd"></a>7.1 amd</h3><h3 id="7-2-bail"><a href="#7-2-bail" class="headerlink" title="7.2 bail"></a>7.2 bail</h3><h3 id="7-3-cache"><a href="#7-3-cache" class="headerlink" title="7.3 cache"></a>7.3 cache</h3><h3 id="7-4-loader"><a href="#7-4-loader" class="headerlink" title="7.4 loader"></a>7.4 loader</h3><h3 id="7-5-parallelism"><a href="#7-5-parallelism" class="headerlink" title="7.5 parallelism"></a>7.5 parallelism</h3><h3 id="7-6-profile"><a href="#7-6-profile" class="headerlink" title="7.6 profile"></a>7.6 profile</h3><h3 id="7-7-recordPath"><a href="#7-7-recordPath" class="headerlink" title="7.7 recordPath"></a>7.7 recordPath</h3><h3 id="7-8-recordInputPath"><a href="#7-8-recordInputPath" class="headerlink" title="7.8 recordInputPath"></a>7.8 recordInputPath</h3><h3 id="7-9-recordOutputPath"><a href="#7-9-recordOutputPath" class="headerlink" title="7.9 recordOutputPath"></a>7.9 recordOutputPath</h3><p>==========================</p>
<h1 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h1><p>===============================</p>
<h1 id="D-指南"><a href="#D-指南" class="headerlink" title="D 指南"></a>D 指南</h1><p><a href="https://doc.webpack-china.org/guides/development/" target="_blank" rel="noopener">https://doc.webpack-china.org/guides/development/</a></p>
<p style="text-align:right">2018.1.25 星期四 14:42 </p>

<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><h3 id="1-1-前提条件"><a href="#1-1-前提条件" class="headerlink" title="1.1 前提条件"></a>1.1 前提条件</h3><h3 id="1-2-本地安装"><a href="#1-2-本地安装" class="headerlink" title="1.2 本地安装"></a>1.2 本地安装</h3><h3 id="1-3-全局安装"><a href="#1-3-全局安装" class="headerlink" title="1.3 全局安装"></a>1.3 全局安装</h3><h3 id="1-4-最新体验版本"><a href="#1-4-最新体验版本" class="headerlink" title="1.4 最新体验版本"></a>1.4 最新体验版本</h3><h2 id="二-起步"><a href="#二-起步" class="headerlink" title="二 起步"></a>二 起步</h2><h3 id="2-1-基本安装"><a href="#2-1-基本安装" class="headerlink" title="2.1 基本安装"></a>2.1 基本安装</h3><h3 id="2-2-创建一个bundle文件"><a href="#2-2-创建一个bundle文件" class="headerlink" title="2.2 创建一个bundle文件"></a>2.2 创建一个bundle文件</h3><h3 id="2-3-模块"><a href="#2-3-模块" class="headerlink" title="2.3 模块"></a>2.3 模块</h3><h3 id="2-4-使用一个配置文件"><a href="#2-4-使用一个配置文件" class="headerlink" title="2.4 使用一个配置文件"></a>2.4 使用一个配置文件</h3><h3 id="2-5-NPM脚本"><a href="#2-5-NPM脚本" class="headerlink" title="2.5 NPM脚本"></a>2.5 NPM脚本</h3><h3 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2.6 结论"></a>2.6 结论</h3><h2 id="三-管理资源"><a href="#三-管理资源" class="headerlink" title="三 管理资源"></a>三 管理资源</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><h3 id="3-2-加载CSS"><a href="#3-2-加载CSS" class="headerlink" title="3.2 加载CSS"></a>3.2 加载CSS</h3><h3 id="3-3-加载字体"><a href="#3-3-加载字体" class="headerlink" title="3.3 加载字体"></a>3.3 加载字体</h3><h3 id="3-4-加载数据"><a href="#3-4-加载数据" class="headerlink" title="3.4 加载数据"></a>3.4 加载数据</h3><h3 id="3-5-全局资源"><a href="#3-5-全局资源" class="headerlink" title="3.5 全局资源"></a>3.5 全局资源</h3><h3 id="3-6-回退处理"><a href="#3-6-回退处理" class="headerlink" title="3.6 回退处理"></a>3.6 回退处理</h3><h3 id="3-7-下一章节指南"><a href="#3-7-下一章节指南" class="headerlink" title="3.7 下一章节指南"></a>3.7 下一章节指南</h3><h3 id="3-8-延伸阅读"><a href="#3-8-延伸阅读" class="headerlink" title="3.8 延伸阅读"></a>3.8 延伸阅读</h3><h2 id="四-管理输出"><a href="#四-管理输出" class="headerlink" title="四 管理输出"></a>四 管理输出</h2><h3 id="4-1-预先准备"><a href="#4-1-预先准备" class="headerlink" title="4.1 预先准备"></a>4.1 预先准备</h3><h3 id="4-2-设定HtmlWebpackPlugin"><a href="#4-2-设定HtmlWebpackPlugin" class="headerlink" title="4.2 设定HtmlWebpackPlugin"></a>4.2 设定HtmlWebpackPlugin</h3><h3 id="4-3-清理-dist文件夹"><a href="#4-3-清理-dist文件夹" class="headerlink" title="4.3 清理/dist文件夹"></a>4.3 清理/dist文件夹</h3><h3 id="4-4-Manifest"><a href="#4-4-Manifest" class="headerlink" title="4.4 Manifest"></a>4.4 Manifest</h3><h3 id="4-5-结论"><a href="#4-5-结论" class="headerlink" title="4.5 结论"></a>4.5 结论</h3><h2 id="五-开发"><a href="#五-开发" class="headerlink" title="五 开发"></a>五 开发</h2><h3 id="5-1-使用source-map"><a href="#5-1-使用source-map" class="headerlink" title="5.1 使用source map"></a>5.1 使用source map</h3><h3 id="5-2-选择一个开发工具"><a href="#5-2-选择一个开发工具" class="headerlink" title="5.2 选择一个开发工具"></a>5.2 选择一个开发工具</h3><h3 id="5-3-使用观察模式"><a href="#5-3-使用观察模式" class="headerlink" title="5.3 使用观察模式"></a>5.3 使用观察模式</h3><h3 id="5-4-使用-webpack-dev-server"><a href="#5-4-使用-webpack-dev-server" class="headerlink" title="5.4 使用 webpack-dev-server"></a>5.4 使用 webpack-dev-server</h3><h3 id="5-5-使用-Webpack-dev-middleware"><a href="#5-5-使用-Webpack-dev-middleware" class="headerlink" title="5.5 使用 Webpack-dev-middleware"></a>5.5 使用 Webpack-dev-middleware</h3><h3 id="5-6-调整文本编辑器"><a href="#5-6-调整文本编辑器" class="headerlink" title="5.6 调整文本编辑器"></a>5.6 调整文本编辑器</h3><h3 id="5-7-结论"><a href="#5-7-结论" class="headerlink" title="5.7 结论"></a>5.7 结论</h3><h2 id="六-模块热替换"><a href="#六-模块热替换" class="headerlink" title="六 模块热替换"></a>六 模块热替换</h2><h3 id="6-1-启用-HMR"><a href="#6-1-启用-HMR" class="headerlink" title="6.1 启用 HMR"></a>6.1 启用 HMR</h3><h3 id="6-2-通过Node-js-API"><a href="#6-2-通过Node-js-API" class="headerlink" title="6.2 通过Node.js API"></a>6.2 通过Node.js API</h3><h3 id="6-3-问题"><a href="#6-3-问题" class="headerlink" title="6.3 问题"></a>6.3 问题</h3><h3 id="6-4-HMR-修改样式表"><a href="#6-4-HMR-修改样式表" class="headerlink" title="6.4 HMR 修改样式表"></a>6.4 HMR 修改样式表</h3><h3 id="6-5-其他代码和框架"><a href="#6-5-其他代码和框架" class="headerlink" title="6.5 其他代码和框架"></a>6.5 其他代码和框架</h3><h2 id="七-Tree-Shaking"><a href="#七-Tree-Shaking" class="headerlink" title="七 Tree Shaking"></a>七 Tree Shaking</h2><h3 id="7-1-添加一个通用模块"><a href="#7-1-添加一个通用模块" class="headerlink" title="7.1 添加一个通用模块"></a>7.1 添加一个通用模块</h3><h3 id="7-2-精简输出"><a href="#7-2-精简输出" class="headerlink" title="7.2 精简输出"></a>7.2 精简输出</h3><h3 id="7-3-警告"><a href="#7-3-警告" class="headerlink" title="7.3 警告"></a>7.3 警告</h3><h3 id="7-4-结论"><a href="#7-4-结论" class="headerlink" title="7.4 结论"></a>7.4 结论</h3><h2 id="八-生产环境构建"><a href="#八-生产环境构建" class="headerlink" title="八 生产环境构建"></a>八 生产环境构建</h2><h3 id="8-1-配置"><a href="#8-1-配置" class="headerlink" title="8.1 配置"></a>8.1 配置</h3><h3 id="8-2-NPM-Script"><a href="#8-2-NPM-Script" class="headerlink" title="8.2 NPM Script"></a>8.2 NPM Script</h3><h3 id="8-3-Minification"><a href="#8-3-Minification" class="headerlink" title="8.3 Minification"></a>8.3 Minification</h3><h3 id="8-4-source-map"><a href="#8-4-source-map" class="headerlink" title="8.4 source map"></a>8.4 source map</h3><h3 id="8-5-指定环境"><a href="#8-5-指定环境" class="headerlink" title="8.5 指定环境"></a>8.5 指定环境</h3><h3 id="8-6-Split-CSS"><a href="#8-6-Split-CSS" class="headerlink" title="8.6 Split CSS"></a>8.6 Split CSS</h3><h3 id="8-7-CLI-替代选项"><a href="#8-7-CLI-替代选项" class="headerlink" title="8.7 CLI 替代选项"></a>8.7 CLI 替代选项</h3><h2 id="九-代码分离"><a href="#九-代码分离" class="headerlink" title="九 代码分离"></a>九 代码分离</h2><h3 id="9-1-入口起点"><a href="#9-1-入口起点" class="headerlink" title="9.1 入口起点"></a>9.1 入口起点</h3><h3 id="9-2-防止重复"><a href="#9-2-防止重复" class="headerlink" title="9.2 防止重复"></a>9.2 防止重复</h3><h3 id="9-3-动态导入"><a href="#9-3-动态导入" class="headerlink" title="9.3 动态导入"></a>9.3 动态导入</h3><h3 id="9-4-bundle分析"><a href="#9-4-bundle分析" class="headerlink" title="9.4 bundle分析"></a>9.4 bundle分析</h3><h3 id="9-5-下一步"><a href="#9-5-下一步" class="headerlink" title="9.5 下一步"></a>9.5 下一步</h3><h2 id="零-懒加载"><a href="#零-懒加载" class="headerlink" title="零 懒加载"></a>零 懒加载</h2><h3 id="0-1-示例"><a href="#0-1-示例" class="headerlink" title="0.1 示例"></a>0.1 示例</h3><h3 id="0-2-框架"><a href="#0-2-框架" class="headerlink" title="0.2 框架"></a>0.2 框架</h3><h2 id="一-缓存"><a href="#一-缓存" class="headerlink" title="一 缓存"></a>一 缓存</h2><h3 id="1-1-输出文件的文件名"><a href="#1-1-输出文件的文件名" class="headerlink" title="1.1 输出文件的文件名"></a>1.1 输出文件的文件名</h3><h3 id="1-2-提取模板"><a href="#1-2-提取模板" class="headerlink" title="1.2 提取模板"></a>1.2 提取模板</h3><h3 id="1-3-模块标识符"><a href="#1-3-模块标识符" class="headerlink" title="1.3 模块标识符"></a>1.3 模块标识符</h3><h3 id="1-4-结论"><a href="#1-4-结论" class="headerlink" title="1.4 结论"></a>1.4 结论</h3><h3 id="1-5-译注"><a href="#1-5-译注" class="headerlink" title="1.5 译注"></a>1.5 译注</h3><h2 id="二-创建Library"><a href="#二-创建Library" class="headerlink" title="二 创建Library"></a>二 创建Library</h2><h3 id="2-1-创建一个library"><a href="#2-1-创建一个library" class="headerlink" title="2.1 创建一个library"></a>2.1 创建一个library</h3><h3 id="2-2-基本配置"><a href="#2-2-基本配置" class="headerlink" title="2.2 基本配置"></a>2.2 基本配置</h3><h3 id="2-3-外部化lodash"><a href="#2-3-外部化lodash" class="headerlink" title="2.3 外部化lodash"></a>2.3 外部化lodash</h3><h3 id="2-4-外部扩展的限制"><a href="#2-4-外部扩展的限制" class="headerlink" title="2.4 外部扩展的限制"></a>2.4 外部扩展的限制</h3><h3 id="2-5-暴露library"><a href="#2-5-暴露library" class="headerlink" title="2.5 暴露library"></a>2.5 暴露library</h3><h3 id="2-6-最终步骤"><a href="#2-6-最终步骤" class="headerlink" title="2.6 最终步骤"></a>2.6 最终步骤</h3><h2 id="三-Shimming"><a href="#三-Shimming" class="headerlink" title="三 Shimming"></a>三 Shimming</h2><h3 id="3-1-shimming全局变量"><a href="#3-1-shimming全局变量" class="headerlink" title="3.1 shimming全局变量"></a>3.1 shimming全局变量</h3><h3 id="3-2-细粒度shimming"><a href="#3-2-细粒度shimming" class="headerlink" title="3.2 细粒度shimming"></a>3.2 细粒度shimming</h3><h3 id="3-3-全局exports"><a href="#3-3-全局exports" class="headerlink" title="3.3 全局exports"></a>3.3 全局exports</h3><h3 id="3-4-加载polyfills"><a href="#3-4-加载polyfills" class="headerlink" title="3.4 加载polyfills"></a>3.4 加载polyfills</h3><h3 id="3-5-深度优化"><a href="#3-5-深度优化" class="headerlink" title="3.5 深度优化"></a>3.5 深度优化</h3><h3 id="3-6-Node内置"><a href="#3-6-Node内置" class="headerlink" title="3.6 Node内置"></a>3.6 Node内置</h3><h3 id="3-7-其他工具"><a href="#3-7-其他工具" class="headerlink" title="3.7 其他工具"></a>3.7 其他工具</h3><h2 id="四-TypeScript"><a href="#四-TypeScript" class="headerlink" title="四 TypeScript"></a>四 TypeScript</h2><h3 id="4-1-基础安装"><a href="#4-1-基础安装" class="headerlink" title="4.1 基础安装"></a>4.1 基础安装</h3><h3 id="4-2-Loader"><a href="#4-2-Loader" class="headerlink" title="4.2 Loader"></a>4.2 Loader</h3><h3 id="4-3-source-map"><a href="#4-3-source-map" class="headerlink" title="4.3 source map"></a>4.3 source map</h3><h3 id="4-4-使用第三方库"><a href="#4-4-使用第三方库" class="headerlink" title="4.4 使用第三方库"></a>4.4 使用第三方库</h3><h3 id="4-5-导入其他资源"><a href="#4-5-导入其他资源" class="headerlink" title="4.5 导入其他资源"></a>4.5 导入其他资源</h3><h3 id="4-6-构建性能"><a href="#4-6-构建性能" class="headerlink" title="4.6 构建性能"></a>4.6 构建性能</h3><h2 id="五-渐进式网络应用程序"><a href="#五-渐进式网络应用程序" class="headerlink" title="五 渐进式网络应用程序"></a>五 渐进式网络应用程序</h2><h3 id="5-1-现在我们并没有离线环境"><a href="#5-1-现在我们并没有离线环境" class="headerlink" title="5.1 现在我们并没有离线环境"></a>5.1 现在我们并没有离线环境</h3><h3 id="5-2-天津Workbox"><a href="#5-2-天津Workbox" class="headerlink" title="5.2 天津Workbox"></a>5.2 天津Workbox</h3><h3 id="5-3-注册我们的Service-Worker"><a href="#5-3-注册我们的Service-Worker" class="headerlink" title="5.3 注册我们的Service Worker"></a>5.3 注册我们的Service Worker</h3><h3 id="5-4-结论"><a href="#5-4-结论" class="headerlink" title="5.4 结论"></a>5.4 结论</h3><h2 id="六-迁移到新版本"><a href="#六-迁移到新版本" class="headerlink" title="六 迁移到新版本"></a>六 迁移到新版本</h2><h2 id="七-使用环境变量"><a href="#七-使用环境变量" class="headerlink" title="七 使用环境变量"></a>七 使用环境变量</h2><h2 id="八-构建性能"><a href="#八-构建性能" class="headerlink" title="八 构建性能"></a>八 构建性能</h2><h3 id="8-1-常规"><a href="#8-1-常规" class="headerlink" title="8.1 常规"></a>8.1 常规</h3><h4 id="1-保持版本最新"><a href="#1-保持版本最新" class="headerlink" title="1 保持版本最新"></a>1 保持版本最新</h4><h4 id="2-Loaders"><a href="#2-Loaders" class="headerlink" title="2 Loaders"></a>2 Loaders</h4><h4 id="3-Bootstrap"><a href="#3-Bootstrap" class="headerlink" title="3 Bootstrap"></a>3 Bootstrap</h4><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4 解析"></a>4 解析</h4><h4 id="5-Dlls"><a href="#5-Dlls" class="headerlink" title="5 Dlls"></a>5 Dlls</h4><h4 id="6-Samller-Faster"><a href="#6-Samller-Faster" class="headerlink" title="6 Samller = Faster"></a>6 Samller = Faster</h4><h4 id="7-Worker-Pool"><a href="#7-Worker-Pool" class="headerlink" title="7 Worker Pool"></a>7 Worker Pool</h4><h4 id="8-持久化缓存"><a href="#8-持久化缓存" class="headerlink" title="8 持久化缓存"></a>8 持久化缓存</h4><h4 id="9-自定义-plugins-loaders"><a href="#9-自定义-plugins-loaders" class="headerlink" title="9 自定义 plugins/loaders"></a>9 自定义 plugins/loaders</h4><h3 id="8-2-Development"><a href="#8-2-Development" class="headerlink" title="8.2 Development"></a>8.2 Development</h3><h4 id="1-增量编译"><a href="#1-增量编译" class="headerlink" title="1 增量编译"></a>1 增量编译</h4><h4 id="2-在内存中编译"><a href="#2-在内存中编译" class="headerlink" title="2 在内存中编译"></a>2 在内存中编译</h4><h4 id="3-Devtool"><a href="#3-Devtool" class="headerlink" title="3 Devtool"></a>3 Devtool</h4><h4 id="4-避免在生产环境下才会用"><a href="#4-避免在生产环境下才会用" class="headerlink" title="4 避免在生产环境下才会用"></a>4 避免在生产环境下才会用</h4><h4 id="5-最小化入口chunk"><a href="#5-最小化入口chunk" class="headerlink" title="5 最小化入口chunk"></a>5 最小化入口chunk</h4><h3 id="8-3-Production"><a href="#8-3-Production" class="headerlink" title="8.3 Production"></a>8.3 Production</h3><h4 id="1-多个编译时"><a href="#1-多个编译时" class="headerlink" title="1 多个编译时"></a>1 多个编译时</h4><h4 id="2-Source-Maps"><a href="#2-Source-Maps" class="headerlink" title="2 Source Maps"></a>2 Source Maps</h4><h3 id="8-4-工具相关问题"><a href="#8-4-工具相关问题" class="headerlink" title="8.4 工具相关问题"></a>8.4 工具相关问题</h3><h4 id="1-Babel"><a href="#1-Babel" class="headerlink" title="1 Babel"></a>1 Babel</h4><h4 id="2-Typescript"><a href="#2-Typescript" class="headerlink" title="2 Typescript"></a>2 Typescript</h4><h4 id="3-Sass"><a href="#3-Sass" class="headerlink" title="3 Sass"></a>3 Sass</h4><h2 id="九-开发-Vagrant"><a href="#九-开发-Vagrant" class="headerlink" title="九 开发-Vagrant"></a>九 开发-Vagrant</h2><h3 id="9-1-项目配置"><a href="#9-1-项目配置" class="headerlink" title="9.1 项目配置"></a>9.1 项目配置</h3><h3 id="9-2-启动服务器"><a href="#9-2-启动服务器" class="headerlink" title="9.2 启动服务器"></a>9.2 启动服务器</h3><h3 id="9-3-配合nginx的高级用法"><a href="#9-3-配合nginx的高级用法" class="headerlink" title="9.3 配合nginx的高级用法"></a>9.3 配合nginx的高级用法</h3><h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><h2 id="零-管理依赖"><a href="#零-管理依赖" class="headerlink" title="零 管理依赖"></a>零 管理依赖</h2><h3 id="0-1-带表达式的require语句"><a href="#0-1-带表达式的require语句" class="headerlink" title="0.1 带表达式的require语句"></a>0.1 带表达式的require语句</h3><h3 id="0-2-require-context"><a href="#0-2-require-context" class="headerlink" title="0.2 require.context"></a>0.2 require.context</h3><h3 id="0-3-上下文模块"><a href="#0-3-上下文模块" class="headerlink" title="0.3 上下文模块"></a>0.3 上下文模块</h3><h2 id="一-公共路径-Public-Path"><a href="#一-公共路径-Public-Path" class="headerlink" title="一 公共路径(Public Path)"></a>一 公共路径(Public Path)</h2><h3 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h3><h3 id="1-2-在构建项目时设置路径值"><a href="#1-2-在构建项目时设置路径值" class="headerlink" title="1.2 在构建项目时设置路径值"></a>1.2 在构建项目时设置路径值</h3><h3 id="1-3-即时设定路径值"><a href="#1-3-即时设定路径值" class="headerlink" title="1.3 即时设定路径值"></a>1.3 即时设定路径值</h3><h2 id="二-集成-Intergrations"><a href="#二-集成-Intergrations" class="headerlink" title="二 集成(Intergrations)"></a>二 集成(Intergrations)</h2><h3 id="2-1-NPM-Scripts"><a href="#2-1-NPM-Scripts" class="headerlink" title="2.1 NPM Scripts"></a>2.1 NPM Scripts</h3><h3 id="2-2-Grunt"><a href="#2-2-Grunt" class="headerlink" title="2.2 Grunt"></a>2.2 Grunt</h3><h3 id="2-3-Gulp"><a href="#2-3-Gulp" class="headerlink" title="2.3 Gulp"></a>2.3 Gulp</h3><h3 id="2-4-Mocha"><a href="#2-4-Mocha" class="headerlink" title="2.4 Mocha"></a>2.4 Mocha</h3><h3 id="2-5-Karma"><a href="#2-5-Karma" class="headerlink" title="2.5 Karma"></a>2.5 Karma</h3><h1 id="E-LOADERS"><a href="#E-LOADERS" class="headerlink" title="E LOADERS"></a>E LOADERS</h1><h1 id="F-插件"><a href="#F-插件" class="headerlink" title="F 插件"></a>F 插件</h1>]]></content>
      <categories>
        <category>w3</category>
        <category>pkg</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack学习小结</title>
    <url>/sum/jsplus/webpack%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<!-- mediasoup的时候准备使用；还没有用，v4就出了（零配置）；
还是可以先v3 -->
<p>v3</p>
<p><a href="https://doc.webpack-china.org/guides/" target="_blank" rel="noopener">https://doc.webpack-china.org/guides/</a></p>
<p style="text-align:right">2018.2.8 星期四 16:42 </p>

<a id="more"></a>
<h2 id="一-SMTC"><a href="#一-SMTC" class="headerlink" title="一 SMTC"></a>一 SMTC</h2><p>webpack.test.conf.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack=<span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin=<span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin=<span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> extractLess = <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">    filename: <span class="string">"[name].[contenthash].css"</span>,</span><br><span class="line">    <span class="comment">// disable: process.env.NODE_ENV === "development"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    context:path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">    entry:&#123;</span><br><span class="line">        <span class="comment">// main:['./src/js/app1.js','./src/js/app2.js'],</span></span><br><span class="line">        main:[<span class="string">'./src/js/app.js'</span>,<span class="string">'./src/js/common.js'</span>],</span><br><span class="line">        vendor:[<span class="string">'./src/js/lib/tab.js'</span>,<span class="string">'./src/js/lib/lottery.js'</span>],</span><br><span class="line">        polyfills:[<span class="string">'./src/js/polyfills.js'</span>],</span><br><span class="line">        <span class="comment">// dll:['mediasoup-client']</span></span><br><span class="line">        <span class="comment">// dll:['mediasoup-client','ocanvas']</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// filename:'[name].[hash].js',</span></span><br><span class="line">        filename:<span class="string">'[name].bundle.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'./dist'</span>),</span><br><span class="line">        <span class="comment">// path:__dirname + './dist',</span></span><br><span class="line">        publicPath:<span class="string">'/'</span></span><br><span class="line">        <span class="comment">// library: '[name]', // 当前Dll的所有内容都会存放在这个参数指定变量名的一个全局变量下，注意与DllPlugin的name参数保持一致</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// devtool:'cheap-module-eval-source-map',</span></span><br><span class="line">    devtool:<span class="string">'inline-source-map'</span>,</span><br><span class="line">    <span class="comment">// devtool:'source-map',</span></span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:[<span class="string">'./dist'</span>,<span class="string">'./'</span>],</span><br><span class="line">        port:<span class="number">9000</span>,</span><br><span class="line">        compress: <span class="literal">true</span>,</span><br><span class="line">        hot:<span class="literal">true</span></span><br><span class="line">    &#125;,    </span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[<span class="string">'.js'</span>,<span class="string">'.less'</span>],</span><br><span class="line">        alias:&#123;</span><br><span class="line">            <span class="string">'data'</span>:path.resolve(__dirname,<span class="string">'../data/'</span>),</span><br><span class="line">            <span class="string">'ajs'</span>:path.resolve(__dirname,<span class="string">'../assets/js'</span>),</span><br><span class="line">            <span class="string">'acss'</span>:path.resolve(__dirname,<span class="string">'../assets/css'</span>),</span><br><span class="line">            <span class="string">'aimg'</span>:path.resolve(__dirname,<span class="string">'../assets/images'</span>),</span><br><span class="line">            <span class="string">'lib'</span>:path.resolve(__dirname,<span class="string">'../src/js/lib'</span>),</span><br><span class="line">            <span class="string">'components'</span>:path.resolve(__dirname,<span class="string">'../src/css/components'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            <span class="comment">// enforce:'pre',</span></span><br><span class="line">            <span class="comment">// test:/\.js$/,</span></span><br><span class="line">            <span class="comment">// loader:['eslint-loader'],</span></span><br><span class="line">            <span class="comment">// include:path.resolve(__dirname,'../src/js'),</span></span><br><span class="line">            <span class="comment">// // exclude:/node_modules/,</span></span><br><span class="line">            <span class="comment">// options:&#123;</span></span><br><span class="line">            <span class="comment">//     // configFile: path.resolve(__dirname,'../.eslintrc.js'), // 指定eslint的配置文件在哪里</span></span><br><span class="line">            <span class="comment">//     eslintPath: path.resolve(__dirname,'../.eslintrc.js'), // 指定eslint的配置文件在哪里</span></span><br><span class="line">            <span class="comment">//     failOnWarning: false, // eslint报warning了就终止webpack编译</span></span><br><span class="line">            <span class="comment">//     failOnError: true, // eslint报error了就终止webpack编译</span></span><br><span class="line">            <span class="comment">//     cache: true, // 开启eslint的cache，cache存在node_modules/.cache目录里</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:<span class="string">"css-loader"</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="comment">// loader:ExtractTextPlugin.extract(</span></span><br><span class="line">                <span class="comment">// "style-loader",</span></span><br><span class="line">                <span class="comment">// "css-loader?sourceMap"</span></span><br><span class="line">            <span class="comment">// ),</span></span><br><span class="line">            include:path.resolve(__dirname, <span class="string">'../src/css'</span>)</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test:<span class="regexp">/\.less/</span>,</span><br><span class="line">            use:extractLess.extract(&#123;</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">"css-loader"</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">"less-loader"</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        strictMath:<span class="literal">true</span>,</span><br><span class="line">                        noIeCompat:<span class="literal">true</span>,</span><br><span class="line">                        sourceMap:<span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;],</span><br><span class="line">                <span class="comment">// use style-loader in development</span></span><br><span class="line">                fallback: <span class="string">"style-loader"</span><span class="comment">//</span></span><br><span class="line">            &#125;),</span><br><span class="line">            include:path.resolve(__dirname,<span class="string">'../src/css/'</span>)</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">            loader:<span class="string">'url-loader?limit=8192&amp;name=./static/img/[hash].[ext]'</span>, <span class="comment">//  &lt;= 8kb的图片base64内联</span></span><br><span class="line">            <span class="comment">// use:['url','file-loader'],</span></span><br><span class="line">            include:path.resolve(__dirname,<span class="string">'../src/images/'</span>),</span><br><span class="line">            query: &#123;</span><br><span class="line">                <span class="comment">//   limit: 10000,</span></span><br><span class="line">                <span class="comment">//   name: utils.assetsPath('img/[name].[hash:7].[ext]')</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">            loader: <span class="string">'url'</span>,</span><br><span class="line">            include:path.resolve(__dirname,<span class="string">'../src/fonts'</span>),</span><br><span class="line">            query: &#123;</span><br><span class="line">                limit: <span class="number">10000</span>,</span><br><span class="line">                <span class="comment">// name: utils.assetsPath('fonts/[name].[hash:7].[ext]')</span></span><br><span class="line">                name: <span class="string">'./static/fonts/[name].[hash].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="comment">// 如果你所有的jQuery插件都是用webpack来加载的话，</span></span><br><span class="line">            <span class="comment">// 的确用ProvidePlugin就足够了；但总有那么些需求是只能用&lt;script&gt;来加载的。</span></span><br><span class="line">            test: <span class="built_in">require</span>.resolve(<span class="string">'jquery'</span>),  <span class="comment">// 此loader配置项的目标是NPM中的jquery</span></span><br><span class="line">            loader: <span class="string">'expose-loader?$!expose-loader?jQuery'</span>, <span class="comment">// 先把jQuery对象声明成为全局变量`jQuery`，再通过管道进一步又声明成为全局变量`$`</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            test:<span class="built_in">require</span>.resolve(<span class="string">'../assets/js/iscroll.js'</span>),</span><br><span class="line">            loader: <span class="string">'exports-loader?IScroll'</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</span></span><br><span class="line">        noParse:<span class="regexp">/iscroll/</span></span><br><span class="line">        <span class="comment">// 从webpack 3.0.0开始</span></span><br><span class="line">        <span class="comment">// noParse:content=&gt;&#123;return /iscroll/.test(content)&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>), <span class="comment">// 打包css/less的时候会用到ExtractTextPlugin</span></span><br><span class="line">        extractLess,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env.NODE_ENV'</span>:<span class="built_in">JSON</span>.stringify(<span class="string">'devlopment'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name: <span class="string">'vendor'</span>,</span><br><span class="line">            filename: <span class="string">"vendor.js"</span>,</span><br><span class="line">            chunks: [<span class="string">'vendor'</span>,<span class="string">'dll'</span>],</span><br><span class="line">            minChunks:<span class="number">3</span>,</span><br><span class="line">            <span class="comment">// async:true,</span></span><br><span class="line">            <span class="comment">// children:true</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">/* new webpack.DllPlugin(&#123;</span></span><br><span class="line"><span class="comment">            path: 'manifest.json', // 本Dll文件中各模块的索引，供DllReferencePlugin读取使用</span></span><br><span class="line"><span class="comment">            name: '[name]',  // 当前Dll的所有内容都会存放在这个参数指定变量名的一个全局变量下，注意与参数output.library保持一致</span></span><br><span class="line"><span class="comment">            context:path.resolve(__dirname, '../'), // 指定一个路径作为上下文环境，需要与DllReferencePlugin的context参数保持一致，建议统一设置为项目根目录</span></span><br><span class="line"><span class="comment">        &#125;), */</span></span><br><span class="line">        <span class="comment">/* 跟业务代码一样，该兼容的还是得兼容 */</span></span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">            $:<span class="string">'jquery'</span>,</span><br><span class="line">            jQuery:<span class="string">'jquery'</span>,</span><br><span class="line">            <span class="string">'window.jQuery'</span>:<span class="string">'jquery'</span>,</span><br><span class="line">            <span class="string">'window.$'</span>:<span class="string">'jquery'</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">// generate dist index.html with correct asset hash for caching.</span></span><br><span class="line">        <span class="comment">// you can customize output by editing /index.html</span></span><br><span class="line">        <span class="comment">// see https://github.com/ampedandwired/html-webpack-plugin</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            title:<span class="string">'htmlwebpackplugin title'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">            favicon:<span class="string">'./src/favicon.ico'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            excludeChunks:[<span class="string">'polyfills'</span>]</span><br><span class="line">            <span class="comment">// chunks:['main','vendor'],</span></span><br><span class="line">            <span class="comment">// minify:false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 配置了这个属性之后 vue 和 vue-router这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了</span></span><br><span class="line">    <span class="comment">//externals对象的key是给require时用的，比如require('vue'),，对象的value表示的是如何在global（即window）中访问到该对象，这里是window.Vue</span></span><br><span class="line">    externals:&#123;</span><br><span class="line">        <span class="comment">// jquery:'window.jQuery',</span></span><br><span class="line">        <span class="comment">// mediasoupclient:'mediasoup-client'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// target:'web'//default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p style="text-align:right">2018.2.11 星期日 14:32</p>

<h2 id="二-配置说明"><a href="#二-配置说明" class="headerlink" title="二 配置说明"></a>二 配置说明</h2><h3 id="2-1-context，entry-module-rules-0-test-和module-rules-0-loader"><a href="#2-1-context，entry-module-rules-0-test-和module-rules-0-loader" class="headerlink" title="2.1 context，entry , module.rules[0].test 和module.rules[0].loader"></a>2.1 context，entry , module.rules[0].test 和module.rules[0].loader</h3><ol start="0">
<li>context:基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader   </li>
<li>entry:字符串：指向具体入口文件</li>
<li>test:请求文件的绝对路径。它已经根据 resolve 规则解析。<br> 正则，<code>require.resolve(&#39;../assets/js/iscroll.js&#39;)</code></li>
<li>path:,指向路径</li>
<li>loader:字符串，指向某个loader<blockquote>
<p>path.resolve 和path.join用法和区别</p>
</blockquote>
</li>
</ol>
<h3 id="2-2-output-publicPath-和-devServer-contentBase"><a href="#2-2-output-publicPath-和-devServer-contentBase" class="headerlink" title="2.2 output.publicPath 和 devServer.contentBase"></a>2.2 output.publicPath 和 devServer.contentBase</h3><ol>
<li>output.publicPath:webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。</li>
<li>devServer.contentBase:指定服务器提供静态资源的路径，devServer启动后，可以根据该contentBase（可以数组，指定过个资源路径）引入资源</li>
</ol>
<h3 id="2-3-module的几个常见概念"><a href="#2-3-module的几个常见概念" class="headerlink" title="2.3 module的几个常见概念"></a>2.3 module的几个常见概念</h3><ol>
<li>modules.rules[0].resourec :module.rules[0].test配合 module.rules[0].include/excluede的使用</li>
<li>module.rules[0].test == module.rules[0].resource.test<blockquote>
<p>如果你提供了一个 Rule.test 选项，就不能再提供 Rule.resource</p>
</blockquote>
</li>
<li>和module.rules[0].loaders==module.rules[0].use  </li>
<li>module.rules[0].loader==module.rules[0].use:[{loader}]</li>
<li>module.rules[0].rules 好像见过</li>
</ol>
<h3 id="2-4-第三方库的引入：shimming，CommonsChunkPlugin，DllPlugin和UglifyJSPlugin"><a href="#2-4-第三方库的引入：shimming，CommonsChunkPlugin，DllPlugin和UglifyJSPlugin" class="headerlink" title="2.4 第三方库的引入：shimming，CommonsChunkPlugin，DllPlugin和UglifyJSPlugin"></a>2.4 第三方库的引入：shimming，CommonsChunkPlugin，DllPlugin和UglifyJSPlugin</h3><p>/shimming/</p>
<ol>
<li>ProvidePlugin：把模块作为应用程序中的一个全局变量。</li>
<li>imports-loader: 模块需要某个依赖时使用，比如this指向window，bootstrap需要jQuery</li>
<li>exports-loader：将一个全局变量作为一个普通的模块来导出,需要import</li>
<li>expose-loader: 暴露一个全局变量，不需要import。注意和ProvidePlugin的区别:？？ProvidePlugin可以暴露jQuery1.11.3的全局变量吗<blockquote>
<p>The expose loader adds modules to the global object. This is useful for debugging, or supporting libraries that depend on libraries in globals.</p>
</blockquote>
</li>
<li>script-loader：估计和expose差不多</li>
</ol>
<p>/构建性能/</p>
<ol start="6">
<li>noParse:expose,script，还有exports的模块应该可以用module.noParse配置<blockquote>
<p>noParse:防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</p>
</blockquote>
</li>
<li>module.externals :有人说不符合webpack模块管理了？？<blockquote>
<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。<br>例如，从 CDN 引入 jQuery，而不是把它打包：</p>
</blockquote>
</li>
<li>DllPlugin：？？如果不用externals排除，用该方法剥离不经常改动的第三方依赖<blockquote>
<p>使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。<br>DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。</p>
</blockquote>
</li>
</ol>
<p>/代码分离/</p>
<ol start="9">
<li>CommonsChunkPlugin：提取公共子模块，提供缓存。属于代码分离–防止重复。公共模块提出来，利用缓存，没有修改的部分，hashID不会更改<blockquote>
<p>CommonsChunkPlugin，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。<br>将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。这可以通过使用新的 entry(入口) 起点，以及再额外配置一个 CommonsChunkPlugin 实例的组合方式来实现：</p>
</blockquote>
</li>
<li>ExtractTextPlugin:也属于代码分离，用于将 CSS 从主应用程序中分离</li>
</ol>
<p>/精简输出/</p>
<ol>
<li>UglifyJSPlugin:Tree Shaking–精简输出</li>
</ol>
<h3 id="2-5-DLLPlugin-CommonsChunkPlugin-noparse-还是external"><a href="#2-5-DLLPlugin-CommonsChunkPlugin-noparse-还是external" class="headerlink" title="2.5 DLLPlugin ,CommonsChunkPlugin,noparse 还是external"></a>2.5 DLLPlugin ,CommonsChunkPlugin,noparse 还是external</h3><p>教你如何玩转webpack.DllPlugin #6<br><a href="https://github.com/superpig/blog/issues/6" target="_blank" rel="noopener">https://github.com/superpig/blog/issues/6</a></p>
<h4 id="1-问题场景："><a href="#1-问题场景：" class="headerlink" title="1 问题场景："></a>1 问题场景：</h4><p>首先单独打包第三方库文件，其次想抽取不同入口的common部分。因为该项目是多入口结构，AngularJS入口的库文件都是通过公司CDN引入，只有vue.html入口下的库文件通过npm引入，我们希望打包的Vue相关的库文件只用于vue.html入口下。</p>
<h4 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2 解决方案："></a>2 解决方案：</h4><ol>
<li>CDN &amp; 配置externals<br>第三方库文件通过公司CDN引入，webpack配置extenals将依赖的库指向全局变量，从而不再打包库文件。这种方案是可以满足我们的需求的，但是配置externals存在不完美的地方，<a href="https://zhuanlan.zhihu.com/p/21748318" target="_blank" rel="noopener">这篇文章有详细介绍</a>。</li>
<li>CommonsChunkPlugin<br>webpack的CommonsChunkPlugin插件，官网提供了抽取vendor的解决思路，其中manifest的作用防止再次构建时改变vendor的hash，导致无法利用浏览器的缓存。同时，我们还需要抽取不同入口的common部分，所以综上，理想的webpack配置如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name: <span class="string">"vendor"</span>,</span><br><span class="line">            minChunks: <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">module</span>.context &amp;&amp; <span class="built_in">module</span>.context.indexOf(<span class="string">"node_modules"</span>) !== <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name: <span class="string">"manifest"</span>,</span><br><span class="line">            minChunks: <span class="literal">Infinity</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name: <span class="string">'common'</span>,</span><br><span class="line">            filename: <span class="string">'js/common.[chunkhash].js'</span>,</span><br><span class="line">            minChunks: <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，实际效果是webpack<strong>只打包了vendor库文件，不同入口下的common部分没提取出来</strong>。所以，该方案无法满足需求。<br><strong>$_PS:</strong> common建立第三个buddle，不可行吗？？</p>
<ol start="3">
<li>webpack.DllPlugin &amp; add-asset-html-webpack-plugin<br>webpack.DllPlugin的作用是打包一个“动态链接库（dll）”，dll包就是我们的库文件，用于业务代码引用，而且打包业务代码时，不需要再次打包dll包。使用这个功能，我们需要两个步骤：</li>
</ol>
<ul>
<li>打包dll包</li>
<li>引用dll包，打包业务代码<br>为了打包dll包，我们需要单独配置一个dll.config.js：<br>接着，就是我们如何在打包业务代码时引用vendor.dll.js：</li>
</ul>
<ol start="4">
<li>webpack.DllPlugin &amp; html-webpack-include-assets-plugin<br>打包dll包的过程同上，所以直接看html-webpack-include-assets-plugin的使用配置。<br>这里多用一个CopyWebpackPlugin插件，将vendor.dll.js文件拷贝到build目录。注意使用HtmlWebpackIncludeAssetsPlugin时，需要将append参数设置为false，保证vendor.dll.js在业务代码之前插入。</li>
</ol>
<p>这里多用一个CopyWebpackPlugin插件，将vendor.dll.js文件拷贝到build目录。注意使用HtmlWebpackIncludeAssetsPlugin时，需要将append参数设置为false，保证vendor.dll.js在业务代码之前插入。</p>
<h3 id="2-6-DIIPlugin"><a href="#2-6-DIIPlugin" class="headerlink" title="2.6 DIIPlugin"></a>2.6 DIIPlugin</h3><h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1 使用"></a>1 使用</h4><p>彻底解决Webpack打包性能问题  </p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/21748318" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21748318</a></p>
<ol>
<li>首先我们来打包ddl包，首先配置一个这样的 ddl.config.js：   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> vendors = [</span><br><span class="line">    <span class="string">'react'</span>,</span><br><span class="line">    <span class="string">'react-dom'</span>,</span><br><span class="line">    <span class="string">'react-router'</span>,</span><br><span class="line">    <span class="comment">// ...其它库</span></span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'build'</span>,</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        library: <span class="string">'[name]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="string">"lib"</span>: vendors,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            path: <span class="string">'manifest.json'</span>,</span><br><span class="line">            name: <span class="string">'[name]'</span>,</span><br><span class="line">            context: __dirname,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>  运行Webpack，会输出两个文件一个是打包好的 lib.js，一个就是 manifest.json，它里面的内容大概是这样的：<br>    <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"vendor_ac51ba426d4f259b8b18"</span>,</span><br><span class="line">    <span class="attr">"content"</span>: &#123;</span><br><span class="line">        <span class="attr">"./node_modules/react/react.js"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"./node_modules/react/lib/React.js"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"./node_modules/react/node_modules/object-assign/index.js"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"./node_modules/react/lib/ReactChildren.js"</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">"./node_modules/react/lib/PooledClass.js"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"./node_modules/react/lib/reactProdInvariant.js"</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="comment">// ............</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ol start="2">
<li>接下来我们就可以快乐地打包业务代码啦，首先写好打包配置文件 webpack.config.js： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'build'</span>,</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            context: __dirname,</span><br><span class="line">            manifest: <span class="built_in">require</span>(<span class="string">'./manifest.json'</span>),</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2 其他"></a>2 其他</h4><p>预打包Dll，实现webpack音速编译<br><a href="http://array_huang.coding.me/webpack-book/chapter4/webpack-dll.html" target="_blank" rel="noopener">http://array_huang.coding.me/webpack-book/chapter4/webpack-dll.html</a><br>在每个页面里，都要按这个顺序来加载js文件：Dll文件 =&gt; CommonsChunkPlugin生成的公用chunk文件（如果没用CommonsChunkPlugin那就忽略啦） =&gt; 页面本身的入口文件。</p>
<p>有两个注意事项：</p>
<ul>
<li>如果你是像我一样利用HtmlWebpackPlugin来生成HTML并自动加载chunk的话，请务必在<code>&lt;head&gt;</code>里手写<code>&lt;script&gt;</code>来加载Dll文件。</li>
<li>为了完全分离源文件和编译后生成的文件，也为了方便在编译前可以清空build目录，不应直接把Dll文件编译生成到build目录里，我建议可以先生成到源文件src目录里，再用file-loader给原封不动搬运过去。</li>
</ul>
<h4 id="3-思考"><a href="#3-思考" class="headerlink" title="3 思考"></a>3 思考</h4><ol start="0">
<li>DII应该是打包了，只不过是单独打包</li>
<li>大的第三方库，不是CDN就是该方法了，比如：react、angular、jQuery3+等</li>
<li>老旧库（没有export，不能import)是不是需要提供shimming也可以DII，否则只能external了    </li>
<li>引入的静态资源：图片、css、字体等是否也是这样打包</li>
<li>需要注意的可能是生成dll文件的，路径引入问题 </li>
</ol>
<h3 id="2-7-bootstrap配置"><a href="#2-7-bootstrap配置" class="headerlink" title="2.7 bootstrap配置"></a>2.7 bootstrap配置</h3><p><strong>$_TODO:</strong> </p>
<h2 id="三-实际"><a href="#三-实际" class="headerlink" title="三 实际"></a>三 实际</h2><p>webpack简单和复杂的地方：配置。由于高度可配置，可以灵活使用，没法确定哪一个一定是最优的选择。<br>但是，需要选择一个最适合实际项目的配置  </p>
<h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>目前，基本没什么需求。<br>没有确定需要使用的第三方依赖，除mediasoup。<br>只要求，conference-client独立出来    </p>
<h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><ol>
<li>由于使用webpack，不使用external，DII单独打包第三方依赖（不改动），commonsChunk打包提取项目开发中的公共库。  <ol>
<li>没有了CDN或者页面引入，包括jQuery，iScroll等。所有依赖都是库都通过DII打包</li>
<li>noparse也不需要了</li>
<li>开发和生产中，只需要打包一次就行了；除非三方依赖发生改变。</li>
</ol>
</li>
<li>上述方案，并没有考虑引入bootstrap等css，font静态资源。</li>
<li>开发中只生成一个js文件，一个css文件。所有依赖都打包，包括老旧库，使用import方式引用</li>
<li>要求生成一份conference-client.min.js，需要参照library，额外配置，发布一份js</li>
<li>非现代浏览器用babel-polyfill，因为我们只需要chrome，useBuildin:true</li>
<li>conference-client可能需要提供ES5。因为是库，需要babel-loader,preset:env,babel-runtime</li>
<li>小组/个人开发，不提供eslint（也没有配置成功，可配置编辑器）</li>
</ol>
<p style="text-align:right">2.11 星期日 17:22</p>



]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Iframe操作</title>
    <url>/sum/js/iframe%E6%93%8D%E4%BD%9C(008)/</url>
    <content><![CDATA[<p>iframe之间dom操作；没有frame/frameset具体比较的内容，有参考链接</p>
<p style="text-align:right">2018.2.8 星期四 14:00</p>  

<a id="more"></a>
<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-获取frames方式"><a href="#一-获取frames方式" class="headerlink" title="一 获取frames方式"></a>一 获取frames方式</h2><h3 id="1-1-通过name，和id都可以直接获取。"><a href="#1-1-通过name，和id都可以直接获取。" class="headerlink" title="1.1 通过name，和id都可以直接获取。"></a>1.1 通过name，和id都可以直接获取。</h3><p>区别：name直接返回window对象；id返回iframe对象.<br>和通过window.name,window.id是一个概念。  </p>
<p>通过id获取的iframe对象，可以通过id.contentWindow,id.contentDocument获取window,和document对象。<br>通过name获取的是window，可以通过name.document获取document对象。</p>
<h3 id="1-2-frames"><a href="#1-2-frames" class="headerlink" title="1.2 frames"></a>1.2 frames</h3><p>frames[index]–&gt;window<br>frames[id]   –&gt;iframe<br>frames[name] –&gt;window  </p>
<h3 id="1-3-iframeElement"><a href="#1-3-iframeElement" class="headerlink" title="1.3 iframeElement"></a>1.3 iframeElement</h3><h2 id="二-iframe跨域操作"><a href="#二-iframe跨域操作" class="headerlink" title="二 iframe跨域操作"></a>二 iframe跨域操作</h2><p>是不可能的<br>参考：跨域操作.md A 新手学跨域之iframe</p>
<p>/<strong><em>参考</em></strong>/    </p>
<h1 id="A-JavaScript操作iframe之不得不说的秘密（一）-021-D-js"><a href="#A-JavaScript操作iframe之不得不说的秘密（一）-021-D-js" class="headerlink" title="A [JavaScript操作iframe之不得不说的秘密（一）] 021-D-js"></a>A [JavaScript操作iframe之不得不说的秘密（一）] 021-D-js</h1><!-- **$_YX:** [JavaScript操作iframe之不得不说的秘密（一）](https://app.yinxiang.com/Home.action#n=9afadee8-3b6e-47f4-9a78-fdfcae7c8b60&s=s67&b=67835be7-0476-470a-9448-0eb7e8f8a6e4&ses=4&sh=1&sds=5&) -->
<h1 id="B-frame-iframe-frameset之间的关系与区别"><a href="#B-frame-iframe-frameset之间的关系与区别" class="headerlink" title="B frame,iframe,frameset之间的关系与区别"></a>B frame,iframe,frameset之间的关系与区别</h1><p><a href="http://www.cnblogs.com/wennxxin/archive/2008/10/11/1308516.html" target="_blank" rel="noopener">http://www.cnblogs.com/wennxxin/archive/2008/10/11/1308516.html</a><br>Posted on 2008-10-11 09:39 匆匆小游客  </p>
<h2 id="一-框架概念"><a href="#一-框架概念" class="headerlink" title="一 框架概念"></a>一 框架概念</h2><h2 id="二"><a href="#二" class="headerlink" title="二  "></a>二 <frameset> <frame></frameset></h2><p><frameset> 称框架标记，用以宣告HTML文件为框架模式，并设定视窗如何分割。 </frameset></p>
<p><frame> 则只是设定某一个框窗内的参数属性。 </p>
<h2 id="三"><a href="#三" class="headerlink" title="三 "></a>三 <noframes></noframes></h2><p>当别人使用的浏览器太旧，不支援框架这个功能时，他看到的将会是一片空白。为了避免 这种情况，可使用 <noframes> 这个标记，当使用者的浏览器看不到框架时，他就会看到 <noframes> 与 </noframes> 之间的内容，而不是一片空白。这些内容可以是提醒 浏览转用新的浏览器的字句，甚至是一个没有框架的网页或能自动切换至没有框架的版本 亦可。<br>应用方法：<br>在<frameset> 标记范围加入 </frameset></noframes> 标记，以下是一个例子： </p>
<h2 id="四"><a href="#四" class="headerlink" title="四 "></a>四 <iframe></iframe></h2><p>这标记只适用於 IE(comet:也使用于FireFox)。 它的作用是在一页网页中间插入一个框窗以显示另一个文件。它是 一个围堵标记，但围着的字句只有在浏览器不支援 iframe 标记时才会显示，如<noframes> 一样，可以放些提醒字句之类。通常 iframe 配合一个辨认浏览器的 JavaScript 会较好，若 JavaScript 认出该浏览器并非 Internet Explorer 便会切换至另一版本。PS：一定要使用关闭，否则后面的内容显示不出来。</noframes></p>
<h2 id="五-frame和iframe的区别"><a href="#五-frame和iframe的区别" class="headerlink" title="五 frame和iframe的区别"></a>五 frame和iframe的区别</h2><p>1、frame不能脱离frameSet单独使用，iframe可以；<br>2、frame不能放在body中；如下可以正常显示：<br>3、嵌套在frameSet中的iframe必需放在body中；如下可以正常显示：<br>4、不嵌套在frameSet中的iframe可以随意使用；<br>5、frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制，如：<br>6、如果在同一个页面使用了两个以上的iframe，在IE中可以正常显示，在firefox中只能显示出第一个；使用两个以上的frame在IE和firefox中均可正常</p>
<h1 id="C-frame和iframe的区别"><a href="#C-frame和iframe的区别" class="headerlink" title="C [frame和iframe的区别]"></a>C [frame和iframe的区别]</h1><p><a href="http://blog.csdn.net/lyr1985/article/details/6067026" target="_blank" rel="noopener">http://blog.csdn.net/lyr1985/article/details/6067026</a><br>2010年12月10日 10:00:00</p>
<p>以上代码在IE7和firefox2.0中测试。<br>另外相关论坛窃取总结 :-)<br>我个人认为:   </p>
<p><strong>$_PS:</strong> 上半部是抄的B；下半部不知从那里引得，老太婆的裹脚布</p>
<h1 id="D-html框架之iframe和frame及frameset的相关属性介绍"><a href="#D-html框架之iframe和frame及frameset的相关属性介绍" class="headerlink" title="D html框架之iframe和frame及frameset的相关属性介绍"></a>D html框架之iframe和frame及frameset的相关属性介绍</h1><p><a href="http://www.haorooms.com/post/html_frameset_contro" target="_blank" rel="noopener">http://www.haorooms.com/post/html_frameset_contro</a><br>2015年1月8日 </p>
<h2 id="一-iframe和frame的区别"><a href="#一-iframe和frame的区别" class="headerlink" title="一 iframe和frame的区别"></a>一 iframe和frame的区别</h2><p>1、frame不能脱离frameSet单独使用，iframe可以；<br>2、frame不能放在body中；<br>相反，假如iframe放在frameSet属性下面，则必需放在body中<br>3、iframe是一个html标签，在html中任何地方，都可以随意使用，而frame不可以。<br>而frame必须嵌套在frameSet中，且不能再table等标签中使用。<br>4、frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制<br>5、如果在同一个页面使用了两个以上的iframe，在IE中可以正常显示，在firefox中只能显示出第一个；使用两个以上的frame在IE和firefox中均可正常</p>
<h2 id="二-frameset相关属性介绍"><a href="#二-frameset相关属性介绍" class="headerlink" title="二 frameset相关属性介绍"></a>二 frameset相关属性介绍</h2><p>border 设置框架的边框粗细。<br>bordercolor 设置框架的边框颜色。<br>frameborder 设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。<br>cols<br>    纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“”表示该区域占用余下页面空间。例如：cols=”25%,200,*” 表示将页面分为三部分，左面部分占页面25%，中间横向宽度为200像素，页面余下的作为右面部分。<br>rows 横向分割页面。数值表示方法与意义与cols相同。<br>framespacing 设置框架与框架间的保留的空白距离。</p>
<p style="text-align:right"> 14:30</p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack_2-Configuration</title>
    <url>/w3/pkg/webpack_2-configuration/</url>
    <content><![CDATA[<!-- # 配置 -->
<p>cc.<br><a href="https://doc.webpack-china.org/configuration/" target="_blank" rel="noopener">https://doc.webpack-china.org/configuration/</a></p>
<p style="text-align:right">2018.2.8 星期四 19:02</p>


<a id="more"></a>
<h2 id="一-配置"><a href="#一-配置" class="headerlink" title="一 配置"></a>一 配置</h2><h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1 选项"></a>1.1 选项</h3><h2 id="二-使用不同语言进行配置"><a href="#二-使用不同语言进行配置" class="headerlink" title="二 使用不同语言进行配置"></a>二 使用不同语言进行配置</h2><h3 id="2-1-TypeScript"><a href="#2-1-TypeScript" class="headerlink" title="2.1 TypeScript"></a>2.1 TypeScript</h3><h3 id="2-2-CoffeeScript"><a href="#2-2-CoffeeScript" class="headerlink" title="2.2 CoffeeScript"></a>2.2 CoffeeScript</h3><h3 id="2-3-Babel-and-JSX"><a href="#2-3-Babel-and-JSX" class="headerlink" title="2.3 Babel and JSX"></a>2.3 Babel and JSX</h3><h2 id="三-多种配置类型"><a href="#三-多种配置类型" class="headerlink" title="三 多种配置类型"></a>三 多种配置类型</h2><p>除了导出单个配置对象，还有一些方式满足其他需求。</p>
<h3 id="3-1-导出一个函数"><a href="#3-1-导出一个函数" class="headerlink" title="3.1 导出一个函数"></a>3.1 导出一个函数</h3><p>最终，你会发现需要在开发和生产构建之间，消除 webpack.config.js 的差异。（至少）有两种选项：  </p>
<p>作为导出一个配置对象的替代，还有一种可选的导出方式是，从 webpack 配置文件中导出一个函数。该函数在调用时，可传入两个参数：  </p>
<ol>
<li>环境对象(environment)作为第一个参数。有关语法示例，请查看CLI 文档的环境选项。 </li>
<li>一个选项 map 对象（argv）作为第二个参数。这个对象描述了传递给 webpack 的选项，并且具有 output-filename 和 optimize-minimize 等 key。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+<span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env, argv</span>) </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> &#123;</span><br><span class="line">+       devtool: env.production ? <span class="string">'source-maps'</span> : <span class="string">'eval'</span>,</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">+              compress: argv[<span class="string">'optimize-minimize'</span>] <span class="comment">// 只有传入 -p 或 --optimize-minimize</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">+  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-导出一个Promise"><a href="#3-2-导出一个Promise" class="headerlink" title="3.2 导出一个Promise"></a>3.2 导出一个Promise</h3><p>webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量。</p>
<pre><code>module.exports = () =&gt; {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve({
                entry: &apos;./app.js&apos;,
                /* ... */
            })
        }, 5000)
    })
}
</code></pre><p><strong>$_PS:</strong> 实际意义不懂    </p>
<h3 id="3-3-导出多个配置对象"><a href="#3-3-导出多个配置对象" class="headerlink" title="3.3 导出多个配置对象"></a>3.3 导出多个配置对象</h3><p>作为导出一个配置对象/配置函数的替代，你可能需要导出多个配置对象（从 webpack 3.1.0 开始支持导出多个函数）。当运行 webpack 时，所有的配置对象都会构建。例如，导出多个配置对象，对于针对多个构建目标（例如 AMD 和 CommonJS）打包一个 library 非常有用。</p>
<pre><code>module.exports = [{
    output: {
        filename: &apos;./dist-amd.js&apos;,
        libraryTarget: &apos;amd&apos;
    },
    entry: &apos;./app.js&apos;,
    }, {
    output: {
        filename: &apos;./dist-commonjs.js&apos;,
        libraryTarget: &apos;commonjs&apos;
    },
    entry: &apos;./app.js&apos;,
}]
</code></pre><h2 id="四-入口和上下文"><a href="#四-入口和上下文" class="headerlink" title="四 入口和上下文"></a>四 入口和上下文</h2><p>entry 对象是用于 webpack 查找启动并构建 bundle。其上下文是入口文件所处的目录的绝对路径的字符串。</p>
<h3 id="4-1-context"><a href="#4-1-context" class="headerlink" title="4.1 context"></a>4.1 context</h3><p>string<br>基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader</p>
<pre><code>context: path.resolve(__dirname, &quot;app&quot;)
</code></pre><p>默认使用当前目录，但是推荐在配置中传递一个值。这使得你的配置独立于 CWD(current working directory - 当前执行路径)。</p>
<h3 id="4-2-entry"><a href="#4-2-entry" class="headerlink" title="4.2 entry"></a>4.2 entry</h3><p>string | [string] | object { <key>: string | [string] } | (function: () =&gt; string | [string] | object { <key>: string | [string] })</key></key></p>
<p>起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。如果传递一个数组，那么数组的每一项都会执行。<br>动态加载的模块不是入口起点。</p>
<p>简单规则：每个 HTML 页面都有一个入口起点。单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点。</p>
<pre><code>entry: {
    home: &quot;./home.js&quot;,
    about: &quot;./about.js&quot;,
    contact: &quot;./contact.js&quot;
}
</code></pre><h3 id="4-3-命名"><a href="#4-3-命名" class="headerlink" title="4.3 命名"></a>4.3 命名</h3><p>如果传入一个字符串或字符串数组，chunk 会被命名为 main。如果传入一个对象，则每个键(key)会是 chunk 的名称，该值描述了 chunk 的入口起点。</p>
<h3 id="4-4-动态入口"><a href="#4-4-动态入口" class="headerlink" title="4.4 动态入口"></a>4.4 动态入口</h3><pre><code>entry: () =&gt; &apos;./demo&apos;
</code></pre><p>或</p>
<pre><code>entry: () =&gt; new Promise((resolve) =&gt; resolve([&apos;./demo&apos;, &apos;./demo2&apos;]))
</code></pre><p>当结合 output.library 选项时：如果传入数组，则只导出最后一项。</p>
<h2 id="五-输出"><a href="#五-输出" class="headerlink" title="五 输出"></a>五 输出</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p style="text-align:right"> </p>

<h2 id="六-模块-Module"><a href="#六-模块-Module" class="headerlink" title="六 模块(Module)"></a>六 模块(Module)</h2><h3 id="6-1-module-noParse"><a href="#6-1-module-noParse" class="headerlink" title="6.1 module.noParse"></a>6.1 module.noParse</h3><p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</p>
<h3 id="6-2-module-rules"><a href="#6-2-module-rules" class="headerlink" title="6.2 module.rules"></a>6.2 module.rules</h3><h3 id="6-3-Rule"><a href="#6-3-Rule" class="headerlink" title="6.3 Rule"></a>6.3 Rule</h3><p>每个规则可以分为三部分 - 条件(condition)，结果(result)和嵌套规则(nested rule)。</p>
<h4 id="1-Rule条件"><a href="#1-Rule条件" class="headerlink" title="1 Rule条件"></a>1 Rule条件</h4><p>条件有两种输入值：</p>
<ol>
<li>resource：请求文件的绝对路径。它已经根据 resolve 规则解析。</li>
<li>issuer: 被请求资源(requested the resource)的模块文件的绝对路径。是导入时的位置。<br>例如: 从 app.js 导入 ‘./style.css’，resource 是 /path/to/style.css. issuer 是 /path/to/app.js。</li>
</ol>
<p>在规则中，属性 test, include, exclude 和 resource 对 resource 匹配，并且属性 issuer 对 issuer 匹配。</p>
<p>当使用多个条件时，所有条件都匹配。</p>
<blockquote>
<p>小心！resource 是文件的解析路径，这意味着符号链接的资源是真正的路径，而不是符号链接位置。在使用工具来符号链接包的时候（如 npm link）比较好记，像 /node_modules/ 等常见条件可能会不小心错过符号链接的文件。</p>
</blockquote>
<h4 id="2-Rule-结果"><a href="#2-Rule-结果" class="headerlink" title="2 Rule 结果"></a>2 Rule 结果</h4><p>规则结果只在规则条件匹配时使用。<br>规则有两种输入值：</p>
<ol>
<li>应用的 loader：应用在 resource 上的 loader 数组。</li>
<li>Parser 选项：用于为模块创建解析器的选项对象。<br>这些属性会影响 loader：loader, options, use。<br>也兼容这些属性：query, loaders。</li>
</ol>
<p>enforce 属性会影响 loader 种类。不论是普通的，前置的，后置的 loader。<br>parser 属性会影响 parser 选项。</p>
<h4 id="3-嵌套的-Rule"><a href="#3-嵌套的-Rule" class="headerlink" title="3 嵌套的 Rule"></a>3 嵌套的 Rule</h4><p>可以使用属性 rules 和 oneOf 指定嵌套规则。<br>这些规则用于在规则条件(rule condition)匹配时进行取值。</p>
<h3 id="6-4-Rule-enforce"><a href="#6-4-Rule-enforce" class="headerlink" title="6.4 Rule.enforce"></a>6.4 Rule.enforce</h3><p>可能的值有：”pre” | “post”<br>指定 loader 种类。没有值表示是普通 loader。</p>
<p>还有一个额外的种类”行内 loader”，loader 被应用在 import/require 行内。</p>
<p>所有 loader 通过 前置, 行内, 普通, 后置 排序，并按此顺序使用。</p>
<p>所有普通 loader 可以通过在请求中加上 ! 前缀来忽略（覆盖）。<br>所有普通和前置 loader 可以通过在请求中加上 -! 前缀来忽略（覆盖）。<br>所有普通，后置和前置 loader 可以通过在请求中加上 !! 前缀来忽略（覆盖）。<br>不应该使用行内 loader 和 ! 前缀，因为它们是非标准的。它们可在由 loader 生成的代码中使用。</p>
<h3 id="6-5-Rule-exclude"><a href="#6-5-Rule-exclude" class="headerlink" title="6.5 Rule.exclude"></a>6.5 Rule.exclude</h3><p>Rule.exclude 是 Rule.resource.exclude 的简写。如果你提供了 Rule.exclude 选项，就不能再提供 Rule.resource。详细请查看 Rule.resource 和 Condition.exclude。</p>
<h3 id="6-6-Rule-include"><a href="#6-6-Rule-include" class="headerlink" title="6.6 Rule.include"></a>6.6 Rule.include</h3><p>Rule.include 是 Rule.resource.include 的简写。如果你提供了 Rule.include 选项，就不能再提供 Rule.resource。详细请查看 Rule.resource 和 Condition.include。</p>
<h3 id="6-7-Rule-issuer"><a href="#6-7-Rule-issuer" class="headerlink" title="6.7 Rule.issuer"></a>6.7 Rule.issuer</h3><p>一个条件，用来与被发布的 request 对应的模块项匹配。在以下示例中，a.js request 的发布者(issuer)是 index.js 文件的路径。</p>
<pre><code>index.js
</code></pre><p>import A from ‘./a.js’<br>这个选项可以用来将 loader 应用到一个特定模块或一组模块的依赖中。</p>
<h3 id="6-8-Rule-loader"><a href="#6-8-Rule-loader" class="headerlink" title="6.8 Rule.loader"></a>6.8 Rule.loader</h3><p>Rule.loader 是 Rule.use: [ { loader } ] 的简写。详细请查看 Rule.use 和 UseEntry.loader。</p>
<h3 id="6-9-Rule-loaders"><a href="#6-9-Rule-loaders" class="headerlink" title="6.9 Rule.loaders"></a>6.9 <del>Rule.loaders</del></h3><blockquote>
<p>由于需要支持 Rule.use，此选项已废弃。<br>Rule.loaders 是 Rule.use 的别名。详细请查看 Rule.use。</p>
</blockquote>
<h3 id="6-0-Rule-oneOf"><a href="#6-0-Rule-oneOf" class="headerlink" title="6.0 Rule.oneOf"></a>6.0 Rule.oneOf</h3><p>规则数组，当规则匹配时，只使用第一个匹配规则。</p>
<pre><code>{
    test: /.css$/,
    oneOf: [
        {
        resourceQuery: /inline/, // foo.css?inline
        use: &apos;url-loader&apos;
        },
        {
        resourceQuery: /external/, // foo.css?external
        use: &apos;file-loader&apos;
        }
    ]
}
</code></pre><h3 id="6-1-Rule-options-Rule-query"><a href="#6-1-Rule-options-Rule-query" class="headerlink" title="6.1 Rule.options/Rule.query"></a>6.1 <del>Rule.options/Rule.query</del></h3><p>Rule.options 和 Rule.query 是 Rule.use: [ { options } ] 的简写。详细请查看 Rule.use 和 UseEntry.options。</p>
<blockquote>
<p>由于需要支持 Rule.options 和 UseEntry.options，Rule.use，Rule.query 已废弃。</p>
</blockquote>
<h3 id="6-2-Rule-parser"><a href="#6-2-Rule-parser" class="headerlink" title="6.2 Rule.parser"></a>6.2 Rule.parser</h3><p>解析选项对象。所有应用的解析选项都将合并。<br>解析器(parser)可以查阅这些选项，并相应地禁用或重新配置。大多数默认插件，会如下解释值：</p>
<ol>
<li>将选项设置为 false，将禁用解析器。</li>
<li>将选项设置为 true，或不修改将其保留为 undefined，可以启用解析器。</li>
</ol>
<p>然而，一些解析器(parser)插件可能不光只接收一个布尔值。例如，内部的 NodeStuffPlugin 差距，可以接收一个对象，而不是 true，来为特定的规则添加额外的选项。</p>
<p>示例（默认的插件解析器选项）：</p>
<pre><code>parser: {
    amd: false, // 禁用 AMD
    commonjs: false, // 禁用 CommonJS
    system: false, // 禁用 SystemJS
    harmony: false, // 禁用 ES2015 Harmony import/export
    requireInclude: false, // 禁用 require.include
    requireEnsure: false, // 禁用 require.ensure
    requireContext: false, // 禁用 require.context
    browserify: false, // 禁用特殊处理的 browserify bundle
    requireJs: false, // 禁用 requirejs.*
    node: false, // 禁用 __dirname, __filename, module, require.extensions, require.main 等。
    node: {...} // 在模块级别(module level)上重新配置 node 层(layer)
}
</code></pre><h3 id="6-3-Rule-resource"><a href="#6-3-Rule-resource" class="headerlink" title="6.3 Rule.resource"></a>6.3 Rule.resource</h3><p>条件会匹配 resource。既可以提供 Rule.resource 选项，也可以使用快捷选项 Rule.test，Rule.exclude 和 Rule.include。在 Rule 条件 中查看详细。</p>
<h3 id="6-4-Rule-resourceQuery"><a href="#6-4-Rule-resourceQuery" class="headerlink" title="6.4 Rule.resourceQuery"></a>6.4 Rule.resourceQuery</h3><pre><code>{
    test: /.css$/,
    resourceQuery: /inline/,
    use: &apos;url-loader&apos;
}
</code></pre><h3 id="6-5-Rule-rules"><a href="#6-5-Rule-rules" class="headerlink" title="6.5 Rule.rules"></a>6.5 Rule.rules</h3><h3 id="6-6-Rule-test"><a href="#6-6-Rule-test" class="headerlink" title="6.6 Rule.test"></a>6.6 Rule.test</h3><p>Rule.test 是 Rule.resource.test 的简写。如果你提供了一个 Rule.test 选项，就不能再提供 Rule.resource。详细请查看 Rule.resource 和 Condition.test。</p>
<h3 id="6-7-Rule-use"><a href="#6-7-Rule-use" class="headerlink" title="6.7 Rule.use"></a>6.7 Rule.use</h3><p>应用于模块的 UseEntries 列表。每个入口(entry)指定使用一个 loader。<br>传递字符串（如：use: [ “style-loader” ]）是 loader 属性的简写方式（如：use: [ { loader: “style-loader “} ]）。<br>Loaders can be chained by passing multiple loaders, which will be applied from right to left (last to first configured).</p>
<pre><code>use: [
    &apos;style-loader&apos;,
    {
        loader: &apos;css-loader&apos;,
        options: {
            importLoaders: 1
        }
    },
    {
        loader: &apos;less-loader&apos;,
        options: {
            noIeCompat: true
        }
    }
]
</code></pre><h3 id="6-8-条件"><a href="#6-8-条件" class="headerlink" title="6.8 条件"></a>6.8 条件</h3><p>条件可以是这些之一：</p>
<ol>
<li>字符串：匹配输入必须以提供的字符串开始。是的。目录绝对路径或文件绝对路径。</li>
<li>正则表达式：test 输入值。</li>
<li>函数：调用输入的函数，必须返回一个真值(truthy value)以匹配。</li>
<li>条件数组：至少一个匹配条件。</li>
<li>对象：匹配所有属性。每个属性都有一个定义行为。</li>
</ol>
<p>{ test: Condition }：匹配特定条件。一般是提供一个正则表达式或正则表达式的数组，但这不是强制的。<br>{ include: Condition }：匹配特定条件。一般是提供一个字符串或者字符串数组，但这不是强制的。<br>{ exclude: Condition }：排除特定条件。一般是提供一个字符串或字符串数组，但这不是强制的。<br>{ and: [Condition] }：必须匹配数组中的所有条件<br>{ or: [Condition] }：匹配数组中任何一个条件<br>{ not: [Condition] }：必须排除这个条件</p>
<p>示例:</p>
<pre><code>{
    test: /\.css$/,
    include: [
        path.resolve(__dirname, &quot;app/styles&quot;),
        path.resolve(__dirname, &quot;vendor/styles&quot;)
    ]
}
</code></pre><h3 id="6-9-UseEntry"><a href="#6-9-UseEntry" class="headerlink" title="6.9 UseEntry"></a>6.9 UseEntry</h3><h3 id="6-0-模块上下文"><a href="#6-0-模块上下文" class="headerlink" title="6.0 模块上下文"></a>6.0 模块上下文</h3><blockquote>
<p>Avoid using these options as they are deprecated and will soon be removed. 避免使用这些选项，因为它们已废弃，并将很快删除。</p>
</blockquote>
<pre><code>module: {
    exprContextCritical: true,
    exprContextRecursive: true,
    exprContextRegExp: false,
    exprContextRequest: &quot;.&quot;,
    unknownContextCritical: true,
    unknownContextRecursive: true,
    unknownContextRegExp: false,
    unknownContextRequest: &quot;.&quot;,
    wrappedContextCritical: false
    wrappedContextRecursive: true,
    wrappedContextRegExp: /.*/,
    strictExportPresence: false // since webpack 2.3.0
}
</code></pre><p><strong>$_PS:</strong> 上面两个什么鬼</p>
<p style="text-align:right"> 19:57 </p>


<h2 id="七-解析"><a href="#七-解析" class="headerlink" title="七 解析"></a>七 解析</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h3><h3 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八 插件"></a>八 插件</h2><h3 id="8-1-plugins"><a href="#8-1-plugins" class="headerlink" title="8.1 plugins"></a>8.1 plugins</h3><h2 id="九-开发中Server-DevServer"><a href="#九-开发中Server-DevServer" class="headerlink" title="九 开发中Server(DevServer)"></a>九 开发中Server(DevServer)</h2><h3 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h3><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><h3 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h3><h3 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h3><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><h2 id="零-Devtool"><a href="#零-Devtool" class="headerlink" title="零 Devtool"></a>零 Devtool</h2><h3 id="0-1-devtool"><a href="#0-1-devtool" class="headerlink" title="0.1 devtool"></a>0.1 devtool</h3><h3 id="0-2-Qualities"><a href="#0-2-Qualities" class="headerlink" title="0.2 Qualities"></a>0.2 Qualities</h3><h3 id="0-3-Development"><a href="#0-3-Development" class="headerlink" title="0.3 Development"></a>0.3 Development</h3><h3 id="0-4-Special-cases"><a href="#0-4-Special-cases" class="headerlink" title="0.4 Special cases"></a>0.4 Special cases</h3><h3 id="0-5-Production"><a href="#0-5-Production" class="headerlink" title="0.5 Production"></a>0.5 Production</h3><h2 id="一-构建目标"><a href="#一-构建目标" class="headerlink" title="一 构建目标"></a>一 构建目标</h2><h3 id="1-1-target"><a href="#1-1-target" class="headerlink" title="1.1 target"></a>1.1 target</h3><h3 id="1-2-string"><a href="#1-2-string" class="headerlink" title="1.2 string"></a>1.2 string</h3><h3 id="1-3-function"><a href="#1-3-function" class="headerlink" title="1.3 function"></a>1.3 function</h3><h2 id="二-Watch和WatchOptions"><a href="#二-Watch和WatchOptions" class="headerlink" title="二 Watch和WatchOptions"></a>二 Watch和WatchOptions</h2><h3 id="2-1-watch"><a href="#2-1-watch" class="headerlink" title="2.1 watch"></a>2.1 watch</h3><h3 id="2-2-watchOptions"><a href="#2-2-watchOptions" class="headerlink" title="2.2 watchOptions"></a>2.2 watchOptions</h3><h3 id="2-3-watchOptions-aggregated"><a href="#2-3-watchOptions-aggregated" class="headerlink" title="2.3 watchOptions.aggregated"></a>2.3 watchOptions.aggregated</h3><h3 id="2-4-watchOptions-ignored"><a href="#2-4-watchOptions-ignored" class="headerlink" title="2.4 watchOptions.ignored"></a>2.4 watchOptions.ignored</h3><h3 id="2-5-watchOptions-poll"><a href="#2-5-watchOptions-poll" class="headerlink" title="2.5 watchOptions.poll"></a>2.5 watchOptions.poll</h3><h2 id="三-外部扩展-Externals"><a href="#三-外部扩展-Externals" class="headerlink" title="三 外部扩展(Externals)"></a>三 外部扩展(Externals)</h2><p>externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer’s environment)中的依赖。<strong>此功能通常对 library 开发人员来说是最有用的，然而也会有各种各样的应用程序用到它</strong>。</p>
<blockquote>
<p>用户(consumer)，在这里是指，引用了「使用 webpack 打包的 library」的所有终端用户的应用程序(end user application)。</p>
</blockquote>
<h3 id="3-1-externals"><a href="#3-1-externals" class="headerlink" title="3.1 externals"></a>3.1 externals</h3><p>string array object function regex  </p>
<p><strong>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)</strong>。</p>
<p>例如，从 CDN 引入 jQuery，而不是把它打包：<br>index.html</p>
<pre><code>&lt;script
src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;
integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;
crossorigin=&quot;anonymous&quot;&gt;
&lt;/script&gt;
</code></pre><p>webpack.config.js</p>
<pre><code>externals: {
    jquery: &apos;jQuery&apos;
}
</code></pre><p><strong>这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行</strong>：</p>
<pre><code>import $ from &apos;jquery&apos;;
$(&apos;.my-element&apos;).animate(...);
</code></pre><p>具有外部依赖(external dependency)的 bundle 可以在各种模块上下文(module context)中使用，例如 CommonJS, AMD, 全局变量和 ES2015 模块。外部 library 可能是以下任何一种形式：</p>
<ul>
<li>root：可以通过一个全局变量访问 library（例如，通过 script 标签）。</li>
<li>commonjs：可以将 library 作为一个 CommonJS 模块访问。</li>
<li>commonjs2：和上面的类似，但导出的是 module.exports.default.</li>
<li>amd：类似于 commonjs，但使用 AMD 模块系统。<br>可以接受各种语法……<h4 id="1-string"><a href="#1-string" class="headerlink" title="1 string"></a>1 string</h4>请查看上面的例子。属性名称是 jquery，表示应该排除 import $ from ‘jquery’ 中的 jquery 模块。为了替换这个模块，jQuery 的值将被用来检索一个全局的 jQuery 变量。换句话说，当设置为一个字符串时，它将被视为全局的（定义在上面和下面）。<br><strong>$_PS:</strong> ？意思是<code>import $ from &#39;jquery&#39;</code>仍然需要,不从模块引了，而检索全局<h4 id="2-array"><a href="#2-array" class="headerlink" title="2 array"></a>2 array</h4><h4 id="3-object"><a href="#3-object" class="headerlink" title="3 object"></a>3 object</h4><h4 id="4-funciton"><a href="#4-funciton" class="headerlink" title="4 funciton"></a>4 funciton</h4><h4 id="5-regex"><a href="#5-regex" class="headerlink" title="5 regex"></a>5 regex</h4></li>
</ul>
<h2 id="四-性能-Performance"><a href="#四-性能-Performance" class="headerlink" title="四 性能(Performance)"></a>四 性能(Performance)</h2><h3 id="4-1-performance"><a href="#4-1-performance" class="headerlink" title="4.1 performance"></a>4.1 performance</h3><h3 id="4-2-performance-hints"><a href="#4-2-performance-hints" class="headerlink" title="4.2 performance.hints"></a>4.2 performance.hints</h3><h3 id="4-3-performanc-emaxEntry"><a href="#4-3-performanc-emaxEntry" class="headerlink" title="4.3 performanc.emaxEntry"></a>4.3 performanc.emaxEntry</h3><h3 id="4-4-performanc"><a href="#4-4-performanc" class="headerlink" title="4.4 performanc."></a>4.4 performanc.</h3><h3 id="4-5-performanc"><a href="#4-5-performanc" class="headerlink" title="4.5 performanc."></a>4.5 performanc.</h3><h2 id="五-Node"><a href="#五-Node" class="headerlink" title="五 Node"></a>五 Node</h2><h3 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4-1"><a href="#5-4-1" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5-1"><a href="#5-5-1" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.</h3><h2 id="六-统计-Stats"><a href="#六-统计-Stats" class="headerlink" title="六 统计(Stats)"></a>六 统计(Stats)</h2><h3 id="6-1-stats"><a href="#6-1-stats" class="headerlink" title="6.1 stats"></a>6.1 stats</h3><h2 id="七-其它选项"><a href="#七-其它选项" class="headerlink" title="七 其它选项"></a>七 其它选项</h2><h3 id="7-1-amd"><a href="#7-1-amd" class="headerlink" title="7.1 amd"></a>7.1 amd</h3><h3 id="7-2-bail"><a href="#7-2-bail" class="headerlink" title="7.2 bail"></a>7.2 bail</h3><h3 id="7-3-cache"><a href="#7-3-cache" class="headerlink" title="7.3 cache"></a>7.3 cache</h3><h3 id="7-4-loader"><a href="#7-4-loader" class="headerlink" title="7.4 loader"></a>7.4 loader</h3><h3 id="7-5-parallelism"><a href="#7-5-parallelism" class="headerlink" title="7.5 parallelism"></a>7.5 parallelism</h3><h3 id="7-6-profile"><a href="#7-6-profile" class="headerlink" title="7.6 profile"></a>7.6 profile</h3><h3 id="7-7-recordPath"><a href="#7-7-recordPath" class="headerlink" title="7.7 recordPath"></a>7.7 recordPath</h3><h3 id="7-8-recordInputPath"><a href="#7-8-recordInputPath" class="headerlink" title="7.8 recordInputPath"></a>7.8 recordInputPath</h3><h3 id="7-9-recordOutputPath"><a href="#7-9-recordOutputPath" class="headerlink" title="7.9 recordOutputPath"></a>7.9 recordOutputPath</h3>]]></content>
      <categories>
        <category>w3</category>
        <category>pkg</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Bookmarklet</title>
    <url>/sum/jsplus/bookmarklet(015)/</url>
    <content><![CDATA[<p>小标签有没有大作用(浏览器插件也很好用的情况下)<br>lenovo CHECKBOX可能就是bookmarklet</p>
<p style="text-align:right">2018.2.2 星期五 16:28</p>

<a id="more"></a>
<h1 id="A-Bookmarklet编写指南"><a href="#A-Bookmarklet编写指南" class="headerlink" title="A Bookmarklet编写指南"></a>A Bookmarklet编写指南</h1><p><a href="http://www.ruanyifeng.com/blog/2011/06/a_guide_for_writing_bookmarklet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/06/a_guide_for_writing_bookmarklet.html</a><br>2011年6月11日</p>
<p>前一段日子，我写了两个Bookmarklet—-<a href="http://www.ruanyifeng.com/blog/2011/01/api_for_google_s_url_shortener.html" target="_blank" rel="noopener">“短网址生成”</a>和<a href="http://www.ruanyifeng.com/blog/2011/05/bookmarklet_of_unshortening_url.html" target="_blank" rel="noopener">“短网址还原”</a>。<br><strong>$_PS:</strong> 这两玩意，有点问题了。有需要再研究</p>
<h2 id="一、什么是Bookmarklet？"><a href="#一、什么是Bookmarklet？" class="headerlink" title="一、什么是Bookmarklet？"></a>一、什么是Bookmarklet？</h2><p>Bookmarklet是一个复合词，由Bookmark（书签）和-let（小的）构成，中文可以译成”书签工具”。</p>
<p>它在形式上与”书签”一样，都保存在浏览器收藏夹里。但是，它不是一个以”http://“开头的网址，而是一段Javascript代码，以”javascript:”开头。点击之后，会对当前页面执行某种操作。</p>
<p>它通常在网页中以链接的形式出现，就像下面这样：</p>
<pre><code>&lt;a href=&quot;javascript:alert(&apos;hi&apos;);&quot;&gt;xxx&lt;/a&gt;
</code></pre><p>用户直接把这个链接拖到地址栏或收藏夹就可以用了。</p>
<h2 id="二、Bookmarklet的优点"><a href="#二、Bookmarklet的优点" class="headerlink" title="二、Bookmarklet的优点"></a>二、Bookmarklet的优点</h2><p>它有几个很显著的优点，其他技术难以取代：</p>
<ol>
<li>安装快速<br>Bookmarklet的安装，就是在收藏夹中保存一段代码，一步就能完成。所有浏览器都原生支持。</li>
<li>使用方便<br>用的时候，点一下这个链接就行了。</li>
<li>开发容易<br>一段Javascript代码就是Bookmarklet的所有内容，不需要用到其他技术，比开发一个浏览器插件简单多了。</li>
<li>跨浏览器<br>所有浏览器都支持Bookmarklet。如果写的正确，同样一个Bookmarklet在各种浏览器上都能正常使用。</li>
</ol>
<h2 id="三、Bookmarklet的编写规则"><a href="#三、Bookmarklet的编写规则" class="headerlink" title="三、Bookmarklet的编写规则"></a>三、Bookmarklet的编写规则</h2><ol>
<li><p>必须以”javascript:”开头<br>浏览器把”javascript:”当做协议看待。有了它，浏览器才知道要用javascript解释后面的代码。它的作用等同于将代码放在<code>&lt;script&gt;&lt;/script&gt;</code>之间运行。</p>
</li>
<li><p>所有代码必须在同一行<br>因为浏览器把Bookmarklet当做网址保存，而网址是不能分行的，所以Bookmarklet也不能分行。</p>
<p> 另一方面，网址是有长度限制的。IE的最长网址不能超过2083个字符（IE6不能超过508个字符），这也就是Bookmarklet的最长长度。压缩工具可以帮忙减少长度，但是使用下面提到的连接外部代码的方法，可以避开这个限制。</p>
</li>
<li><p>使用单引号<br>根据Javascript的语法，单引号（’xxx’）和双引号（”xxx”）都能使用。但是由于html语言主要使用双引号，所以Bookmarklet优先使用单引号。万一遇到必须使用双引号的情况，就采用它的URL编码形式”%22”。</p>
</li>
<li><p>不要污染全局变量<br>Bookmarklet最好不要生成新的全局变量，可以采用直接运行匿名函数的方式：</p>
<pre><code>javascript: (function(){...})();
</code></pre><p> 上面式子的第一个括号，定义了一个匿名函数；最后一个括号表示立即执行这个匿名函数。所有的变量都是匿名函数的内部变量，不会生成任何新的全局变量。</p>
<p> 如果必须设置全局变量，就取罕见的变量名（比如hd8ki2），防止与已经存在的全局变量同名。</p>
</li>
<li><p>对文本和URL进行编码<br> 为了防止出现非法字符，代码以外的文本都应该使用encodeURIComponent()函数进行编码，比如把空格变成%20。</p>
</li>
</ol>
<h2 id="四、Bookmarklet的编写技巧"><a href="#四、Bookmarklet的编写技巧" class="headerlink" title="四、Bookmarklet的编写技巧"></a>四、Bookmarklet的编写技巧</h2><h3 id="4-1-获取网页信息"><a href="#4-1-获取网页信息" class="headerlink" title="4.1. 获取网页信息"></a>4.1. 获取网页信息</h3><p>获取当前页面的标题：document.title。<br>获取当前页面的URL： location.href。<br>获取当前选中的文本：</p>
<pre><code>var t;
t = (function(){
    if (window.getSelection){
    　　return window.getSelection().toString();
    }else if(document.getSelection){
    　　return document.getSelection();
    }else if (document.selection){
    　　return document.selection.createRange().text;
    }
    return &apos;&apos;;
})();
</code></pre><h3 id="4-2-防止刷新页面"><a href="#4-2-防止刷新页面" class="headerlink" title="4.2. 防止刷新页面"></a>4.2. 防止刷新页面</h3><p>如果代码对页面有改动（比如使用了document.write），浏览器就会用一个新页面替换原有页面。所以最好用void()命令，把语句放在里面。</p>
<p>举例来说，下面这个Bookmarklet会导致原页面被一个新页面替代：</p>
<pre><code>javascript:document.links[0].href=&apos;http://www.ibm.com/&apos;;
</code></pre><p>加上void以后，页面就不会跳转了：</p>
<pre><code>javascript:void(document.links[0].href=&apos;http://www.ibm.com/&apos;);
</code></pre><h3 id="4-3-框架（frameset）"><a href="#4-3-框架（frameset）" class="headerlink" title="4.3. 框架（frameset）"></a>4.3. 框架（frameset）</h3><p>对于使用”框架”（frameset）的网页，那些需要操作页面的Bookmarklet一般不起作用。所以，如果发现网页使用了框架，就告诉用户Bookmarklet无法使用。</p>
<pre><code>if(frames.length &gt; 0)
　　alert(&apos;对不起，不适用于框架。&apos;);
else{
　　/* 正常情况的代码 */
}
</code></pre><p>但是，上面的代码有一个问题，那就是行内框架iframe也包含在frames.length之中，所以必须排除iframe的影响。</p>
<pre><code>if(frames.length &gt; 
　document.getElementsByTagName(&apos;iframe&apos;).length)
　　alert(&apos;对不起，不适用于框架。&apos;);
else{
　　/* 正常情况的代码 */
}
</code></pre><h3 id="4-4-连接外部javascript代码"><a href="#4-4-连接外部javascript代码" class="headerlink" title="4.4. 连接外部javascript代码"></a>4.4. 连接外部javascript代码</h3><p>有时，Bookmarklet必须再引入外部的Javascript代码，这就需要为当前页面添加一个script标签。</p>
<pre><code>javascript:(function(){
　　var script=document.createElement(&apos;script&apos;);
　　script.setAttribute(&apos;src&apos;,&apos;http://path/to/external/file.js&apos;);
    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);
})();
</code></pre><h3 id="4-5-添加外部函数库"><a href="#4-5-添加外部函数库" class="headerlink" title="4.5. 添加外部函数库"></a>4.5. 添加外部函数库</h3><p>如果Bookmarklet需要用到外部函数库，就必须把它也加进来。但是，前提是必须先检查一下，看看原页面是否已经加载了这个函数库。</p>
<p>下面以加载jQuery为例：</p>
<pre><code>if (!window.jQuery) {
　　script=document.createElement( &apos;script&apos; );
　　script.src=&apos;http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&apos;;
　　script.onload=foo;
　　document.body.appendChild(script);
} else {
　　foo();
} 
function foo() {
　　/* ... */
}
</code></pre><h2 id="五、延伸阅读"><a href="#五、延伸阅读" class="headerlink" title="五、延伸阅读"></a>五、延伸阅读</h2><p>/end/</p>
<h1 id="B-Bookmarklets放在書籤裡的實用瀏覽器小工具補完列表"><a href="#B-Bookmarklets放在書籤裡的實用瀏覽器小工具補完列表" class="headerlink" title="B Bookmarklets放在書籤裡的實用瀏覽器小工具補完列表"></a>B Bookmarklets放在書籤裡的實用瀏覽器小工具補完列表</h1><p><a href="http://www.playpcesor.com/2007/10/bookmarklets.html" target="_blank" rel="noopener">http://www.playpcesor.com/2007/10/bookmarklets.html</a><br>作者： esor huang  10月 20, 2007<br><strong>$_PS:</strong> 这玩意看着，有些过时。不过受刺激，找到了google页面翻译插件，<a href="https://tinyurl.com/" target="_blank" rel="noopener">TinyURL</a>–这个和软软那个一个意思（估计是缩短bookmarklet）</p>
<blockquote>
<p>TinyURL：<a href="https://tinyurl.com/create.php?url=about%3Ablank" target="_blank" rel="noopener">https://tinyurl.com/create.php?url=about%3Ablank</a></p>
</blockquote>
<h1 id="C-我目前常常使用的瀏覽器-Bookmarklets-書籤小工具2010版"><a href="#C-我目前常常使用的瀏覽器-Bookmarklets-書籤小工具2010版" class="headerlink" title="C 我目前常常使用的瀏覽器 Bookmarklets 書籤小工具2010版"></a>C 我目前常常使用的瀏覽器 Bookmarklets 書籤小工具2010版</h1><p><a href="http://www.playpcesor.com/2010/06/bookmarklets-2010.html" target="_blank" rel="noopener">http://www.playpcesor.com/2010/06/bookmarklets-2010.html</a><br>作者： esor huang  6月 06, 2010    </p>
<p><strong>$_PS:</strong> 没时间读过：刚看到的</p>
<h1 id="D-SEO-Bookmarklets小書籤-–-SEO的實用工具"><a href="#D-SEO-Bookmarklets小書籤-–-SEO的實用工具" class="headerlink" title="D SEO| Bookmarklets小書籤 – SEO的實用工具"></a>D SEO| Bookmarklets小書籤 – SEO的實用工具</h1><p><a href="http://www.darrenhuang.com/2016/06/seo-efficient-tool-bookmarklets.html" target="_blank" rel="noopener">http://www.darrenhuang.com/2016/06/seo-efficient-tool-bookmarklets.html</a><br>JUNE 19, 2016 BY DARREN HUANG 3 COMMENTS    </p>
<ol>
<li><ol>
<li>檢查當前網站有多少頁被index</li>
</ol>
</li>
<li><ol start="2">
<li>檢查當前網頁是否被index</li>
</ol>
</li>
<li><ol start="3">
<li>檢查當前網頁的Cache版本</li>
</ol>
</li>
<li><ol start="4">
<li>開啟Open Site Explorer檢查當前網頁</li>
</ol>
</li>
<li><ol start="5">
<li>檢查當前頁面的Canonical Tag</li>
</ol>
</li>
<li><ol start="6">
<li>檢查當前網頁的meta robots tag</li>
</ol>
</li>
<li><ol start="7">
<li>用Wayback Machine看看當前網頁以前長得怎樣</li>
</ol>
</li>
<li><ol start="8">
<li>檢查當前網頁的Page Speed Insights</li>
</ol>
</li>
<li><ol start="9">
<li>秀出該網頁所有圖片的Alt Tag</li>
</ol>
</li>
<li><ol start="10">
<li>SEO工具包之一: QuiSEO</li>
</ol>
</li>
</ol>
<p><strong>$_PS:</strong> 这个应该是checkbox（lenovo-meeat）。<br><strong>$_PS:</strong> 五小福—-浏览器脚本？？<br><strong>$_PS:</strong> 书签，区域转换，可能用到了bookmarklet </p>
<h1 id="E-在翻译验证测试中巧妙运用-Bookmarklet-来提高效率"><a href="#E-在翻译验证测试中巧妙运用-Bookmarklet-来提高效率" class="headerlink" title="E 在翻译验证测试中巧妙运用 Bookmarklet 来提高效率"></a>E 在翻译验证测试中巧妙运用 Bookmarklet 来提高效率</h1><p><a href="https://www.ibm.com/developerworks/cn/web/1407_zhangxh_bookmarklet/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1407_zhangxh_bookmarklet/index.html</a><br><strong>$_PS:</strong> 也提供了bookmarklet的基本概念和使用</p>
<h1 id="F-15个前端开发-网页设计师必备的Bookmarklet"><a href="#F-15个前端开发-网页设计师必备的Bookmarklet" class="headerlink" title="F 15个前端开发/网页设计师必备的Bookmarklet"></a>F 15个前端开发/网页设计师必备的Bookmarklet</h1><p><a href="http://blog.csdn.net/zhanglin1314/article/details/6803506" target="_blank" rel="noopener">http://blog.csdn.net/zhanglin1314/article/details/6803506</a><br>2011年09月23日 12:34:35   </p>
<p>提示:如果您很少或不习惯使用这种Bookmarklet工具，您也可以考虑使用Firefox的Web Developer工具栏(扩展)，它包含了部分Bookmarklet的功能，也是非常棒的网页开发辅助工具。  </p>
<p><strong>$_PS:</strong> 可能有一点点用吧。但看到上面那句话，一点用也没有了</p>
<h1 id="G-Mr-Coles"><a href="#G-Mr-Coles" class="headerlink" title="G Mr Coles"></a>G Mr Coles</h1><p>真正提供bookmarklet转换的工具</p>
<blockquote>
<p><a href="https://mrcoles.com/bookmarklet/" target="_blank" rel="noopener">https://mrcoles.com/bookmarklet/</a> </p>
</blockquote>
<p style="text-align:right">2.2 17:25</p>


]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>bookmarklet</tag>
      </tags>
  </entry>
  <entry>
    <title>全屏API</title>
    <url>/sum/js/%E5%85%A8%E5%B1%8FAPI(010)/</url>
    <content><![CDATA[<p>全屏API的一些使用经验。可用  </p>
<p style="text-align:right">2018.2.2 星期五 15:28</p>

<a id="more"></a> 
<h1 id="A-Fullscreen-API：全屏操作"><a href="#A-Fullscreen-API：全屏操作" class="headerlink" title="A Fullscreen API：全屏操作"></a>A Fullscreen API：全屏操作</h1><p><a href="http://javascript.ruanyifeng.com/htmlapi/fullscreen.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/htmlapi/fullscreen.html</a></p>
<h2 id="一-方法"><a href="#一-方法" class="headerlink" title="一 方法"></a>一 方法</h2><h3 id="1-1-requestFullscreen"><a href="#1-1-requestFullscreen" class="headerlink" title="1.1 requestFullscreen()"></a>1.1 requestFullscreen()</h3><pre><code>function launchFullscreen(element) {
    if(element.requestFullscreen) {
        element.requestFullscreen();
    } else if(element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if(element.msRequestFullscreen){
        element.msRequestFullscreen();
    } else if(element.webkitRequestFullscreen) {
        element.webkitRequestFullScreen();
    }
}
launchFullscreen(document.documentElement);
launchFullscreen(document.getElementById(&quot;videoElement&quot;));
</code></pre><p>放大一个节点时，Firefox和Chrome在行为上略有不同。Firefox自动为该节点增加一条CSS规则，将该元素放大至全屏状态，width: 100%; height: 100%，而Chrome则是将该节点放在屏幕的中央，保持原来大小，其他部分变黑。为了让Chrome的行为与Firefox保持一致，可以自定义一条CSS规则。</p>
<pre><code>:-webkit-full-screen #myvideo {
    width: 100%;
    height: 100%;
}
</code></pre><h3 id="2-2-exitFullscreen"><a href="#2-2-exitFullscreen" class="headerlink" title="2.2 exitFullscreen"></a>2.2 exitFullscreen</h3><pre><code>function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    }
}
exitFullscreen();
</code></pre><p>用户手动按下ESC键或F11键，也可以退出全屏键。此外，加载新的页面，或者切换tab，或者从浏览器转向其他应用（按下Alt-Tab），也会导致退出全屏状态。</p>
<h2 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h2><h3 id="2-1-document-fullscreenElement"><a href="#2-1-document-fullscreenElement" class="headerlink" title="2.1 document.fullscreenElement"></a>2.1 document.fullscreenElement</h3><pre><code>var fullscreenElement =
document.fullscreenElement ||
document.mozFullScreenElement ||
document.webkitFullscreenElement;
</code></pre><h3 id="2-2-document-fullscreenEnabled"><a href="#2-2-document-fullscreenEnabled" class="headerlink" title="2.2 document.fullscreenEnabled"></a>2.2 document.fullscreenEnabled</h3><pre><code>var fullscreenEnabled =
document.fullscreenEnabled ||
document.mozFullScreenEnabled ||
document.webkitFullscreenEnabled ||
document.msFullscreenEnabled;

if (fullscreenEnabled) {
    videoElement.requestFullScreen();
} else {
    console.log(&apos;浏览器当前不能全屏&apos;);
}
</code></pre><h2 id="三-事件"><a href="#三-事件" class="headerlink" title="三 事件"></a>三 事件</h2><h3 id="3-1-fullscreenchange"><a href="#3-1-fullscreenchange" class="headerlink" title="3.1 fullscreenchange"></a>3.1 fullscreenchange</h3><pre><code>document.addEventListener(&quot;fullscreenchange&quot;, function( event ) {
    if (document.fullscreenElement) {
        console.log(&apos;进入全屏&apos;);
    } else {
        console.log(&apos;退出全屏&apos;);
    }
});
</code></pre><h3 id="3-2-fullscreenerror事件：浏览器无法进入全屏时触发，可能是技术原因，也可能是用户拒绝。"><a href="#3-2-fullscreenerror事件：浏览器无法进入全屏时触发，可能是技术原因，也可能是用户拒绝。" class="headerlink" title="3.2 fullscreenerror事件：浏览器无法进入全屏时触发，可能是技术原因，也可能是用户拒绝。"></a>3.2 fullscreenerror事件：浏览器无法进入全屏时触发，可能是技术原因，也可能是用户拒绝。</h3><h2 id="四-全屏状态的CSS"><a href="#四-全屏状态的CSS" class="headerlink" title="四 全屏状态的CSS"></a>四 全屏状态的CSS</h2><p>大多数浏览器的CSS支持:full-screen伪类，只有IE11支持:fullscreen伪类。使用这个伪类，可以对全屏状态设置单独的CSS属性。</p>
<pre><code>:-webkit-full-screen {
    /* properties */
}

:-moz-full-screen {
    /* properties */
}

:-ms-fullscreen {
    /* properties */
}

:full-screen { /*pre-spec */
    /* properties */
}

:fullscreen { /* spec */
    /* properties */
}

/* deeper elements */
:-webkit-full-screen video {
    width: 100%;
    height: 100%;
}
</code></pre><h2 id="五-参考链接"><a href="#五-参考链接" class="headerlink" title="五 参考链接"></a>五 参考链接</h2><h1 id="B-JavaScript请求全屏是不可靠的"><a href="#B-JavaScript请求全屏是不可靠的" class="headerlink" title="B JavaScript请求全屏是不可靠的"></a>B JavaScript请求全屏是不可靠的</h1><p><a href="http://codewa.com/question/111719.html" target="_blank" rel="noopener">http://codewa.com/question/111719.html</a>     </p>
<p>除了谷歌，全屏请求都是由用户操作出发的，只能响应用户操作，比如，点击,key等。不能通过代码触发   </p>
<p>火狐可以通过更改浏览器设置，也可以相应代码的全屏请求。</p>
<pre><code>about://config
full-screen-api.allow-trusted-requests-only---------false
</code></pre><p style="text-align:right">2.2 16:28</p>

<h1 id="Z-实际"><a href="#Z-实际" class="headerlink" title="Z 实际"></a>Z 实际</h1><h2 id="一-play-asp-aculive-php-acuviewer-php"><a href="#一-play-asp-aculive-php-acuviewer-php" class="headerlink" title="一 play.asp,aculive.php/acuviewer.php"></a>一 play.asp,aculive.php/acuviewer.php</h2><h3 id="1-1-要点"><a href="#1-1-要点" class="headerlink" title="1.1 要点"></a>1.1 要点</h3><ol>
<li>嵌套iframe，play.asp ,aculive.php<ol>
<li>同源：子页面可以操作了父页面 元素，控制全屏</li>
<li>跨域：上面方法不可行。通过postmessage传递事件（<strong>$_PS:</strong> 参考 跨域操作.md）<br>chrome可以通过代码触发全屏；其他不会，ff可以更改浏览器设置；<br>检测到全屏元素undefined，触发player的全屏事件（最后的else是不会进入的，因为是浏览器的设置z阻止了全屏事件，而不是API差异）</li>
</ol>
</li>
<li>ios系统（iPhone，iPad）不支持该API，safari浏览器可以    </li>
<li><p>全屏聊天 ，弹窗</p>
<ol>
<li>prompt选择后，退出全屏。</li>
<li>alert没试过，是不是会立即退出。待确定    </li>
</ol>
</li>
<li><p>全屏聊天时，移动设备键盘弹出时，没有事件监听，也无法获得键盘高度，so无法调整输入框刚好在键盘上面    </p>
<p style="text-align:right">2.2 19:19</p><br><p style="text-align:right">2018.2.8 四 11:30</p>

</li>
</ol>
<h3 id="1-2-SMTC"><a href="#1-2-SMTC" class="headerlink" title="1.2 SMTC"></a>1.2 SMTC</h3><p>见：全屏API</p>
<h3 id="1-3-键盘事件"><a href="#1-3-键盘事件" class="headerlink" title="1.3 键盘事件"></a>1.3 键盘事件</h3><h4 id="1-F11-不会响应"><a href="#1-F11-不会响应" class="headerlink" title="1 F11 不会响应"></a>1 F11 不会响应</h4><p>按下F11：document.webkitIsFullScreen=false。<br>document.onfullscreenchange也监听不到</p>
<h4 id="2-Esc"><a href="#2-Esc" class="headerlink" title="2 Esc"></a>2 Esc</h4><p>document.onfullscreenchange可以检测到</p>
<p>该网址也一样：<br><a href="https://www.ispringsolutions.com/ispring-quizmaker/demos" target="_blank" rel="noopener">https://www.ispringsolutions.com/ispring-quizmaker/demos</a></p>
<p style="text-align:right">2.8 12:08</p>


<p># C jQuery制作Web全屏效果<br>作者：大漠 日期：2012-03-20<br><a href="https://www.w3cplus.com/jquery/create-your-website-fullscreen-with-jquery" target="_blank" rel="noopener">https://www.w3cplus.com/jquery/create-your-website-fullscreen-with-jquery</a><br><strong>$_PS:</strong>  jQuery插件</p>
<p>其它：<br># D [Javascript 开启浏览器全屏模式]<br><!-- [**$_WX**](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552521&idx=1&sn=3b82e7c8c1f398bee2811b3822dfb49a&chksm=8025acc8b75225de4324e3147bfb334562575367bce6cb775400e6fe5743b43c817a1e59be85&mpshare=1&scene=1&srcid=0831TNCeMumbMGLNxHhmIxpg##)   
[**$_YX**](https://app.yinxiang.com/Home.action#n=d6c58596-8431-4d7b-9f48-285fc8c9d7b7&s=s67&b=67835be7-0476-470a-9448-0eb7e8f8a6e4&ses=4&sh=1&sds=5&) --></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Css编码</title>
    <url>/sum/css/css%E7%BC%96%E7%A0%81(001)/</url>
    <content><![CDATA[<blockquote>
<p>CSS 本身并无编程特性，但在其工程化技术的发展中缺不乏很多优秀的编程思想，无论是自定义的 DSL 还是基于 JS，这其中带给我们思考的正是“编译思想”</p>
</blockquote>
<p>–&gt; css编码<br>大象无形</p>
<!-- 实际、
CSS 样式书写规范、
这些 CSS 命名规范，将省下你大把调试时间、
在css中什么是最好的注释、
编写现代 CSS 代码的 20 个建议、
浏览器默认样式 -->
<a id="more"></a>
<h1 id="z-实际"><a href="#z-实际" class="headerlink" title="z 实际"></a>z 实际</h1><!-- 别人写的一堆单行css样式   
被刷BEM  
前段时间，还有关于css书写的一篇 -->
<p style="text-align:right">2018.1.30 二 16:40</p>

<h2 id="一-css中常见问题"><a href="#一-css中常见问题" class="headerlink" title="一 css中常见问题"></a>一 css中常见问题</h2><h3 id="1-1-关于Normalize"><a href="#1-1-关于Normalize" class="headerlink" title="1.1 关于Normalize"></a>1.1 关于Normalize</h3><p>可能并不需要引入整个normalize.css，或者reset.css。<br>最近的项目，单独对chrome做一些样式重写就好了；可以借鉴normalize<br>（以后要兼容，考虑定制；情况并不会很多，注意定制样式的位置或者文件，引入的方式）</p>
<p>如果做多个浏览器，normalize最合适，浏览器间的样式差异是客观存在的（事实）。</p>
<h3 id="1-2-autoprefix-，-postcss-与-mixin"><a href="#1-2-autoprefix-，-postcss-与-mixin" class="headerlink" title="1.2 autoprefix ， postcss 与 mixin"></a>1.2 autoprefix ， postcss 与 mixin</h3><p>基于上述说明，autoprefix 也是可以省掉的<br>编辑器可以autoprefix，打包工具也可以实现，（浏览器中加载js渲染也可行，没有试过）</p>
<h3 id="1-3-hack"><a href="#1-3-hack" class="headerlink" title="1.3 hack"></a>1.3 hack</h3><p>normalize 解决浏览器默认样式的差异<br>autoprefix 自动添加浏览器前缀，主要是一些新特性</p>
<p>对于一些不支持的样式，比如圆角、阴影，可以找一些第三方解决方案（pie.htc等）<br>尽管normalize，不同浏览器还是存在一些不同；又或是真对某个浏览器做一些特殊的设置，需要传统解决方法–属性前缀、后缀、条件注释、特定支持的css（haslayout，zoom，auto，@support,@media）</p>
<p>注意hack的使用方式：就近，单独文件，条件注释</p>
<h3 id="1-4-media"><a href="#1-4-media" class="headerlink" title="1.4 @media"></a>1.4 @media</h3><p>ie不知道那些版本不支持媒体查询，可能需要HTML5 的response<br><strong>$_NOTE:</strong>没有做过</p>
<h3 id="1-5-less-sass-stylus"><a href="#1-5-less-sass-stylus" class="headerlink" title="1.5 less,sass,stylus"></a>1.5 less,sass,stylus</h3><p>实际需求</p>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><h2 id="二-css风格"><a href="#二-css风格" class="headerlink" title="二 css风格"></a>二 css风格</h2><h3 id="2-1-单行-多行"><a href="#2-1-单行-多行" class="headerlink" title="2.1 单行/多行"></a>2.1 单行/多行</h3><p>优缺点：略<br>有些引用的，或者原子类的，可以单行；多行是目前的主流<br>而且，项目中有许多方式可以压缩代码</p>
<p>如果一定要写在head里，谁也没有办法<br>但是可以写在html里，加上contenteditable，可以在页面中改变文档样式（当前）</p>
<h3 id="2-2-顺序"><a href="#2-2-顺序" class="headerlink" title="2.2 顺序"></a>2.2 顺序</h3><ol>
<li>字母顺序<br> 目前，仍然没有记住26个字母的顺序。（记过几次，仍然是计划中要掌握的必备技能）</li>
<li>先后性<br> 定位，显示，字体颜色，背景，其他（动画、content、z-index）<br> 现在已经没有css4，css5，标准已经按模块划分了。<br> 找过模块，还是熟悉目前逻辑性的先后性风格</li>
</ol>
<h3 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3 注释"></a>2.3 注释</h3><p>具体见 [css注释风格.css];</p>
<pre><code>/**
* 多行注释
* 1. Correct the line height in all browsers.
*/

/* 块级注释
========================================================================== */
</code></pre><p>其它：<br><a href="#B-在-css-中什么是最好的注释">在css中什么是最好的注释</a>  </p>
<h3 id="2-4-简写"><a href="#2-4-简写" class="headerlink" title="2.4 简写"></a>2.4 简写</h3><p>避免过度简写（具体案例忘了，以下只是一个提示性代码）</p>
<pre><code>background:url(&quot;./images/icon.png&quot;) no-repeat left;
background:#8f3;//背景图被覆盖
div { margin:0;padding:0; }//避免浏览器无关的重新计算
...
</code></pre><h3 id="2-5-命名"><a href="#2-5-命名" class="headerlink" title="2.5 命名"></a>2.5 命名</h3><ol>
<li>可以有驼峰：动词短语.fadeOut,多个单词拼接短语.arv_fullscreenButton</li>
<li>可以有下划线，划分组件元素 .armplaylistControl_bar  </li>
</ol>
<p>有的建议，都小写，用 —连接；但对于我这么复杂的项目，有点难堪<br>复杂：JS，css中都要区分命名空间，css中公共原子也定义了命名空间</p>
<h3 id="2-6-数值"><a href="#2-6-数值" class="headerlink" title="2.6 数值"></a>2.6 数值</h3><ol>
<li>0px 后面没有px</li>
<li>小数点 0 都不需要写 </li>
<li>颜色 尽量一种风格 hls(a)？rgb(a)？; #333等简写</li>
</ol>
<h3 id="2-7-ID"><a href="#2-7-ID" class="headerlink" title="2.7 ID"></a>2.7 ID</h3><p>不推荐ID，即少用ID</p>
<h3 id="2-8-嵌套"><a href="#2-8-嵌套" class="headerlink" title="2.8 嵌套"></a>2.8 嵌套</h3><p>层次少对浏览器友好</p>
<h2 id="三-其他规范"><a href="#三-其他规范" class="headerlink" title="三 其他规范"></a>三 其他规范</h2><p>前面部分，有些在pdf中是存在的</p>
<h3 id="3-1-残存的pdf"><a href="#3-1-残存的pdf" class="headerlink" title="3.1 残存的pdf"></a>3.1 残存的pdf</h3><p>模块（化）思想<br>同JS三层：base，common，pages<br>命名空间</p>
<ol>
<li>原子层，不需要命名空间（多人协作）；<br> 只在pages层，做命名空间（多人协作）</li>
<li>可以驼峰，下划线 <code></code> (B_E)<br> M,应该是给了粒子了<blockquote>
<p>《编写高质量代码–Web前端开发修炼之道》。该书久远：推单行，reset.css    </p>
</blockquote>
</li>
</ol>
<p>思考:</p>
<ol>
<li>高粒度，一个样式可能需要多个原子类<br> 可复用 VS 精简，不可兼得</li>
<li>所以，抽出了common层？？</li>
<li>单个，className可能会很长</li>
</ol>
<h3 id="3-2-BEM"><a href="#3-2-BEM" class="headerlink" title="3.2 BEM"></a>3.2 BEM</h3><pre><code>.nav{}
.nav__item{}
.nav--blue{}
</code></pre><p>以下摘：<a href="https://www.zhihu.com/question/21935157" target="_blank" rel="noopener">https://www.zhihu.com/question/21935157</a>    </p>
<blockquote>
<ol>
<li>这么长，影响书写效率吧。肯定会影响但这是个很大的问题吗（自动提示会缓解一些） </li>
<li>html和css的size肯定会大一些。size大的顾虑是影响传输，在gzip面前可以忽略 </li>
<li>不爽。的确很违背习惯，但任何个人喜好和习惯作借囗都不职业 风格不重要。  </li>
</ol>
<p>我更关心它的好处： </p>
<ol>
<li>SCSS嵌套过多。超过3层就很难阅读了。 </li>
<li>嵌套多，选择器的层级就会多，性能不知不觉变差 </li>
<li>复用。这么长的名，想冲突都难<br>还有一个代码设计上的原则，不暴露抽象类。举例：</li>
</ol>
<p>这样更符合编程的特点。重要的是在维护上。假如变样了需要继承另一个抽象类，不需要改html，只要改css。这样SoC更彻底。<br>风格无非是某种形式，可以约束人做到一致。背后的设计思想才值得应用。如果用BEM的风格，但没做到抽象类的封装，没做到选择器的扁平，那就是失败的应用。<br>最后，我非常认同这种设计思想。但我还是不会照搬它的命名规则。太TM囧了！</p>
<p>作者：张克军<br>链接：<a href="https://www.zhihu.com/question/21935157/answer/19836373" target="_blank" rel="noopener">https://www.zhihu.com/question/21935157/answer/19836373</a></p>
</blockquote>
<blockquote>
<p>反对这种命名方式的人，大多举了个例子——如果我想将一个f30的类，改成f35怎么办？是挂羊头卖狗肉的直接将.f30{font-size:30px}改成.f30{font-size:35}吗？还是要进行全局搜索，改动所有的html的class名？<br>长命名有非常多的好处，“抽象”和“避免冲突”，避免“选择符权重竞赛”等等，上面克军的回答很清晰，我就不赘述了。</p>
</blockquote>
<blockquote>
<p>css预编译语言配合嵌套的做法好不好我不知道，bem好不好我也不知道，我只是知道如果有人说出“性能问题”四个字，那他已经赢了、而且还是立于不败之地那种……根本没办法讨论。<br>然后，我不喜欢bem。太长了符号太多辣眼睛。</p>
</blockquote>
<blockquote>
<p>个人认为如果已经使用了 SCSS 或者 LESS 之类的，再用这种写法就没有意义了。以模块化的命名方式更好，可以参考网易的 NEC 命名方式。</p>
</blockquote>
<blockquote>
<p>强大的命名规范可以让我们的代码更容易阅读和理解，也更容易控制，虽然这种命名方式看起来有点儿奇怪</p>
</blockquote>
<p>NEC相关：略过<br><a href="http://blog.csdn.net/chen_zw/article/details/47908475" target="_blank" rel="noopener">http://blog.csdn.net/chen_zw/article/details/47908475</a><br><a href="https://segmentfault.com/a/1190000007956424" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007956424</a></p>
<h3 id="3-3-OOCSS"><a href="#3-3-OOCSS" class="headerlink" title="3.3 OOCSS"></a>3.3 OOCSS</h3><h3 id="3-4-atomic-css"><a href="#3-4-atomic-css" class="headerlink" title="3.4 atomic css"></a>3.4 atomic css</h3><h3 id="3-5-css-in-js"><a href="#3-5-css-in-js" class="headerlink" title="3.5 css in js"></a>3.5 css in js</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h2 id="四-现写项目中的规则"><a href="#四-现写项目中的规则" class="headerlink" title="四 现写项目中的规则"></a>四 现写项目中的规则</h2><h3 id="4-1-play-asp-中arvplayer-less"><a href="#4-1-play-asp-中arvplayer-less" class="headerlink" title="4.1 play.asp 中arvplayer.less"></a>4.1 play.asp 中arvplayer.less</h3><h4 id="1-videojs-都是-连接"><a href="#1-videojs-都是-连接" class="headerlink" title="1 videojs 都是 - 连接"></a>1 videojs 都是 - 连接</h4><pre><code>.video-js  .vjs-volume-panel.noVolumeContr.vjs-volume-panel-horizontal.vjs-slider-active
.vjs-menu li.vjs-menu-title    
</code></pre><ol>
<li>命名空间vjs，</li>
<li>E和M都是 - 连接：  vjs-volume-panel-horizontal</li>
</ol>
<h4 id="2-arvplayer-less"><a href="#2-arvplayer-less" class="headerlink" title="2 arvplayer.less"></a>2 arvplayer.less</h4><ol>
<li><p>JS中用arv_做命名空间;又用到CSS样式中，分离不同区块内容 </p>
<pre><code>.arv_fullscreenButton
.arv_setting
.arv_bigPlayButton
</code></pre></li>
<li><p>arv-做命名空间，也是使用 - 连接；<br> 这里没有通用样式</p>
<pre><code>arv-note-control，arv-fullscreen-exit， arv-tip-enabled，
</code></pre></li>
<li><p>驼峰，一个是上面JS中.arv_bigPlayButton ；<br> 另一个是动词短语，所以驼峰写一起了（这里可以接受，《编写高-》没有说不使用驼峰）</p>
<pre><code>arv-fadeOut
</code></pre><p style="text-align:right">20:03 </p><br><p style="text-align:right">2018.1.31 三 长_天 09:43 </p>

</li>
</ol>
<h3 id="4-2-mobile-channel-php-channel-less"><a href="#4-2-mobile-channel-php-channel-less" class="headerlink" title="4.2 mobile/channel.php channel.less"></a>4.2 mobile/channel.php channel.less</h3><h4 id="1-略jj"><a href="#1-略jj" class="headerlink" title="1 略jj"></a>1 略jj</h4><ol>
<li>移动端一个页面(channel.php),考虑到多页面复用，重构以前样式：用了arm-做命名空间，定义了通用样式<br> PS:通用样式不需要命名空间，但是担心现在做的样式会和之前的冲突，使用命名空间写起来方便</li>
<li>在定义JS中变量，方法名时，使用命名空间/arm[a-z]*/表示移动端变量，方法，   ar表示pc端共用移动端的变量或方法。（原始页面(channel.php,playlist.php) 并没有这样的考虑）<br> 鉴于上述JS中命名空间，使用到了css中</li>
</ol>
<h4 id="2-具体"><a href="#2-具体" class="headerlink" title="2 具体"></a>2 具体</h4><ol>
<li>arm- 做命名空间，表示可以通用的样式</li>
<li><p>修饰符 - 连接</p>
<pre><code>arm-list，arm-full-top，arm-chevron-up
arm-blink，
#armplayerNote  .armplayerNote-content
</code></pre></li>
<li><p>#armplayerNote ，ID做了区块划分，-表示了样式     </p>
<pre><code>.armplayerNote-content 表示 armplayerNote下属的content样式
</code></pre><ol>
<li>为什么没有用 . 做区块划分：怕不明显吧  haha。包括#armchatroom, </li>
<li>#armplayerNote-close：只在JS使用，表示唯一，方便查找元素 </li>
</ol>
</li>
<li><p>同样的#armplaylistControl定义了区块，_代表元素  </p>
<pre><code>.armplaylistControl_title，.armplaylistControl_bar 表示该块的title，bar 元素  
</code></pre></li>
<li><p>同样的,下面这些 -content表示该快下的内容样式   </p>
<pre><code>.armcomment-content,.armnote-content   
.armstudio-content ,.armsubscribe-content
</code></pre><ol>
<li>这些内容是在search.php中的，之前是使用的.arm_comment,.arm_note,现在变为.armcomment-content;</li>
<li>这些内容没有使用ID来定义块，即没有#armcomment,#armnote（.armcomment-content是一个列表，有多个comment）;</li>
<li>还有.armsearchItem这样一个类，和.armplaylistControl_title相同</li>
<li>原来有.arm-content ，并没有指出属于那一块的content；最开始的时候只是定义了一个通用样式</li>
</ol>
<p>.armstudio-content有些符合NEC的味道</p>
</li>
<li><p>还有一类下划线，抄袭了原来的命名风格，做了区块划分，在channel.php</p>
<pre><code>#ch_home，#ch_videos，ch_playlists，ch_channels   
#author_uploads，#author_popular_uploads，
#arm_playlists，#arm_channels  
.arm_navs
</code></pre><p style="text-align:right">11:43 </p><br><p style="text-align:right">17:20 </p>
</li>
<li><p>基于原子类，重新定义了.arm-full-top , .arm-full-close</p>
<pre><code>.arm-full      .arm-full-top        .arm-full-left   
arm-full_close .arm-full_close-top  .arm-full_close-left        
</code></pre><ol>
<li>.arm-full-top , .arm-full-close 显然考虑了其他全屏方向</li>
<li>最后介于都是top，才有了最原始的定义</li>
<li>定义左边全屏后，逻辑也明显有了不同（都是top逻辑也不同，但可复用）。可以整块移动，也提升性能</li>
</ol>
</li>
</ol>
<h3 id="4-3-chatroom-armchat-less"><a href="#4-3-chatroom-armchat-less" class="headerlink" title="4.3 chatroom/armchat.less"></a>4.3 chatroom/armchat.less</h3><ol>
<li><p>虽然可以是新的项目，也使用arm-定义了命名空间，代表公共的可以复用的基本样式</p>
<pre><code>.arm-li2 li
.arm-tab
</code></pre></li>
<li><p>使用- 做连接</p>
<pre><code>.arm-dot-topLeft
.arm-tab_title-active1
</code></pre></li>
<li><p>重新定义了 .arm-tabTitle ,arm-tabContainer</p>
<pre><code>.arm-tab_title,arm-tab_container
</code></pre><p> 原来不知道受什么影响，用了驼峰，不能明确表达组件间关系了</p>
</li>
<li><p>驼峰的使用</p>
<pre><code>#armchat
#armchatPublic，#armchatParticipate
#armchatInput
</code></pre></li>
<li><p>另类，body.arm-chat-full</p>
<ol>
<li>#armchatroom在上一级页面(aculive.php)定义了iframe；虽然可用，还是为了避免冲突，何况JS中也使用</li>
<li><p>也没有很多个页面需要标识本页面。<br>所以body无法以<code>#armchatroom</code> ID的形式标识,定义了一个.arm-chat的原子类，-full表示修饰</p>
<p> body.arm-chat-full</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-4-混合，acuviewer-php和aculive-php中play-asp"><a href="#4-4-混合，acuviewer-php和aculive-php中play-asp" class="headerlink" title="4.4 混合，acuviewer.php和aculive.php中play.asp"></a>4.4 混合，acuviewer.php和aculive.php中play.asp</h3><ol>
<li>开始只有playerNote全屏，定义了.arm-full,.arm-full-close</li>
<li>出了全屏聊天，为了复用注释，即使逻辑不同，定义了相同了.arm-full-top,.arm-full-close</li>
<li>再全屏聊天，pc上要左半边，移动已经全屏了，.arm-full-left,.arm-full-full<br> 因为开始的.arm-close，又多了.arm-full_close-left,.arm-full_close-full;<br> 忧伤，有没有太长，？和定义在层级下比较呢</li>
</ol>
<h3 id="4-5-其它"><a href="#4-5-其它" class="headerlink" title="4.5 其它"></a>4.5 其它</h3><ol>
<li>即使用了less，也没有依赖嵌套，编译后多于4层的很少</li>
<li>没有使用mixin，@import<br><strong>$_TODO:</strong>使用mixin</li>
<li>armchat.php中，响应式 全屏，定义了变量（绝对定位，非fixed）</li>
</ol>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>so，css规范：</p>
<ol>
<li>驼峰、下划线均可以使用 BA_E-M; BA_E-M BA_E-M1 BA_E-M2; BA BA-M1 BA-M2</li>
<li>尽量少用ID；除了划分区块，JS中需要</li>
<li>公共/原子类，是不需要命名空间的；除非命名空间是用来划分作用域，比如：font20,w30,..</li>
<li>项目需要，是否构建一个原子类css库，或者只是些common层和pages层</li>
<li>尽量减少层级嵌套</li>
</ol>
<p style="text-align:right">18:10 </p>


<h1 id="A-CSS-样式书写规范"><a href="#A-CSS-样式书写规范" class="headerlink" title="A [CSS 样式书写规范]"></a>A [CSS 样式书写规范]</h1><p><a href="http://web.jobbole.com/91792/" target="_blank" rel="noopener">原文</a><br><!-- [github](https://github.com/chokcoco/CSSWritingRules)
[**$_WX**](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552360&idx=1&sn=8d2bc092405fc23379a786a6b7a36274&chksm=8025ada9b75224bfd372ce168cb0f9cb6959255e2a7e94556eacea5d1d8e4b559dd494704ae5&mpshare=1&scene=1&srcid=0807j4gkNgNb8V991GfiVEKQ#)
[**$_YX**](https://app.yinxiang.com/Home.action#n=fdb9c024-9c5b-4980-89e2-b754ee0f4c68&s=s67&b=c6633e78-2582-4902-a18a-147003fbf323&ses=4&sh=1&sds=5&)  --></p>
<p><strong>$_PS:</strong> 既然md，就都cc；修正标题越级2-&gt;4</p>
<h2 id="编码设置"><a href="#编码设置" class="headerlink" title="编码设置"></a>编码设置</h2><p>采用 <code>UTF-8</code> 编码，在 CSS 代码头部使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"utf-8"</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，必须要定义在 CSS 文件<strong>所有字符的前面</strong>（包括编码注释），<code>@charset</code> 才会生效。</p>
</blockquote>
<p>例如，下面的例子都会使得 <code>@charset</code> 失效：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 字符编码 */</span></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">"utf-8"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">"utf-8"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间规范"><a href="#命名空间规范" class="headerlink" title="命名空间规范"></a>命名空间规范</h2><ul>
<li>布局：以 g 为命名空间，例如：.g-wrap 、.g-header、.g-content。</li>
<li>状态：以 s 为命名空间，表示动态的、具有交互性质的状态，例如：.s-current、s-selected。</li>
<li>工具：以 u 为命名空间，表示不耦合业务逻辑的、可复用的的工具，例如：u-clearfix、u-ellipsis。</li>
<li>组件：以 m 为命名空间，表示可复用、移植的组件模块，例如：m-slider、m-dropMenu。</li>
<li>钩子：以 j 为命名空间，表示特定给 JavaScript 调用的类名，例如：j-request、j-open。</li>
</ul>
<h3 id="命名空间思想"><a href="#命名空间思想" class="headerlink" title="命名空间思想"></a>命名空间思想</h3><p>没有选择 <code>BEM</code> 这种命名过于严苛及样式名过长过丑的规则，采取了一种比较折中的方案。</p>
<h3 id="不建议使用下划线-进行连接"><a href="#不建议使用下划线-进行连接" class="headerlink" title="不建议使用下划线 _ 进行连接"></a>不建议使用下划线 _ 进行连接</h3><ul>
<li>节省操作，输入的时候少按一个 <code>shift</code> 键</li>
<li>能良好区分 JavaScript 变量命名</li>
</ul>
<h3 id="字符小写"><a href="#字符小写" class="headerlink" title="字符小写"></a>字符小写</h3><p>定义的选择器名，属性及属性值的书写皆为小写。</p>
<blockquote>
<p>在xhtml标准中规定了所有标签、属性和值都小写，CSS 书写也应该遵循此约定。</p>
</blockquote>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>当一个规则包含多个选择器时，每个选择器独占一行。</p>
<blockquote>
<p>、+、~、&gt; 选择器的两边各保留一个空格。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-header</span> &gt; <span class="selector-class">.g-header-des</span>,</span><br><span class="line"><span class="selector-class">.g-content</span> ~ <span class="selector-class">.g-footer</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名短且语义化良好"><a href="#命名短且语义化良好" class="headerlink" title="命名短且语义化良好"></a>命名短且语义化良好</h3><p>对于选择器的命名，尽量简洁且具有语义化，不应该出现 <code>g-abc</code> 这种语义模糊的命名。</p>
<h2 id="规则声明块"><a href="#规则声明块" class="headerlink" title="规则声明块"></a>规则声明块</h2><ul>
<li>当规则声明块中有多个样式声明时，每条样式独占一行。</li>
<li>在规则声明块的左大括号 { 前加一个空格。</li>
<li>在样式属性的冒号 : 后面加上一个空格，前面不加空格。</li>
<li>在每条样式后面都以分号 ; 结尾。</li>
<li>规则声明块的右大括号 } 独占一行。</li>
<li>每个规则声明间用空行分隔。</li>
<li>所有最外层引号使用单引号 ‘ 。</li>
<li>当一个属性有多个属性值时，以逗号 , 分隔属性值，每个逗号后添加一个空格，当单个属性值过长时，每个属性值独占一行。</li>
</ul>
<p>完整示例如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-footer</span>,</span><br><span class="line"><span class="selector-class">.g-header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-content</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, deeppink <span class="number">25%</span>, transparent <span class="number">25%</span>) -<span class="number">50px</span> <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">225deg</span>, deeppink <span class="number">25%</span>, transparent <span class="number">25%</span>) -<span class="number">50px</span> <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">315deg</span>, deeppink <span class="number">25%</span>, transparent <span class="number">25%</span>),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, deeppink <span class="number">25%</span>, transparent <span class="number">25%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数值与单位"><a href="#数值与单位" class="headerlink" title="数值与单位"></a>数值与单位</h2><ul>
<li><p>当属性值或颜色参数为 0 - 1 之间的数时，省略小数点前的 0 。</p>
<p><del><code>color: rgba(255, 255, 255, 0.5)</code></del></p>
<p><code>color: rgba(255, 255, 255, .5);</code></p>
</li>
<li><p>当长度值为 0 时省略单位。</p>
<p><del><code>margin: 0px auto</code></del></p>
<p><code>margin: 0 auto</code></p>
</li>
<li><p>十六进制的颜色属性值使用小写和尽量简写。</p>
<p><del><code>color: #ffcc00</code></del></p>
<p><code>color: #fc0</code></p>
</li>
</ul>
<h2 id="样式属性顺序"><a href="#样式属性顺序" class="headerlink" title="样式属性顺序"></a>样式属性顺序</h2><p>单个样式规则下的属性在书写时，应按功能进行分组，并以 Positioning Model &gt; Box Model &gt; Typographic &gt; Visual 的顺序书写，提高代码的可读性。</p>
<ul>
<li>如果包含 content 属性，应放在最前面；</li>
<li>Positioning Model 布局方式、位置，相关属性包括：position / top / right / bottom / left / z-index / display / float / …</li>
<li>Box Model 盒模型，相关属性包括：width / height / padding / margin / border / overflow / …</li>
<li>Typographic 文本排版，相关属性包括：font / line-height / text-align / word-wrap / …</li>
<li>Visual 视觉外观，相关属性包括：color / background / list-style / transform / animation / transition / …</li>
</ul>
<p>Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。盒模型紧跟其后，因为他决定了一个组件的大小和位置。其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。</p>
<h2 id="合理使用使用引号"><a href="#合理使用使用引号" class="headerlink" title="合理使用使用引号"></a>合理使用使用引号</h2><p>在某些样式中，会出现一些含有空格的关键字或者中文关键字。</p>
<h3 id="font-family-内使用引号"><a href="#font-family-内使用引号" class="headerlink" title="font-family 内使用引号"></a><code>font-family</code> 内使用引号</h3><p>当字体名字中间有空格，中文名字体及 Unicode 字符编码表示的中文字体，为了保证兼容性，都建议在字体两端添加单引号或者双引号：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'Microsoft YaHei'</span>, <span class="string">'黑体-简'</span>, <span class="string">'\5b8b\4f53'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="background-image-的-url-内使用引号"><a href="#background-image-的-url-内使用引号" class="headerlink" title="background-image 的 url 内使用引号"></a><code>background-image</code> 的 url 内使用引号</h3><p>如果路径里面有空格，旧版 IE 是无法识别的，会导致路径失效，建议不管是否存在空格，都添加上单引号或者双引号：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'...'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="避免使用-important"><a href="#避免使用-important" class="headerlink" title="避免使用 !important"></a>避免使用 <code>!important</code></h2><p>除去某些极特殊的情况，尽量不要不要使用 <code>!important</code>。</p>
<p><code>!important</code> 的存在会给后期维护以及多人协作带来噩梦般的影响。</p>
<blockquote>
<p>当存在样式覆盖层叠时，如果你发现新定义的一个样式无法覆盖一个旧的样式，只有加上 <code>!important</code> 才能生效时，是因为你新定义的选择器的优先级不够旧样式选择器的优先级高。所以，合理的书写新样式选择器，是完全可以规避一些看似需要使用 <code>!important</code> 的情况的。</p>
</blockquote>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>星号与内容之间必须保留一个空格。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 表格隔行变色 */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>星号要一列对齐，星号与内容之间必须保留一个空格。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sometimes you need to include optional context for the entire component. Do that up here if it's important enough.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="规则声明块内注释"><a href="#规则声明块内注释" class="headerlink" title="规则声明块内注释"></a>规则声明块内注释</h3><p>使用 // 注释，// 后面加上一个空格，注释独立一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    // ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>文件顶部必须包含文件注释，用 @name 标识文件说明。星号要一列对齐，星号与内容之间必须保留一个空格，标识符冒号与内容之间必须保留一个空格。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name: 文件名或模块名</span><br><span class="line"> * @description: 文件或模块描述</span><br><span class="line"> * @author: author-name(mail-name@domain.com)</span><br><span class="line"> *          author-name2(mail-name2@domain.com)</span><br><span class="line"> * @update: 2015-04-29 00:02</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@description为文件或模块描述。</li>
<li>@update为可选项，建议每次改动都更新一下。</li>
</ul>
<p>当该业务项目主要由固定的一个或多个人负责时，需要添加@author标识，一方面是尊重劳动成果，另一方面方便在需要时快速定位责任人。</p>
<h2 id="SASS-使用建议"><a href="#SASS-使用建议" class="headerlink" title="SASS 使用建议"></a>SASS 使用建议</h2><h3 id="嵌套层级规定"><a href="#嵌套层级规定" class="headerlink" title="嵌套层级规定"></a>嵌套层级规定</h3><p>使用 <code>SASS</code> 、 <code>LESS</code> 等预处理器时，建议嵌套层级不超过 3 层。</p>
<h3 id="组件-公用类的使用方法"><a href="#组件-公用类的使用方法" class="headerlink" title="组件/公用类的使用方法"></a>组件/公用类的使用方法</h3><p>组件/公用类使用 <code>%placeholders</code> 定义，使用 <code>@extend</code> 引用。如：<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%clearfix &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-header</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %clearfix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="组件类的思考"><a href="#组件类的思考" class="headerlink" title="组件类的思考"></a>组件类的思考</h4><p>使用 SASS ，经常会预先定义好一些常用公用组件类，譬如清除浮动，水平垂直居中，文字 ellipsis。又或者多个元素具有同样的样式，我们希望能够少写这部分代码，公共部分抽离出来只写一次，达到复用。</p>
<p>但是复用的方式在 SASS 中有多种，那么是使用单独使用一个类定义，给需要的标签添加，还是使用 <code>@include</code> 或者 <code>@extend</code> 在定义的类中引入一个 <code>@mixin</code>，或者一个 <code>@function</code> 呢？</p>
<p>基于让 CSS 更简洁以及代码的复用考虑，采用上面的使用 <code>%placeholders</code> 定义，使用 <code>@extend</code> 引用的方案。</p>
<ul>
<li><code>%placeholders</code>，只是一个占位符，只要不通过 <code>@extend</code> 调用，编译后不会产生任何代码量</li>
<li>使用 <code>@extend</code> 引用，则是因为每次调用相同的 <code>%placeholders</code> 时，编译出来相同的 CSS 样式会进行合并（反之，如果使用 <code>@include</code> 调用定义好的 <code>@mixin</code>，编译出来相同的 CSS 样式不会进行合并）</li>
<li>这里的组件类特指那些不会动态改变的 CSS 样式，注意与那些可以通过传参生成不同数值样式的 <code>@mixin</code> 方法进行区分</li>
</ul>
<h3 id="尽量避免使用标签名"><a href="#尽量避免使用标签名" class="headerlink" title="尽量避免使用标签名"></a>尽量避免使用标签名</h3><p>使用 SASS ，或者说在 CSS 里也有这种困惑。</p>
<p>假设我们有如下 html 结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"g-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"g-content-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在给最里层的标签命名书写样式的时候，我们有两种选择：<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-content</span> &#123;</span><br><span class="line">  <span class="selector-class">.g-content-list</span> &#123;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者是<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-content</span> &#123;</span><br><span class="line">  <span class="selector-class">.g-content-list</span> &#123;</span><br><span class="line">    <span class="selector-class">.item</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是，编译之后生成了下面这两个，到底使用哪个好呢？</p>
<ul>
<li><code>.g-content .g-content-list li { }</code></li>
<li><code>.g-content .g-content-list .item { }</code></li>
</ul>
<p>基于 CSS 选择器的解析规则（从右向左），建议使用上述第二种 <code>.g-content .g-content-list .item { }</code> ，避免使用通用标签名作为选择器的一环可以提高 CSS 匹配性能。</p>
<blockquote>
<p>浏览器的排版引擎解析 CSS 是基于从右向左（right-to-left）的规则，这么做是为了使样式规则能够更快地与渲染树上的节点匹配。</p>
</blockquote>
<blockquote>
<p>我觉得不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。</p>
</blockquote>
<h1 id="B-在-css-中什么是好的注释"><a href="#B-在-css-中什么是好的注释" class="headerlink" title="B [在 css 中什么是好的注释]"></a>B [在 css 中什么是好的注释]</h1><blockquote>
<p>英文：Keith J. Grant  译文：众成翻译/KING<br>zcfy.cc/article/thoughts-on-self-documenting-css</p>
</blockquote>
<p>Robert C. Martin写的《Clean Code》是我读过的最好的编程书籍之一，若没有读过，推荐你将它加入书单。</p>
<blockquote>
<p>注释就意味着代码无法自说明 —— Robert C. Martin  </p>
</blockquote>
<h2 id="不好：-块分隔注释"><a href="#不好：-块分隔注释" class="headerlink" title="不好： 块分隔注释"></a>不好： 块分隔注释</h2><p>对CSS而言，块分隔注释是非常特殊的，如下：</p>
<pre><code>/* -----------------
* TOOLTIPS
* ----------------- */
</code></pre><p>但事实上，很长很长的CSS文件已经不再流行了。若你的项目确实需要这种很大的CSS文件，它应该是由多个小的部分，通过CSS预处理工具组合而成的。 </p>
<h2 id="不好：解释语法"><a href="#不好：解释语法" class="headerlink" title="不好：解释语法"></a>不好：解释语法</h2><p>注释应该解释“为什么”，而不是“是什么”，即说明原因而不是说明作用（Why, not what）。</p>
<p>此处有一个例外，由于CSS有很多属性，也许有些属性是你完全不知道的，那么你用这种注释是正常的。  </p>
<h2 id="不好：对库进行介绍"><a href="#不好：对库进行介绍" class="headerlink" title="不好：对库进行介绍"></a>不好：对库进行介绍</h2><h2 id="不好-过时的注释"><a href="#不好-过时的注释" class="headerlink" title="不好: 过时的注释"></a>不好: 过时的注释</h2><h2 id="有时有用的：有特殊意义的注释"><a href="#有时有用的：有特殊意义的注释" class="headerlink" title="有时有用的：有特殊意义的注释"></a>有时有用的：有特殊意义的注释</h2><p>因为有时候代码的意图不是那么显而易见的。</p>
<p>但此时也需要问一个问题：有什么办法能让代码自说明呢？需要可以考虑将这些特定的属性移到第二个选择器中，专门为这些按钮设置的选择器。</p>
<h2 id="好：注解难懂的补丁性的代码"><a href="#好：注解难懂的补丁性的代码" class="headerlink" title="好：注解难懂的补丁性的代码"></a>好：注解难懂的补丁性的代码</h2><p>一些工具如KSS , 会在CSS文件中创建一些样式规范。如下：</p>
<pre><code>/*
Alerts
An alert box requires a contextual class to specify its importance.
一个警告信息框需要与语境有关的的类来指定其重要性

Markup:
&lt;div&gt;
Take note of this important alert message.
&lt;/div&gt;

alert-success - Something good or successful 好的或成功的
alert-info - Something worth noting, but not super important 不那么重要的
alert-warning - Something to note, may require attention 需要被提示并记录，需要引起注意的
alert-danger - Something important. Usually signifies an error. 非常重要的，常用于错误

Styleguide Alerts
*/
</code></pre><p>这不仅仅是注释，这是规范，它能被KSS解析并用于生成HTML。这已经算是项目文档的一部分了，而且不得不说，这比手动创建一个分离的HTML文件要好很多，因为其在同一个文件内且始终与代码相匹配。</p>
<p>另外一种指令式注释为许可信息，当使用第三方库并在注释中注明许可信息时，一般都需要包含。</p>
<p>而我贴出Robert Martin关于注释的话时，似乎应该解释一下，但我没有那么做。因为我认为这是一句容易理解的话，若你还在代码中到处写注释，那么请先思考是否合理。</p>
<h1 id="C-这些-CSS-命名规范，将省下你大把调试时间"><a href="#C-这些-CSS-命名规范，将省下你大把调试时间" class="headerlink" title="C [这些 CSS 命名规范，将省下你大把调试时间]"></a>C [这些 CSS 命名规范，将省下你大把调试时间]</h1><p><a href="https://medium.freecodecamp.org/css-naming-conventions-that-will-save-you-hours-of-debugging-35cea737d849" target="_blank" rel="noopener">原文</a><br><a href="https://github.com/xitu/gold-miner/blob/master/TODO/css-naming-conventions-that-will-save-you-hours-of-debugging.md" target="_blank" rel="noopener">译文</a><br><!-- [**$_WX**](http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227719&idx=1&sn=b72d098aa0f55f63d273cbe3c006c92d&chksm=bd495fc38a3ed6d59d42f749f5e1c9aa95ba8503d864b9c83f7c54e62909e4084aa5a6411e18&mpshare=1&scene=1&srcid=01295h5mzKv5bfESsAvPi7dW##)   
[**$_YX**](https://app.yinxiang.com/Home.action#n=5dc9f964-6390-4e9b-b861-7adffa4a1dec&s=s67&b=c6633e78-2582-4902-a18a-147003fbf323&ses=4&sh=1&sds=5&)  -->  </p>
<h2 id="使用连字符分隔的字符串"><a href="#使用连字符分隔的字符串" class="headerlink" title="使用连字符分隔的字符串"></a>使用连字符分隔的字符串</h2><p>但问题是这种命名法并不适用于 CSS。  </p>
<p>这是一种非常标准的 CSS 命名规范。也可以说更易读。<br>同时，这也和 CSS 属性名称保持了一致。</p>
<h2 id="BEM-命名规范"><a href="#BEM-命名规范" class="headerlink" title="BEM 命名规范"></a>BEM 命名规范</h2><h2 id="为何要使用命名规范？"><a href="#为何要使用命名规范？" class="headerlink" title="为何要使用命名规范？"></a>为何要使用命名规范？</h2><blockquote>
<p>在计算机科学当中只有两类难题：缓存失效和命名 - Phil Karlton</p>
</blockquote>
<h2 id="和-JavaScript-关联的-CSS-名称"><a href="#和-JavaScript-关联的-CSS-名称" class="headerlink" title="和 JavaScript 关联的 CSS 名称"></a>和 JavaScript 关联的 CSS 名称</h2><h3 id="1-使用-js-类名"><a href="#1-使用-js-类名" class="headerlink" title="1. 使用 js- 类名"></a>1. 使用 js- 类名</h3><h3 id="2-使用-Rel-属性"><a href="#2-使用-Rel-属性" class="headerlink" title="2. 使用 Rel 属性"></a>2. 使用 Rel 属性</h3><p>一般来说，rel 属性 定义着链接资源和引用它的文件之间的关系。</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;main.css&quot;&gt;
//
&lt;div class=&quot;site-navigation&quot; rel=&quot;js-site-navigation&quot;&gt;&lt;/div&gt;
const nav = document.querySelector(&quot;[rel=&apos;js-site-navigation&apos;]&quot;)
</code></pre><p><strong>我对这种方法持保留态度。</strong></p>
<h3 id="3-别用数据属性（data-attributes）"><a href="#3-别用数据属性（data-attributes）" class="headerlink" title="3. 别用数据属性（data attributes）"></a>3. 别用数据属性（data attributes）</h3><p>有些开发者用数据属性（data attributes）作为 JavaScript 钩子。这是不对的。根据定义，data 属性（data attributes）是用来 储存自定义数据（to store custom data） 的。</p>
<h2 id="附加提议：写更多的-CSS-注释"><a href="#附加提议：写更多的-CSS-注释" class="headerlink" title="附加提议：写更多的 CSS 注释"></a>附加提议：写更多的 CSS 注释</h2><p>这是因为 CSS 不是最简洁优雅的『语言』，有条理的注释可以让你花更少时间来理解自己的代码。<br>有益无弊，何乐不为。</p>
<p>你可以看看 Bootstrap 的注释写得有多好。</p>
<h1 id="D-编写现代-CSS-代码的-20-个建议"><a href="#D-编写现代-CSS-代码的-20-个建议" class="headerlink" title="D [编写现代 CSS 代码的 20 个建议]"></a>D [编写现代 CSS 代码的 20 个建议]</h1><p><a href="https://segmentfault.com/a/1190000006834519" target="_blank" rel="noopener">原文</a><br><!-- [**$_WX:**](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552516&idx=1&sn=4b514ddc001016ff19c98a5c6aa6b767&chksm=8025acc5b75225d3fb90e384f0cc0428949436f35ef5cce1174c1f557d409d73ae600328d504&mpshare=1&scene=1&srcid=0827C3LExGWe1L6GXTwGF4ty##)  
[**$_YX:**](https://app.yinxiang.com/Home.action#n=ad5f14a0-2dce-454e-9c0f-df194dba90c8&s=s67&b=c6633e78-2582-4902-a18a-147003fbf323&ses=4&sh=1&sds=5&)  --></p>
<ol>
<li>明白何谓Margin Collapse</li>
<li>使用Flexbox进行布局</li>
<li>使用CSS Reset</li>
<li>一切应为Border-box</li>
<li>以背景图方式使用Images</li>
<li>Better Table Borders</li>
<li>注释格式优化</li>
<li><p>使用Kebab-case命名变量<br> 对于样式类名或者ID名的命名都需要在多个单词之间添加-符号，CSS本身是大小写不敏感的因此你是用不了camelCase的，另一方面，很久之前也不支持下划线，所以现在的默认的命名方式就是使用-:   </p>
<p> 而涉及到具体的变量命名规范时，建议是使用BEM规范，只要遵循一些简单的原则即可以保证基于组件风格的命名一致性。你也可以参考CSS Tricks来获得更多的细节描述。</p>
</li>
<li>避免重复代码</li>
<li>使用transform添加CSS Animations</li>
<li>不要重复造轮子</li>
<li>尽可能使用低优先级的选择器</li>
<li>避免使用!important</li>
<li>Em, Rem, 以及 Pixel</li>
<li>在大型项目中使用预处理器</li>
<li>使用Autoprefixers来提升浏览器兼容性</li>
<li>在生产环境下使用Minified代码</li>
<li>多参阅Caniuse</li>
<li>Validate:校验</li>
</ol>
<h1 id="A-浏览器默认样式"><a href="#A-浏览器默认样式" class="headerlink" title="A- 浏览器默认样式"></a>A- 浏览器默认样式</h1><p style="text-align:right">2018.2.22 二 14:40</p>

<p><a href="https://www.jianshu.com/p/f7018b32ca4a" target="_blank" rel="noopener">https://www.jianshu.com/p/f7018b32ca4a</a><br><!-- 九彩拼盘     --><br><!-- 2015.03.23 10:54* 字数 201 阅读 1128评论 3喜欢 8     --></p>
<p>浏览器都拥有一套自己的默认样式。<br>浏览器之所以有默认样式表，是为了没有样式表的页面也能凑活着看。<br>不同浏览器；以及版本不同的浏览器的默认样式一般都是不同的。  </p>
<h2 id="重置样式表"><a href="#重置样式表" class="headerlink" title="重置样式表"></a>重置样式表</h2><p>为了保证页面在不同浏览器中显示的尽可能的一致，我们会重置不同浏览器默认的样式，称为重置样式表。</p>
<p>有很多别人整理的不错的重置样式表，例如CSS Reset ， strppd.css，normalize.css。我比较喜欢和推荐的是normalize.css。<br>normalize.css:<a href="https://github.com/necolas/normalize.css" target="_blank" rel="noopener">https://github.com/necolas/normalize.css</a><br>css reset:<a href="https://meyerweb.com/eric/tools/css/reset/index.html" target="_blank" rel="noopener">https://meyerweb.com/eric/tools/css/reset/index.html</a><br>strppd.css:<a href="http://iainspad.com/strppd-css/" target="_blank" rel="noopener">http://iainspad.com/strppd-css/</a>  </p>
<h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><p>IE的默认样式:<a href="https://www.iecss.com/" target="_blank" rel="noopener">https://www.iecss.com/</a><br>Firefox的默认样式:<a href="https://hg.mozilla.org/mozilla-central/file/tip/layout/style/html.css" target="_blank" rel="noopener">https://hg.mozilla.org/mozilla-central/file/tip/layout/style/html.css</a><br>(<strong>$_PS:</strong> Mercurial &gt; mozilla-central / error)<br>WebKit的默认样式:<a href="http://trac.webkit.org/browser/trunk/Source/WebCore/css/html.css" target="_blank" rel="noopener">http://trac.webkit.org/browser/trunk/Source/WebCore/css/html.css</a><br>浏览器默认样式对比表:<a href="http://developer.doyoe.com/default-style/" target="_blank" rel="noopener">http://developer.doyoe.com/default-style/</a>   </p>
<p style="text-align:right">14:45 </p>

]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Js代码规范</title>
    <url>/sum/js/js%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83(001)/</url>
    <content><![CDATA[<p>大音希声<br><!-- 万变不离其宗。 --></p>
<a id="more"></a>
<!-- # 实际 -->
<!-- coding中逐渐养成好的习惯 -->
<!-- 能用es6 的新特性，包括api就完美了 -->  
<p>面向对象，命令式<br>函数式、声明式</p>
<h1 id="JavaScript代码风格要素"><a href="#JavaScript代码风格要素" class="headerlink" title="[JavaScript代码风格要素]"></a>[JavaScript代码风格要素]</h1><p>一个function只做一件事，让function成为代码组合的最小单元。</p>
<p>删除不必要的代码。</p>
<p>使用主动语态。</p>
<p>避免一连串结构松散的，不知所云的代码。</p>
<p>将相关的代码写在一起。</p>
<p>利用判断true值的方式来编写代码。</p>
<p>不同的技术方案利用不同的代码组织结构来实现。</p>
<blockquote>
<p>代码应该简单，而不是简单化。</p>
</blockquote>
<h1 id="如何优雅的编写-JavaScript-代码"><a href="#如何优雅的编写-JavaScript-代码" class="headerlink" title="[如何优雅的编写 JavaScript 代码]"></a>[如何优雅的编写 JavaScript 代码]</h1><p>避免使用 js 糟粕和鸡肋<br>编写简洁的 JavaScript 代码<br>使用 ES6/ES7 新特性   </p>
<h1 id="如何让-JS-写得更漂亮"><a href="#如何让-JS-写得更漂亮" class="headerlink" title="[如何让 JS 写得更漂亮]"></a>[如何让 JS 写得更漂亮]</h1><p>01 按强类型风格写代码<br>02 减少作用域查找<br>03 避免==的使用<br>04 合并表达式<br>05 减少魔数<br>06 使用ES6简化代码     </p>
<h1 id="编写现代-JavaScript-代码"><a href="#编写现代-JavaScript-代码" class="headerlink" title="[编写现代 JavaScript 代码]"></a>[编写现代 JavaScript 代码]</h1><p>使用可格式化代码的 linter<br>为你的 linter 定制现代化的规则<br>使用 ES2015+ 的新特性<br>使用函数式编程<br>其他的一些建议     </p>
<h1 id="远离面条代码：编写可维护的-JS-代码"><a href="#远离面条代码：编写可维护的-JS-代码" class="headerlink" title="[远离面条代码：编写可维护的 JS 代码]"></a>[远离面条代码：编写可维护的 JS 代码]</h1><p>1、分析项目<br>不考虑你是开发者，把自己当成一个用户去审视项目<br>浏览代码看一下用了哪些工具<br>阅读工具的文档和最佳实践<br>通过单元测试，从更高的角度上了解项目        </p>
<p>2、建立规范<br>使用 .editorconfig 来保证不同编辑器之间的代码规范<br>确定好缩进方式。tab或空格都无所谓<br>保证命名规范<br>如果还没使用，那么推荐使用格式工具，例如 ESLint ， JSLint，或 JSHint 等<br>更新依赖，但是要理性的慢慢升级 </p>
<p>3、整理<br>使用 Karma、Jasmine 或 Nightwatch.js 来建立单元测试或浏览器自动化测试<br>保证架构和设计模式一致性<br>不要混用 design patterns，尽可能结合已有的设计模式<br>决定你是否想将项目分离成模块。每个模块只做明确的一个功能的并且和外面的代码解耦<br>如果不想做模块化，专注于分离成多个可测试的小型代码块<br>为你的代码建立文档和合适的命名方式<br>使用 JSDoc 来自动生成注释<br>提交每一个代码变更。如果出错方便回滚    </p>
<p>4、不要疯掉<br>不要抱怨前面的程序员。负面情绪不能帮你重构，只会浪费你的时间<br>每行代码都有它存在的原因。记住我们写的代码也是</p>
<h1 id="翻译：谷歌HTML、CSS和JavaScript风格规范"><a href="#翻译：谷歌HTML、CSS和JavaScript风格规范" class="headerlink" title="[翻译：谷歌HTML、CSS和JavaScript风格规范]"></a>[翻译：谷歌HTML、CSS和JavaScript风格规范]</h1><p><a href="http://www.zhangxinxu.com/wordpress/2012/07/google-html-css-javascript-style-guides/" target="_blank" rel="noopener">翻译：谷歌HTML、CSS和JavaScript风格规范</a>(zhang)</p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>HTML样式规范并没有多少惊喜。</p>
<p>语义HTML5作为text/html<br>分离的标记、样式和脚本<br>在可能情况下验证你的标记<br>技术不支持的时候使用备胎，如canvas<br>谷歌推荐打理每一个字节：使用UTF-8编码，剔除尾部的空白，避免实体引用，如&mdash;及&rdquo; 甚至推荐忽略可选结构以及结束标签，如：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>节约字节数 = 节约钞票数<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>如题。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>作者吐槽：这……我虽然赞同要省字节，但是还是倾向于严格的XHTML解析。<br>译者吐槽：一字不差同上。</p>
</blockquote>
<p>奇怪的是，谷歌建议使用连续的两个小空格代替tab空格。这不是两倍的字节大小吗？</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>样式规范主要就是更进一步的最佳实践以及字节节约技术：</p>
<p>使用有效的CSS, 除非是bugs处理或专属语法（浏览器私有前缀）<br>使用短ID或类命名，但确保他们不要太过隐晦，或直白（如#blue-button）<br>大型项目使用前缀，如#xyz-help, .xyz-column<br>选择器尽可能简单，如#example，而不是ul#example<br>使用缩写<br>url()中不使用引号，0后面不跟单位<br>使用#ABC这种简写的16进制颜色表示，而不是#AABBCC<br>每个声明最后都要有分号（即使是最后一个）<br>避免浏览器hacks<br>谷歌建议尺寸前面的数值0省掉，如.5em, 可以节约一个字符.</p>
<p>规范还推荐每个声明占据一行。<br>然后，声明的书写按照首字母顺序排列，如下：</p>
<blockquote>
<p>作者吐槽：对于属性的排序我还是喜欢根据其相关性，如块类型/尺寸，字体，文字对齐，填充，边距，颜色，背景，边框及其他属性。虽然，可以会让其他开发人员困惑，但是我自己用了好多年了！<br>译者吐槽：一字不差同上。</p>
</blockquote>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>JavaScript的风格规范比较长，这可以理解，不过我们可以提炼出一些基本点：</p>
<p>总是使用var声明变量<br>行末别忘了分号<br>使用标准而不是不标准的功能<br>使用驼峰命名（如：camelCaseNames）以及大写的常量（如：UPPERCASE），避免使用const关键字，因为IE不支持<br>使用命名空间技术<br>避免eval()除非反序列化（奇怪的是JSON解析并未提及）<br>避免对象上使用with(), 数组使用for in<br>使用对象以及数组字面量而不是更冗长的声明<br>要知道truthy和falsy规则<br>JavaScript资源中不使用IE条件注释<br>不修改内置对象的原型——这会让人颜面扫地，因为这是让JavaScript更加强大的功能之一，但你知道这会导致问题<br>小心使用闭包以及不要循环引用<br>同样，小心使用”this”<br>这里有个不太寻常的推荐，不在块域中使用function, 如：</p>
<pre><code class="javascript"><span class="keyword">if</span> (x) {
<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{}
}
而不是：

<span class="keyword">if</span> (x) {
<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{}
}
</code></pre>
<p>显然，第二种语法到处都有使用。其可以正常运作，但是在ECMAScript中是无效的。</p>
<p>文档还提到，包装对象应该永远不要用在基元上，除非是类型转换。其会导致意想不到的结果，例如：</p>
<pre><code>var x = new Boolean(false);
if (x) {
    // 代码执行
}
</code></pre><p>愚蠢的JavaScript.</p>
<p>最后，规范说你应该优先使用单引号(‘)于双引号(“)，因为字符串可能包含HTML代码。</p>
<blockquote>
<p>作者吐槽：我使用双引号到处沾花惹草，我不确定我能简单地改变这个习惯。但，我在PHP中对静态字符串又使用单引号。可能是我挑剔吧~~<br>译者吐槽：一字不差同上。</p>
</blockquote>
<p>文档最好的建议是：保持一致。开发人员很少会赞同每个程序的规范要按照你自己的那套规则走。保持一致可以让6个月之后别人可以更容易地理解你的代码，可以让生活更加美好！</p>
<p>其它：<br><a href="https://alloyteam.github.io/JX/doc/specification/google-javascript.xml" target="_blank" rel="noopener">Google JavaScript 编码规范指南</a><br><a href="https://github.com/yuche/javascript" target="_blank" rel="noopener">Airbnb JavaScript 编码规范</a><br><a href="http://www.ruanyifeng.com/blog/2012/04/javascript_programming_style.html" target="_blank" rel="noopener">Javascript编程风格</a>(ruan)<br><a href="http://codespec.lookapi.org/#/" target="_blank" rel="noopener">编码规范</a>: html/css/less/JavaScript/ecmascript/e-json/模块和加载器      </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6入门-13_异步操作</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/13_%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="三-异步操作"><a href="#三-异步操作" class="headerlink" title="三 异步操作"></a>三 异步操作</h2><p style="text-align:right">2018.1.28 星期日 22:18</p><br>p171-P194<br><br>异步编程对JavaScript语言太重要。JavaScript只有一根线程，如果没有异步编程，根本没法用，非卡死不可。<br><br>ES6诞生以前，异步编程的方法，大概有下面四种。<br>1. 回调函数<br>2. 事件监听<br>3. 发布/订阅<br>4. Promise 对象<br>ES6将JavaScript异步编程带入了一个全新的阶段。<br>### 3.1 基本概念<br>1. 异步<br>2. 回调函数<br><br>        fs.readFile(‘/etc/passwd’, function (err, data) {<br>            if (err) throw err;<br>            console.log(data);<br>        });<br>    /<strong><em>EXTERNAL</em></strong>/ 一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。<br>3. Promise<br>    /<strong><em>BACKGROUND</em></strong>/ 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为<strong>“回调函数噩梦”（callback hell）。</strong><br><br>    /<strong><em>RESOLVE</em></strong>/ Promise就是为了解决这个问题而提出的。它<strong>不是新的语法功能，而是一种新的写法*</strong>，允许将回调函数的横向加载，改成纵向加载。<br><br>    可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。<br>    /<strong><em>PROBLEMS</em></strong>/ Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。<br>4. 那么，有没有更好的写法呢<br>### 3.2 Generator函数<br>#### 1 协程<br>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下。<br>。。<br>    function asnycJob() {<br>        // …其他代码<br>        var f = yield readFile(fileA);<br>        // …其他代码<br>    }<br>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。<br>#### 2 Generator函数的概念<br>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br><br>整个Generator函数就是<strong>一个封装的异步任务，或者说是异步任务的容器</strong>。异步操作需要暂停的地方，都用yield语句注明。<br><br>    function<em> gen(x){<br>        var y = yield x + 2;<br>        return y;<br>    }<br>    var g = gen(1);<br>    g.next() // { value: 3, done: false }<br>    g.next() // { value: undefined, done: true }<br>上面代码中，调用Generator函数，<strong>会返回一个内部指针（即遍历器）g</strong> 。这是Generator函数不同于普通函数的另一个地方，<strong>即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针</strong>（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到 x + 2 为止。<br>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，<strong>会返回一个对象，表示当前阶段的信息（value属性和done属性）。</strong>value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。<br>#### 3 Generator函数的数据交换和错误处理<br>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。<br>1. next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。<br><br>        function</em> gen(x){<br>            var y = yield x + 2;<br>            return y;<br>        }<br>        var g = gen(1);<br>        g.next() // { value: 3, done: false }<br>        g.next(2) // { value: 2, done: true }<br>    作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。<br>2. Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><br>        function<em> gen(x){<br>            try {<br>                var y = yield x + 2;<br>            } catch (e){<br>                console.log(e);<br>            }<br>            return y;<br>        }<br>        var g = gen(1);<br>        g.next();<br>        g.throw（’出错了’）;<br>        // 出错了<br>    上面代码的最后一行，Generator函数体外，<strong>使用指针对象的throw方法抛出的错误</strong>，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的<br>#### 4 异步任务的封装<br>1. 下面看看如何使用 Generator 函数，执行一个真实的异步任务。<br><br>        var fetch = require(‘node-fetch’);<br>        function</em> gen(){<br>            var url = ‘<a href="https://api.github.com/users/github&#39;" target="_blank" rel="noopener">https://api.github.com/users/github&#39;</a>;<br>            var result = yield fetch(url);<br>            console.log(result.bio);<br>        }<br>    上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。<br><br>2. 执行这段代码的方法如下。<br><br>        var g = gen();<br>        var result = g.next();<br>        result.value.then(function(data){<br>            return data.json();<br>        }).then(function(data){<br>            g.next(data);<br>        });<br>    上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。<br><br>/PROBLEMS/ 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。<br>### 3.3 Thunk函数<br>    var x = 1;<br>    function f(m){<br>        return m <em> 2;<br>    }<br>    f(x + 5)<br>#### 1 参数的求值策略<br>1. 一种意见是”传值调用”（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。<br>    <code>f(6)</code><br>2. 另一种意见是”传名调用”（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。<br>    `(x + 5) </em> 2`<br>3. 传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f(a, b)&#123;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">f(3 * x * x - 2 * x - 1, x);</span><br></pre></td></tr></table></figure><br><br>#### 2 Thunk函数的含义<br>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。<strong>这个临时函数就叫做Thunk函数</strong>。<br>    function f(m){<br>        return m <em> 2;<br>    }<br>    f(x + 5);<br>    // 等同于<br>    var thunk = function () {<br>        return x + 5;<br>    };<br>    function f(thunk){<br>        return thunk() </em> 2;<br>    }<br><p style="text-align:right">2018.1.29 01：10</p><br><p style="text-align:right">2018.1.29 星期一 21:53</p>

<h4 id="3-JavaScript语言的Thunk函数"><a href="#3-JavaScript语言的Thunk函数" class="headerlink" title="3 JavaScript语言的Thunk函数"></a>3 JavaScript语言的Thunk函数</h4><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，<strong>Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数</strong>。<br>    // 正常版本的readFile（多参数版本）<br>    fs.readFile(fileName, callback);<br>    // Thunk版本的readFile（单参数版本）<br>    var readFileThunk = Thunk(fileName);<br>    readFileThunk(callback);<br>        var Thunk = function (fileName){<br>        return function (callback){<br>            return fs.readFile(fileName, callback);<br>        };<br>    };<br>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。<br>    var Thunk = function(fn){<br>    return function (){<br>        var args = Array.prototype.slice.call(arguments);<br>        return function (callback){<br>            args.push(callback);<br>            return fn.apply(this, args);<br>        }<br>        };<br>    };<br>使用上面的转换器，生成 fs.readFile 的Thunk函数。</p>
<pre><code>var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
</code></pre><h4 id="4-Thunkify模块"><a href="#4-Thunkify模块" class="headerlink" title="4 Thunkify模块"></a>4 Thunkify模块</h4><p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>Thunkify的源码与上一节那个简单的转换器非常像。<br>它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关</p>
<h4 id="5-Generator-函数的流程管理"><a href="#5-Generator-函数的流程管理" class="headerlink" title="5 Generator 函数的流程管理"></a>5 Generator 函数的流程管理</h4><p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，<strong>Thunk函数现在可以用于Generator函数的自动流程管理</strong>。<br>以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<pre><code>var fs = require(&apos;fs&apos;);
var thunkify = require(&apos;thunkify&apos;);
var readFile = thunkify(fs.readFile);
var gen = function* (){
    var r1 = yield readFile(&apos;/etc/fstab&apos;);
    console.log(r1.toString());
    var r2 = yield readFile(&apos;/etc/shells&apos;);
    console.log(r2.toString());
};
</code></pre><p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。<br>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<h4 id="6-Thunk函数的自动流程管理"><a href="#6-Thunk函数的自动流程管理" class="headerlink" title="6 Thunk函数的自动流程管理"></a>6 Thunk函数的自动流程管理</h4><p>Thunk函数真正的威力，在于可以自动执行Generator函数。<br><strong>$_EXCLUDE:</strong>略过，Thunk  没有感觉到目前的需要；</p>
<h3 id="3-4-co模块"><a href="#3-4-co模块" class="headerlink" title="3.4 co模块"></a>3.4 co模块</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h4><p>用于Generator函数的自动执行。<br>co模块可以让你不用编写Generator函数的执行器。</p>
<pre><code>var co = require(&apos;co&apos;);
co(gen);
</code></pre><p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<h4 id="2-co模块的原理"><a href="#2-co模块的原理" class="headerlink" title="2 co模块的原理"></a>2 co模块的原理</h4><p>Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。<br>两种方法可以做到这一点。<br>（1）回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。<br>（2）Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。<br>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h4 id="3-基于Promise对象的自动执行"><a href="#3-基于Promise对象的自动执行" class="headerlink" title="3 基于Promise对象的自动执行"></a>3 基于Promise对象的自动执行</h4><h4 id="4-co模块的源码"><a href="#4-co模块的源码" class="headerlink" title="4 co模块的源码"></a>4 co模块的源码</h4><h4 id="5-处理并发的异步操作"><a href="#5-处理并发的异步操作" class="headerlink" title="5 处理并发的异步操作"></a>5 处理并发的异步操作</h4><p><strong>$_EXCLUDE:</strong>知道上面两个都是用来自动执行Generator函数的。。慢慢理解吧</p>
<h3 id="3-5-async函数"><a href="#3-5-async函数" class="headerlink" title="3.5 async函数"></a>3.5 async函数</h3><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1 含义"></a>1 含义</h4><p>Generator函数的语法糖。</p>
<pre><code>var fs = require(&apos;fs&apos;);
    var readFile = function (fileName){
    return new Promise(function (resolve, reject){
        fs.readFile(fileName, function(error, data){
        if (error) reject(error);
        resolve(data);
        });
    });
};
var gen = function* (){
    var f1 = yield readFile(&apos;/etc/fstab&apos;);
    var f2 = yield readFile(&apos;/etc/shells&apos;);
    console.log(f1.toString());
    console.log(f2.toString());
};
</code></pre><p>写成 async 函数</p>
<pre><code>var asyncReadFile = async function (){
    var f1 = await readFile(&apos;/etc/fstab&apos;);
    var f2 = await readFile(&apos;/etc/shells&apos;);
    console.log(f1.toString());
    console.log(f2.toString());
};
</code></pre><p>async 函数对 Generator 函数的改进，体现在以下三点。<br>（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async 函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code>var result = asyncReadFile();
</code></pre><p>（2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。<br>（3）更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<h4 id="2-async函数的实现"><a href="#2-async函数的实现" class="headerlink" title="2 async函数的实现"></a>2 async函数的实现</h4><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<p>spawn 函数的实现，基本就是前文自动执行器的翻版。<br><strong>$_FALLBACK:</strong>前面介绍的两个chunk,co；主角终于出场了</p>
<p>而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p>
<h4 id="3-async-函数的用法"><a href="#3-async-函数的用法" class="headerlink" title="3 async 函数的用法"></a>3 async 函数的用法</h4><p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<ol>
<li><p>下面是一个例子。</p>
<pre><code>async function getStockPriceByName(name) {
    var symbol = await getStockSymbol(name);
    var stockPrice = await getStockPrice(symbol);
    return stockPrice;
}
getStockPriceByName(&apos;goog&apos;).then(function (result){
    console.log(result);
});
</code></pre></li>
<li><p>下面的例子，指定多少毫秒后输出一个值</p>
<pre><code>function timeout(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}
async function asyncPrint(value, ms) {
    await timeout(ms);
    console.log(value)
}
asyncPrint(&apos;hello world&apos;, 50);         
</code></pre><h4 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4 注意点"></a>4 注意点</h4></li>
<li><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>
<pre><code>async function myFunction() {
try {
    await somethingThatReturnsAPromise();
} catch (err) {
    console.log(err);
}
}
// 另一种写法
async function myFunction() {
await somethingThatReturnsAPromise().catch(function (err){
    console.log(err);
};
}
</code></pre></li>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li><p>但是，如果将forEach方法的参数改成async函数，也有问题。</p>
<pre><code>async function dbFuc(db) {
    let docs = [{}, {}, {}];
    // 可能得到错误结果
    docs.forEach(async function (doc) {
        await db.post(doc);
    });
}
</code></pre><p> 上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
</li>
<li>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。    <h4 id="5-与Promise、Generator的比较"><a href="#5-与Promise、Generator的比较" class="headerlink" title="5 与Promise、Generator的比较"></a>5 与Promise、Generator的比较</h4>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li>
<li><p>首先是Promise的写法。</p>
<pre><code>function chainAnimationsPromise(elem, animations) {
    // 变量ret用来保存上一个动画的返回值
    var ret = null;
    // 新建一个空的Promise
    var p = Promise.resolve();
    // 使用then方法，添加所有动画
    for(var anim in animations) {
        p = p.then(function(val) {
            ret = val;
            return anim(elem);
        })
    }
    // 返回一个部署了错误捕捉机制的Promise
    return p.catch(function(e) {
        /* 忽略错误，继续执行 */
    }).then(function() {
        return ret;
    });
}
</code></pre></li>
<li><p>接着是Generator函数的写法。</p>
<pre><code>function chainAnimationsGenerator(elem, animations) {
    return spawn(function*() {
        var ret = null;
        try {
            for(var anim of animations) {
                ret = yield anim(elem);
            }
        } catch(e) {
            /* 忽略错误，继续执行 */
        }
        return ret;
    });
}
</code></pre></li>
<li>最后是Async函数的写法。<pre><code>async function chainAnimationsAsync(elem, animations) {
    var ret = null;
    try {
        for(var anim of animations) {
            ret = await anim(elem);
        }
    } catch(e) {
        /* 忽略错误，继续执行 */
    }
    return ret;
}        
</code></pre></li>
</ol>
<p style="text-align:right">2018.1.30 0：24 </p>

<p>读后总结：</p>
<ol>
<li>整个章节是在讲异步；</li>
<li>但是理解的不是很深入，只是”知道了”；</li>
<li>截止到目前，实际工作中接触的少；以后肯定要多接触</li>
</ol>
]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6入门-12_Promise对象</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/12_Promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>前言</p>
<p>一 ECMAScript 6简介<br>二 let和const命令<br>三 变量的解构赋值<br>四 字符串的扩展<br>五 数值的扩展<br>六 数组的扩展<br>七 对象的扩展<br>八 函数的扩展<br>九 Set和Map数据<br>零 Iterator和for…of..<br>一 Generator函数</p>
<h2 id="二-Promise对象"><a href="#二-Promise对象" class="headerlink" title="二 Promise对象"></a>二 Promise对象</h2><p style="text-align:right">2018.1.28 星期日 22:58 +1 细化笔记</p><br><p style="text-align:right">2018.1.14 星期日 20:08</p>

<h3 id="2-1-Promise的含义"><a href="#2-1-Promise的含义" class="headerlink" title="2.1 Promise的含义"></a>2.1 Promise的含义</h3><p><strong>所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作）</strong>，且这个事件提供统一的API，可供进一步处理。<br>Promise对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>
<h3 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h3><p>/step0/ ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<pre><code>var promise = new Promise(function(resolve, reject) {
    // ... some code
    if (/* 异步操作成功 */){
        resolve(value);
    } else {
        reject(error);
    }
});
</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>/step1/ Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br>        promise.then(function(value) {<br>            // success<br>        }, function(value) {<br>            // failure<br>        });<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。<br>这两个函数都接受Promise对象传出的值作为参数。  </p>
<ol>
<li><p>一个Promise对象的简单例子</p>
<pre><code>function timeout(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms, &apos;done&apos;);
    });
}
timeout(100).then((value) =&gt; {
    console.log(value);
});
</code></pre></li>
<li><p>一个用Promise对象实现的Ajax操作的例子</p>
<pre><code>var getJSON = function(url) {
    var promise = new Promise(function(resolve, reject){
        var client = new XMLHttpRequest();
        client.open(&quot;GET&quot;, url);
        client.onreadystatechange = handler;
        client.responseType = &quot;json&quot;;
        client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
        client.send();
        function handler() {
        if (this.status === 200) {
            resolve(this.response);
        } else {
            reject(new Error(this.statusText));
        }
        };
    });
    return promise;
};
getJSON(&quot;/posts.json&quot;).then(function(json) {
    console.log(&apos;Contents: &apos; + json);
}, function(error) {
    console.error(&apos;出错了&apos;, error);
});
</code></pre></li>
<li><p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p>
<pre><code>var p1 = new Promise(function(resolve, reject){
    // ...
});
var p2 = new Promise(function(resolve, reject){
    // ...
    resolve(p1);
})
</code></pre><p> 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，    那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p>
</li>
</ol>
<h3 id="2-3-Promise-prototype-then"><a href="#2-3-Promise-prototype-then" class="headerlink" title="2.3 Promise.prototype.then()"></a>2.3 Promise.prototype.then()</h3><ol>
<li><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
    return json.post;
}).then(function(post) {
    // ...
});
</code></pre></li>
<li><p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。  </p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
    return getJSON(post.commentURL);
}).then(function funcA(comments) {
    console.log(&quot;Resolved: &quot;, comments);
}, function funcB(err){
    console.log(&quot;Rejected: &quot;, err);
});    
</code></pre><p> 如果采用箭头函数，上面的代码可以写得更简洁</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
    post =&gt; getJSON(post.commentURL)
).then(
    comments =&gt; console.log(&quot;Resolved: &quot;, comments),
    err =&gt; console.log(&quot;Rejected: &quot;, err)
);
</code></pre><h3 id="2-4-Promise-prototype-catch"><a href="#2-4-Promise-prototype-catch" class="headerlink" title="2.4 Promise.prototype.catch()"></a>2.4 Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。<br>..</p>
</li>
<li><p>下面是一个例子。</p>
<pre><code>var promise = new Promise(function(resolve, reject) {
    throw new Error(&apos;test&apos;)
});
promise.catch(function(error) { console.log(error) });
// Error: test
</code></pre></li>
<li><p>如果Promise状态已经变成resolved，再抛出错误是无效的。</p>
<pre><code>var promise = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    throw new Error(&apos;test&apos;);
});
promise
    .then(function(value) { console.log(value) })
    .catch(function(error) { console.log(error) });
    // ok
</code></pre></li>
<li><p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
    return getJSON(post.commentURL);
}).then(function(comments) {
    // some code
}).catch(function(error) {
    // 处理前面三个Promise产生的错误
});
</code></pre><p> 上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
</li>
<li><p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。    </p>
<ol>
<li>..</li>
<li>..</li>
<li><p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>
<pre><code>process.on(&apos;unhandledRejection&apos;, function (err, p) {
    console.error(err.stack)
});
</code></pre></li>
</ol>
</li>
<li>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。<br> catch方法之中，还能再抛出错误</li>
</ol>
<h3 id="2-5-Promise-all"><a href="#2-5-Promise-all" class="headerlink" title="2.5 Promise.all()"></a>2.5 Promise.all()</h3><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br><code>var p = Promise.all([p1,p2,p3]);</code><br>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例。）</p>
<pre><code>// 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function(id){
    return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);
});
Promise.all(promises).then(function(posts) {
    // ...
}).catch(function(reason){
    // ...
});
</code></pre><h3 id="2-6-Promise-race"><a href="#2-6-Promise-race" class="headerlink" title="2.6 Promise.race()"></a>2.6 Promise.race()</h3><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<h3 id="2-7-Promise-resolve"><a href="#2-7-Promise-resolve" class="headerlink" title="2.7 Promise.resolve()"></a>2.7 Promise.resolve()</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。<br><code>var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));</code><br>上面代码将jQuery生成deferred对象，转为一个新的Promise对象。</p>
<ol>
<li><p>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</p>
<pre><code>var p = Promise.resolve(&apos;Hello&apos;);
p.then(function (s){
    console.log(s)
});
// Hello
</code></pre></li>
<li><p>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>
<pre><code>var p = Promise.resolve();
p.then(function () {
    // ...
});
</code></pre></li>
<li>如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。          <h3 id="2-8-Promise-reject"><a href="#2-8-Promise-reject" class="headerlink" title="2.8 Promise.reject()"></a>2.8 Promise.reject()</h3></li>
</ol>
<h3 id="2-9-Generator函数与Promise的结合"><a href="#2-9-Generator函数与Promise的结合" class="headerlink" title="2.9 Generator函数与Promise的结合"></a>2.9 Generator函数与Promise的结合</h3><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<pre><code>function getFoo () {
    return new Promise(function (resolve, reject){
        resolve(&apos;foo&apos;);
    });
}
var g = function* () {
    try {
        var foo = yield getFoo();
        console.log(foo);
    } catch (e) {
        console.log(e);
    }
};
function run (generator) {
    var it = generator();
    function go(result) {
        if (result.done) return result.value;
        return result.value.then(function (value) {
            return go(it.next(value));
        }, function (error) {
            return go(it.throw(value));
        });
    }
    go(it.next());
}
run(g);
</code></pre><p>上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。    </p>
<h3 id="2-9-async函数"><a href="#2-9-async函数" class="headerlink" title="2.9 async函数"></a>2.9 async函数</h3><p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7</p>
<p style="text-align:right">2018.1.14 20：38</p><br><p style="text-align:right">1.28 23：38 细化完成</p>

<h2 id="三-异步操作"><a href="#三-异步操作" class="headerlink" title="三 异步操作"></a>三 异步操作</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><h3 id="3-2-Generator函数"><a href="#3-2-Generator函数" class="headerlink" title="3.2 Generator函数"></a>3.2 Generator函数</h3><h3 id="3-3-Thunk函数"><a href="#3-3-Thunk函数" class="headerlink" title="3.3 Thunk函数"></a>3.3 Thunk函数</h3><h3 id="3-4-co模块"><a href="#3-4-co模块" class="headerlink" title="3.4 co模块"></a>3.4 co模块</h3><h3 id="3-5-async函数"><a href="#3-5-async函数" class="headerlink" title="3.5 async函数"></a>3.5 async函数</h3><p style="text-align:right">2018.1.14 星期日 23:08</p>

<h2 id="四-Class"><a href="#四-Class" class="headerlink" title="四 Class"></a>四 Class</h2><h3 id="4-1-Class基本语法"><a href="#4-1-Class基本语法" class="headerlink" title="4.1 Class基本语法"></a>4.1 Class基本语法</h3><h3 id="4-2-Class的继承"><a href="#4-2-Class的继承" class="headerlink" title="4.2 Class的继承"></a>4.2 Class的继承</h3><h2 id="五-Module"><a href="#五-Module" class="headerlink" title="五 Module"></a>五 Module</h2><h3 id="5-1-export命令"><a href="#5-1-export命令" class="headerlink" title="5.1 export命令"></a>5.1 export命令</h3><h3 id="5-2-import命令"><a href="#5-2-import命令" class="headerlink" title="5.2 import命令"></a>5.2 import命令</h3><h3 id="5-3-模块的整体输入"><a href="#5-3-模块的整体输入" class="headerlink" title="5.3 模块的整体输入"></a>5.3 模块的整体输入</h3><h3 id="5-4-module命令"><a href="#5-4-module命令" class="headerlink" title="5.4 module命令"></a>5.4 module命令</h3><h3 id="5-5-export-default命令"><a href="#5-5-export-default命令" class="headerlink" title="5.5 export default命令"></a>5.5 export default命令</h3><h3 id="5-6-模块的继承"><a href="#5-6-模块的继承" class="headerlink" title="5.6 模块的继承"></a>5.6 模块的继承</h3><h3 id="5-7-ES6模块的转码"><a href="#5-7-ES6模块的转码" class="headerlink" title="5.7 ES6模块的转码"></a>5.7 ES6模块的转码</h3><h2 id="六-编程风格"><a href="#六-编程风格" class="headerlink" title="六 编程风格"></a>六 编程风格</h2><h3 id="6-1-块级作用域"><a href="#6-1-块级作用域" class="headerlink" title="6.1 块级作用域"></a>6.1 块级作用域</h3><h3 id="6-2-字符串"><a href="#6-2-字符串" class="headerlink" title="6.2 字符串"></a>6.2 字符串</h3><h3 id="6-3-解构赋值"><a href="#6-3-解构赋值" class="headerlink" title="6.3 解构赋值"></a>6.3 解构赋值</h3><h3 id="6-4-对象"><a href="#6-4-对象" class="headerlink" title="6.4 对象"></a>6.4 对象</h3><h3 id="6-5-数组"><a href="#6-5-数组" class="headerlink" title="6.5 数组"></a>6.5 数组</h3><h3 id="6-6-函数"><a href="#6-6-函数" class="headerlink" title="6.6 函数"></a>6.6 函数</h3><h3 id="6-7-Map结构"><a href="#6-7-Map结构" class="headerlink" title="6.7 Map结构"></a>6.7 Map结构</h3><h3 id="6-8-Class"><a href="#6-8-Class" class="headerlink" title="6.8 Class"></a>6.8 Class</h3><h3 id="6-9-模块"><a href="#6-9-模块" class="headerlink" title="6.9 模块"></a>6.9 模块</h3><h2 id="七-参考链接"><a href="#七-参考链接" class="headerlink" title="七 参考链接"></a>七 参考链接</h2><h3 id="7-1-官方文件"><a href="#7-1-官方文件" class="headerlink" title="7.1 官方文件"></a>7.1 官方文件</h3><h3 id="7-2-综合介绍"><a href="#7-2-综合介绍" class="headerlink" title="7.2 综合介绍"></a>7.2 综合介绍</h3><p style="text-align:right">2018.1.15 00：22</p>

<p>读后总结： </p>
<ol>
<li>知道 Promise是一个对象：构造函数，接受一个函数参数，该函数有resolve,reject两个参数</li>
<li>以及该对象配套方法</li>
<li>目标，是掌握该对象的意义</li>
</ol>
]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6入门-14_class</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/14_class/</url>
    <content><![CDATA[<h2 id="四-Class"><a href="#四-Class" class="headerlink" title="四 Class"></a>四 Class</h2><p></p><p style="text-align:right">2018.1.28 星期日 22:18</p><br>p171-P194<p></p>
<h3 id="4-1-Class基本语法"><a href="#4-1-Class基本语法" class="headerlink" title="4.1 Class基本语法"></a>4.1 Class基本语法</h3><h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><h4 id="（2）constructor方法"><a href="#（2）constructor方法" class="headerlink" title="（2）constructor方法"></a>（2）constructor方法</h4><h4 id="（3）实例对象"><a href="#（3）实例对象" class="headerlink" title="（3）实例对象"></a>（3）实例对象</h4><h4 id="（4）name属性"><a href="#（4）name属性" class="headerlink" title="（4）name属性"></a>（4）name属性</h4><h4 id="（5）Class表达式"><a href="#（5）Class表达式" class="headerlink" title="（5）Class表达式"></a>（5）Class表达式</h4><h4 id="（6）不存在变量提升"><a href="#（6）不存在变量提升" class="headerlink" title="（6）不存在变量提升"></a>（6）不存在变量提升</h4><h4 id="（7）严格模式"><a href="#（7）严格模式" class="headerlink" title="（7）严格模式"></a>（7）严格模式</h4><h3 id="4-2-Class的继承"><a href="#4-2-Class的继承" class="headerlink" title="4.2 Class的继承"></a>4.2 Class的继承</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h4><h4 id="2-类的prototype属性和proto属性"><a href="#2-类的prototype属性和proto属性" class="headerlink" title="2 类的prototype属性和proto属性"></a>2 类的prototype属性和proto属性</h4><h4 id="3-Object-getPrototypeOf"><a href="#3-Object-getPrototypeOf" class="headerlink" title="3 Object.getPrototypeOf()"></a>3 Object.getPrototypeOf()</h4><h4 id="4-实例的proto属性"><a href="#4-实例的proto属性" class="headerlink" title="4 实例的proto属性"></a>4 实例的proto属性</h4><h4 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5 原生构造函数的继承"></a>5 原生构造函数的继承</h4><p><strong>$_TODO:</strong> 没看懂</p>
<h4 id="6-class的取值函数（getter）和存值函数（setter）"><a href="#6-class的取值函数（getter）和存值函数（setter）" class="headerlink" title="6 class的取值函数（getter）和存值函数（setter）"></a>6 class的取值函数（getter）和存值函数（setter）</h4><h4 id="7-Class的Generator方法"><a href="#7-Class的Generator方法" class="headerlink" title="7 Class的Generator方法"></a>7 Class的Generator方法</h4><h3 id="4-3-Class的静态方法"><a href="#4-3-Class的静态方法" class="headerlink" title="4.3 Class的静态方法"></a>4.3 Class的静态方法</h3><h3 id="4-4-new-target属性"><a href="#4-4-new-target属性" class="headerlink" title="4.4 new.target属性"></a>4.4 new.target属性</h3><h3 id="4-5-修饰器"><a href="#4-5-修饰器" class="headerlink" title="4.5 修饰器"></a>4.5 修饰器</h3><h4 id="1-类的修饰"><a href="#1-类的修饰" class="headerlink" title="1 类的修饰"></a>1 类的修饰</h4><h4 id="2-方法的修饰"><a href="#2-方法的修饰" class="headerlink" title="2 方法的修饰"></a>2 方法的修饰</h4><h4 id="3-core-decorators-js"><a href="#3-core-decorators-js" class="headerlink" title="3 core-decorators.js"></a>3 core-decorators.js</h4><h4 id="4-Mixin"><a href="#4-Mixin" class="headerlink" title="4 Mixin"></a>4 Mixin</h4><h4 id="5-Trait"><a href="#5-Trait" class="headerlink" title="5 Trait"></a>5 Trait</h4><h4 id="6-Babel转码器的支持"><a href="#6-Babel转码器的支持" class="headerlink" title="6 Babel转码器的支持"></a>6 Babel转码器的支持</h4><p><strong>$_TODO:</strong> 可能是ES7；整章直接略过了</p>
<h2 id="五-Module"><a href="#五-Module" class="headerlink" title="五 Module"></a>五 Module</h2><h2 id="六-编程风格"><a href="#六-编程风格" class="headerlink" title="六 编程风格"></a>六 编程风格</h2><h3 id="6-1-块级作用域"><a href="#6-1-块级作用域" class="headerlink" title="6.1 块级作用域"></a>6.1 块级作用域</h3><h3 id="6-2-字符串"><a href="#6-2-字符串" class="headerlink" title="6.2 字符串"></a>6.2 字符串</h3><h3 id="6-3-解构赋值"><a href="#6-3-解构赋值" class="headerlink" title="6.3 解构赋值"></a>6.3 解构赋值</h3><h3 id="6-4-对象"><a href="#6-4-对象" class="headerlink" title="6.4 对象"></a>6.4 对象</h3><h3 id="6-5-数组"><a href="#6-5-数组" class="headerlink" title="6.5 数组"></a>6.5 数组</h3><h3 id="6-6-函数"><a href="#6-6-函数" class="headerlink" title="6.6 函数"></a>6.6 函数</h3><h3 id="6-7-Map结构"><a href="#6-7-Map结构" class="headerlink" title="6.7 Map结构"></a>6.7 Map结构</h3><h3 id="6-8-Class"><a href="#6-8-Class" class="headerlink" title="6.8 Class"></a>6.8 Class</h3><h3 id="6-9-模块"><a href="#6-9-模块" class="headerlink" title="6.9 模块"></a>6.9 模块</h3><h2 id="七-参考链接"><a href="#七-参考链接" class="headerlink" title="七 参考链接"></a>七 参考链接</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
  </entry>
  <entry>
    <title>ECMAScript 6入门-16_编程风格</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/16_%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="六-编程风格"><a href="#六-编程风格" class="headerlink" title="六 编程风格"></a>六 编程风格</h2><p style="text-align:right">2018.1.27 星期六 00:16</p><br>P235-P244<br>多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的avaScript风格规范。<br><br>### 6.1 块级作用域<br>#### 1 let取代var<br>1. 上面代码如果用var替代let，<strong>实际上就声明了一个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效</strong>，var命令做不到这一点。<br>2. var命令存在变量提升效用，let命令没有这个问题。<strong>违反了变量先声明后使用的原则。</strong><br><br>#### 2 全局常量和线程安全<br>    // bad<br>    var a = 1, b = 2, c = 3;<br>    // good<br>    const a = 1;<br>    const b = 2;<br>    const c = 3;<br>    // best<br>    const [a, b, c] = [1, 2, 3];<br>1. 在let和const之间，<strong>建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算</strong>。<br>2. const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br><br>所有的函数都应该设置为常量。<br>let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。<br><br>#### 3 严格模式<br>V8引擎只在严格模式之下，支持let和const。结合前两点，这实际上意味着，将来所有的编程都是针对严<br>格模式的。<br><br>### 6.2 字符串<br>    // bad<br>    const a = “foobar”;<br>    const b = ‘foo’ + a + ‘bar’;<br>    // acceptable<br>    const c = <code>foobar</code>;<br>    // good<br>    const a  = ‘foobar’;<br>    const b = <code>foo${a}bar</code>;<br>    const c = ‘foobar’;<br>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。<br>### 6.3 解构赋值<br>1. 使用数组成员对变量赋值，优先使用解构赋值。<br><br>        const arr = [1, 2, 3, 4];<br>        // bad<br>        const first = arr[0];<br>        const second = arr[1];<br>        // good<br>        const [first, second] = arr;<br>2. 函数的参数如果是对象的成员，优先使用解构赋值。<br><br>        // bad<br>        function getFullName(user) {<br>            const firstName = user.firstName;<br>            const lastName = user.lastName;<br>        }<br>        // good<br>        function getFullName(obj) {<br>            const { firstName, lastName } = obj;<br>        }<br>        // best<br>        function getFullName({ firstName, lastName }) {<br>        }<br>        $_PROBLEM:不明白，需要参考函数部分<br>3. 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。<br><br>        // bad<br>        function processInput(input) {<br>            return [left, right, top, bottom];<br>        }<br>        // good<br>        function processInput(input) {<br>            return { left, right, top, bottom };<br>        }<br>        const { left, right } = processInput(input);<br>### 6.4 对象<br>1. 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。<br>2. 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。<br><br>        // bad<br>        const a = {};<br>        a.x = 3;<br>        // if reshape unavoidable<br>        const a = {};<br>        Object.assign(a, { x: 3 });<br>        // good<br>        const a = { x: null };<br>        a.x = 3;<br>3. 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。<br><br>        // bad<br>        const obj = {<br>            id: 5,<br>            name: ‘San Francisco’,<br>        };<br>        obj[getKey(‘enabled’)] = true;<br>        // good<br>        const obj = {<br>             id: 5,<br>             name: ‘San Francisco’,<br>            [getKey(‘enabled’)]: true,<br>        };<br>4. 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。<br><br>        var ref = ‘some value’;<br>        // bad<br>        const atom = {<br>            ref: ref,<br>            value: 1,<br>            addValue: function (value) {<br>                return atom.value + value;<br>            },<br>        };<br>        // good<br>        const atom = {<br>            ref,<br>            value: 1,<br>            addValue(value) {<br>                return atom.value + value;<br>            },<br>        };<br>### 6.5 数组<br>1. 使用扩展运算符（…）拷贝数组。<br><br>        // bad<br>        const len = items.length;<br>        const itemsCopy = [];<br>        let i;<br>            for (i = 0; i &lt; len; i++) {<br>            itemsCopy[i] = items[i];<br>        }<br>        // good<br>        const itemsCopy = […items];<br>2. 使用Array.from方法，将类似数组的对象转为数组。<br><br>        const foo = document.querySelectorAll(‘.foo’);<br>        const nodes = Array.from(foo);<br>### 6.6 函数<br>1. 立即执行函数可以写成箭头函数的形式。<br><br>        (() =&gt; {<br>            console.log(‘Welcome to the Internet.’);<br>        })();<br>2. 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。<br><br>        // bad<br>        [1, 2, 3].map(function (x) {<br>            return x <em> x;<br>        });<br>        // good<br>        [1, 2, 3].map((x) =&gt; {<br>            return x </em> x;<br>        });<br>3. 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。<br><br>        // bad<br>        const self = this;<br>        const boundMethod = function(…params) {<br>            return method.apply(self, params);<br>        }<br>        // acceptable<br>        const boundMethod = method.bind(this);<br>        // best<br>        const boundMethod = (…params) =&gt; method.apply(this, params);<br>4. 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。<br><br>        // bad<br>        function divide(a, b, option = false ) {<br>        }<br>        // good<br>        function divide(a, b, { option = false } = {}) {<br>        }<br>4. 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。<br><br>        // bad<br>        function concatenateAll() {<br>            const args = Array.prototype.slice.call(arguments);<br>            return args.join(‘’);<br>        }<br>        // good<br>        function concatenateAll(…args) {<br>            return args.join(‘’);<br>        }<br>5. 使用默认值语法设置函数参数的默认值。<br><br>        // bad<br>        function handleThings(opts) {<br>            opts = opts || {};<br>        }<br>        // good<br>        function handleThings(opts = {}) {<br>            // …<br>        }<br>### 6.7 Map结构<br>    let map = new Map(arr);<br>    for (let key of map.keys()) {<br>        console.log(key);<br>    }<br>    for (let value of map.values()) {<br>        console.log(value);<br>    }<br>    for (let item of map.entries()) {<br>        console.log(item[0], item[1]);<br>    }<br>注意区分Object和Map，只有模拟实体对象时，才使用Object。<strong>如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制</strong>。<br><br>### 6.8 Class<br>1. 总是用class，取代需要prototype操作。因为class的写法更简洁，更易于理解。<br><br>        // bad<br>        function Queue(contents = []) {<br>            this._queue = […contents];<br>        }<br>        Queue.prototype.pop = function() {<br>            const value = this._queue[0];<br>            this._queue.splice(0, 1);<br>            return value;<br>        }<br>        // good<br>        class Queue {<br>            constructor(contents = []) {<br>                this._queue = […contents];<br>            }<br>            pop() {<br>                const value = this._queue[0];<br>                this._queue.splice(0, 1);<br>                return value;<br>            }<br>        }<br>2. 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。<br><br>        // bad<br>        const inherits = require(‘inherits’);<br>        function PeekableQueue(contents) {<br>            Queue.apply(this, contents);<br>        }<br>        inherits(PeekableQueue, Queue);<br>            PeekableQueue.prototype.peek = function() {<br>            return this._queue[0];<br>        }<br>        // good<br>        class PeekableQueue extends Queue {<br>            peek() {<br>                return this._queue[0];<br>            }<br>        }<br>### 6.9 模块<br>1. 首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。<br><br>        // bad<br>        const moduleA = require(‘moduleA’);<br>        const func1 = moduleA.func1;<br>        const func2 = moduleA.func2;<br>        // good<br>        import { func1, func2 } from ‘moduleA’;<br>2. 使用export取代module.exports。<br><br>        // commonJS的写法<br>        var React = require(‘react’);<br>        var Breadcrumbs = React.createClass({<br>            render() {<br>                return <nav>;<br>            }<br>        });<br>        module.exports = Breadcrumbs;<br>        // ES6的写法<br>        import React from ‘react’;<br>        const Breadcrumbs = React.createClass({<br>            render() {<br>                return <nav>;<br>            }<br>        });<br>        export default Breadcrumbs<br>4. 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。<br>$_PROBLEM:有一个默认输出是什么意义，如果不想有一个默认输出呢；<br>$_ANSWER:模块化，应该都是细化的，和之前common.js的引入方式不同了<br><br>        // bad<br>        import * as myObject ‘./importModule’;<br>        // good<br>        import myObject from ‘./importModule’;<br>5. 如果模块默认输出一个函数，函数名的首字母应该小写。<br><br>        function makeStyleGuide() {<br>        }<br>        export default makeStyleGuide;<br>6. 如果模块默认输出一个对象，对象名的首字母应该大写。<br><br>        const StyleGuide = {<br>            es6: {<br>            }<br>        };<br>        export default StyleGuide;<br><p style="text-align:right">2018.</p>

<p>读后总结： </p>
<ol>
<li>都是平时书写中就应该实现的细节</li>
</ol>
</nav></nav>]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6入门-15_Module</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/15_Module/</url>
    <content><![CDATA[<h2 id="五-Module"><a href="#五-Module" class="headerlink" title=".五 Module"></a>.五 Module</h2><p style="text-align:right">2018.1.26 星期五 22:43</p><br>p226-P233<br><br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。<br><br><strong>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</strong><br>0. CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 <code>var { stat, exists, readFile } = require(&#39;fs&#39;);</code><br>1. ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br><code>import { stat, exists, readFile } from &#39;fs&#39;;</code><br><br><strong>所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。</strong><br><br>### 5.1 export命令<br>0. 模块功能主要由两个命令构成：export和import。<br>1. export命令用于用户自定义模块，规定对外接口；<br>import命令用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突。<br>2. ES6允许将独立的JS文件作为模块，也就是说，允许一个JavaScript脚本文件调用另一个脚本文件。该文件<br>内部的所有变量，外部无法获取，必须使用export关键字输出变量。<br><br>.<br><br>    // profile.js<br>    export var firstName = ‘Michael’;<br>    export var lastName = ‘Jackson’;<br>    export var year = 1958;<br>    // better<br>    export {firstName, lastName, year};<br>### 5.2 import命令<br>1. import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。<br><br>        // main.js<br>        import {firstName, lastName, year} from ‘./profile’;<br>        function sfirsetHeader(element) {<br>            element.textContent = firstName + ‘ ‘ + lastName;<br>        }<br>2. 如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名。<br><br>        import { lastName as surname } from ‘./profile’;<br>3. ES6支持多重加载，即所加载的模块中又加载其他模块。<br><br>        import { Vehicle } from ‘./Vehicle’;<br>        class Car extends Vehicle {<br>            move () {<br>                console.log(this.name + ‘ is spinning wheels…’)<br>            }<br>        }<br>        export { Car }<br>4. 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。<br><br>        export { es6 as default } from ‘./someModule’;<br>        // 等同于<br>        import { es6 } from ‘./someModule’;<br>        export default es6;<br>    export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，h应该采用标准写法。<br>### 5.3 模块的整体输入<br>    // circle.js<br>    export function area(radius) {<br>        return Math.PI <em> radius </em> radius;<br>    }<br>    export function circumference(radius) {<br>        return 2 <em> Math.PI </em> radius;<br>    }<br>    // main.js<br>    import { area, circumference } from ‘circle’;<br>    console.log(“圆面积：” + area(4));<br>    console.log(“圆周长：” + circumference(14));<br>上面写法是逐一指定要输入的方法。另一种写法是整体输入。<br><br>        import <em> as circle from ‘circle’;<br>        console.log(“圆面积：” + circle.area(4));<br>        console.log(“圆周长：” + circle.circumference(14));<br>### 5.4 module命令<br>    // main.js<br>    module circle from ‘circle’;<br>    console.log(“圆面积：” + circle.area(4));<br>    console.log(“圆周长：” + circle.circumference(14));<br>module命令可以取代import语句，达到整体输入模块的作用。  
</em>module命令后面跟一个变量，表示输入的模块定义在该变量上。<em><br>### 5.5 export default命令<br>1. 代码是一个模块文件 export-default.js ，它的默认输出是一个函数。<br><strong>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</strong><br><br>        // export-default.js<br>        export default function () {<br>            console.log(‘foo’);<br>        }<br>        // import-default.js<br>        import customName from ‘./export-default’;<br>        customName(); // ‘foo’<br>2. 用在非匿名函数前，也是可以的。<br><strong>foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</strong><br><br>        // export-default.js<br>        export default function foo() {<br>            console.log(‘foo’);<br>        }<br>        // 或者写成<br>        function foo() {<br>            console.log(‘foo’);<br>        }<br>        export default foo;<br>3. 比较一下默认输出和正常输出。<br><strong>第一组是使用 export default 时，对应的import语句不需要使用大括号；第二组是不使用 export default 时，对应的import语句需要使用大括号。</strong><br>        import crc32 from ‘crc32’;<br>        // 对应的输出<br>        export default function crc32(){}<br><br>        import { crc32 } from ‘crc32’;<br>        // 对应的输出<br>        export function crc32(){};<br><strong>显然，一个模块只能有一个默认输出，因此export deault 命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</strong><br>本质上， export default 就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所<br>以，下面的写法是有效的。<br><br>    // modules.js<br>    export default function (x, y) {<br>        return x </em> y;<br>    };<br>    // app.js<br>    import { default } from ‘modules’;<br>1. 有了 export default 命令，输入模块时就非常直观了，以输入jQuery模块为例。<br><br>        import $ from ‘jquery’;<br>2. 如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。<br><br>    import customName, { otherMethod } from ‘./export-default’;<br>3. 如果要输出默认的值，只需将值跟在 export default 之后即可。<br><br>        export default 42;<br>4. export default 也可以用来输出类。<br><br>        // MyClass.js<br>        export default class { … }<br>        // main.js<br>        import MyClass from ‘MyClass’<br>        let o = new MyClass();<br>### 5.6 模块的继承<br>1. 代码中的“export <em>”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。<br><br>        // circleplus.js<br>        export </em> from ‘circle’;<br>        export var e = 2.71828182846;<br>        export default function(x) {<br>            return Math.exp(x);<br>        }<br>2. 这时，也可以将circle的属性或方法，改名后再输出。<br>只输出circle模块的area方法，且将其改名为circleArea。<br><br>        // circleplus.js<br>        export { area as circleArea } from ‘circle’;<br>3. 加载上面模块的写法如下。<br><br>        // main.js<br>        module math from “circleplus”;<br>        import exp from “circleplus”;<br>        console.log(exp(math.pi));<br>### 5.7 ES6模块的转码<br>#### 1 ES6 module transpiler<br>#### 2 SystemJS<br><strong>$_EXCLUDE:</strong> 这两可能是过时的；因为用babel<br><br><p style="text-align:right">2018.1.26 23：59</p>

<p>读后总结： </p>
<ol>
<li>使用上想简单了，语法还是有限制的</li>
<li>Module的加入，改变了JS引入的方式，传统js文件的书写方式，要有一个大的改变；</li>
<li>包括类的定义和使用，比如定义一个Tab；不是构造函数了</li>
<li>结合今天webpack，传统的js库，需要pollfill引入</li>
</ol>
]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
        <category>ECMAScript6入门</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack_4-Guides</title>
    <url>/w3/pkg/webpack_4-guides/</url>
    <content><![CDATA[<!-- # 指南 -->
<p>cc and abstract.<br><a href="https://doc.webpack-china.org/guides/development/" target="_blank" rel="noopener">https://doc.webpack-china.org/guides/development/</a></p>
<p style="text-align:right">2018.1.25 星期四 14:42 </p>

<a id="more"></a>
<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><h3 id="1-1-前提条件"><a href="#1-1-前提条件" class="headerlink" title="1.1 前提条件"></a>1.1 前提条件</h3><h3 id="1-2-本地安装"><a href="#1-2-本地安装" class="headerlink" title="1.2 本地安装"></a>1.2 本地安装</h3><h3 id="1-3-全局安装"><a href="#1-3-全局安装" class="headerlink" title="1.3 全局安装"></a>1.3 全局安装</h3><h3 id="1-4-最新体验版本"><a href="#1-4-最新体验版本" class="headerlink" title="1.4 最新体验版本"></a>1.4 最新体验版本</h3><h2 id="二-起步"><a href="#二-起步" class="headerlink" title="二 起步"></a>二 起步</h2><h3 id="2-1-基本安装"><a href="#2-1-基本安装" class="headerlink" title="2.1 基本安装"></a>2.1 基本安装</h3><h3 id="2-2-创建一个bundle文件"><a href="#2-2-创建一个bundle文件" class="headerlink" title="2.2 创建一个bundle文件"></a>2.2 创建一个bundle文件</h3><h3 id="2-3-模块"><a href="#2-3-模块" class="headerlink" title="2.3 模块"></a>2.3 模块</h3><h3 id="2-4-使用一个配置文件"><a href="#2-4-使用一个配置文件" class="headerlink" title="2.4 使用一个配置文件"></a>2.4 使用一个配置文件</h3><h3 id="2-5-NPM脚本"><a href="#2-5-NPM脚本" class="headerlink" title="2.5 NPM脚本"></a>2.5 NPM脚本</h3><h3 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2.6 结论"></a>2.6 结论</h3><h2 id="三-管理资源"><a href="#三-管理资源" class="headerlink" title="三 管理资源"></a>三 管理资源</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><h3 id="3-2-加载CSS"><a href="#3-2-加载CSS" class="headerlink" title="3.2 加载CSS"></a>3.2 加载CSS</h3><h3 id="3-3-加载字体"><a href="#3-3-加载字体" class="headerlink" title="3.3 加载字体"></a>3.3 加载字体</h3><h3 id="3-4-加载数据"><a href="#3-4-加载数据" class="headerlink" title="3.4 加载数据"></a>3.4 加载数据</h3><h3 id="3-5-全局资源"><a href="#3-5-全局资源" class="headerlink" title="3.5 全局资源"></a>3.5 全局资源</h3><h3 id="3-6-回退处理"><a href="#3-6-回退处理" class="headerlink" title="3.6 回退处理"></a>3.6 回退处理</h3><h3 id="3-7-下一章节指南"><a href="#3-7-下一章节指南" class="headerlink" title="3.7 下一章节指南"></a>3.7 下一章节指南</h3><h3 id="3-8-延伸阅读"><a href="#3-8-延伸阅读" class="headerlink" title="3.8 延伸阅读"></a>3.8 延伸阅读</h3><h2 id="四-管理输出"><a href="#四-管理输出" class="headerlink" title="四 管理输出"></a>四 管理输出</h2><h3 id="4-1-预先准备"><a href="#4-1-预先准备" class="headerlink" title="4.1 预先准备"></a>4.1 预先准备</h3><h3 id="4-2-设定HtmlWebpackPlugin"><a href="#4-2-设定HtmlWebpackPlugin" class="headerlink" title="4.2 设定HtmlWebpackPlugin"></a>4.2 设定HtmlWebpackPlugin</h3><h3 id="4-3-清理-dist文件夹"><a href="#4-3-清理-dist文件夹" class="headerlink" title="4.3 清理/dist文件夹"></a>4.3 清理/dist文件夹</h3><h3 id="4-4-Manifest"><a href="#4-4-Manifest" class="headerlink" title="4.4 Manifest"></a>4.4 Manifest</h3><h3 id="4-5-结论"><a href="#4-5-结论" class="headerlink" title="4.5 结论"></a>4.5 结论</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>#### </p>
<h2 id="五-开发"><a href="#五-开发" class="headerlink" title="五 开发"></a>五 开发</h2><h3 id="5-1-使用source-map"><a href="#5-1-使用source-map" class="headerlink" title="5.1 使用source map"></a>5.1 使用source map</h3><h3 id="5-2-选择一个开发工具"><a href="#5-2-选择一个开发工具" class="headerlink" title="5.2 选择一个开发工具"></a>5.2 选择一个开发工具</h3><h3 id="5-3-使用观察模式"><a href="#5-3-使用观察模式" class="headerlink" title="5.3 使用观察模式"></a>5.3 使用观察模式</h3><h3 id="5-4-使用-webpack-dev-server"><a href="#5-4-使用-webpack-dev-server" class="headerlink" title="5.4 使用 webpack-dev-server"></a>5.4 使用 webpack-dev-server</h3><h3 id="5-5-使用-Webpack-dev-middleware"><a href="#5-5-使用-Webpack-dev-middleware" class="headerlink" title="5.5 使用 Webpack-dev-middleware"></a>5.5 使用 Webpack-dev-middleware</h3><h3 id="5-6-调整文本编辑器"><a href="#5-6-调整文本编辑器" class="headerlink" title="5.6 调整文本编辑器"></a>5.6 调整文本编辑器</h3><h3 id="5-7-结论"><a href="#5-7-结论" class="headerlink" title="5.7 结论"></a>5.7 结论</h3><h2 id="六-模块热替换"><a href="#六-模块热替换" class="headerlink" title="六 模块热替换"></a>六 模块热替换</h2><h3 id="6-1-启用-HMR"><a href="#6-1-启用-HMR" class="headerlink" title="6.1 启用 HMR"></a>6.1 启用 HMR</h3><h3 id="6-2-通过Node-js-API"><a href="#6-2-通过Node-js-API" class="headerlink" title="6.2 通过Node.js API"></a>6.2 通过Node.js API</h3><h3 id="6-3-问题"><a href="#6-3-问题" class="headerlink" title="6.3 问题"></a>6.3 问题</h3><h3 id="6-4-HMR-修改样式表"><a href="#6-4-HMR-修改样式表" class="headerlink" title="6.4 HMR 修改样式表"></a>6.4 HMR 修改样式表</h3><h3 id="6-5-其他代码和框架"><a href="#6-5-其他代码和框架" class="headerlink" title="6.5 其他代码和框架"></a>6.5 其他代码和框架</h3><h2 id="七-Tree-Shaking"><a href="#七-Tree-Shaking" class="headerlink" title="七 Tree Shaking"></a>七 Tree Shaking</h2><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。</p>
<p>webpack 2 内置支持 ES2015 模块（别名 harmony modules），并能检测出未使用的模块导出。</p>
<h3 id="7-1-添加一个通用模块"><a href="#7-1-添加一个通用模块" class="headerlink" title="7.1 添加一个通用模块"></a>7.1 添加一个通用模块</h3><p>注意，上面的 unused harmony export square 注释。如果你看下面的代码，你会注意到 square 没有被导出，但是，它仍然被包含在 bundle 中。我们将在下一节中解决这个问题。</p>
<h3 id="7-2-精简输出"><a href="#7-2-精简输出" class="headerlink" title="7.2 精简输出"></a>7.2 精简输出</h3><p>UglifyJSPlugin</p>
<p>显然，现在整个 bundle 都已经被精简过，但是如果仔细观察，则不会看到 square 函数被引入，但会看到 cube 函数的修改版本（function r(e){return e<em>e</em>e}n.a=r）</p>
<h3 id="7-3-警告"><a href="#7-3-警告" class="headerlink" title="7.3 警告"></a>7.3 警告</h3><p>请注意，webpack 本身并不会执行 tree-shaking。它需要依赖于像 UglifyJS 这样的第三方工具来执行实际的未引用代码(dead code)删除工作。有些情况下，tree-shaking 可能不会生效。例如，考虑以下模块：<br>。。<br>一般来说，当一个工具不能保证某些特定的代码路径(path)不会导致副作用(side-effects)时，即使你确信它不应该存在生成的 bundle 中，但这个代码仍然会保留。常见的情况有：从第三方模块中调用一个函数，webpack 和/或 压缩工具(minifier)无法检查此模块；从第三方模块导入的函数被重新导出，等等。</p>
<h3 id="7-4-结论"><a href="#7-4-结论" class="headerlink" title="7.4 结论"></a>7.4 结论</h3><p>为了学会使用 tree shaking，你必须……</p>
<ul>
<li>使用 ES2015 模块语法（即 import 和 export）。</li>
<li>引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。</li>
</ul>
<h2 id="八-生产环境构建"><a href="#八-生产环境构建" class="headerlink" title="八 生产环境构建"></a>八 生产环境构建</h2><h3 id="8-1-配置"><a href="#8-1-配置" class="headerlink" title="8.1 配置"></a>8.1 配置</h3><p>开发环境(development)和生产环境(production)的构建目标差异很大。<strong>在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server</strong>。而<strong>在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间</strong>。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p>
<h3 id="8-2-NPM-Script"><a href="#8-2-NPM-Script" class="headerlink" title="8.2 NPM Script"></a>8.2 NPM Script</h3><h3 id="8-3-Minification"><a href="#8-3-Minification" class="headerlink" title="8.3 Minification"></a>8.3 Minification</h3><p>注意，虽然 UglifyJSPlugin 是代码压缩方面比较好的选择，但是还有一些其他可选择项。以下有几个同样很受欢迎的插件：</p>
<h3 id="8-4-source-map"><a href="#8-4-source-map" class="headerlink" title="8.4 source map"></a>8.4 source map</h3><p>我们鼓励你在<strong>生产环境中启用 source map，因为它们对调试源码(debug)和运行基准测试(benchmark tests)很有帮助</strong>。虽然有如此强大的功能，然而还是应该针对生成环境用途，选择一个构建快速的推荐配置（具体细节请查看 devtool）。对于本指南，我们将在生产环境中使用 source-map 选项，而不是我们在<strong>开发环境中用到的inline-source-map</strong>：</p>
<blockquote>
<p>避免在生产中使用 inline-<strong><em> 和 eval-</em></strong>，因为它们可以增加 bundle 大小，并降低整体性能。</p>
</blockquote>
<h3 id="8-5-指定环境"><a href="#8-5-指定环境" class="headerlink" title="8.5 指定环境"></a>8.5 指定环境</h3><p>许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。例如，当不处于生产环境中时，某些 library 为了使调试变得容易，可能会添加额外的日志记录(log)和测试(test)。其实，当使用 process.env.NODE_ENV === ‘production’ 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量：</p>
<p>如果你正在使用像 react 这样的 library，那么在添加此 DefinePlugin 插件后，你应该看到 bundle 大小显著下降。还要注意，任何位于 /src 的本地代码都可以关联到 process.env.NODE_ENV 环境变量，所以以下检查也是有效的：</p>
<pre><code>import { cube } from &apos;./math.js&apos;;
if (process.env.NODE_ENV !== &apos;production&apos;) {
    console.log(&apos;Looks like we are in development mode!&apos;);
}
</code></pre><h3 id="8-6-Split-CSS"><a href="#8-6-Split-CSS" class="headerlink" title="8.6 Split CSS"></a>8.6 Split CSS</h3><h3 id="8-7-CLI-替代选项"><a href="#8-7-CLI-替代选项" class="headerlink" title="8.7 CLI 替代选项"></a>8.7 CLI 替代选项</h3><h2 id="九-代码分离"><a href="#九-代码分离" class="headerlink" title="九 代码分离"></a>九 代码分离</h2><p>代码分离是 webpack 中最引人注目的特性之一。<strong>此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间</strong>。</p>
<p>有三种常用的代码分离方法：</p>
<ul>
<li>入口起点：使用 entry 配置手动地分离代码。</li>
<li>防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。</li>
<li>动态导入：通过模块的内联函数调用来分离代码。<h3 id="9-1-入口起点"><a href="#9-1-入口起点" class="headerlink" title="9.1 入口起点"></a>9.1 入口起点</h3>正如前面提到的，这种方法存在一些问题:</li>
</ul>
<ol>
<li>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>
<li>这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。<br>以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 ./src/index.js 中也引入过 lodash，这样就在两个 bundle 中造成重复引用。接着，我们通过使用 CommonsChunkPlugin 来移除重复的模块。<h3 id="9-2-防止重复"><a href="#9-2-防止重复" class="headerlink" title="9.2 防止重复"></a>9.2 防止重复</h3>CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 lodash 模块去除:</li>
</ol>
<p>这里我们使用 CommonsChunkPlugin 之后，现在应该可以看出，index.bundle.js 中已经移除了重复的依赖模块。需要注意的是，CommonsChunkPlugin 插件将 lodash 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。执行 npm run build 查看效果：</p>
<p>以下是由社区提供的，一些对于代码分离很有帮助的插件和 loaders：</p>
<ul>
<li>ExtractTextPlugin: 用于将 CSS 从主应用程序中分离。</li>
<li>bundle-loader: 用于分离代码和延迟加载生成的 bundle。</li>
<li>promise-loader: 类似于 bundle-loader ，但是使用的是 promises。</li>
<li>CommonsChunkPlugin 插件还可以通过使用显式的 vendor chunks 功能，从应用程序代码中分离 vendor 模块。<h3 id="9-3-动态导入"><a href="#9-3-动态导入" class="headerlink" title="9.3 动态导入"></a>9.3 动态导入</h3>$_MORE:和ES import，async有关<h3 id="9-4-bundle分析"><a href="#9-4-bundle分析" class="headerlink" title="9.4 bundle分析"></a>9.4 bundle分析</h3><h3 id="9-5-下一步"><a href="#9-5-下一步" class="headerlink" title="9.5 下一步"></a>9.5 下一步</h3></li>
</ul>
<h2 id="零-懒加载"><a href="#零-懒加载" class="headerlink" title="零 懒加载"></a>零 懒加载</h2><p>实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块</p>
<h3 id="0-1-示例"><a href="#0-1-示例" class="headerlink" title="0.1 示例"></a>0.1 示例</h3><pre><code>button.onclick = e =&gt; import(/* webpackChunkName: &quot;print&quot; */ &apos;./print&apos;).then(module =&gt; {
    var print = module.default;
    print();
});
</code></pre><blockquote>
<p>注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。</p>
</blockquote>
<h3 id="0-2-框架"><a href="#0-2-框架" class="headerlink" title="0.2 框架"></a>0.2 框架</h3><p>许多框架和类库对于如何用它们自己的方式来实现（懒加载）都有自己的建议。这里有一些例子：</p>
<ul>
<li>React: Code Splitting and Lazy Loading<br>*Vue: Lazy Load in Vue using Webpack’s code splitting</li>
</ul>
<h2 id="一-缓存"><a href="#一-缓存" class="headerlink" title="一 缓存"></a>一 缓存</h2><h3 id="1-1-输出文件的文件名"><a href="#1-1-输出文件的文件名" class="headerlink" title="1.1 输出文件的文件名"></a>1.1 输出文件的文件名</h3><p>可以看到，bundle 的名称是它内容（通过 hash）的映射。如果我们不做修改，然后再次运行构建，我们的文件名按照期望，依然保持不变。然而，如果我们再次运行，可能会发现情况并非如此：</p>
<p>这也是因为 webpack 在入口 chunk 中，包含了某些样板(boilerplate)，特别是 runtime 和 manifest。（译注：样板(boilerplate)指 webpack 运行时的引导代码）</p>
<h3 id="1-2-提取模板"><a href="#1-2-提取模板" class="headerlink" title="1.2 提取模板"></a>1.2 提取模板</h3><p>就像我们之前从代码分离了解到的，CommonsChunkPlugin 可以用于将模块分离到单独的文件中。然而 <strong>CommonsChunkPlugin 有一个较少有人知道的功能是，能够在每次修改后的构建结果中，将 webpack 的样板(boilerplate)和 manifest 提取出来。通过指定 entry 配置中未用到的名称</strong>，此插件会自动将我们需要的内容提取到单独的包中：</p>
<pre><code>const path = require(&apos;path&apos;);
const webpack = require(&apos;webpack&apos;);
const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
    entry: &apos;./src/index.js&apos;,
    plugins: [
        new CleanWebpackPlugin([&apos;dist&apos;]),
        new HtmlWebpackPlugin({
            title: &apos;Caching&apos;
        }),
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;vender&apos;
        }),
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;manifest&apos;
        })
    ],
    output: {
        filename: &apos;[name].[chunkhash].js&apos;,
        path: path.resolve(__dirname, &apos;dist&apos;)
    }
};
</code></pre><p>将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。<strong>这可以通过使用新的 entry(入口) 起点，以及再额外配置一个 CommonsChunkPlugin 实例的组合方式来实现</strong>：    </p>
<blockquote>
<p>注意，引入顺序在这里很重要。CommonsChunkPlugin 的 ‘vendor’ 实例，必须在 ‘manifest’ 实例之前引入。</p>
</blockquote>
<h3 id="1-3-模块标识符"><a href="#1-3-模块标识符" class="headerlink" title="1.3 模块标识符"></a>1.3 模块标识符</h3><p>再次运行构建，然后我们期望的是，只有 main bundle 的 hash 发生变化，然而……</p>
<p>……我们可以看到这三个文件的 hash 都变化了。这是因为每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</p>
<ul>
<li>main bundle 会随着自身的新增内容的修改，而发生变化。</li>
<li>vendor bundle 会随着自身的 module.id 的修改，而发生变化。</li>
<li>manifest bundle 会因为当前包含一个新模块的引用，而发生变化。<br>第一个和最后一个都是符合预期的行为 – 而 vendor 的 hash 发生变化是我们要修复的。幸运的是，可以使用两个插件来解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建：<h3 id="1-4-结论"><a href="#1-4-结论" class="headerlink" title="1.4 结论"></a>1.4 结论</h3><h3 id="1-5-译注"><a href="#1-5-译注" class="headerlink" title="1.5 译注"></a>1.5 译注</h3></li>
</ul>
<h2 id="二-创建Library"><a href="#二-创建Library" class="headerlink" title="二 创建Library"></a>二 创建Library</h2><h3 id="2-1-创建一个library"><a href="#2-1-创建一个library" class="headerlink" title="2.1 创建一个library"></a>2.1 创建一个library</h3><h3 id="2-2-基本配置"><a href="#2-2-基本配置" class="headerlink" title="2.2 基本配置"></a>2.2 基本配置</h3><h3 id="2-3-外部化lodash"><a href="#2-3-外部化lodash" class="headerlink" title="2.3 外部化lodash"></a>2.3 外部化lodash</h3><h3 id="2-4-外部扩展的限制"><a href="#2-4-外部扩展的限制" class="headerlink" title="2.4 外部扩展的限制"></a>2.4 外部扩展的限制</h3><h3 id="2-5-暴露library"><a href="#2-5-暴露library" class="headerlink" title="2.5 暴露library"></a>2.5 暴露library</h3><h3 id="2-6-最终步骤"><a href="#2-6-最终步骤" class="headerlink" title="2.6 最终步骤"></a>2.6 最终步骤</h3><p>$_EXCLUDE:没有创建库，所以无法配置；目前不创建库</p>
<h2 id="三-Shimming"><a href="#三-Shimming" class="headerlink" title="三 Shimming"></a>三 Shimming</h2><p style="text-align:right">2018.2.9 星期五 18:30</p>

<p>webpack 编译器(compiler)能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。<strong>然而，一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量</strong>。这些“不符合规范的模块”就是 shimming 发挥作用的地方。</p>
<blockquote>
<p>我们不推荐使用全局的东西！在 webpack 背后的整个概念是让前端开发更加模块化。也就是说，需要编写具有良好的封闭性(well contained)、彼此隔离的模块，以及不要依赖于那些隐含的依赖模块（例如，全局变量）。请只在必要的时候才使用本文所述的这些特性。</p>
</blockquote>
<p><strong>shimming 另外一个使用场景就是，当你希望 polyfill 浏览器功能以支持更多用户时</strong>。在这种情况下，你可能只想要将这些 polyfills 提供给到需要修补(patch)的浏览器（也就是实现按需加载）。</p>
<p>下面的文章将向我们展示这两种用例。</p>
<h3 id="3-1-shimming全局变量"><a href="#3-1-shimming全局变量" class="headerlink" title="3.1 shimming全局变量"></a>3.1 shimming全局变量</h3><pre><code>plugins: [
 new webpack.ProvidePlugin({
    _: &apos;lodash&apos;,
    join: [&apos;lodash&apos;, &apos;join&apos;]
 })
</code></pre><p>   ]<br>我们还可以使用 ProvidePlugin 暴露某个模块中单个导出值，只需通过一个“数组路径”进行配置   </p>
<h3 id="3-2-细粒度shimming"><a href="#3-2-细粒度shimming" class="headerlink" title="3.2 细粒度shimming"></a>3.2 细粒度shimming</h3><p>一些传统的模块依赖的 this 指向的是 window 对象<br>    module: {<br>         rules: [<br>           {<br>             test: require.resolve(‘index.js’),<br>             use: ‘imports-loader?this=&gt;window’<br>           }<br>         ]<br>    },<br><strong>$_PS:</strong> shimming的第一种情况。如，bootstrap需要jQuey，也是这种方式    </p>
<h3 id="3-3-全局exports"><a href="#3-3-全局exports" class="headerlink" title="3.3 全局exports"></a>3.3 全局exports</h3><p>你可能从来没有在自己的源码中做过这些事情，<strong>但是你也许遇到过一个老旧的库(library)，和上面所展示的代码类似。在这个用例中，我们可以使用 exports-loader，将一个全局变量作为一个普通的模块来导出</strong>。例如，为了将 file 导出为 file 以及将 helpers.parse 导出为 parse，做如下调整：</p>
<pre><code>module: {
     rules: [
       {
            test: require.resolve(&apos;globals.js&apos;),
            use: &apos;exports-loader?file,parse=helpers.parse&apos;
       }
     ]
},
</code></pre><p><strong>$_PS:</strong> 还是第一种情况。比如jQuery1.11.3，或者其他老旧库，将一个全局变量作为一个普通的模块来导出    </p>
<h3 id="3-4-加载polyfills"><a href="#3-4-加载polyfills" class="headerlink" title="3.4 加载polyfills"></a>3.4 加载polyfills</h3><p>有很多方法来载入 polyfills。例如，要引入 babel-polyfill 我们只需要如下操作：</p>
<pre><code>npm install --save babel-polyfill
</code></pre><p>然后使用 import 将其添加到我们的主 bundle 文件：</p>
<blockquote>
<p>请注意，我们没有将 import 绑定到变量。这是因为只需在基础代码(code base)之外，再额外执行 polyfills，这样我们就可以假定代码中已经具有某些原生功能。</p>
</blockquote>
<p>polyfills 虽然是一种模块引入方式，<strong>但是并不推荐在主 bundle 中引入 polyfills</strong>，因为这不利于具备这些模块功能的现代浏览器用户，会使他们下载体积很大、但却不需要的脚本文件。</p>
<p>让我们把 import 放入一个新文件，并加入 whatwg-fetch polyfill：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> modernBrowser = (</span></span><br><span class="line"><span class="javascript">        <span class="string">'fetch'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp;</span></span><br><span class="line"><span class="javascript">        <span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span></span></span><br><span class="line">    );</span><br><span class="line">    if ( !modernBrowser ) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> scriptElement = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        scriptElement.async = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        scriptElement.src = <span class="string">'/polyfills.bundle.js'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.head.appendChild(scriptElement);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-深度优化"><a href="#3-5-深度优化" class="headerlink" title="3.5 深度优化"></a>3.5 深度优化</h3><p>babel-preset-env package 使用 browserslist 来转译那些你浏览器中不支持的特性。这里预设了 useBuiltIns 选项，默认值是 false，<strong>能将你的全局 babel-polyfill 导入方式，改进为更细粒度的 import 格式</strong>：</p>
<pre><code>import &apos;core-js/modules/es7.string.pad-start&apos;;
import &apos;core-js/modules/es7.string.pad-end&apos;;
import &apos;core-js/modules/web.timers&apos;;
import &apos;core-js/modules/web.immediate&apos;;
import &apos;core-js/modules/web.dom.iterable&apos;;
</code></pre><p><strong>$_PS:</strong> 开发库的时候使用。项目中还有一些API需要调用，自定义的对象，全局对象的API就不可以使用了<code>Array.prototype.forEach</code>。开发中用上面babel-loader,  useBuiltIns 设为true </p>
<h3 id="3-6-Node内置"><a href="#3-6-Node内置" class="headerlink" title="3.6 Node内置"></a>3.6 Node内置</h3><p>像 process 这种 Node 内置模块，能直接根据配置文件(configuration file)进行正确的 polyfills，且不需要任何特定的 loaders 或者 plugins。查看 node 配置页面获取更多信息。</p>
<h3 id="3-7-其他工具"><a href="#3-7-其他工具" class="headerlink" title="3.7 其他工具"></a>3.7 其他工具</h3><p>还有一些其他的工具能够帮助我们处理这些老旧的模块。</p>
<ol>
<li>script-loader 会在全局上下文中对代码进行取值，类似于通过一个 script 标签引入脚本。在这种模式下，每一个标准的库(library)都应该能正常运行。require, module 等的取值是 undefined。<blockquote>
<p>当使用 script-loader 时，模块将转化为字符串，然后添加到 bundle 中。它不会被 webpack 压缩，所以你应该选择一个 min 版本。同时，使用此 loader 将不会有 devtool 的支持。</p>
</blockquote>
</li>
<li><p>这些老旧的模块如果没有 AMD/CommonJS 规范版本，<strong>但你也想将他们加入 dist 文件，你可以使用 noParse 来标识出这个模块。这样就能使 webpack 将引入这些模块，但是不进行转化(parse)，以及不解析(resolve) require() 和 import 语句。这个实践将提升构建性能</strong>。</p>
<blockquote>
<p>例如 ProvidePlugin，任何需要 AST 的功能，都无法正常运行。  </p>
</blockquote>
</li>
<li><p>最后，有一些模块支持不同的模块格式，比如 AMD 规范、CommonJS 规范和遗留模块(legacy)。在大多数情况下，他们首先检查define，然后使用一些古怪的代码来导出一些属性。在这些情况下，可以通过imports-loader设置 define=&gt;false 来强制 CommonJS 路径。<br><strong>$_PS:</strong> 什么鬼，imports-loader之前不是用了吗</p>
</li>
</ol>
<blockquote>
<p>译者注：shim 是一个库(library)，它将一个新的 API 引入到一个旧的环境中，而且仅靠旧的环境中已有的手段实现。polyfill 就是一个用在浏览器 API 上的 shim。我们通常的做法是先检查当前浏览器是否支持某个 API，如果不支持的话就加载对应的 polyfill。然后新旧浏览器就都可以使用这个 API 了。</p>
</blockquote>
<p><strong>$__PS:</strong> 下面这些plugin,loader,configuration 不是一个概念，注意使用</p>
<ol>
<li>ProvidePlugin：把模块作为应用程序中的一个全局变量。</li>
<li>imports-loader: 模块需要某个依赖时使用，比如this指向window，bootstrap需要jQuery</li>
<li>exports-loader：将一个全局变量作为一个普通的模块来导出,需要import</li>
<li>expose-loader: 暴露一个全局变量，不需要import。注意和ProvidePlugin的区别:？？ProvidePlugin可以暴露jQuery1.11.3的全局变量吗<blockquote>
<p>The expose loader adds modules to the global object. This is useful for debugging, or supporting libraries that depend on libraries in globals.</p>
</blockquote>
</li>
<li>script-loader：估计和expose差不多</li>
<li>noParse:expose,script，还有exports的模块应该可以用module.noParse配置<blockquote>
<p>noParse:防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</p>
</blockquote>
</li>
<li><p>module.externals :有人说不符合webpack模块管理了？？</p>
<blockquote>
<p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。<br>例如，从 CDN 引入 jQuery，而不是把它打包：</p>
</blockquote>
</li>
<li><p>DllPlugin：？？如果不用externals排除，用该方法剥离不经常改动的第三方依赖</p>
<blockquote>
<p>使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。<br>DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。</p>
</blockquote>
</li>
<li>CommonsChunkPlugin：提取公共子模块，提供缓存。属于代码分离–防止重复。公共模块提出来，利用缓存，没有修改的部分，hashID不会更改<blockquote>
<p>CommonsChunkPlugin，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p>
</blockquote>
</li>
<li>ExtractTextPlugin:也属于代码分离，用于将 CSS 从主应用程序中分离</li>
<li>UglifyJSPlugin:Tree Shaking–精简输出</li>
</ol>
<p style="text-align:right">2.9 20:46 </p>


<h2 id="四-TypeScript"><a href="#四-TypeScript" class="headerlink" title="四 TypeScript"></a>四 TypeScript</h2><h3 id="4-1-基础安装"><a href="#4-1-基础安装" class="headerlink" title="4.1 基础安装"></a>4.1 基础安装</h3><h3 id="4-2-Loader"><a href="#4-2-Loader" class="headerlink" title="4.2 Loader"></a>4.2 Loader</h3><h3 id="4-3-source-map"><a href="#4-3-source-map" class="headerlink" title="4.3 source map"></a>4.3 source map</h3><h3 id="4-4-使用第三方库"><a href="#4-4-使用第三方库" class="headerlink" title="4.4 使用第三方库"></a>4.4 使用第三方库</h3><h3 id="4-5-导入其他资源"><a href="#4-5-导入其他资源" class="headerlink" title="4.5 导入其他资源"></a>4.5 导入其他资源</h3><h3 id="4-6-构建性能"><a href="#4-6-构建性能" class="headerlink" title="4.6 构建性能"></a>4.6 构建性能</h3><p>$_EXCLUDE:typescript语法没有用到</p>
<h2 id="五-渐进式网络应用程序"><a href="#五-渐进式网络应用程序" class="headerlink" title="五 渐进式网络应用程序"></a>五 渐进式网络应用程序</h2><h3 id="5-1-现在我们并没有离线环境"><a href="#5-1-现在我们并没有离线环境" class="headerlink" title="5.1 现在我们并没有离线环境"></a>5.1 现在我们并没有离线环境</h3><h3 id="5-2-天津Workbox"><a href="#5-2-天津Workbox" class="headerlink" title="5.2 天津Workbox"></a>5.2 天津Workbox</h3><h3 id="5-3-注册我们的Service-Worker"><a href="#5-3-注册我们的Service-Worker" class="headerlink" title="5.3 注册我们的Service Worker"></a>5.3 注册我们的Service Worker</h3><h3 id="5-4-结论"><a href="#5-4-结论" class="headerlink" title="5.4 结论"></a>5.4 结论</h3><p>$_EXCLUDE:PWA，最后构建</p>
<h2 id="六-迁移到新版本"><a href="#六-迁移到新版本" class="headerlink" title="六 迁移到新版本"></a>六 迁移到新版本</h2><p>$_EXCLUDE:没有迁移</p>
<h2 id="七-使用环境变量"><a href="#七-使用环境变量" class="headerlink" title="七 使用环境变量"></a>七 使用环境变量</h2><p>$_PROBLEM:没实际实例，看不到目的，所以操作不明</p>
<h2 id="八-构建性能"><a href="#八-构建性能" class="headerlink" title="八 构建性能"></a>八 构建性能</h2><h3 id="8-1-常规"><a href="#8-1-常规" class="headerlink" title="8.1 常规"></a>8.1 常规</h3><h4 id="1-保持版本最新"><a href="#1-保持版本最新" class="headerlink" title="1 保持版本最新"></a>1 保持版本最新</h4><h4 id="2-Loaders"><a href="#2-Loaders" class="headerlink" title="2 Loaders"></a>2 Loaders</h4><h4 id="3-Bootstrap"><a href="#3-Bootstrap" class="headerlink" title="3 Bootstrap"></a>3 Bootstrap</h4><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4 解析"></a>4 解析</h4><h4 id="5-Dlls"><a href="#5-Dlls" class="headerlink" title="5 Dlls"></a>5 Dlls</h4><h4 id="6-Samller-Faster"><a href="#6-Samller-Faster" class="headerlink" title="6 Samller = Faster"></a>6 Samller = Faster</h4><h4 id="7-Worker-Pool"><a href="#7-Worker-Pool" class="headerlink" title="7 Worker Pool"></a>7 Worker Pool</h4><h4 id="8-持久化缓存"><a href="#8-持久化缓存" class="headerlink" title="8 持久化缓存"></a>8 持久化缓存</h4><h4 id="9-自定义-plugins-loaders"><a href="#9-自定义-plugins-loaders" class="headerlink" title="9 自定义 plugins/loaders"></a>9 自定义 plugins/loaders</h4><h3 id="8-2-Development"><a href="#8-2-Development" class="headerlink" title="8.2 Development"></a>8.2 Development</h3><h4 id="1-增量编译"><a href="#1-增量编译" class="headerlink" title="1 增量编译"></a>1 增量编译</h4><h4 id="2-在内存中编译"><a href="#2-在内存中编译" class="headerlink" title="2 在内存中编译"></a>2 在内存中编译</h4><h4 id="3-Devtool"><a href="#3-Devtool" class="headerlink" title="3 Devtool"></a>3 Devtool</h4><h4 id="4-避免在生产环境下才会用"><a href="#4-避免在生产环境下才会用" class="headerlink" title="4 避免在生产环境下才会用"></a>4 避免在生产环境下才会用</h4><h4 id="5-最小化入口chunk"><a href="#5-最小化入口chunk" class="headerlink" title="5 最小化入口chunk"></a>5 最小化入口chunk</h4><h3 id="8-3-Production"><a href="#8-3-Production" class="headerlink" title="8.3 Production"></a>8.3 Production</h3><h4 id="1-多个编译时"><a href="#1-多个编译时" class="headerlink" title="1 多个编译时"></a>1 多个编译时</h4><h4 id="2-Source-Maps"><a href="#2-Source-Maps" class="headerlink" title="2 Source Maps"></a>2 Source Maps</h4><h2 id="8-4-工具相关问题"><a href="#8-4-工具相关问题" class="headerlink" title="8.4 工具相关问题"></a>8.4 工具相关问题</h2><h4 id="1-Babel"><a href="#1-Babel" class="headerlink" title="1 Babel"></a>1 Babel</h4><h4 id="2-Typescript"><a href="#2-Typescript" class="headerlink" title="2 Typescript"></a>2 Typescript</h4><h4 id="3-Sass"><a href="#3-Sass" class="headerlink" title="3 Sass"></a>3 Sass</h4><h2 id="九-开发-Vagrant"><a href="#九-开发-Vagrant" class="headerlink" title="九 开发-Vagrant"></a>九 开发-Vagrant</h2><h3 id="9-1-项目配置"><a href="#9-1-项目配置" class="headerlink" title="9.1 项目配置"></a>9.1 项目配置</h3><h3 id="9-2-启动服务器"><a href="#9-2-启动服务器" class="headerlink" title="9.2 启动服务器"></a>9.2 启动服务器</h3><h3 id="9-3-配合nginx的高级用法"><a href="#9-3-配合nginx的高级用法" class="headerlink" title="9.3 配合nginx的高级用法"></a>9.3 配合nginx的高级用法</h3><h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><p>$_EXCLUDE:不需要</p>
<h2 id="零-管理依赖"><a href="#零-管理依赖" class="headerlink" title="零 管理依赖"></a>零 管理依赖</h2><h3 id="0-1-带表达式的require语句"><a href="#0-1-带表达式的require语句" class="headerlink" title="0.1 带表达式的require语句"></a>0.1 带表达式的require语句</h3><h3 id="0-2-require-context"><a href="#0-2-require-context" class="headerlink" title="0.2 require.context"></a>0.2 require.context</h3><h3 id="0-3-上下文模块"><a href="#0-3-上下文模块" class="headerlink" title="0.3 上下文模块"></a>0.3 上下文模块</h3><p>$_MORE:不明白</p>
<h2 id="一-公共路径-Public-Path"><a href="#一-公共路径-Public-Path" class="headerlink" title="一 公共路径(Public Path)"></a>一 公共路径(Public Path)</h2><p>webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径。它被称为公共路径(publicPath)。</p>
<h3 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h3><h4 id="1-在构建项目时设置路径值"><a href="#1-在构建项目时设置路径值" class="headerlink" title="1 在构建项目时设置路径值"></a>1 在构建项目时设置路径值</h4><p>在开发模式中，我们通常有一个 assets/ 文件夹，它往往存放在和首页一个级别的目录下。这样是挺方便；但是如果在生产环境下，你想把这些静态文件统一使用CDN加载，那该怎么办？</p>
<p>想要解决这个问题，你可以使用有着悠久历史的环境变量。比如说，我们设置了一个名为 ASSET_PATH 的变量：</p>
<pre><code>import webpack from &apos;webpack&apos;;
// 如果预先定义过环境变量，就将其赋值给`ASSET_PATH`变量，否则赋值为根目录
const ASSET_PATH = process.env.ASSET_PATH || &apos;/&apos;;

export default {
    output: {
        publicPath: ASSET_PATH
    },

    plugins: [
        // 该插件帮助我们安心地使用环境变量
        new webpack.DefinePlugin({
            &apos;process.env.ASSET_PATH&apos;: JSON.stringify(ASSET_PATH)
        })
    ]
};
</code></pre><h4 id="2-即时设定路径值"><a href="#2-即时设定路径值" class="headerlink" title="2 即时设定路径值"></a>2 即时设定路径值</h4><p>另一个可能出现的情况是，我们需要即时设置公共路径。webpack 提供一个全局变量供你设置，它名叫<code>__webpack_public_path__</code>。所以在你的项目入口，你可以简单地设置如下：</p>
<pre><code>__webpack_public_path__ = process.env.ASSET_PATH;
</code></pre><p>一切设置完成。因为我们已经在我们的配置项中使用了DefinePlugin， process.env.ASSET_PATH 就已经被定义了， 所以让我们能够安心地使用它了。</p>
<p>警告：请注意，如果你在入口文件中使用 ES6 模块导入，则在导入后对 <strong>webpack_public_path</strong> 进行赋值。在这种情况下，你必须将公共路径(public path)赋值移至自己的专属模块，然后将其导入到你的 entry.js 之上：</p>
<pre><code>// entry.js
import &apos;./public-path&apos;;
import &apos;./app&apos;;
</code></pre><p>$_MORE:警告是什么意思？？</p>
<h2 id="二-集成-Intergrations"><a href="#二-集成-Intergrations" class="headerlink" title="二 集成(Intergrations)"></a>二 集成(Intergrations)</h2><h3 id="2-1-NPM-Scripts"><a href="#2-1-NPM-Scripts" class="headerlink" title="2.1 NPM Scripts"></a>2.1 NPM Scripts</h3><h3 id="2-2-Grunt"><a href="#2-2-Grunt" class="headerlink" title="2.2 Grunt"></a>2.2 Grunt</h3><h3 id="2-3-Gulp"><a href="#2-3-Gulp" class="headerlink" title="2.3 Gulp"></a>2.3 Gulp</h3><h3 id="2-4-Mocha"><a href="#2-4-Mocha" class="headerlink" title="2.4 Mocha"></a>2.4 Mocha</h3><h3 id="2-5-Karma"><a href="#2-5-Karma" class="headerlink" title="2.5 Karma"></a>2.5 Karma</h3><p>$_EXCLUDE:不需要集成，单独使用</p>
<p style="text-align:right"> </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>pkg</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack_1-Concepts</title>
    <url>/w3/pkg/webpack_1-concepts/</url>
    <content><![CDATA[<p>cc.<br><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/</a></p>
<p style="text-align:right">2018.1.22 星期三 15:30</p>

<a id="more"></a>
<p style="text-align:right">2018.2.9 星期五 15:30</p>

<h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h2><p>本质上，webpack 是<strong>一个现代 JavaScript 应用程序的静态模块打包器(module bundler)</strong>。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p>它是高度可配置的，但是，在开始前你需要先理解四个核心概念：<br>入口(entry),输出(output),loader,插件(plugins)  </p>
<p>本文档旨在给出这些概念的高度概述，同时提供具体概念的详尽相关用例。</p>
<h3 id="1-1-入口-entry"><a href="#1-1-入口-entry" class="headerlink" title="1.1 入口(entry)"></a>1.1 入口(entry)</h3><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>每个依赖项随即被处理，最后输出到称之为 bundles 的文件中，我们将在下一章节详细讨论这个过程。</p>
<p>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。</p>
<h3 id="1-2-出口-output"><a href="#1-2-出口-output" class="headerlink" title="1.2 出口(output)"></a>1.2 出口(output)</h3><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：</p>
<h3 id="1-3-loader"><a href="#1-3-loader" class="headerlink" title="1.3 loader"></a>1.3 loader</h3><p><strong>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理</strong>。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。</p>
<blockquote>
<p><strong>注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图</strong>。</p>
</blockquote>
<p>在更高层面，在 webpack 的配置中 loader 有两个目标。</p>
<ol>
<li>识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性)</li>
<li><p>转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性)<br>webpack.config.js</p>
<p> const path = require(‘path’);<br> const config = {</p>
<pre><code>entry: &apos;./path/to/my/entry/file.js&apos;,
output: {
    path: path.resolve(__dirname, &apos;dist&apos;),
    filename: &apos;my-first-webpack.bundle.js&apos;
},
module: {
    rules: [
    { test: /\.txt$/, use: &apos;raw-loader&apos; }
    ]
}
</code></pre><p> };</p>
<p> module.exports = config;<br>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：<br>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</p>
</li>
</ol>
<blockquote>
<p>重要的是要记得，在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告”<br>loader 还有更多我们尚未提到的具体配置属性。</p>
</blockquote>
<h3 id="1-4-插件-plugins"><a href="#1-4-插件-plugins" class="headerlink" title="1.4 插件(plugins)"></a>1.4 插件(plugins)</h3><p>//webpack.config.js</p>
<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装
const webpack = require(&apos;webpack&apos;); // 用于访问内置插件
const path = require(&apos;path&apos;);

const config = {
    entry: &apos;./path/to/my/entry/file.js&apos;,
    output: {
        path: path.resolve(__dirname, &apos;dist&apos;),
        filename: &apos;my-first-webpack.bundle.js&apos;
    },
    module: {
        rules: [
        { test: /\.txt$/, use: &apos;raw-loader&apos; }
        ]
    },
    plugins: [
        new webpack.optimize.UglifyJsPlugin(),
        new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})
    ]
};

module.exports = config;
</code></pre><h2 id="二-入口起点-Entry-Points"><a href="#二-入口起点-Entry-Points" class="headerlink" title="二 入口起点(Entry Points)"></a>二 入口起点(Entry Points)</h2><h3 id="2-1-单个入口（简写）语法"><a href="#2-1-单个入口（简写）语法" class="headerlink" title="2.1 单个入口（简写）语法"></a>2.1 单个入口（简写）语法</h3><h3 id="2-2-对象语法"><a href="#2-2-对象语法" class="headerlink" title="2.2 对象语法"></a>2.2 对象语法</h3><h3 id="2-3-常见场景"><a href="#2-3-常见场景" class="headerlink" title="2.3 常见场景"></a>2.3 常见场景</h3><h4 id="1-分离应用程序"><a href="#1-分离应用程序" class="headerlink" title="1 分离应用程序"></a>1 分离应用程序</h4><h4 id="2-多页面应用程序"><a href="#2-多页面应用程序" class="headerlink" title="2 多页面应用程序"></a>2 多页面应用程序</h4><h2 id="三-输出-Output"><a href="#三-输出-Output" class="headerlink" title="三 输出(Output)"></a>三 输出(Output)</h2><p>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。</p>
<h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h3><p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p>
<ul>
<li>filename 用于输出文件的文件名。</li>
<li><p>目标输出目录 path 的绝对路径。</p>
<h3 id="3-2-多个入口起点"><a href="#3-2-多个入口起点" class="headerlink" title="3.2 多个入口起点"></a>3.2 多个入口起点</h3><p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</p>
<h3 id="3-3-高级进阶"><a href="#3-3-高级进阶" class="headerlink" title="3.3 高级进阶"></a>3.3 高级进阶</h3><p>以下是使用 CDN 和资源 hash 的复杂示例：<br>config.js</p>
<p>  output: {</p>
<pre><code>path: &quot;/home/proj/cdn/assets/[hash]&quot;,
publicPath: &quot;http://cdn.example.com/assets/[hash]/&quot;
</code></pre><p>  }<br>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p>
<p>  <strong>webpack_public_path</strong> = myRuntimePublicPath<br>  // 剩余的应用程序入口</p>
</li>
</ul>
<h2 id="四-Loader"><a href="#四-Loader" class="headerlink" title="四 Loader"></a>四 Loader</h2><p><strong>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件</strong>。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p>
<h3 id="4-1-示例"><a href="#4-1-示例" class="headerlink" title="4.1 示例"></a>4.1 示例</h3><h3 id="4-2-使用Loader"><a href="#4-2-使用Loader" class="headerlink" title="4.2 使用Loader"></a>4.2 使用Loader</h3><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h4><h4 id="2-内联"><a href="#2-内联" class="headerlink" title="2 内联"></a>2 内联</h4><pre><code>import Styles from &apos;style-loader!css-loader?modules!./styles.css&apos;;
</code></pre><h4 id="3-CLI"><a href="#3-CLI" class="headerlink" title="3 CLI"></a>3 CLI</h4><pre><code>webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos;
</code></pre><h3 id="4-3-Loader特性"><a href="#4-3-Loader特性" class="headerlink" title="4.3 Loader特性"></a>4.3 Loader特性</h3><h3 id="4-4-解析Loader"><a href="#4-4-解析Loader" class="headerlink" title="4.4 解析Loader"></a>4.4 解析Loader</h3><h2 id="五-插件-Plugins"><a href="#五-插件-Plugins" class="headerlink" title="五 插件(Plugins)"></a>五 插件(Plugins)</h2><p>插件是 wepback 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p>
<p><strong>插件目的在于解决 loader 无法实现的其他事</strong>。</p>
<h3 id="5-1-剖析"><a href="#5-1-剖析" class="headerlink" title="5.1 剖析"></a>5.1 剖析</h3><h3 id="5-2-用法"><a href="#5-2-用法" class="headerlink" title="5.2 用法"></a>5.2 用法</h3><h3 id="5-3-配置"><a href="#5-3-配置" class="headerlink" title="5.3 配置"></a>5.3 配置</h3><h3 id="5-4-Node-API"><a href="#5-4-Node-API" class="headerlink" title="5.4 Node API"></a>5.4 Node API</h3><h2 id="六-配置-Configuration"><a href="#六-配置-Configuration" class="headerlink" title="六 配置(Configuration)"></a>六 配置(Configuration)</h2><p>你可能已经注意到，很少有 webpack 配置看起来很完全相同。这是因为 <strong>webpack 的配置文件，是导出一个对象的 JavaScript 文件</strong>。此对象，由 webpack 根据对象定义的属性进行解析。</p>
<p><strong>因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情：</strong></p>
<ol>
<li>通过 require(…) 导入其他文件</li>
<li>通过 require(…) 使用 npm 的工具函数</li>
<li>使用 JavaScript 控制流表达式，例如 ?: 操作符</li>
<li>对常用值使用常量或变量</li>
<li>编写并执行函数来生成部分配置</li>
</ol>
<p>请在合适的时机使用这些特性。<br>虽然技术上可行，但应避免以下做法：</p>
<ul>
<li>在使用 webpack 命令行接口(CLI)（应该编写自己的命令行接口(CLI)，或使用 –env）时，访问命令行接口(CLI)参数</li>
<li>导出不确定的值（调用 webpack 两次应该产生同样的输出文件）</li>
<li>编写很长的配置（应该将配置拆分为多个文件）</li>
</ul>
<blockquote>
<p>你需要从这份文档中收获最大的点，就是你的 webpack 配置，可以有很多种的格式和风格。但为了你和你的团队能够易于理解和维护，你们要始终采取同一种用法、格式和风格。</p>
</blockquote>
<p>接下来的例子展示了 webpack 配置对象(webpack configuration object)如何即具有表现力，又具有可配置性，这是因为配置对象即是代码：</p>
<h3 id="6-1-最简单的配置"><a href="#6-1-最简单的配置" class="headerlink" title="6.1 最简单的配置"></a>6.1 最简单的配置</h3><h3 id="6-2-多个Target"><a href="#6-2-多个Target" class="headerlink" title="6.2 多个Target"></a>6.2 多个Target</h3><h3 id="6-3-使用其他配置语言"><a href="#6-3-使用其他配置语言" class="headerlink" title="6.3 使用其他配置语言"></a>6.3 使用其他配置语言</h3><h2 id="七-模块-Modules"><a href="#七-模块-Modules" class="headerlink" title="七 模块(Modules)"></a>七 模块(Modules)</h2><p>在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。</p>
<p>每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
<p>Node.js 从最一开始就支持模块化编程。然而，在 web，模块化的支持正缓慢到来。在 web 存在多种支持 JavaScript 模块化的工具，这些工具各有优势和限制。<strong>webpack 基于从这些系统获得的经验教训，并将模块的概念应用于项目中的任何文件</strong>。</p>
<h3 id="7-1-什么是webpack模块"><a href="#7-1-什么是webpack模块" class="headerlink" title="7.1 什么是webpack模块"></a>7.1 什么是webpack模块</h3><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p>
<ol>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>样式(url(…))或 HTML 文件(<img src="http://you img base url/...?e=1585218234&token=your qiniu access key:k95GU4oVpOW993LtbJgLU315Mpw=">)中的图片链接(image url)<blockquote>
<p>webpack 1 需要特定的 loader 来转换 ES 2015 import，然而通过 webpack 2 可以开箱即用。</p>
</blockquote>
<h3 id="7-2-支持的模块类型"><a href="#7-2-支持的模块类型" class="headerlink" title="7.2 支持的模块类型"></a>7.2 支持的模块类型</h3><strong>webpack 通过 loader 可以支持各种语言和预处理器编写模块</strong>。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括：<br>CoffeeScript,TypeScript,ESNext (Babel),Sass,Less,Stylus  </li>
</ol>
<p>总的来说，webpack 提供了可定制的、强大和丰富的 API，允许任何技术栈使用 webpack，保持了在你的开发、测试和生成流程中无侵入性(non-opinionated)。</p>
<p>有关完整列表，请参考 loader 列表 或 自己编写。</p>
<h2 id="八-模块解析-Module-Resolution"><a href="#八-模块解析-Module-Resolution" class="headerlink" title="八 模块解析(Module Resolution)"></a>八 模块解析(Module Resolution)</h2><p>resolver 是一个库(library)，用于帮助找到模块的绝对路径。一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：</p>
<pre><code>import foo from &apos;path/to/module&apos;
// 或者
require(&apos;path/to/module&apos;)
</code></pre><p>所依赖的模块可以是来自应用程序代码或第三方的库(library)。resolver 帮助 webpack 找到 bundle 中需要引入的模块代码，这些代码在包含在每个 require/import 语句中。 当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径</p>
<h3 id="8-1-webpack中的解析规则"><a href="#8-1-webpack中的解析规则" class="headerlink" title="8.1 webpack中的解析规则"></a>8.1 webpack中的解析规则</h3><p>使用 enhanced-resolve，webpack 能够解析三种文件路径：</p>
<h4 id="1-绝对路径"><a href="#1-绝对路径" class="headerlink" title="1 绝对路径"></a>1 绝对路径</h4><pre><code>import &quot;/home/me/file&quot;;
import &quot;C:\\Users\\me\\file&quot;;
</code></pre><p>由于我们已经取得文件的绝对路径，因此不需要进一步再做解析。</p>
<h4 id="2-相对路径"><a href="#2-相对路径" class="headerlink" title="2 相对路径"></a>2 相对路径</h4><pre><code>import &quot;../src/file1&quot;;
import &quot;./file2&quot;;
</code></pre><p>在这种情况下，使用 import 或 require 的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在 import/require 中给定的相对路径，会添加此上下文路径(context path)，以产生模块的绝对路径(absolute path)。</p>
<h4 id="3-模块路径"><a href="#3-模块路径" class="headerlink" title="3 模块路径"></a>3 模块路径</h4><pre><code>import &quot;module&quot;;
import &quot;module/lib/file&quot;;
</code></pre><p>模块将在 resolve.modules 中指定的所有目录内搜索。 你可以替换初始模块路径，此替换路径通过使用 resolve.alias 配置选项来创建一个别名。</p>
<ol>
<li>一旦根据上述规则解析路径后，解析器(resolver)将检查路径是否指向文件或目录。如果路径指向一个文件：<ol>
<li>如果路径具有文件扩展名，则被直接将文件打包。</li>
<li>否则，将使用 [resolve.extensions] 选项作为文件扩展名来解析，此选项告诉解析器在解析中能够接受哪些扩展名（例如 .js, .jsx）。</li>
</ol>
</li>
<li>如果路径指向一个文件夹，则采取以下步骤找到具有正确扩展名的正确文件：<ol>
<li>如果文件夹中包含 package.json 文件，则按照顺序查找 resolve.mainFields 配置选项中指定的字段。并且 package.json 中的第一个这样的字段    确定文件路径。</li>
<li>如果 package.json 文件不存在或者 package.json 文件中的 main 字段没有返回一个有效路径，则按照顺序查找 resolve.mainFiles 配置选项中指定的文件名，看是否能在 import/require 目录下匹配到一个存在的文件名。</li>
<li>文件扩展名通过 resolve.extensions 选项采用类似的方法进行解析。<br>webpack 根据构建目标(build target)为这些选项提供了合理的默认配置。<h3 id="8-2-解析Loader-Resolving-Loader"><a href="#8-2-解析Loader-Resolving-Loader" class="headerlink" title="8.2 解析Loader(Resolving Loader)"></a>8.2 解析Loader(Resolving Loader)</h3>Loader 解析遵循与文件解析器指定的规则相同的规则。但是 resolveLoader 配置选项可以用来为 Loader 提供独立的解析规则。<h3 id="8-3-缓存"><a href="#8-3-缓存" class="headerlink" title="8.3 缓存"></a>8.3 缓存</h3>每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。</li>
</ol>
</li>
</ol>
<p>有关上述配置的更多信息，请查看解析 API学习。</p>
<h2 id="九-依赖图-Dependency-Graph"><a href="#九-依赖图-Dependency-Graph" class="headerlink" title="九 依赖图(Dependency Graph)"></a>九 依赖图(Dependency Graph)</h2><p>任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为依赖提供给你的应用程序。</p>
<p>webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。</p>
<blockquote>
<p>对于 HTTP/1.1 客户端，由 webpack 打包你的应用程序会尤其强大，因为在浏览器发起一个新请求时，它能够减少应用程序必须等待的时间。对于 HTTP/2，你还可以使用代码拆分(Code Splitting)以及通过 webpack 打包来实现最佳优化。</p>
</blockquote>
<h2 id="零-构建目标-Targets"><a href="#零-构建目标-Targets" class="headerlink" title="零 构建目标(Targets)"></a>零 构建目标(Targets)</h2><p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。</p>
<blockquote>
<p>webpack 的 target 属性不要和 output.libraryTarget 属性混淆。有关 output 属性的更多信息，请查看我们的指南。</p>
</blockquote>
<h3 id="0-1-用法"><a href="#0-1-用法" class="headerlink" title="0.1 用法"></a>0.1 用法</h3><p>要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值。<br>webpack.config.js</p>
<pre><code>module.exports = {
    target: &apos;node&apos;
};
</code></pre><p>在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。</p>
<p>每个target都有各种部署(deployment)/环境(environment)特定的附加项，以支持满足其需求。查看target 的可用值。</p>
<h3 id="0-2-多个Target"><a href="#0-2-多个Target" class="headerlink" title="0.2 多个Target"></a>0.2 多个Target</h3><p>尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：<br>webpack.config.js</p>
<pre><code>var path = require(&apos;path&apos;);
var serverConfig = {
    target: &apos;node&apos;,
    output: {
        path: path.resolve(__dirname, &apos;dist&apos;),
        filename: &apos;lib.node.js&apos;
    }
    //…
};

var clientConfig = {
    target: &apos;web&apos;, // &lt;=== 默认是 &apos;web&apos;，可省略
    output: {
        path: path.resolve(__dirname, &apos;dist&apos;),
        filename: &apos;lib.js&apos;
    }
    //…
};

module.exports = [ serverConfig, clientConfig ];
</code></pre><p>上面的例子将在你的 dist 文件夹下创建 lib.js 和 lib.node.js 文件。</p>
<h3 id="0-3-资源"><a href="#0-3-资源" class="headerlink" title="0.3 资源"></a>0.3 资源</h3><h2 id="一-Manifest"><a href="#一-Manifest" class="headerlink" title="一 Manifest"></a>一 Manifest</h2><p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p>
<ol>
<li>你或你的团队编写的源码。</li>
<li>你的源码会依赖的任何第三方的 library 或 “vendor” 代码。</li>
<li>webpack 的 runtime 和 manifest，管理所有模块的交互。<br>本文将重点介绍这三个部分中的最后部分，runtime 和 manifest。<h3 id="1-1-Runtime"><a href="#1-1-Runtime" class="headerlink" title="1.1 Runtime"></a>1.1 Runtime</h3><h3 id="1-2-Manifest"><a href="#1-2-Manifest" class="headerlink" title="1.2 Manifest"></a>1.2 Manifest</h3><h3 id="1-3-问题"><a href="#1-3-问题" class="headerlink" title="1.3 问题"></a>1.3 问题</h3></li>
</ol>
<h2 id="二-模块热替换-Hot-Module-Replace"><a href="#二-模块热替换-Hot-Module-Replace" class="headerlink" title="二 模块热替换(Hot Module Replace)"></a>二 模块热替换(Hot Module Replace)</h2><h3 id="2-1-这一切是如何运行的？"><a href="#2-1-这一切是如何运行的？" class="headerlink" title="2.1 这一切是如何运行的？"></a>2.1 这一切是如何运行的？</h3><h3 id="2-2-在应用程序中"><a href="#2-2-在应用程序中" class="headerlink" title="2.2 在应用程序中"></a>2.2 在应用程序中</h3><h3 id="2-3-在编译器中"><a href="#2-3-在编译器中" class="headerlink" title="2.3 在编译器中"></a>2.3 在编译器中</h3><h3 id="2-4-在HMT-Runtime中"><a href="#2-4-在HMT-Runtime中" class="headerlink" title="2.4 在HMT Runtime中"></a>2.4 在HMT Runtime中</h3><h3 id="2-5-入门"><a href="#2-5-入门" class="headerlink" title="2.5 入门"></a>2.5 入门</h3><p style="text-align:right">2.9 18:22</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>pkg</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-9_jQ辅助工具</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%209%20%E7%AB%A0%20jQ%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h3 id="8-1-创建jQ插件"><a href="#8-1-创建jQ插件" class="headerlink" title="8.1 创建jQ插件"></a>8.1 创建jQ插件</h3><h3 id="8-2-创建jQ插件实战"><a href="#8-2-创建jQ插件实战" class="headerlink" title="8.2 创建jQ插件实战"></a>8.2 创建jQ插件实战</h3><h3 id="8-3-jQ-UI插件应用"><a href="#8-3-jQ-UI插件应用" class="headerlink" title="8.3 jQ UI插件应用"></a>8.3 jQ UI插件应用</h3><p style="text-align:right">2018.1.20 星期六 22：59</p>

<h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><p>P398-P400</p>
<h3 id="9-1-检测浏览器"><a href="#9-1-检测浏览器" class="headerlink" title="9.1 检测浏览器"></a>9.1 检测浏览器</h3><h4 id="1-jQuery检测浏览器的类型"><a href="#1-jQuery检测浏览器的类型" class="headerlink" title="1 jQuery检测浏览器的类型"></a>1 jQuery检测浏览器的类型</h4><p>$.browser  5个属性：safari,opera,msie,mozilla<br>缺乏灵活性，1.3本不建议使用</p>
<h4 id="2-JS检测浏览器的类型"><a href="#2-JS检测浏览器的类型" class="headerlink" title="2 JS检测浏览器的类型"></a>2 JS检测浏览器的类型</h4><pre><code>var userAgent=navigator.userAgent.toLowerCase()
jQuery.browser={
    version:(userAgent.match(/.+(?:rv|it|ra|ie)[\/:]([\d.]+)/)||[0,&apos;0&apos;])[1],
    safari:/webkit/.test(userAgent),
    opera:/opera/.test(userAgent),
    msie:/msie/.test(userAgent)&amp;&amp;!/opera/.test(userAgent),
    mozilla:/mozilla/.test(userAgent)&amp;&amp;!/(compatible|webkit)/  .test(userAgent)      
}
</code></pre><h4 id="3-更灵巧的浏览器检测方法"><a href="#3-更灵巧的浏览器检测方法" class="headerlink" title="3 更灵巧的浏览器检测方法"></a>3 更灵巧的浏览器检测方法</h4><p>字符串检测法（上面，1.3不再支持了）<br>现在多，特征检测法</p>
<h4 id="4-检测浏览器版本号"><a href="#4-检测浏览器版本号" class="headerlink" title="4 检测浏览器版本号"></a>4 检测浏览器版本号</h4><ol>
<li>jQuery实现<br> $.browser.version</li>
<li>JS实现<br>正则，nav.userAgent<h4 id="5-检测浏览器的盒模型"><a href="#5-检测浏览器的盒模型" class="headerlink" title="5 检测浏览器的盒模型"></a>5 检测浏览器的盒模型</h4></li>
<li>jQ<br> $.boxModel</li>
<li>JS<br> function isBoxModel(){<pre><code>var d=do.creE(&apos;div&apos;)
d.st.wi=d.st.paddLe=&apos;1px&apos;
do.body.appC(d)
var w=d.offsetWidth
d.st.disp=&apos;none&apos;
do.body.reC(d)
return w===2
</code></pre> }<h4 id="6-浏览器特性综合测试"><a href="#6-浏览器特性综合测试" class="headerlink" title="6 浏览器特性综合测试"></a>6 浏览器特性综合测试</h4>1.3后重新设计了浏览器检测方法。把相关属性都放到support对象中<br>boxModel,cssFloat,hrefNormalized,htmlSerialize,leadingWhitespace,<br>noCloneEvent,objectAll,opacity,scriptEval,style,tbody</li>
</ol>
<h3 id="9-2-字符串处理"><a href="#9-2-字符串处理" class="headerlink" title="9.2 字符串处理"></a>9.2 字符串处理</h3><p>trim(),param()</p>
<h4 id="1-修剪字符串"><a href="#1-修剪字符串" class="headerlink" title="1 修剪字符串"></a>1 修剪字符串</h4><ol>
<li>jQ</li>
<li>JS<br> function trim(text){<pre><code>return (text||&quot;&quot;).replace(/^\s+|\s+$/g,&quot;&quot;)
</code></pre> }<h4 id="2-序列化字符串"><a href="#2-序列化字符串" class="headerlink" title="2 序列化字符串"></a>2 序列化字符串</h4></li>
<li>jQ<br> jQuery.param(obj)</li>
<li>JS<br> function param(a){<pre><code>var s=[]
function add(key,val){
    s[s.length]=encodeURIComponent(key)+&apos;=&apos;+encodeURIComponent(value)
}
for(var j in a){
    add(j,a[j])
}
return s.join(&quot;&amp;&quot;).replace(/%20/g,&quot;+&quot;)
</code></pre> }</li>
</ol>
<h3 id="9-3-数组处理"><a href="#9-3-数组处理" class="headerlink" title="9.3 数组处理"></a>9.3 数组处理</h3><h4 id="1-检测数组"><a href="#1-检测数组" class="headerlink" title="1 检测数组"></a>1 检测数组</h4><ol>
<li>jQ</li>
<li>JS<br> function isArray(obj){<pre><code>return Object.prototype.toString.call(obj)===&quot;[object Array]&quot;
</code></pre> }</li>
<li>关于isFunction()函数<br> function isArray(obj){<pre><code>return Object.prototype.toString.call(obj)===&quot;[object Function]&quot;
</code></pre> }<h4 id="2-遍历数组或集合对象"><a href="#2-遍历数组或集合对象" class="headerlink" title="2 遍历数组或集合对象"></a>2 遍历数组或集合对象</h4></li>
<li>jQ</li>
<li>JS<br> function each(obj,callback,args){<pre><code>var name,i=0,length=obj.length
if(args){//如果存在第三个参数
    if(length===undefined){//如果是对象
        for(name in obj){
            if(callback.apply(obj[name],args)===false)
                break;//回调函数返回false，跳出循环
        }
    }else{//如果数组
        for(;i&lt;length;){
            if(callback.apply(obj[i++],args)===false)
                break
        }
    }
}else{
    if(length===undefined){
        for(name in object){
            if(callback.call(obj[name],name,obj[name])===false)
                break
        }
    }else{
        for(var val=obj[0];i&lt;length&amp;&amp;callback.call(val,i,val)!==false;
            val=obj[i++]){}
    }
}
return obj
</code></pre> }<h4 id="3-转换为数组"><a href="#3-转换为数组" class="headerlink" title="3 转换为数组"></a>3 转换为数组</h4></li>
<li>jQ<br> jQuery.makeArray($(‘li’))</li>
<li>JS<h4 id="4-过滤数组"><a href="#4-过滤数组" class="headerlink" title="4 过滤数组"></a>4 过滤数组</h4></li>
<li>jQ<br> jQuery.grep(array,callback,[invert])</li>
<li>JS<br>jQ定义的grep函数用法比较复杂，但使用JS直接定义方法却很简单<h4 id="5-映射数组"><a href="#5-映射数组" class="headerlink" title="5 映射数组"></a>5 映射数组</h4></li>
<li>jQ jQuery.map(array,callback)<h4 id="6-合并数组"><a href="#6-合并数组" class="headerlink" title="6 合并数组"></a>6 合并数组</h4><h4 id="7-删除数组中重复的元素"><a href="#7-删除数组中重复的元素" class="headerlink" title="7 删除数组中重复的元素"></a>7 删除数组中重复的元素</h4></li>
<li>jQ<br> jQuery.unique($arr1)<br>只能处理DOM元素数组    </li>
</ol>
<p>// EXCLUDE:上中有些没有用过，而且JS现在已经有很好的数组处理方法</p>
<h3 id="9-4-多库共存"><a href="#9-4-多库共存" class="headerlink" title="9.4 多库共存"></a>9.4 多库共存</h3><h4 id="1-解决-名字冲突"><a href="#1-解决-名字冲突" class="headerlink" title="1 解决$名字冲突"></a>1 解决$名字冲突</h4><h4 id="2-解决jQuery名字冲突"><a href="#2-解决jQuery名字冲突" class="headerlink" title="2 解决jQuery名字冲突"></a>2 解决jQuery名字冲突</h4><pre><code>noConflict:function(deep){
    window.$=_$
        if(deep)
            window.jQuery=_jQuery
    return jQuery        
}
</code></pre><h3 id="9-5-数据缓存"><a href="#9-5-数据缓存" class="headerlink" title="9.5 数据缓存"></a>9.5 数据缓存</h3><h4 id="1-jQ数据缓存的作用"><a href="#1-jQ数据缓存的作用" class="headerlink" title="1 jQ数据缓存的作用"></a>1 jQ数据缓存的作用</h4><h4 id="2-定义缓存数据"><a href="#2-定义缓存数据" class="headerlink" title="2 定义缓存数据"></a>2 定义缓存数据</h4><h4 id="3-获取缓存数据"><a href="#3-获取缓存数据" class="headerlink" title="3 获取缓存数据"></a>3 获取缓存数据</h4><h4 id="4-删除缓存数据"><a href="#4-删除缓存数据" class="headerlink" title="4 删除缓存数据"></a>4 删除缓存数据</h4><h4 id="5-jQ数据缓存的JS实现"><a href="#5-jQ数据缓存的JS实现" class="headerlink" title="5 jQ数据缓存的JS实现"></a>5 jQ数据缓存的JS实现</h4><pre><code>var expando=&apos;jQuery&apos;+now(),uuid=0,windowData={}
jQuery.extend({
    cache:{},
    data:function(elem,name,data){
        elem=elem==window?windowData:elem
        var id=elem[expando]//为当前元素定义一个数据属性
        if(!id){
            id=elem[expando]=++uuid
        }
        //如果缓存数据对象中未存在特定数据的属性
        if(name&amp;&amp;!jQuery.cahce[id]){
            jQuery.cache[id]={}
        }
        if(data!==undefined){
            jQuery.cache[id][name]=data
        }
        return name?jQuery.cache[id][name]:id
    }
})

//下面JS模拟jQ实现方法，并通过示例看数据缓存的作用原理
var expando=&apos;jQuery&apos;+now()
uuid=0
windowData={}
cache={}
function data(elem,name,data){
    elem=elem==window?windowData:elem
    var id=elem[expando]
    if(!id) id=elem[expando]=++uuid
    if(name&amp;&amp;!cache[id]) cache[id]={}
    if(data!==undefined) cache[id][name]=data
    return name?cache[id][name]:id
}
function now(){return +new Date}
//为方便jQ对象操作，有绑定到jQuery.fn原型对象上
jQuery.fn.extend({
    data:function(key,value){}
})
</code></pre><h4 id="6-jQ数据缓存的使用规范"><a href="#6-jQ数据缓存的使用规范" class="headerlink" title="6 jQ数据缓存的使用规范"></a>6 jQ数据缓存的使用规范</h4><p>// TODO:数据缓存，在数据方面实用。再研究</p>
<h3 id="9-6-数据队列"><a href="#9-6-数据队列" class="headerlink" title="9.6 数据队列"></a>9.6 数据队列</h3><p>‘先进先出’ (FIFO: first in first out)<br>定义queue()方法实现对队列的完整操作<br>对于一系列需要按次序执行的函数特别有用：animate动画，Ajax异步请求，交互，ti’me’out</p>
<h4 id="1-添加队列"><a href="#1-添加队列" class="headerlink" title="1 添加队列"></a>1 添加队列</h4><pre><code>$div.queue(name,callback)  //name 默认fx
</code></pre><p>// INCLUED:9.6_queue.html    </p>
<h4 id="2-获取队列"><a href="#2-获取队列" class="headerlink" title="2 获取队列"></a>2 获取队列</h4><pre><code>$div.queue(name)
</code></pre><p>如果匹配的元素不止一个，则返回第一个元素的</p>
<h4 id="3-替换队列"><a href="#3-替换队列" class="headerlink" title="3 替换队列"></a>3 替换队列</h4><pre><code>$
$div.queue(&apos;fa&apos;,function(){})
$div.queue(&apos;fx&apos;,fa)
</code></pre><p>如果第二参数为空数组，会清除原来的动画序列    </p>
<h4 id="4-删除队列函数"><a href="#4-删除队列函数" class="headerlink" title="4 删除队列函数"></a>4 删除队列函数</h4><pre><code>$(this).dequeue()
</code></pre><h3 id="9-7-内核工具"><a href="#9-7-内核工具" class="headerlink" title="9.7 内核工具"></a>9.7 内核工具</h3><h4 id="1-遍历jQ对象"><a href="#1-遍历jQ对象" class="headerlink" title="1 遍历jQ对象"></a>1 遍历jQ对象</h4><h4 id="2-遍历jQ对象的JS实现"><a href="#2-遍历jQ对象的JS实现" class="headerlink" title="2 遍历jQ对象的JS实现"></a>2 遍历jQ对象的JS实现</h4><pre><code>..
// 然后在jQuery.fn对象上绑定原型方法
each:function(callback,args){
    return jQuery.each(this,callback,args)
}
</code></pre><h4 id="3-获取jQ对象的元素个数"><a href="#3-获取jQ对象的元素个数" class="headerlink" title="3 获取jQ对象的元素个数"></a>3 获取jQ对象的元素个数</h4><pre><code>jQuery.fn=jQuery.prototype={
    size:function(){
        return this.length
    }
}
</code></pre><p>length属性，size()</p>
<h4 id="4-获取选择器和选择范围"><a href="#4-获取选择器和选择范围" class="headerlink" title="4 获取选择器和选择范围"></a>4 获取选择器和选择范围</h4><p>selector,context 属性</p>
<h4 id="5-获取jQ对象的元素"><a href="#5-获取jQ对象的元素" class="headerlink" title="5 获取jQ对象的元素"></a>5 获取jQ对象的元素</h4><pre><code>var li=$li.get()//转换为DOM集合
li.reverse()
</code></pre><p>// CHECK:？返回的是jQ对象还是DOM</p>
<p style="text-align:right">1.21 00：34</p><br><p style="text-align:right">2018.1.21 日 22：34</p>


<h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2><p>P401-P423<br>//  INCLUED:10_case.html,case.js,…</p>
<h3 id="10-1-案例背景介绍"><a href="#10-1-案例背景介绍" class="headerlink" title="10.1 案例背景介绍"></a>10.1 案例背景介绍</h3><p>电子相册网站</p>
<ol>
<li>照片按类展示</li>
<li>照片视图包括缩微图、小图和灯箱视图</li>
<li>照片分类可以任意定制</li>
<li>可以定制相册皮肤，实现用户自己决定相册的肤色<h3 id="10-2-网站设计思路"><a href="#10-2-网站设计思路" class="headerlink" title="10.2 网站设计思路"></a>10.2 网站设计思路</h3><h3 id="10-3-结构设计"><a href="#10-3-结构设计" class="headerlink" title="10.3 结构设计"></a>10.3 结构设计</h3><h3 id="10-4-样式设计"><a href="#10-4-样式设计" class="headerlink" title="10.4 样式设计"></a>10.4 样式设计</h3><h3 id="10-5-网站脚本设计"><a href="#10-5-网站脚本设计" class="headerlink" title="10.5 网站脚本设计"></a>10.5 网站脚本设计</h3></li>
</ol>
<p>// EXCLUDE:通过case.js知道是2017.7月份，看了本书1，2，10章节<br>    //本章内容不错；但是实际，而且现在的工作内容中，更加丰富和变化<br>    //基于现在的工作，没有价值；但是ajax的思想是一直存在的</p>
<p style="text-align:right">1.21 23：52</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>Mediasoup文档</title>
    <url>/w3/ser/mediasoup%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>toc and abstract.  </p>
<p><a href="https://mediasoup.org/documentation/" target="_blank" rel="noopener">https://mediasoup.org/documentation/</a><br><a id="more"></a></p>
<p style="text-align:right;">2018.1.19 星期五 18:32</p>

<h1 id="一-General"><a href="#一-General" class="headerlink" title="一 General"></a>一 General</h1><h2 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1 Overview"></a>1.1 Overview</h2><p>An SFU (Selective Forwarding Unit)</p>
<h3 id="1-mediasoup-goals"><a href="#1-mediasoup-goals" class="headerlink" title="1 mediasoup goals"></a>1 mediasoup goals</h3><h3 id="2-Server-side"><a href="#2-Server-side" class="headerlink" title="2 Server side"></a>2 Server side</h3><p>….</p>
<h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><h3 id="3-Client-side"><a href="#3-Client-side" class="headerlink" title="3 Client side"></a>3 Client side</h3><p>….</p>
<h4 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h4><h2 id="1-2-Glossay"><a href="#1-2-Glossay" class="headerlink" title="1.2 Glossay"></a>1.2 Glossay</h2><p>Both mediasoup and mediasoup-client refer to the same common entities that are represented in both client and server sides</p>
<h3 id="1-Room"><a href="#1-Room" class="headerlink" title="1 Room"></a>1 Room</h3><h3 id="2-Peer"><a href="#2-Peer" class="headerlink" title="2 Peer"></a>2 Peer</h3><h3 id="3-Transport"><a href="#3-Transport" class="headerlink" title="3 Transport"></a>3 Transport</h3><h3 id="4-Producer"><a href="#4-Producer" class="headerlink" title="4 Producer"></a>4 Producer</h3><h3 id="5-Consumer"><a href="#5-Consumer" class="headerlink" title="5 Consumer"></a>5 Consumer</h3><h3 id="6-Profile"><a href="#6-Profile" class="headerlink" title="6 Profile"></a>6 Profile</h3><h2 id="1-3-mediasoup-protocol"><a href="#1-3-mediasoup-protocol" class="headerlink" title="1.3 mediasoup protocol"></a>1.3 mediasoup protocol</h2><p>Although mediasoup does not implement a signaling protocol, both the client (mediasoup-client) and the server (mediasoup) must exchange messages. Those messages can be request/response pairs or notifications, and can be sent in both directions.<br>….</p>
<h3 id="1-Request-response-pairs-and-notifications"><a href="#1-Request-response-pairs-and-notifications" class="headerlink" title="1 Request/response pairs and notifications"></a>1 Request/response pairs and notifications</h3><h3 id="2-Message-target"><a href="#2-Message-target" class="headerlink" title="2 Message target"></a>2 Message target</h3><h3 id="3-Message-examples"><a href="#3-Message-examples" class="headerlink" title="3 Message examples"></a>3 Message examples</h3><blockquote>
<p>It’s up to the application how to correlate those requests and their associated responses, for example by enveloping the request and its response into a signaling transaction that uses a id field to match them.  </p>
</blockquote>
<h2 id="1-4-RTC-stats"><a href="#1-4-RTC-stats" class="headerlink" title="1.4 RTC stats"></a>1.4 RTC stats</h2><p>Similar to WebRTC and ORTC, mediasoup provides stats in server side. If enabled, they are also delivered to mediasoup-client.<br>Currently stats are generated for the following entities:</p>
<ol>
<li>WebRtcTransport</li>
<li>Producer</li>
<li>Consumer<br>Stats are an Array of Objects.</li>
</ol>
<p><strong>$_EXCULDE:</strong> 好像和自己没多大关系</p>
<p>=====================================================</p>
<h1 id="二-mediasoup"><a href="#二-mediasoup" class="headerlink" title="二 mediasoup"></a>二 mediasoup</h1><h2 id="2-1-Installation"><a href="#2-1-Installation" class="headerlink" title="2.1 Installation"></a>2.1 Installation</h2><h2 id="2-2-API"><a href="#2-2-API" class="headerlink" title="2.2 API"></a>2.2 API</h2><h3 id="1-mediasoup"><a href="#1-mediasoup" class="headerlink" title="1 mediasoup"></a>1 mediasoup</h3><h3 id="2-Server"><a href="#2-Server" class="headerlink" title="2 Server"></a>2 Server</h3><h3 id="3-Room"><a href="#3-Room" class="headerlink" title="3 Room"></a>3 Room</h3><h3 id="4-Peer"><a href="#4-Peer" class="headerlink" title="4 Peer"></a>4 Peer</h3><h3 id="5-Transport"><a href="#5-Transport" class="headerlink" title="5 Transport"></a>5 Transport</h3><h3 id="6-WebRtcTransport"><a href="#6-WebRtcTransport" class="headerlink" title="6 WebRtcTransport"></a>6 WebRtcTransport</h3><h3 id="7-PlainRtpTransport"><a href="#7-PlainRtpTransport" class="headerlink" title="7 PlainRtpTransport"></a>7 PlainRtpTransport</h3><h3 id="8-Producer"><a href="#8-Producer" class="headerlink" title="8 Producer"></a>8 Producer</h3><h3 id="9-Consumer"><a href="#9-Consumer" class="headerlink" title="9 Consumer"></a>9 Consumer</h3><h3 id="0-ActiveSpeakerDetector"><a href="#0-ActiveSpeakerDetector" class="headerlink" title="0 ActiveSpeakerDetector"></a>0 ActiveSpeakerDetector</h3><h3 id="1-RtpStreamer"><a href="#1-RtpStreamer" class="headerlink" title="1 RtpStreamer"></a>1 RtpStreamer</h3><h3 id="2-errors"><a href="#2-errors" class="headerlink" title="2 errors"></a>2 errors</h3><h2 id="2-3-Debugging"><a href="#2-3-Debugging" class="headerlink" title="2.3 Debugging"></a>2.3 Debugging</h2><h3 id="1-Log-levels"><a href="#1-Log-levels" class="headerlink" title="1 Log levels"></a>1 Log levels</h3><ol>
<li>“mediasoup:mediasoup-worker”</li>
<li>“mediasoup:WARN:mediasoup-worker”</li>
<li>“mediasoup:ERROR:mediasoup-worker”</li>
</ol>
<h3 id="2-Enable-logging"><a href="#2-Enable-logging" class="headerlink" title="2 Enable logging"></a>2 Enable logging</h3><pre><code>$ export DEBUG=&quot;mediasoup*&quot;
$ node myapp.js
# or:
$ DEBUG=&quot;mediasoup*&quot; node myapp.js

process.env.DEBUG = &quot;mediasoup*&quot;
const mediasoup = require(&quot;mediasoup&quot;);

$ export DEBUG=&quot;mediasoup:WARN:* mediasoup:ERROR:*&quot;
</code></pre><h3 id="3-Log-tags"><a href="#3-Log-tags" class="headerlink" title="3 Log tags"></a>3 Log tags</h3><p>info,ice,dtls,rtp,srtp,rtcp,rtx,rbe</p>
<pre><code>$ export DEBUG=&quot;mediasoup:mediasoup-worker:* *ERROR*&quot;
$ node myapp.js

const mediasoup = require(&quot;mediasoup&quot;);
const server = mediasoup.Server({
    logLevel : &quot;debug&quot;,
    logTags  : [ &quot;ice&quot; ]
});
</code></pre><h2 id="2-4-Building"><a href="#2-4-Building" class="headerlink" title="2.4 Building"></a>2.4 Building</h2><h1 id="三-mediasoup-client"><a href="#三-mediasoup-client" class="headerlink" title="三 mediasoup-client"></a>三 mediasoup-client</h1><h2 id="3-1-Installation"><a href="#3-1-Installation" class="headerlink" title="3.1 Installation"></a>3.1 Installation</h2><h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><h3 id="1-mediasoupClient"><a href="#1-mediasoupClient" class="headerlink" title="1 mediasoupClient"></a>1 mediasoupClient</h3><h3 id="2-Room"><a href="#2-Room" class="headerlink" title="2 Room"></a>2 Room</h3><h3 id="3-Transport-1"><a href="#3-Transport-1" class="headerlink" title="3 Transport"></a>3 Transport</h3><h3 id="4-Producer-1"><a href="#4-Producer-1" class="headerlink" title="4 Producer"></a>4 Producer</h3><h3 id="5-Peer"><a href="#5-Peer" class="headerlink" title="5 Peer"></a>5 Peer</h3><h3 id="6-Consumer"><a href="#6-Consumer" class="headerlink" title="6 Consumer"></a>6 Consumer</h3><h2 id="3-3-Debugging"><a href="#3-3-Debugging" class="headerlink" title="3.3 Debugging"></a>3.3 Debugging</h2><h3 id="1-Log-levels-1"><a href="#1-Log-levels-1" class="headerlink" title="1 Log levels"></a>1 Log levels</h3><h3 id="2-Enable-logging-1"><a href="#2-Enable-logging-1" class="headerlink" title="2 Enable logging"></a>2 Enable logging</h3><pre><code>&lt;script&gt;
    window.localStorage.setItem(&apos;debug&apos;, &apos;mediasoup-client:WARN* mediasoup-client:ERROR*&apos;);
&lt;/script&gt;
&lt;script src=&apos;/js/your-bundled-app.js&apos;&gt;&lt;/script&gt;
</code></pre><p style="text-align:right;">19:22</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>mediasoup</tag>
      </tags>
  </entry>
  <entry>
    <title>Debug-Npm</title>
    <url>/w3/jslib/debug-npm/</url>
    <content><![CDATA[<!-- # debug 学习 -->
<p><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">https://www.npmjs.com/package/debug</a><br><a id="more"></a> </p>
<p style="text-align:right">2018.1.18 星期四 17:20</p>

<h2 id="一-Install"><a href="#一-Install" class="headerlink" title="一 Install"></a>一 Install</h2><pre><code>$ npm install debug
</code></pre><h2 id="二-Usage"><a href="#二-Usage" class="headerlink" title="二 Usage"></a>二 Usage</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><pre><code>var debug = require(&apos;debug&apos;)(&apos;http&apos;)
http = require(&apos;http&apos;)

debug(&apos;listening&apos;);

var a = require(&apos;debug&apos;)(&apos;worker:a&apos;)
    , b = require(&apos;debug&apos;)(&apos;worker:b&apos;);

function work() {
    a(&apos;doing lots of uninteresting work&apos;);
    setTimeout(work, Math.random() * 1000);
}
</code></pre><h3 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h3><pre><code>set DEBUG=*,-not_this
</code></pre><h2 id="三-Namespace-Colors"><a href="#三-Namespace-Colors" class="headerlink" title="三 Namespace Colors"></a>三 Namespace Colors</h2><h3 id="3-1-Node-js"><a href="#3-1-Node-js" class="headerlink" title="3.1 Node.js"></a>3.1 Node.js</h3><p>colors are enabled when stderr is a TTY.<br>install the supports-color module alongside debug<br>// Question:?TTF</p>
<h3 id="3-2-Web-Browser"><a href="#3-2-Web-Browser" class="headerlink" title="3.2 Web Browser"></a>3.2 Web Browser</h3><h2 id="四-Millisecond-diff"><a href="#四-Millisecond-diff" class="headerlink" title="四 Millisecond diff"></a>四 Millisecond diff</h2><p>When stdout is not a TTY, Date#toISOString() is used<br>// Question:?TTF</p>
<h2 id="五-Conventions"><a href="#五-Conventions" class="headerlink" title="五 Conventions"></a>五 Conventions</h2><p>（公约、惯例、常规、etc）</p>
<h2 id="六-Wildcards"><a href="#六-Wildcards" class="headerlink" title="六 Wildcards"></a>六 Wildcards</h2><p>（通配符） * - </p>
<h2 id="七-Environment-Variables"><a href="#七-Environment-Variables" class="headerlink" title="七 Environment Variables"></a>七 Environment Variables</h2><table>
<thead>
<tr>
<th>name</th>
<th>purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEBUG</td>
<td>Enables/disables specific debugging namespaces.</td>
</tr>
<tr>
<td>DEBUG_HIDE_DATE</td>
<td>Hide date from debug output (non-TTY).</td>
</tr>
<tr>
<td>DEBUG_COLORS</td>
<td>Whether or not to use colors in the debug output.</td>
</tr>
<tr>
<td>DEBUG_DEPTH</td>
<td>Object inspection depth.</td>
</tr>
<tr>
<td>DEBUG_SHOW_HIDDEN</td>
<td>Shows hidden properties on inspected objects.</td>
</tr>
</tbody>
</table>
<h2 id="八-Formatters"><a href="#八-Formatters" class="headerlink" title="八 Formatters"></a>八 Formatters</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h3><p>Debug uses printf-style formatting. Below are the officially supported formatters:</p>
<table>
<thead>
<tr>
<th>formatter</th>
<th>representation</th>
</tr>
</thead>
<tbody>
<tr>
<td>%O</td>
<td>Pretty-print an Object on multiple lines.</td>
</tr>
<tr>
<td>%o</td>
<td>Pretty-print an Object all on a single line.</td>
</tr>
<tr>
<td>%s</td>
<td>String.</td>
</tr>
<tr>
<td>%d</td>
<td>Number (both integer and float).</td>
</tr>
<tr>
<td>%j</td>
<td>JSON. Replaced with the string ‘[Circular]’ if the argument contains circular references.</td>
</tr>
<tr>
<td>%%</td>
<td>Single percent sign (‘%’). This does not consume an argument.</td>
</tr>
</tbody>
</table>
<h3 id="8-2-Custom-formatters"><a href="#8-2-Custom-formatters" class="headerlink" title="8.2 Custom formatters"></a>8.2 Custom formatters</h3><pre><code>const createDebug = require(&apos;debug&apos;)
createDebug.formatters.h = (v) =&gt; {
    return v.toString(&apos;hex&apos;)
}

// …elsewhere
const debug = createDebug(&apos;foo&apos;)
debug(&apos;this is hex: %h&apos;, new Buffer(&apos;hello world&apos;))
//   foo this is hex: 68656c6c6f20776f726c6421 +0ms
</code></pre><h2 id="九-Browser-Support"><a href="#九-Browser-Support" class="headerlink" title="九 Browser Support"></a>九 Browser Support</h2><p>You can build a browser-ready script using browserify, or just use the browserify-as-a-service build, if you don’t want to build it yourself.</p>
<pre><code>localStorage.debug = &apos;worker:*&apos;
a = debug(&apos;worker:a&apos;);
</code></pre><h2 id="十-Output-streams"><a href="#十-Output-streams" class="headerlink" title="十 Output streams"></a>十 Output streams</h2><pre><code>var debug = require(&apos;debug&apos;);
var error = debug(&apos;app:error&apos;);

// by default stderr is used
error(&apos;goes to stderr!&apos;);

var log = debug(&apos;app:log&apos;);
// set this namespace to log via console.log
log.log = console.log.bind(console); // don&apos;t forget to bind to console!
log(&apos;goes to stdout&apos;);
error(&apos;still goes to stderr!&apos;);

// set all output to go via console.info
// overrides all per-namespace log settings
debug.log = console.info.bind(console);
error(&apos;now goes to stdout via console.info&apos;);
log(&apos;still goes to stdout, but via console.info now&apos;);
</code></pre><p>// TODO:目前，尚不清楚，没有那么复杂的应用</p>
<h2 id="一-Checking-whether-a-debug-target-is-enabled"><a href="#一-Checking-whether-a-debug-target-is-enabled" class="headerlink" title="一 Checking whether a debug target is enabled"></a>一 Checking whether a debug target is enabled</h2><pre><code>const debug = require(&apos;debug&apos;)(&apos;http&apos;);
if (debug.enabled) {
    // do stuff...
}
</code></pre><h2 id="Authors"><a href="#Authors" class="headerlink" title="Authors"></a>Authors</h2><h2 id="Backers"><a href="#Backers" class="headerlink" title="Backers"></a>Backers</h2><h2 id="Sponsors"><a href="#Sponsors" class="headerlink" title="Sponsors"></a>Sponsors</h2><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>(The MIT License)</p>
<p style="text-align:right">17:50</p>

<p>学习总结：<br>快速学习，能够马上入手。<br>文档也就一页。<br>如需要深度掌握（有实际需求）再来学习</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-7_Ajax异步通信高效实践</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%207%20%E7%AB%A0%20Ajax%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h3 id="5-1-事件模型"><a href="#5-1-事件模型" class="headerlink" title="5.1 事件模型"></a>5.1 事件模型</h3><h3 id="5-2-jQuery事件模型"><a href="#5-2-jQuery事件模型" class="headerlink" title="5.2 jQuery事件模型"></a>5.2 jQuery事件模型</h3><h3 id="5-3-jQuery页面初始化"><a href="#5-3-jQuery页面初始化" class="headerlink" title="5.3 jQuery页面初始化"></a>5.3 jQuery页面初始化</h3><h3 id="5-4-使用JS自定义jQ的事件方法"><a href="#5-4-使用JS自定义jQ的事件方法" class="headerlink" title="5.4 使用JS自定义jQ的事件方法"></a>5.4 使用JS自定义jQ的事件方法</h3><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h3 id="6-1-直接显示和隐藏"><a href="#6-1-直接显示和隐藏" class="headerlink" title="6.1 直接显示和隐藏"></a>6.1 直接显示和隐藏</h3><h3 id="6-2-滑动显示和隐藏"><a href="#6-2-滑动显示和隐藏" class="headerlink" title="6.2 滑动显示和隐藏"></a>6.2 滑动显示和隐藏</h3><h3 id="6-3-渐隐和渐显"><a href="#6-3-渐隐和渐显" class="headerlink" title="6.3 渐隐和渐显"></a>6.3 渐隐和渐显</h3><h3 id="6-4-自定义动画"><a href="#6-4-自定义动画" class="headerlink" title="6.4 自定义动画"></a>6.4 自定义动画</h3><p style="text-align:right">2018.1.18 20:47 星期四 </p>

<h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h3 id="7-1-Ajax应用的准备"><a href="#7-1-Ajax应用的准备" class="headerlink" title="7.1 Ajax应用的准备"></a>7.1 Ajax应用的准备</h3><h4 id="1-Ajax应用利弊分析"><a href="#1-Ajax应用利弊分析" class="headerlink" title="1 Ajax应用利弊分析"></a>1 Ajax应用利弊分析</h4><h4 id="2-安装虚拟服务器"><a href="#2-安装虚拟服务器" class="headerlink" title="2 安装虚拟服务器"></a>2 安装虚拟服务器</h4><ol>
<li>安装PHP虚拟服务器<br>AppServ工具包：Apache，Apache Monitor,PHP,MySql,PHP-Nuk,phpMyAdmin</li>
<li>安装ASP虚拟服务器<br>IIS</li>
</ol>
<h3 id="7-2-Ajax应用的第一个示例"><a href="#7-2-Ajax应用的第一个示例" class="headerlink" title="7.2 Ajax应用的第一个示例"></a>7.2 Ajax应用的第一个示例</h3><h4 id="1-jQ实现"><a href="#1-jQ实现" class="headerlink" title="1 jQ实现"></a>1 jQ实现</h4><h4 id="2-JS实现"><a href="#2-JS实现" class="headerlink" title="2 JS实现"></a>2 JS实现</h4><pre><code>var xhr=new XMLHttpRequest()
var xhr=new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;)
var xhr=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)
</code></pre><h3 id="7-3-从JS角度分析XMLHttpRequest对象"><a href="#7-3-从JS角度分析XMLHttpRequest对象" class="headerlink" title="7.3 从JS角度分析XMLHttpRequest对象"></a>7.3 从JS角度分析XMLHttpRequest对象</h3><h4 id="1-XMLHttpRequest对象成员和用法"><a href="#1-XMLHttpRequest对象成员和用法" class="headerlink" title="1 XMLHttpRequest对象成员和用法"></a>1 XMLHttpRequest对象成员和用法</h4><h4 id="2-建立异步连接"><a href="#2-建立异步连接" class="headerlink" title="2 建立异步连接"></a>2 建立异步连接</h4><pre><code>xhr.open(method,url,async,user,pwd)
</code></pre><h4 id="3-发送请求"><a href="#3-发送请求" class="headerlink" title="3 发送请求"></a>3 发送请求</h4><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><h4 id="7-获取响应消息"><a href="#7-获取响应消息" class="headerlink" title="7 获取响应消息"></a>7 获取响应消息</h4><pre><code>//test.asp 
&lt;%@LANGUAGE=&quot;JAVASCRIPT&quot; CODEPAGE=&quot;65001&quot;%&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;%
Response.ContentType=&quot;text/xml&quot;
Response.Write(&quot;&lt;data&gt;相应xml数据&lt;/data&gt;&quot;)
%&gt;
</code></pre><h3 id="7-4-从jQ角度分析XMLHttpRequest对象"><a href="#7-4-从jQ角度分析XMLHttpRequest对象" class="headerlink" title="7.4 从jQ角度分析XMLHttpRequest对象"></a>7.4 从jQ角度分析XMLHttpRequest对象</h3><h4 id="4-跟踪响应状态"><a href="#4-跟踪响应状态" class="headerlink" title="4 跟踪响应状态"></a>4 跟踪响应状态</h4><p>ajaxStart() ajaxSend() ajaxComplete() ajaxSuccess() ajaxStop() ajaxError()<br><strong>$_EXCUSE:</strong> 现在都没有见过，应该是过时了的</p>
<h4 id="5-载入网页文件"><a href="#5-载入网页文件" class="headerlink" title="5 载入网页文件"></a>5 载入网页文件</h4><pre><code>$(&quot;div&quot;).load(&quot;test.html&quot;)
**$_EXCUSE:** 见过吗，待考证。没有用过
</code></pre><h4 id="6-预设Ajax选项"><a href="#6-预设Ajax选项" class="headerlink" title="6 预设Ajax选项"></a>6 预设Ajax选项</h4><p>ajaxSetup()</p>
<h4 id="7-预处理请求的字符串"><a href="#7-预处理请求的字符串" class="headerlink" title="7 预处理请求的字符串"></a>7 预处理请求的字符串</h4><p>serialize()<br>serializeArray()  返回json对象</p>
<p><strong>$_EXCUSE:</strong> 本章基本没什么新颖内容。千篇一律，快速略过</p>
<p style="text-align:right">22：24</p>


<h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h3 id="8-1-创建jQ插件"><a href="#8-1-创建jQ插件" class="headerlink" title="8.1 创建jQ插件"></a>8.1 创建jQ插件</h3><h3 id="8-2-创建jQ插件实战"><a href="#8-2-创建jQ插件实战" class="headerlink" title="8.2 创建jQ插件实战"></a>8.2 创建jQ插件实战</h3><h3 id="8-3-jQ-UI插件应用"><a href="#8-3-jQ-UI插件应用" class="headerlink" title="8.3 jQ UI插件应用"></a>8.3 jQ UI插件应用</h3><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2><p style="text-align:right">2018.1. 星期 P</p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-8_高效开发和使用插件</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%208%20%E7%AB%A0%20%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h3 id="7-1-Ajax应用的准备"><a href="#7-1-Ajax应用的准备" class="headerlink" title="7.1 Ajax应用的准备"></a>7.1 Ajax应用的准备</h3><h3 id="7-2-Ajax应用的第一个示例"><a href="#7-2-Ajax应用的第一个示例" class="headerlink" title="7.2 Ajax应用的第一个示例"></a>7.2 Ajax应用的第一个示例</h3><h3 id="7-3-从JS角度分析XMLHttpRequest对象"><a href="#7-3-从JS角度分析XMLHttpRequest对象" class="headerlink" title="7.3 从JS角度分析XMLHttpRequest对象"></a>7.3 从JS角度分析XMLHttpRequest对象</h3><h3 id="7-4-从jQ角度分析XMLHttpRequest对象"><a href="#7-4-从jQ角度分析XMLHttpRequest对象" class="headerlink" title="7.4 从jQ角度分析XMLHttpRequest对象"></a>7.4 从jQ角度分析XMLHttpRequest对象</h3><p style="text-align:right">2018.1.18 星期四 23：36 P308</p>

<h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h3 id="8-1-创建jQ插件"><a href="#8-1-创建jQ插件" class="headerlink" title="8.1 创建jQ插件"></a>8.1 创建jQ插件</h3><h4 id="1-jQ插件的类型"><a href="#1-jQ插件的类型" class="headerlink" title="1 jQ插件的类型"></a>1 jQ插件的类型</h4><ol>
<li>jQ方法</li>
<li>全局函数</li>
<li>选择器<h4 id="2-解析jQ插件机制"><a href="#2-解析jQ插件机制" class="headerlink" title="2 解析jQ插件机制"></a>2 解析jQ插件机制</h4> jQuery.extend()  jQuery.fn.extend()<br> jQuery.extend({<pre><code>minValue:function(a,b){return a&lt;b?a:b}
</code></pre> })<br> // 2 jQuery.extend 还可以扩展对象；常见参数<br> function fn(options){<pre><code>var options=jQuery.extend({name1:value1,name2:value2},options)
</code></pre> }</li>
</ol>
<h4 id="3-创建jQ全局函数"><a href="#3-创建jQ全局函数" class="headerlink" title="3 创建jQ全局函数"></a>3 创建jQ全局函数</h4><pre><code>和上一节 extend方法不同
jQuery.minValue=function(a,b){return a&lt;b?a:b}
为避免自己插件和第三方插件名冲突,自己的封装在一个对象上。而且建议jQuery，非$
jQuery.css8={
    minValue:function(){},
    maxValue:function(){},
}
</code></pre><h4 id="4-使用jQ-fn对象创建jQ插件"><a href="#4-使用jQ-fn对象创建jQ插件" class="headerlink" title="4 使用jQ.fn对象创建jQ插件"></a>4 使用jQ.fn对象创建jQ插件</h4><pre><code>jQuery.fn.test=function(){
    return this.each(function(){//返回迭代的jQuery对象
        alert(this.nodeName)
    })
}
</code></pre><h4 id="5-使用extend-方法创建jQ插件"><a href="#5-使用extend-方法创建jQ插件" class="headerlink" title="5 使用extend()方法创建jQ插件"></a>5 使用extend()方法创建jQ插件</h4><pre><code>jQuery.fn.extend({
    test:function(){  }
})
</code></pre><h4 id="6-创建自定义选择器"><a href="#6-创建自定义选择器" class="headerlink" title="6 创建自定义选择器"></a>6 创建自定义选择器</h4><pre><code>//自定义小于等于
jQuery.expr[&quot;:&quot;].le=function(elem,i,match){
    return i&lt;match[3]-0||i==match[3]-0
}
</code></pre><p>// TODO:jQ选择器的艺术，基于正则的表达式 P317</p>
<h4 id="7-优化jQ默认选择器"><a href="#7-优化jQ默认选择器" class="headerlink" title="7 优化jQ默认选择器"></a>7 优化jQ默认选择器</h4><p>// TODO:jQ选择器的艺术，基于正则的表达式 </p>
<h4 id="8-封装jQ插件"><a href="#8-封装jQ插件" class="headerlink" title="8 封装jQ插件"></a>8 封装jQ插件</h4><pre><code>(function($){
    $.extend($.fn,{
        color:function(options){
            var options=$.extend({bcolor:&quot;moren&quot;,fcolor:&quot;moren&quot;},options)
            return this.each(function(){
                $(this).css(&apos;backgroundColor&apos;,options.bcolor)
            })
        }
    })
})(jQuery)
</code></pre><h4 id="9-优化jQ插件——开放公共参数"><a href="#9-优化jQ插件——开放公共参数" class="headerlink" title="9 优化jQ插件——开放公共参数"></a>9 优化jQ插件——开放公共参数</h4><pre><code>(function($){
    $.extend($.fn,{
        color:function(options){
            // diff
            var options=$.extend({},$.fn.color.default,options)
            return this.each(function(){
                $(this).css(&apos;backgroundColor&apos;,options.bcolor)
            })
        }
    })
    // add
    $.fn.color.defaults={bcolor:&quot;white&quot;,&quot;fcolor&quot;:&quot;black&quot;}
})(jQuery)
// 用户不再需要重复定义参数 （见#### 0 调用部分，和上面对比）
</code></pre><h4 id="0-优化jQ插件——开放部分功能"><a href="#0-优化jQ插件——开放部分功能" class="headerlink" title="0 优化jQ插件——开放部分功能"></a>0 优化jQ插件——开放部分功能</h4><pre><code>(function($){
    $.extend($.fn,{
        color:function(options){
            // #### 1 调用隐私方法验证参数
            if(!filter.options) return this
            var options=$.extend({},$.fn.color.default,options)
            return this.each(function(){
                $(this).css(&apos;color&apos;,options.fcolor)
                $(this).css(&apos;backgroundColor&apos;,options.bcolor)
                // #### 0 add
                var _html=$(this).html()
                _html=$.fn.color.format(_html)
                $(this).html(_html)
            })
        }
    })
    $.fn.color.defaults={bcolor:&quot;white&quot;,&quot;fcolor&quot;:&quot;black&quot;}
    // #### 0 add 开放的功能函数
    $.fn.color.format=function(str){
        return str
    }
    // #### 1 定义隐私函数
    function filter(options){
        return !options||(options&amp;&amp;typeof options===&quot;Object&quot;)?true:false
    }

})(jQuery)

//用户传递自己的功能设置，以覆盖插件的默认功能，方便其他用户以当前插件为基础进一步去扩写插件
$(function(){
    $.fn.color.defaults={bcolor:&quot;#eee&quot;,color:&quot;#222&quot;}
    $.fn.color.format=function(str){return &quot;&lt;strong&gt;&quot;+str+&quot;&lt;/strong&gt;&quot;}

    $(&quot;h1&quot;).color()
    $(&quot;p&quot;).color({bcolor:&quot;#f00&quot;})

    $.fn.color.format=function(str){return &quot;&lt;span style=&apos;font-size:20px&apos;&gt;&quot;+str+&quot;&lt;/span&gt;&quot;}
    $(&quot;div&quot;).color()
})
</code></pre><h4 id="1-优化jQ插件——保留插件隐私"><a href="#1-优化jQ插件——保留插件隐私" class="headerlink" title="1 优化jQ插件——保留插件隐私"></a>1 优化jQ插件——保留插件隐私</h4><pre><code>(function($){
    $.extend($.fn,{
        parent:function(options){
            var arr=[]
            $.each(this,function(index,value){
                arr.push(value.parentNode)
            })
            arr=$.unique(arr) //临时数组中过滤重复的元素
            // or
            //return this.setArray(arr) //把变量打包为数组返回
            // update
            return this.pushStack(arr)//返回新建的jQuery对象，而不是修改后的当前
        }
    })
})(jQuery)

$(function(){
    var $p=$(&quot;p&quot;)
    $p.parent().css(&quot;border&quot;,&quot;solid 1px red&quot;)
    $p.hide()//$p已被修改，div隐藏，而不是p
    //改进后
    $p.parent().css(&quot;border&quot;,&quot;solid 1px red&quot;).end().hide()
        // end()能够恢复被破坏的jQuery对象；  即又回到原来的p
})
</code></pre><p>1.0版本，与children（）之类的DOM遍历方法都有破坏性；1.1后 修正    </p>
<h4 id="2-优化jQ插件——非破坏性操作"><a href="#2-优化jQ插件——非破坏性操作" class="headerlink" title="2 优化jQ插件——非破坏性操作"></a>2 优化jQ插件——非破坏性操作</h4><h4 id="3-优化jQ插件——添加事件日志"><a href="#3-优化jQ插件——添加事件日志" class="headerlink" title="3 优化jQ插件——添加事件日志"></a>3 优化jQ插件——添加事件日志</h4><pre><code>// 1st
jQuery.log=function(msg){
    var html=jQuery(&apos;&lt;div class=&quot;log&quot;&gt;&lt;/div&gt;&apos;).text(msg)
    jQuery(&quot;.logbox&quot;).append(html)
}
// 2nd
(function($){
    $.extend($.fn,{
        log:function(msg){
            var html=jQuery(&apos;&lt;div class=&quot;log&quot;&gt;&lt;/div&gt;&apos;).text(msg)
            return this.each(function(){
                jQuery(&quot;.logbox&quot;).append(html)
            })
        }
    })
})(jQuery)
// 3rd 自动搜索最近显示信息的日志信息的元素
(function($){
    $.extend($.fn,{
        log:function(msg){
            // 4th 
            if(typeof msg==&quot;object&quot;){
                var str=&quot;{ &quot;
                $.each(msg,function(name,value){
                    str+=name+&quot;:&quot;+value+&quot;,&quot;
                })
                str=str.substring(0,str.length-2)//清除最后一个成员的逗号
                str+=&quot; }&quot;
                msg=str
            }
            // 4th end
            return this.each(function(){
                var $this=$(this)
                while($this.length){
                    var $logbox=$this.find(&quot;.logbox&quot;)//在当前元素内搜索是否存在日志元素
                    if($logbox.length){
                        var html=jQuery(&apos;&lt;div class=&quot;log&quot;&gt;&lt;/div&gt;&apos;).text(msg)
                        $logbox.append(html)
                        break;//跳出检索
                    }
                    $this=$this.parent()//检索上一级匹配元素
                }
            })
        }
    })
})(jQuery)
// 4th 参数的处理机制

//调用
$(function(){
    $(&quot;h1&quot;).mouseout(function(event){
        $(this).log({
            nodeName:this.nodeName.toLowerCase(),
            eventType:event.type
        })
    })
    $(&quot;p&quot;).click(function(event){
        var e=event.type
        $(this).log(this.nodeName.toLowerCase()+&quot;.&quot;+e)
    })
})
</code></pre><h4 id="4-jQ插件应该注意的问题"><a href="#4-jQ插件应该注意的问题" class="headerlink" title="4 jQ插件应该注意的问题"></a>4 jQ插件应该注意的问题</h4><ol>
<li>命名规则<br>jquery.plug-in_name.js </li>
<li>基本思想<br>方法jQuery.fn,功能jQuery</li>
<li>方法内的this关键字<br>插件方法-jQuery对象；jQuery方法，该函数上下文</li>
<li>迭代匹配元素<br>this.ecah()  this–&gt;当前匹配的DOM元素</li>
<li>方法返回值<br>除特定，都jQuery对象。或返回创建新的jQuery对象</li>
<li>方便压缩<br>末尾必须加上分号</li>
<li>jQuery和$有区别</li>
</ol>
<p>// TODO:非常值得思考；写自己的插件，基于或者没有jQuery</p>
<p style="text-align:right">2018.1.19 星期五 0：42 P337</p>

<p style="text-align:right">2018.1.20 星期六 17：42</p>

<h3 id="8-2-创建jQ插件实战"><a href="#8-2-创建jQ插件实战" class="headerlink" title="8.2 创建jQ插件实战"></a>8.2 创建jQ插件实战</h3><h4 id="1-简化式插件设计"><a href="#1-简化式插件设计" class="headerlink" title="1 简化式插件设计"></a>1 简化式插件设计</h4><pre><code>$.extend($.fn,{
    showIn:function(speed,fn){
        return this.animate({
            height:&quot;show&quot;,
            opacity:&quot;show&quot;
        },speed,fn)
    },
    hideOut:function(){}
})
</code></pre><p>ajax()–&gt;get(),load(),getJSON(),bind(),click(),mouseover()    </p>
<h4 id="2-定宽输出插件"><a href="#2-定宽输出插件" class="headerlink" title="2 定宽输出插件"></a>2 定宽输出插件</h4><pre><code>(function($){
    $.extend($,{
        fixedWidth:function(str,length,char){
            str=str.toString()
            if(!char) char=&quot;...&quot;
            var num=length-lengthB(str)
            if(num&lt;0){
                str=substringB(str,length-lengthB(char))
            }
            return str
            function substringB(str,length){
                var num=0,len=str.length,lenp=&quot;&quot;
                if(len){
                    for(var i=0;i&lt;len;i++){
                        if(num&gt;length) break
                        if(str.charCodeAt(i)&gt;255){
                            num+=2
                            tenp+=str.charAt(i)
                        }else{
                            num++
                            tenp+=str.charAt(i)
                        }
                    }
                    return tenp
                }else{
                    return null
                }
            }
            function lengthB(str){
                var num=0,len=str.length
                if(len){
                    for(var i=0;i&lt;len;i++){
                        if(str.charCodeAt(i)&gt;255){
                            num+=2
                        }else{
                            num++
                        }
                    }
                    return
                }else{
                    return 0
                }
            }
        }
    })
})(jQuery)
</code></pre><h4 id="3-Tab选项卡插件"><a href="#3-Tab选项卡插件" class="headerlink" title="3 Tab选项卡插件"></a>3 Tab选项卡插件</h4><pre><code>(function($){
    var isShow=false
    $.fn.tab=function(options){//类型构造函数
        this.opts=$.extend({},$.fn.tab.defaults,options)
        this._init()
    }
    $.fn.tab.prototype={
        _init:function(){
            var _this=this
            if()

        },
        setDisable:function(index){
            var 
        },
        setEnable:function(index){},
        triggleTab:function(index){},

    }
    $.fn.ta.defaults={

    }
    function showContent(index,opts){

    }
})(jQuery)
</code></pre><h3 id="8-3-jQ-UI插件应用"><a href="#8-3-jQ-UI插件应用" class="headerlink" title="8.3 jQ UI插件应用"></a>8.3 jQ UI插件应用</h3><p><a href="http://plugins.jquery.com" target="_blank" rel="noopener">http://plugins.jquery.com</a><br>Ajax,animattion and Effects,Browser Tweaks,…</p>
<h4 id="1-如何使用外部插件"><a href="#1-如何使用外部插件" class="headerlink" title="1 如何使用外部插件"></a>1 如何使用外部插件</h4><h4 id="2-认识UI插件"><a href="#2-认识UI插件" class="headerlink" title="2 认识UI插件"></a>2 认识UI插件</h4><p>User Interface  <a href="http://jqueryui.com" target="_blank" rel="noopener">http://jqueryui.com</a><br>交互、部件、效果<br>demos,docs,themes,ui,external<br>可自定义选择 下载</p>
<h4 id="3-调整大小"><a href="#3-调整大小" class="headerlink" title="3 调整大小"></a>3 调整大小</h4><h4 id="4-日期选择器"><a href="#4-日期选择器" class="headerlink" title="4 日期选择器"></a>4 日期选择器</h4><p style="text-align:right">18：36</p>

<p>// TODO:第二节，fixedWidth和tab插件的定义，值得学习。包括简化式插件思想<br>    // 自己写写</p>
<h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h3 id="9-1-检测浏览器"><a href="#9-1-检测浏览器" class="headerlink" title="9.1 检测浏览器"></a>9.1 检测浏览器</h3><h3 id="9-2-字符串处理"><a href="#9-2-字符串处理" class="headerlink" title="9.2 字符串处理"></a>9.2 字符串处理</h3><h3 id="9-3-数组处理"><a href="#9-3-数组处理" class="headerlink" title="9.3 数组处理"></a>9.3 数组处理</h3><h3 id="9-4-多库共存"><a href="#9-4-多库共存" class="headerlink" title="9.4 多库共存"></a>9.4 多库共存</h3><h3 id="9-5-数据缓存"><a href="#9-5-数据缓存" class="headerlink" title="9.5 数据缓存"></a>9.5 数据缓存</h3><h3 id="9-6-数据队列"><a href="#9-6-数据队列" class="headerlink" title="9.6 数据队列"></a>9.6 数据队列</h3><h3 id="9-7-内核工具"><a href="#9-7-内核工具" class="headerlink" title="9.7 内核工具"></a>9.7 内核工具</h3><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2><p style="text-align:right">2018.1. 星期 P</p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-6_动画效果设计及其高效实践</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%206%20%E7%AB%A0%20%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h3 id="5-1-事件模型"><a href="#5-1-事件模型" class="headerlink" title="5.1 事件模型"></a>5.1 事件模型</h3><h3 id="5-2-jQuery事件模型"><a href="#5-2-jQuery事件模型" class="headerlink" title="5.2 jQuery事件模型"></a>5.2 jQuery事件模型</h3><h3 id="5-3-jQuery页面初始化"><a href="#5-3-jQuery页面初始化" class="headerlink" title="5.3 jQuery页面初始化"></a>5.3 jQuery页面初始化</h3><h3 id="5-4-使用JS自定义jQ的事件方法"><a href="#5-4-使用JS自定义jQ的事件方法" class="headerlink" title="5.4 使用JS自定义jQ的事件方法"></a>5.4 使用JS自定义jQ的事件方法</h3><p style="text-align:right">2018.1.16 星期 23:12</p> 

<h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h3 id="6-1-直接显示和隐藏"><a href="#6-1-直接显示和隐藏" class="headerlink" title="6.1 直接显示和隐藏"></a>6.1 直接显示和隐藏</h3><h4 id="1-jQ实现显隐效果"><a href="#1-jQ实现显隐效果" class="headerlink" title="1 jQ实现显隐效果"></a>1 jQ实现显隐效果</h4><h4 id="2-JS实现显隐效果"><a href="#2-JS实现显隐效果" class="headerlink" title="2 JS实现显隐效果"></a>2 JS实现显隐效果</h4><pre><code>DOMextend(&quot;show&quot;,function(){
    var _this=this
    _this.style.display=&quot;&quot;
    return _this
})
</code></pre><h4 id="3-折叠效果"><a href="#3-折叠效果" class="headerlink" title="3 折叠效果"></a>3 折叠效果</h4><h4 id="4-树形结构"><a href="#4-树形结构" class="headerlink" title="4 树形结构"></a>4 树形结构</h4><h4 id="5-Tab选项卡"><a href="#5-Tab选项卡" class="headerlink" title="5 Tab选项卡"></a>5 Tab选项卡</h4><h4 id="6-显隐切换"><a href="#6-显隐切换" class="headerlink" title="6 显隐切换"></a>6 显隐切换</h4><h3 id="6-2-滑动显示和隐藏"><a href="#6-2-滑动显示和隐藏" class="headerlink" title="6.2 滑动显示和隐藏"></a>6.2 滑动显示和隐藏</h3><h4 id="1-jQ实现的滑动显隐效果"><a href="#1-jQ实现的滑动显隐效果" class="headerlink" title="1 jQ实现的滑动显隐效果"></a>1 jQ实现的滑动显隐效果</h4><h4 id="2-JS实现的滑动显示效果"><a href="#2-JS实现的滑动显示效果" class="headerlink" title="2 JS实现的滑动显示效果"></a>2 JS实现的滑动显示效果</h4><p>slideDown(t,fn)<br>// EXCLUDE:setInterval实现的；可能已经不具有现实意义了</p>
<h4 id="3-JS实现的滑动隐藏效果"><a href="#3-JS实现的滑动隐藏效果" class="headerlink" title="3 JS实现的滑动隐藏效果"></a>3 JS实现的滑动隐藏效果</h4><p>// EXCLUDE:setInterval实现的；可能已经不具有现实意义了</p>
<h4 id="4-jQ设计的滑动显隐切换"><a href="#4-jQ设计的滑动显隐切换" class="headerlink" title="4 jQ设计的滑动显隐切换"></a>4 jQ设计的滑动显隐切换</h4><p>slideToggle()</p>
<p>// NOTE:自己做的playerNote，用了css3的height，transition，性能应该好一些<br>// TODO:可以考虑封装一波</p>
<h3 id="6-3-渐隐和渐显"><a href="#6-3-渐隐和渐显" class="headerlink" title="6.3 渐隐和渐显"></a>6.3 渐隐和渐显</h3><p>不透明度</p>
<h4 id="1-jQ实现的渐隐渐显效果"><a href="#1-jQ实现的渐隐渐显效果" class="headerlink" title="1 jQ实现的渐隐渐显效果"></a>1 jQ实现的渐隐渐显效果</h4><p>fadeIn(t,fn),fadeOut(),fadeTo(2000,0.4)</p>
<h4 id="2-JS实现的渐显效果"><a href="#2-JS实现的渐显效果" class="headerlink" title="2 JS实现的渐显效果"></a>2 JS实现的渐显效果</h4><pre><code>DOMextend(&apos;setOpacity&apos;,function(n){
    var _this=this
    var n=parseFloat(n)
    if(n&amp;&amp;(n&gt;100)||!n) n=100
    if(n&amp;&amp;n&lt;0&gt;) n=0
    if(_this.filters){
        _this.style.filter=&quot;alpha(opacity=&quot;+n+&quot;)&quot;
    }else{
        _this.style.opacity=n/100
    }
})
</code></pre><p>// EXCLUDE:setInterval实现的；可能已经不具有现实意义了</p>
<h4 id="3-JS实现的渐隐效果"><a href="#3-JS实现的渐隐效果" class="headerlink" title="3 JS实现的渐隐效果"></a>3 JS实现的渐隐效果</h4><p>// EXCLUDE:setInterval实现的；可能已经不具有现实意义了<br>    DOMextend(‘fadeOut’,function(time,fn){<br>        var _this=this<br>        var isShow=_this.getStyle(‘display’)<br>        if(isShow==’none’) return<br>        var t=5 //设置定时器的间隔时间为5毫秒<br>        var step=t*100/time  //计算步长<br>        var i=100 //定义不透明度初始值为100<br>        var interval=setInterval(function(){<br>            _this.setOpacity(i)<br>            i-=step<br>            if(i&lt;=0){<br>                clearTimout(interval)<br>                _this.style.display=’none’<br>                if(fn)//如果存在回调函数，则调用该回调函数<br>                    fn()<br>            }<br>        },t)<br>    })</p>
<h3 id="6-4-自定义动画"><a href="#6-4-自定义动画" class="headerlink" title="6.4 自定义动画"></a>6.4 自定义动画</h3><h4 id="1-jQ自定义动画"><a href="#1-jQ自定义动画" class="headerlink" title="1 jQ自定义动画"></a>1 jQ自定义动画</h4><p>animate({animateObj},t,effect,fn)<br>animate({animateObj},[others])</p>
<h4 id="2-使用jQ停止动画"><a href="#2-使用jQ停止动画" class="headerlink" title="2 使用jQ停止动画"></a>2 使用jQ停止动画</h4><p>stop(是否清空队列,是否立即完成)</p>
<h4 id="3-使用jQ关闭动画"><a href="#3-使用jQ关闭动画" class="headerlink" title="3 使用jQ关闭动画"></a>3 使用jQ关闭动画</h4><p>jQuery.fx.off=true</p>
<h4 id="4-使用JS实现滚动动画"><a href="#4-使用JS实现滚动动画" class="headerlink" title="4 使用JS实现滚动动画"></a>4 使用JS实现滚动动画</h4><pre><code>var $=function(id){
    retrun &quot;string&quot;==typeof id? document.getElementById(id):id
}
var addEventHandler=function(oTarget,sEventType,fnHandler){
    if(oTarget.addEventHandler){//DOM 2事件处理模型
        oTarget.addEventHandler(sEventType,fnHandler)
    }else if(oTarget.attachEvent){
        oTarget.attachEvent(&quot;on&quot;+sEventType,fnHandler)
    }else{//DOM 0 级事件模型
        oTarget[&quot;on&quot;+sEventType]=fnHandler
    }
}

var Scroller=function(){
    this.init.apply(this,arguments)
}
Scroller.prototype={
    init:function(box,scroller,left,right,options){
        var _this=this,box=$(box),scroller=$(scroller)
        this.boxWidth=box.offsetWidth
        this.scroWidth=scroller.offsetWidth
        if(this.scroWidth&lt;=this.boxWidth) return
        box.style.overflow=&quot;hidden&quot;
        scroller.appendChild(scroller.cloneNode(true))
        this.box=box
        this.scroll=true
        this.setOptions(optionis)
        this.side=1//滚动方向向左
        switch(this.options.Side){
            case &quot;right&quot;:
                this.side=-1
                break;
            case &quot;left&quot;:
            default:
                tihs.side=1    
        }
        addEventHandler(scroller,&quot;mouseover&quot;，function(){_this.scroll=false})
        addEventHandler(scroller,&quot;mouseout&quot;，function(){_this.scroll=true})
        if(left){addEventHandler($(left),&quot;click&quot;,function(){_this.side=1})}
        if(right){addEventHandler($(right),&quot;click&quot;,function(){_this.side=-1})}
    },
    setOptions:function(options){
        this.options={//默认值
            Step:1,
            Time:10,
            Side:&quot;left&quot;
        }
        var options=options||{}
        for(var property in options){
            this.options[property]=options[property]
        }
    },
    scrolling:function(){
        if(this.scroll){
            var iscroll=this.box.scrollLeft,thisWidth=this.boxWidth
            if(this.side&gt;0){
                if(iscroll&gt;=(thisWidth*2-this.boxWidth)){iscroll-=thisWidth} 
            }else{
                if(iscroll&lt;=0){iscroll+=thisWidth}
            }
            this.box.scrollLeft=iscroll+this.optionis.Step*this.side
        }
        var _this=this
        window.setTimeout(function(){
            _this.scrolling()
        },this.options.Time)
    }
}
//最后，调用
new Scroller(&apos;box&apos;,&apos;scroll&apos;,&apos;left&apos;,&apos;right&apos;)
</code></pre><p>// TODO:自定义滚动，轮播，分页<br>    //acuviewer的页面上有滚动，还有分页，可以看一看用的插件，也可能也是自己写的</p>
<p style="text-align:right">2018.1.17 00:12</p>    

<h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h3 id="7-1-Ajax应用的准备"><a href="#7-1-Ajax应用的准备" class="headerlink" title="7.1 Ajax应用的准备"></a>7.1 Ajax应用的准备</h3><h3 id="7-2-Ajax应用的"><a href="#7-2-Ajax应用的" class="headerlink" title="7.2 Ajax应用的"></a>7.2 Ajax应用的</h3><h3 id="7-3-从JS"><a href="#7-3-从JS" class="headerlink" title="7.3 从JS"></a>7.3 从JS</h3><h3 id="7-4-从jQ角度"><a href="#7-4-从jQ角度" class="headerlink" title="7.4 从jQ角度"></a>7.4 从jQ角度</h3><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h3 id="8-1-创建jQ"><a href="#8-1-创建jQ" class="headerlink" title="8.1 创建jQ"></a>8.1 创建jQ</h3><h3 id="8-2-创建jQ"><a href="#8-2-创建jQ" class="headerlink" title="8.2 创建jQ"></a>8.2 创建jQ</h3><h3 id="8-3-jQ-UI插件"><a href="#8-3-jQ-UI插件" class="headerlink" title="8.3 jQ UI插件"></a>8.3 jQ UI插件</h3><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2><p style="text-align:right">2018.1. 星期 P</p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>ECMAScript 6入门</title>
    <url>/pdf/es/ECMAScript6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>来源：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a><br>作者：阮一峰<br>全书第一版已由电子工业出版社于2014年10月出版<br>目前，网站的内容是第二版的初稿，预订2016年年初出版。 </p>
<p style="text-align:right">2018.1.14 星期日 23:08</p>


<h2 id="一-ECMAScript-6简介"><a href="#一-ECMAScript-6简介" class="headerlink" title="一 ECMAScript 6简介"></a>一 ECMAScript 6简介</h2><h3 id="1-1-ECMAScript和JavaScript的关系"><a href="#1-1-ECMAScript和JavaScript的关系" class="headerlink" title="1.1 ECMAScript和JavaScript的关系"></a>1.1 ECMAScript和JavaScript的关系</h3><h3 id="1-2-ECMAScript的历史"><a href="#1-2-ECMAScript的历史" class="headerlink" title="1.2 ECMAScript的历史"></a>1.2 ECMAScript的历史</h3><h3 id="1-3-部署进度"><a href="#1-3-部署进度" class="headerlink" title="1.3 部署进度"></a>1.3 部署进度</h3><h3 id="1-4-Babel转码器"><a href="#1-4-Babel转码器" class="headerlink" title="1.4 Babel转码器"></a>1.4 Babel转码器</h3><h3 id="1-5-Traceur转码器"><a href="#1-5-Traceur转码器" class="headerlink" title="1.5 Traceur转码器"></a>1.5 Traceur转码器</h3><h4 id="1-直接插入网页"><a href="#1-直接插入网页" class="headerlink" title="1 直接插入网页"></a>1 直接插入网页</h4><h4 id="2-在线转换"><a href="#2-在线转换" class="headerlink" title="2 在线转换"></a>2 在线转换</h4><h4 id="3-命令行转换"><a href="#3-命令行转换" class="headerlink" title="3 命令行转换"></a>3 命令行转换</h4><h4 id="4-Node-js环境的用法"><a href="#4-Node-js环境的用法" class="headerlink" title="4 Node.js环境的用法"></a>4 Node.js环境的用法</h4><h3 id="1-6-ECMAScript-7"><a href="#1-6-ECMAScript-7" class="headerlink" title="1.6 ECMAScript 7"></a>1.6 ECMAScript 7</h3><h2 id="二-let和const命令"><a href="#二-let和const命令" class="headerlink" title="二 let和const命令"></a>二 let和const命令</h2><h2 id="三-变量的解构赋值"><a href="#三-变量的解构赋值" class="headerlink" title="三 变量的解构赋值"></a>三 变量的解构赋值</h2><h2 id="四-字符串的扩展"><a href="#四-字符串的扩展" class="headerlink" title="四 字符串的扩展"></a>四 字符串的扩展</h2><h2 id="五-数值的扩展"><a href="#五-数值的扩展" class="headerlink" title="五 数值的扩展"></a>五 数值的扩展</h2><h2 id="六-数组的扩展"><a href="#六-数组的扩展" class="headerlink" title="六 数组的扩展"></a>六 数组的扩展</h2><h2 id="七-对象的扩展"><a href="#七-对象的扩展" class="headerlink" title="七 对象的扩展"></a>七 对象的扩展</h2><h2 id="八-函数的扩展"><a href="#八-函数的扩展" class="headerlink" title="八 函数的扩展"></a>八 函数的扩展</h2><h2 id="九-Set和Map数据"><a href="#九-Set和Map数据" class="headerlink" title="九 Set和Map数据"></a>九 Set和Map数据</h2><h2 id="零-Iterator和for…of"><a href="#零-Iterator和for…of" class="headerlink" title="零 Iterator和for…of.."></a>零 Iterator和for…of..</h2><h2 id="一-Generator函数"><a href="#一-Generator函数" class="headerlink" title="一 Generator函数"></a>一 Generator函数</h2><h2 id="二-Promise对象"><a href="#二-Promise对象" class="headerlink" title="二 Promise对象"></a>二 Promise对象</h2><h3 id="2-1-Promise的含义"><a href="#2-1-Promise的含义" class="headerlink" title="2.1 Promise的含义"></a>2.1 Promise的含义</h3><h3 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h3><h3 id="2-3-Promise-prototype-then"><a href="#2-3-Promise-prototype-then" class="headerlink" title="2.3 Promise.prototype.then()"></a>2.3 Promise.prototype.then()</h3><h3 id="2-4-Promise-prototype-catch"><a href="#2-4-Promise-prototype-catch" class="headerlink" title="2.4 Promise.prototype.catch()"></a>2.4 Promise.prototype.catch()</h3><h3 id="2-5-Promise-all"><a href="#2-5-Promise-all" class="headerlink" title="2.5 Promise.all()"></a>2.5 Promise.all()</h3><h3 id="2-6-Promise-race"><a href="#2-6-Promise-race" class="headerlink" title="2.6 Promise.race()"></a>2.6 Promise.race()</h3><h3 id="2-7-Promise-reject"><a href="#2-7-Promise-reject" class="headerlink" title="2.7 Promise.reject()"></a>2.7 Promise.reject()</h3><h3 id="2-8-Generator函数与Promise的结合"><a href="#2-8-Generator函数与Promise的结合" class="headerlink" title="2.8 Generator函数与Promise的结合"></a>2.8 Generator函数与Promise的结合</h3><h3 id="2-9-async函数"><a href="#2-9-async函数" class="headerlink" title="2.9 async函数"></a>2.9 async函数</h3><h2 id="三-异步操作"><a href="#三-异步操作" class="headerlink" title="三 异步操作"></a>三 异步操作</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><h3 id="3-2-Generator函数"><a href="#3-2-Generator函数" class="headerlink" title="3.2 Generator函数"></a>3.2 Generator函数</h3><h3 id="3-3-Thunk函数"><a href="#3-3-Thunk函数" class="headerlink" title="3.3 Thunk函数"></a>3.3 Thunk函数</h3><h3 id="3-4-co模块"><a href="#3-4-co模块" class="headerlink" title="3.4 co模块"></a>3.4 co模块</h3><h3 id="3-5-async函数"><a href="#3-5-async函数" class="headerlink" title="3.5 async函数"></a>3.5 async函数</h3><h2 id="四-Class"><a href="#四-Class" class="headerlink" title="四 Class"></a>四 Class</h2><h3 id="4-1-Class基本语法"><a href="#4-1-Class基本语法" class="headerlink" title="4.1 Class基本语法"></a>4.1 Class基本语法</h3><h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><h4 id="（2）constructor方法"><a href="#（2）constructor方法" class="headerlink" title="（2）constructor方法"></a>（2）constructor方法</h4><h4 id="（3）实例对象"><a href="#（3）实例对象" class="headerlink" title="（3）实例对象"></a>（3）实例对象</h4><h4 id="（4）name属性"><a href="#（4）name属性" class="headerlink" title="（4）name属性"></a>（4）name属性</h4><h4 id="（5）Class表达式"><a href="#（5）Class表达式" class="headerlink" title="（5）Class表达式"></a>（5）Class表达式</h4><h4 id="（6）不存在变量提升"><a href="#（6）不存在变量提升" class="headerlink" title="（6）不存在变量提升"></a>（6）不存在变量提升</h4><h4 id="（7）严格模式"><a href="#（7）严格模式" class="headerlink" title="（7）严格模式"></a>（7）严格模式</h4><h3 id="4-2-Class的继承"><a href="#4-2-Class的继承" class="headerlink" title="4.2 Class的继承"></a>4.2 Class的继承</h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h4><h4 id="2-类的prototype属性和proto属性"><a href="#2-类的prototype属性和proto属性" class="headerlink" title="2 类的prototype属性和proto属性"></a>2 类的prototype属性和proto属性</h4><h4 id="3-Object-getPrototypeOf"><a href="#3-Object-getPrototypeOf" class="headerlink" title="3 Object.getPrototypeOf()"></a>3 Object.getPrototypeOf()</h4><h4 id="4-实例的proto属性"><a href="#4-实例的proto属性" class="headerlink" title="4 实例的proto属性"></a>4 实例的proto属性</h4><h4 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5 原生构造函数的继承"></a>5 原生构造函数的继承</h4><h4 id="6-class的取值函数（getter）和存值函数（setter）"><a href="#6-class的取值函数（getter）和存值函数（setter）" class="headerlink" title="6 class的取值函数（getter）和存值函数（setter）"></a>6 class的取值函数（getter）和存值函数（setter）</h4><h4 id="7-Class的Generator方法"><a href="#7-Class的Generator方法" class="headerlink" title="7 Class的Generator方法"></a>7 Class的Generator方法</h4><h3 id="4-3-Class的静态方法"><a href="#4-3-Class的静态方法" class="headerlink" title="4.3 Class的静态方法"></a>4.3 Class的静态方法</h3><h3 id="4-4-new-target属性"><a href="#4-4-new-target属性" class="headerlink" title="4.4 new.target属性"></a>4.4 new.target属性</h3><h3 id="4-5-修饰器"><a href="#4-5-修饰器" class="headerlink" title="4.5 修饰器"></a>4.5 修饰器</h3><h4 id="1-类的修饰"><a href="#1-类的修饰" class="headerlink" title="1 类的修饰"></a>1 类的修饰</h4><h4 id="2-方法的修饰"><a href="#2-方法的修饰" class="headerlink" title="2 方法的修饰"></a>2 方法的修饰</h4><h4 id="3-core-decorators-js"><a href="#3-core-decorators-js" class="headerlink" title="3 core-decorators.js"></a>3 core-decorators.js</h4><h4 id="4-Mixin"><a href="#4-Mixin" class="headerlink" title="4 Mixin"></a>4 Mixin</h4><h4 id="5-Trait"><a href="#5-Trait" class="headerlink" title="5 Trait"></a>5 Trait</h4><h4 id="6-Babel转码器的支持"><a href="#6-Babel转码器的支持" class="headerlink" title="6 Babel转码器的支持"></a>6 Babel转码器的支持</h4><h2 id="五-Module"><a href="#五-Module" class="headerlink" title="五 Module"></a>五 Module</h2><h3 id="5-1-export命令"><a href="#5-1-export命令" class="headerlink" title="5.1 export命令"></a>5.1 export命令</h3><h3 id="5-2-import命令"><a href="#5-2-import命令" class="headerlink" title="5.2 import命令"></a>5.2 import命令</h3><h3 id="5-3-模块的整体输入"><a href="#5-3-模块的整体输入" class="headerlink" title="5.3 模块的整体输入"></a>5.3 模块的整体输入</h3><h3 id="5-4-module命令"><a href="#5-4-module命令" class="headerlink" title="5.4 module命令"></a>5.4 module命令</h3><h3 id="5-5-export-default命令"><a href="#5-5-export-default命令" class="headerlink" title="5.5 export default命令"></a>5.5 export default命令</h3><h3 id="5-6-模块的继承"><a href="#5-6-模块的继承" class="headerlink" title="5.6 模块的继承"></a>5.6 模块的继承</h3><h3 id="5-7-ES6模块的转码"><a href="#5-7-ES6模块的转码" class="headerlink" title="5.7 ES6模块的转码"></a>5.7 ES6模块的转码</h3><h4 id="1-ES6-module-transpiler"><a href="#1-ES6-module-transpiler" class="headerlink" title="1 ES6 module transpiler"></a>1 ES6 module transpiler</h4><h4 id="2-SystemJS"><a href="#2-SystemJS" class="headerlink" title="2 SystemJS"></a>2 SystemJS</h4><h2 id="六-编程风格"><a href="#六-编程风格" class="headerlink" title="六 编程风格"></a>六 编程风格</h2><h3 id="6-1-块级作用域"><a href="#6-1-块级作用域" class="headerlink" title="6.1 块级作用域"></a>6.1 块级作用域</h3><h4 id="（1）let取代var"><a href="#（1）let取代var" class="headerlink" title="（1）let取代var"></a>（1）let取代var</h4><h4 id="（2）全局常量和线程安全"><a href="#（2）全局常量和线程安全" class="headerlink" title="（2）全局常量和线程安全"></a>（2）全局常量和线程安全</h4><h4 id="（3）严格模式"><a href="#（3）严格模式" class="headerlink" title="（3）严格模式"></a>（3）严格模式</h4><h3 id="6-2-字符串"><a href="#6-2-字符串" class="headerlink" title="6.2 字符串"></a>6.2 字符串</h3><h3 id="6-3-解构赋值"><a href="#6-3-解构赋值" class="headerlink" title="6.3 解构赋值"></a>6.3 解构赋值</h3><h3 id="6-4-对象"><a href="#6-4-对象" class="headerlink" title="6.4 对象"></a>6.4 对象</h3><h3 id="6-5-数组"><a href="#6-5-数组" class="headerlink" title="6.5 数组"></a>6.5 数组</h3><h3 id="6-6-函数"><a href="#6-6-函数" class="headerlink" title="6.6 函数"></a>6.6 函数</h3><h3 id="6-7-Map结构"><a href="#6-7-Map结构" class="headerlink" title="6.7 Map结构"></a>6.7 Map结构</h3><h3 id="6-8-Class"><a href="#6-8-Class" class="headerlink" title="6.8 Class"></a>6.8 Class</h3><h3 id="6-9-模块"><a href="#6-9-模块" class="headerlink" title="6.9 模块"></a>6.9 模块</h3><h2 id="七-参考链接"><a href="#七-参考链接" class="headerlink" title="七 参考链接"></a>七 参考链接</h2><h3 id="7-1-官方文件"><a href="#7-1-官方文件" class="headerlink" title="7.1 官方文件"></a>7.1 官方文件</h3><h3 id="7-2-综合介绍"><a href="#7-2-综合介绍" class="headerlink" title="7.2 综合介绍"></a>7.2 综合介绍</h3><p style="text-align:right">2018.</p>

<p>读后总结： </p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出ES6</title>
    <url>/pdf/es/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAES6/</url>
    <content><![CDATA[<p style="text-align:right">2018.1.13 六 16:43</p>

<h2 id="一-ES6是什么"><a href="#一-ES6是什么" class="headerlink" title="一 ES6是什么"></a>一 ES6是什么</h2><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-an-introduction" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/es6-in-depth-an-introduction</a><br> 作者 Jason Orendorff ，译者 刘振涛 发布于 2015年6月5日</p>
<h3 id="1-1-ECMAScript发生了什么变化？"><a href="#1-1-ECMAScript发生了什么变化？" class="headerlink" title="1.1 ECMAScript发生了什么变化？"></a>1.1 ECMAScript发生了什么变化？</h3><ol>
<li>语言语法 – 语法解析规则、关键字、语句、声明、运算符等。</li>
<li>类型 – 布尔型、数字、字符串、对象等。</li>
<li>原型和继承</li>
<li>内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。<h3 id="1-2-新标准"><a href="#1-2-新标准" class="headerlink" title="1.2 新标准"></a>1.2 新标准</h3><h3 id="1-3-版本号6"><a href="#1-3-版本号6" class="headerlink" title="1.3 版本号6"></a>1.3 版本号6</h3><h3 id="1-6-兑现承诺"><a href="#1-6-兑现承诺" class="headerlink" title="1.6 兑现承诺"></a>1.6 兑现承诺</h3></li>
</ol>
<h2 id="二-迭代器和for-of循环"><a href="#二-迭代器和for-of循环" class="headerlink" title="二 迭代器和for-of循环"></a>二 迭代器和for-of循环</h2><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop</a><br>作者 Jason Orendorff ，译者 刘振涛 发布于 2015年6月26日. 估计阅读时间: 16 分钟</p>
<ol>
<li>for(var i=0;i&lt;arr.length;i++){}，arr.forEach()<br>不能break，return，</li>
<li>for-in ，字符串”1”,”2”(计算有问题)；自定义属性也可以，包括原型链；某些情况随机的顺序<h3 id="2-1强大的for-of循环"><a href="#2-1强大的for-of循环" class="headerlink" title="2.1强大的for-of循环"></a>2.1强大的for-of循环</h3></li>
</ol>
<h3 id="2-2-for-of循环也可以遍历其它的集合"><a href="#2-2-for-of循环也可以遍历其它的集合" class="headerlink" title="2.2 for-of循环也可以遍历其它的集合"></a>2.2 for-of循环也可以遍历其它的集合</h3><p>数组，类数组，字符串，Map，Set。不支持普通对象</p>
<h3 id="2-3-深入理解"><a href="#2-3-深入理解" class="headerlink" title="2.3 深入理解"></a>2.3 深入理解</h3><p>for-of<em>循环语句通过方法调用来遍历各种集合</em>。数组、Maps对象、Sets对象以及其它在我们讨论的对象有一个共同点，它们都有一个迭代器方法。<br>你可以给任意类型的对象添加迭代器方法。</p>
<pre><code>// 因为jQuery对象与数组相似
// 可以为其添加与数组一致的迭代器方法
jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
</code></pre><h3 id="2-4-迭代器对象"><a href="#2-4-迭代器对象" class="headerlink" title="2.4 迭代器对象"></a>2.4 迭代器对象</h3><h3 id="2-5-我何时可以开始使用这一新特性？"><a href="#2-5-我何时可以开始使用这一新特性？" class="headerlink" title="2.5 我何时可以开始使用这一新特性？"></a>2.5 我何时可以开始使用这一新特性？</h3><h2 id="三-生成器"><a href="#三-生成器" class="headerlink" title="三 生成器"></a>三 生成器</h2><p><a href="http://www.infoq.com/cn/articles/es6-in-depth-generators" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/es6-in-depth-generators</a><br>“最具魔力的”      它甚至可以帮助你逃离“回调地狱”。</p>
<h3 id="3-1-ES6生成器（Generators）简介"><a href="#3-1-ES6生成器（Generators）简介" class="headerlink" title="3.1 ES6生成器（Generators）简介"></a>3.1 ES6生成器（Generators）简介</h3><h3 id="3-2-生成器做了什么？"><a href="#3-2-生成器做了什么？" class="headerlink" title="3.2 生成器做了什么？"></a>3.2 生成器做了什么？</h3><h3 id="3-3-生成器是迭代器！"><a href="#3-3-生成器是迭代器！" class="headerlink" title="3.3 生成器是迭代器！"></a>3.3 生成器是迭代器！</h3><h3 id="3-4-生成器和异步代码"><a href="#3-4-生成器和异步代码" class="headerlink" title="3.4 生成器和异步代码"></a>3.4 生成器和异步代码</h3><h3 id="3-5-如何应用这些疯狂的新特性？"><a href="#3-5-如何应用这些疯狂的新特性？" class="headerlink" title="3.5 如何应用这些疯狂的新特性？"></a>3.5 如何应用这些疯狂的新特性？</h3><h3 id="3-6-yield"><a href="#3-6-yield" class="headerlink" title="3.6 yield"></a>3.6 yield</h3><h2 id="四-模版字符串"><a href="#四-模版字符串" class="headerlink" title="四 模版字符串"></a>四 模版字符串</h2><h3 id="4-1-反撇号（-）基础知识"><a href="#4-1-反撇号（-）基础知识" class="headerlink" title="4.1 反撇号（`）基础知识"></a>4.1 反撇号（`）基础知识</h3><h3 id="4-2-反撇号的未来"><a href="#4-2-反撇号的未来" class="headerlink" title="4.2 反撇号的未来"></a>4.2 反撇号的未来</h3><h3 id="4-3-我什么时候可以开始使用这一特性？"><a href="#4-3-我什么时候可以开始使用这一特性？" class="headerlink" title="4.3 我什么时候可以开始使用这一特性？"></a>4.3 我什么时候可以开始使用这一特性？</h3><h3 id="4-4-等等——那么Markdown呢？"><a href="#4-4-等等——那么Markdown呢？" class="headerlink" title="4.4 等等——那么Markdown呢？"></a>4.4 等等——那么Markdown呢？</h3><h3 id="4-5-下回预告"><a href="#4-5-下回预告" class="headerlink" title="4.5 下回预告"></a>4.5 下回预告</h3><h2 id="五-不定参数和默认参数"><a href="#五-不定参数和默认参数" class="headerlink" title="五 不定参数和默认参数"></a>五 不定参数和默认参数</h2><h3 id="5-1-不定参数"><a href="#5-1-不定参数" class="headerlink" title="5.1 不定参数"></a>5.1 不定参数</h3><h3 id="5-2-默认参数"><a href="#5-2-默认参数" class="headerlink" title="5.2 默认参数"></a>5.2 默认参数</h3><h3 id="5-3-停止使用arguments"><a href="#5-3-停止使用arguments" class="headerlink" title="5.3 停止使用arguments"></a>5.3 停止使用arguments</h3><h3 id="5-4-浏览器支持"><a href="#5-4-浏览器支持" class="headerlink" title="5.4 浏览器支持"></a>5.4 浏览器支持</h3><h3 id="5-5-文后盘点"><a href="#5-5-文后盘点" class="headerlink" title="5.5 文后盘点"></a>5.5 文后盘点</h3><h2 id="六-解构-Destructor"><a href="#六-解构-Destructor" class="headerlink" title="六 解构 Destructor"></a>六 解构 Destructor</h2><h3 id="6-1-什么是解构赋值？"><a href="#6-1-什么是解构赋值？" class="headerlink" title="6.1 什么是解构赋值？"></a>6.1 什么是解构赋值？</h3><h3 id="6-2-数组与迭代器的解构"><a href="#6-2-数组与迭代器的解构" class="headerlink" title="6.2 数组与迭代器的解构"></a>6.2 数组与迭代器的解构</h3><h3 id="6-3-对象的解构"><a href="#6-3-对象的解构" class="headerlink" title="6.3 对象的解构"></a>6.3 对象的解构</h3><h3 id="6-4-解构值不是对象、数组或迭代器"><a href="#6-4-解构值不是对象、数组或迭代器" class="headerlink" title="6.4 解构值不是对象、数组或迭代器"></a>6.4 解构值不是对象、数组或迭代器</h3><h3 id="6-5-默认值"><a href="#6-5-默认值" class="headerlink" title="6.5 默认值"></a>6.5 默认值</h3><h3 id="6-6-解构的实际应用"><a href="#6-6-解构的实际应用" class="headerlink" title="6.6 解构的实际应用"></a>6.6 解构的实际应用</h3><h4 id="1-函数参数定义"><a href="#1-函数参数定义" class="headerlink" title="1 函数参数定义"></a>1 函数参数定义</h4><h4 id="2-配置对象参数"><a href="#2-配置对象参数" class="headerlink" title="2 配置对象参数"></a>2 配置对象参数</h4><h4 id="3-与ES6迭代器协议协同使用"><a href="#3-与ES6迭代器协议协同使用" class="headerlink" title="3 与ES6迭代器协议协同使用"></a>3 与ES6迭代器协议协同使用</h4><h4 id="4-多重返回值"><a href="#4-多重返回值" class="headerlink" title="4 多重返回值"></a>4 多重返回值</h4><h4 id="5-使用解构导入部分CommonJS模块"><a href="#5-使用解构导入部分CommonJS模块" class="headerlink" title="5 使用解构导入部分CommonJS模块"></a>5 使用解构导入部分CommonJS模块</h4><h3 id="6-7-文后盘点"><a href="#6-7-文后盘点" class="headerlink" title="6.7 文后盘点"></a>6.7 文后盘点</h3><h2 id="七-箭头函数-Arrow"><a href="#七-箭头函数-Arrow" class="headerlink" title="七 箭头函数 Arrow"></a>七 箭头函数 Arrow</h2><h3 id="7-1-函数表达式无处不在"><a href="#7-1-函数表达式无处不在" class="headerlink" title="7.1 函数表达式无处不在"></a>7.1 函数表达式无处不在</h3><h3 id="7-2-箭袋中的新羽"><a href="#7-2-箭袋中的新羽" class="headerlink" title="7.2 箭袋中的新羽"></a>7.2 箭袋中的新羽</h3><h3 id="7-3-这个函数的this值是什么呢？"><a href="#7-3-这个函数的this值是什么呢？" class="headerlink" title="7.3 这个函数的this值是什么呢？"></a>7.3 这个函数的this值是什么呢？</h3><h3 id="7-4-借助箭头函数洞悉计算机科学的风尘往事"><a href="#7-4-借助箭头函数洞悉计算机科学的风尘往事" class="headerlink" title="7.4 借助箭头函数洞悉计算机科学的风尘往事"></a>7.4 借助箭头函数洞悉计算机科学的风尘往事</h3><h3 id="7-5-我何时可以使用箭头函数？"><a href="#7-5-我何时可以使用箭头函数？" class="headerlink" title="7.5 我何时可以使用箭头函数？"></a>7.5 我何时可以使用箭头函数？</h3><h2 id="八-Symbols"><a href="#八-Symbols" class="headerlink" title="八 Symbols"></a>八 Symbols</h2><h3 id="8-1-它是JavaScript的第七种原始类型"><a href="#8-1-它是JavaScript的第七种原始类型" class="headerlink" title="8.1 它是JavaScript的第七种原始类型"></a>8.1 它是JavaScript的第七种原始类型</h3><h3 id="8-2-从一个简单的布尔类型出发"><a href="#8-2-从一个简单的布尔类型出发" class="headerlink" title="8.2 从一个简单的布尔类型出发"></a>8.2 从一个简单的布尔类型出发</h3><h3 id="8-3-symbol是最终的解决方案"><a href="#8-3-symbol是最终的解决方案" class="headerlink" title="8.3 symbol是最终的解决方案"></a>8.3 symbol是最终的解决方案</h3><h3 id="8-4-但是，到底什么是symbol呢？"><a href="#8-4-但是，到底什么是symbol呢？" class="headerlink" title="8.4 但是，到底什么是symbol呢？"></a>8.4 但是，到底什么是symbol呢？</h3><h3 id="8-5-获取symbol的三种方法"><a href="#8-5-获取symbol的三种方法" class="headerlink" title="8.5 获取symbol的三种方法"></a>8.5 获取symbol的三种方法</h3><h3 id="8-6-symbol在ES6规范中的应用"><a href="#8-6-symbol在ES6规范中的应用" class="headerlink" title="8.6 symbol在ES6规范中的应用"></a>8.6 symbol在ES6规范中的应用</h3><h3 id="8-7-我何时可以使用ES6-symbol？"><a href="#8-7-我何时可以使用ES6-symbol？" class="headerlink" title="8.7 我何时可以使用ES6 symbol？"></a>8.7 我何时可以使用ES6 symbol？</h3><h2 id="九-学习Babel和Broccoli，马上就用ES6"><a href="#九-学习Babel和Broccoli，马上就用ES6" class="headerlink" title="九 学习Babel和Broccoli，马上就用ES6"></a>九 学习Babel和Broccoli，马上就用ES6</h2><h3 id="9-1-转译技术拯救了我们"><a href="#9-1-转译技术拯救了我们" class="headerlink" title="9.1 转译技术拯救了我们"></a>9.1 转译技术拯救了我们</h3><h3 id="9-2-实际体验Babel"><a href="#9-2-实际体验Babel" class="headerlink" title="9.2 实际体验Babel"></a>9.2 实际体验Babel</h3><h3 id="9-3-我们的首个Broccoli与Babel项目"><a href="#9-3-我们的首个Broccoli与Babel项目" class="headerlink" title="9.3 我们的首个Broccoli与Babel项目"></a>9.3 我们的首个Broccoli与Babel项目</h3><h4 id="1-配置项目"><a href="#1-配置项目" class="headerlink" title="1 配置项目"></a>1 配置项目</h4><ol>
<li>NODE</li>
<li>BROCCOLI<h4 id="2-编写一些ES6代码"><a href="#2-编写一些ES6代码" class="headerlink" title="2 编写一些ES6代码"></a>2 编写一些ES6代码</h4><h4 id="3-转译时刻"><a href="#3-转译时刻" class="headerlink" title="3 转译时刻"></a>3 转译时刻</h4><h3 id="9-4-为网站编写ES6代码"><a href="#9-4-为网站编写ES6代码" class="headerlink" title="9.4 为网站编写ES6代码"></a>9.4 为网站编写ES6代码</h3>$_EXCLUDE：本章有点过时</li>
</ol>
<h3 id="9-5-Babel和Broccoli组合还有更多乐趣"><a href="#9-5-Babel和Broccoli组合还有更多乐趣" class="headerlink" title="9.5 Babel和Broccoli组合还有更多乐趣"></a>9.5 Babel和Broccoli组合还有更多乐趣</h3><p>$_EXCLUDE：本章有点过时</p>
<h2 id="十-集合"><a href="#十-集合" class="headerlink" title="十 集合"></a>十 集合</h2><h3 id="0-1-共同发展中的难题"><a href="#0-1-共同发展中的难题" class="headerlink" title="0.1 共同发展中的难题"></a>0.1 共同发展中的难题</h3><h3 id="0-2-为什么要集合？"><a href="#0-2-为什么要集合？" class="headerlink" title="0.2 为什么要集合？"></a>0.2 为什么要集合？</h3><h3 id="0-3-Set"><a href="#0-3-Set" class="headerlink" title="0.3 Set"></a>0.3 Set</h3><h3 id="0-4-Map"><a href="#0-4-Map" class="headerlink" title="0.4 Map"></a>0.4 Map</h3><h3 id="0-5-JS是不同的，第一部分：没有哈希代码的哈希表？"><a href="#0-5-JS是不同的，第一部分：没有哈希代码的哈希表？" class="headerlink" title="0.5 JS是不同的，第一部分：没有哈希代码的哈希表？"></a>0.5 JS是不同的，第一部分：没有哈希代码的哈希表？</h3><h3 id="0-6-JS是不同的，第二部分：意料之外的可预测性"><a href="#0-6-JS是不同的，第二部分：意料之外的可预测性" class="headerlink" title="0.6 JS是不同的，第二部分：意料之外的可预测性"></a>0.6 JS是不同的，第二部分：意料之外的可预测性</h3><h3 id="0-7-推荐使用弱集合的重要原因"><a href="#0-7-推荐使用弱集合的重要原因" class="headerlink" title="0.7 推荐使用弱集合的重要原因"></a>0.7 推荐使用弱集合的重要原因</h3><h3 id="0-8-WeakMap和WeakSet"><a href="#0-8-WeakMap和WeakSet" class="headerlink" title="0.8 WeakMap和WeakSet"></a>0.8 WeakMap和WeakSet</h3><h3 id="0-9-JS是不同的，第三部分：隐藏垃圾回收的不确定性"><a href="#0-9-JS是不同的，第三部分：隐藏垃圾回收的不确定性" class="headerlink" title="0.9 JS是不同的，第三部分：隐藏垃圾回收的不确定性"></a>0.9 JS是不同的，第三部分：隐藏垃圾回收的不确定性</h3><h3 id="0-0-什么时候可以用上这些集合呢？"><a href="#0-0-什么时候可以用上这些集合呢？" class="headerlink" title="0.0 什么时候可以用上这些集合呢？"></a>0.0 什么时候可以用上这些集合呢？</h3><h2 id="十一-生成器-Generator"><a href="#十一-生成器-Generator" class="headerlink" title="十一 生成器 Generator"></a>十一 生成器 Generator</h2><h3 id="1-1-快速回顾"><a href="#1-1-快速回顾" class="headerlink" title="1.1 快速回顾"></a>1.1 快速回顾</h3><h3 id="1-2-如何关停生成器"><a href="#1-2-如何关停生成器" class="headerlink" title="1.2 如何关停生成器"></a>1.2 如何关停生成器</h3><h3 id="1-3-生成器主导模式"><a href="#1-3-生成器主导模式" class="headerlink" title="1.3 生成器主导模式"></a>1.3 生成器主导模式</h3><h3 id="1-4-如何销毁生成器"><a href="#1-4-如何销毁生成器" class="headerlink" title="1.4 如何销毁生成器"></a>1.4 如何销毁生成器</h3><h3 id="1-5-结合生成器实现更多功能"><a href="#1-5-结合生成器实现更多功能" class="headerlink" title="1.5 结合生成器实现更多功能"></a>1.5 结合生成器实现更多功能</h3><p>$_TODO:再看，没怎么看懂</p>
<h2 id="十二-代理-Proxies"><a href="#十二-代理-Proxies" class="headerlink" title="十二 代理 Proxies"></a>十二 代理 Proxies</h2><h3 id="2-1-它是如何做到的？"><a href="#2-1-它是如何做到的？" class="headerlink" title="2.1 它是如何做到的？"></a>2.1 它是如何做到的？</h3><h3 id="2-2-所以，对象到底是什么？"><a href="#2-2-所以，对象到底是什么？" class="headerlink" title="2.2 所以，对象到底是什么？"></a>2.2 所以，对象到底是什么？</h3><h3 id="2-3-代理-Proxy"><a href="#2-3-代理-Proxy" class="headerlink" title="2.3 代理 Proxy"></a>2.3 代理 Proxy</h3><h3 id="2-4-代理句柄"><a href="#2-4-代理句柄" class="headerlink" title="2.4 代理句柄"></a>2.4 代理句柄</h3><h3 id="2-5-小试牛刀（一）：“不可能实现的”自动填充对象"><a href="#2-5-小试牛刀（一）：“不可能实现的”自动填充对象" class="headerlink" title="2.5 小试牛刀（一）：“不可能实现的”自动填充对象"></a>2.5 小试牛刀（一）：“不可能实现的”自动填充对象</h3><h3 id="2-6-小试牛刀（二）：只读视图"><a href="#2-6-小试牛刀（二）：只读视图" class="headerlink" title="2.6 小试牛刀（二）：只读视图"></a>2.6 小试牛刀（二）：只读视图</h3><h3 id="2-7-只言片语"><a href="#2-7-只言片语" class="headerlink" title="2.7 只言片语"></a>2.7 只言片语</h3><h3 id="2-8-现在，你认为对象是什么？"><a href="#2-8-现在，你认为对象是什么？" class="headerlink" title="2.8 现在，你认为对象是什么？"></a>2.8 现在，你认为对象是什么？</h3><h3 id="2-9-我现在可以使用代理么？"><a href="#2-9-我现在可以使用代理么？" class="headerlink" title="2.9 我现在可以使用代理么？"></a>2.9 我现在可以使用代理么？</h3><p>$<em>TODO:再看，没看懂。<br>    $</em>好消息是，可以先查一下浏览器的兼容性</p>
<h2 id="十三-类-Class"><a href="#十三-类-Class" class="headerlink" title="十三 类 Class"></a>十三 类 Class</h2><h3 id="3-1-目前面临的问题"><a href="#3-1-目前面临的问题" class="headerlink" title="3.1 目前面临的问题"></a>3.1 目前面临的问题</h3><h3 id="3-2-方法定义语法"><a href="#3-2-方法定义语法" class="headerlink" title="3.2 方法定义语法"></a>3.2 方法定义语法</h3><h3 id="3-3-类定义语法"><a href="#3-3-类定义语法" class="headerlink" title="3.3 类定义语法"></a>3.3 类定义语法</h3><h2 id="十四-let和const"><a href="#十四-let和const" class="headerlink" title="十四 let和const"></a>十四 let和const</h2><h3 id="4-1-问题-1：JS没有块级作用域"><a href="#4-1-问题-1：JS没有块级作用域" class="headerlink" title="4.1 问题 #1：JS没有块级作用域"></a>4.1 问题 #1：JS没有块级作用域</h3><h3 id="4-2-问题-2：循环内变量过度共享"><a href="#4-2-问题-2：循环内变量过度共享" class="headerlink" title="4.2 问题 #2：循环内变量过度共享"></a>4.2 问题 #2：循环内变量过度共享</h3><h3 id="4-3-let是更完美的var"><a href="#4-3-let是更完美的var" class="headerlink" title="4.3 let是更完美的var"></a>4.3 let是更完美的var</h3><h3 id="4-4-const"><a href="#4-4-const" class="headerlink" title="4.4 const"></a>4.4 const</h3><h3 id="4-5-神秘的代理命名空间"><a href="#4-5-神秘的代理命名空间" class="headerlink" title="4.5 神秘的代理命名空间"></a>4.5 神秘的代理命名空间</h3><h3 id="4-6-我现在可以使用let和const了么？"><a href="#4-6-我现在可以使用let和const了么？" class="headerlink" title="4.6 我现在可以使用let和const了么？"></a>4.6 我现在可以使用let和const了么？</h3><h2 id="十五-子类-Subcalss"><a href="#十五-子类-Subcalss" class="headerlink" title="十五 子类 Subcalss"></a>十五 子类 Subcalss</h2><h3 id="5-1-JavaScript继承"><a href="#5-1-JavaScript继承" class="headerlink" title="5.1 JavaScript继承"></a>5.1 JavaScript继承</h3><h3 id="5-2-子类化的基本概念"><a href="#5-2-子类化的基本概念" class="headerlink" title="5.2 子类化的基本概念"></a>5.2 子类化的基本概念</h3><h3 id="5-3-Super属性"><a href="#5-3-Super属性" class="headerlink" title="5.3 Super属性"></a>5.3 Super属性</h3><h3 id="5-4-子类化内建方法"><a href="#5-4-子类化内建方法" class="headerlink" title="5.4 子类化内建方法"></a>5.4 子类化内建方法</h3><h3 id="5-5-派生类构造函数"><a href="#5-5-派生类构造函数" class="headerlink" title="5.5 派生类构造函数"></a>5.5 派生类构造函数</h3><h3 id="5-6-new-target"><a href="#5-6-new-target" class="headerlink" title="5.6 new.target"></a>5.6 new.target</h3><h3 id="5-7-鱼和熊掌可以得兼"><a href="#5-7-鱼和熊掌可以得兼" class="headerlink" title="5.7 鱼和熊掌可以得兼"></a>5.7 鱼和熊掌可以得兼</h3><h3 id="5-8-目前的可用性"><a href="#5-8-目前的可用性" class="headerlink" title="5.8 目前的可用性"></a>5.8 目前的可用性</h3><p>$_TODO:再看，没怎么看懂啊。。。</p>
<h2 id="十六-模块-Module"><a href="#十六-模块-Module" class="headerlink" title="十六 模块 Module"></a>十六 模块 Module</h2><h3 id="6-1-模块基础知识"><a href="#6-1-模块基础知识" class="headerlink" title="6.1 模块基础知识"></a>6.1 模块基础知识</h3><h3 id="6-2-Export列表"><a href="#6-2-Export列表" class="headerlink" title="6.2 Export列表"></a>6.2 Export列表</h3><h3 id="6-3-重命名import和export"><a href="#6-3-重命名import和export" class="headerlink" title="6.3 重命名import和export"></a>6.3 重命名import和export</h3><h3 id="6-4-Default-exports"><a href="#6-4-Default-exports" class="headerlink" title="6.4 Default exports"></a>6.4 Default exports</h3><h3 id="6-5-模块对象"><a href="#6-5-模块对象" class="headerlink" title="6.5 模块对象"></a>6.5 模块对象</h3><h3 id="6-6-聚合模块"><a href="#6-6-聚合模块" class="headerlink" title="6.6 聚合模块"></a>6.6 聚合模块</h3><h3 id="6-7-import实际都做了些什么？"><a href="#6-7-import实际都做了些什么？" class="headerlink" title="6.7 import实际都做了些什么？"></a>6.7 import实际都做了些什么？</h3><h3 id="6-8-静态vs动态：论规则及破例之法"><a href="#6-8-静态vs动态：论规则及破例之法" class="headerlink" title="6.8 静态vs动态：论规则及破例之法"></a>6.8 静态vs动态：论规则及破例之法</h3><h3 id="6-9-我什么时候可以使用ES6模块？"><a href="#6-9-我什么时候可以使用ES6模块？" class="headerlink" title="6.9 我什么时候可以使用ES6模块？"></a>6.9 我什么时候可以使用ES6模块？</h3><h2 id="十七-展望未来"><a href="#十七-展望未来" class="headerlink" title="十七 展望未来"></a>十七 展望未来</h2><h3 id="7-1-你可能正在使用的特性"><a href="#7-1-你可能正在使用的特性" class="headerlink" title="7.1 你可能正在使用的特性"></a>7.1 你可能正在使用的特性</h3><h3 id="7-2-实用特性"><a href="#7-2-实用特性" class="headerlink" title="7.2 实用特性"></a>7.2 实用特性</h3><h3 id="7-3-文本"><a href="#7-3-文本" class="headerlink" title="7.3 文本"></a>7.3 文本</h3><h3 id="7-4-数字"><a href="#7-4-数字" class="headerlink" title="7.4 数字"></a>7.4 数字</h3><h3 id="7-5-最后的最后"><a href="#7-5-最后的最后" class="headerlink" title="7.5 最后的最后"></a>7.5 最后的最后</h3><p style="text-align:right">2018.1.13 23：28</p>

<p>读后总结：<br>更像是一个标准出来之前的发布介绍会。文中对ES6 新增的东西，分类做了陈述；好像还有一些现在能见到的知识点，没有说明。<br>该系列是从整体上，学习、分析ES6，从其语法-引用，是从语言的角度做阐述说明。</p>
<p>实际应用（具体语法使用）几乎可以说是没有介绍，毕竟是笼统的说明。<br>加上可能有一些滞后性，还需要再看ES6入门-ruan，然后应用到实际代码中</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>目录 </p>
<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h3 id="1-1-认识jQuery"><a href="#1-1-认识jQuery" class="headerlink" title="1.1 认识jQuery"></a>1.1 认识jQuery</h3><h3 id="1-2-jQuery初步体验"><a href="#1-2-jQuery初步体验" class="headerlink" title="1.2 jQuery初步体验"></a>1.2 jQuery初步体验</h3><h3 id="1-3-jQuery核心特性"><a href="#1-3-jQuery核心特性" class="headerlink" title="1.3 jQuery核心特性"></a>1.3 jQuery核心特性</h3><h4 id="1-jQuery构造函数"><a href="#1-jQuery构造函数" class="headerlink" title="1 jQuery构造函数"></a>1 jQuery构造函数</h4><h4 id="2-jQuery链式语法"><a href="#2-jQuery链式语法" class="headerlink" title="2 jQuery链式语法"></a>2 jQuery链式语法</h4><h4 id="3-jQuery选择器"><a href="#3-jQuery选择器" class="headerlink" title="3 jQuery选择器"></a>3 jQuery选择器</h4><h4 id="4-jQuery扩展性"><a href="#4-jQuery扩展性" class="headerlink" title="4 jQuery扩展性"></a>4 jQuery扩展性</h4><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h3 id="2-1-jQuery框架设计概述"><a href="#2-1-jQuery框架设计概述" class="headerlink" title="2.1 jQuery框架设计概述"></a>2.1 jQuery框架设计概述</h3><h4 id="1-设计目标"><a href="#1-设计目标" class="headerlink" title="1 设计目标　"></a>1 设计目标　</h4><h4 id="2-目标实现"><a href="#2-目标实现" class="headerlink" title="2 目标实现"></a>2 目标实现</h4><h3 id="2-2-jQuery原型技术分解"><a href="#2-2-jQuery原型技术分解" class="headerlink" title="2.2 jQuery原型技术分解"></a>2.2 jQuery原型技术分解</h3><h4 id="1-起源——原型继承"><a href="#1-起源——原型继承" class="headerlink" title="1 起源——原型继承"></a>1 起源——原型继承</h4><h4 id="2-生命——返回实例"><a href="#2-生命——返回实例" class="headerlink" title="2 生命——返回实例"></a>2 生命——返回实例</h4><h4 id="3-学步——分隔作用域"><a href="#3-学步——分隔作用域" class="headerlink" title="3 学步——分隔作用域"></a>3 学步——分隔作用域</h4><h4 id="4-生长——跨域访问"><a href="#4-生长——跨域访问" class="headerlink" title="4 生长——跨域访问"></a>4 生长——跨域访问</h4><h4 id="5-成熟——选择器"><a href="#5-成熟——选择器" class="headerlink" title="5 成熟——选择器"></a>5 成熟——选择器</h4><h4 id="6-延续——迭代器"><a href="#6-延续——迭代器" class="headerlink" title="6 延续——迭代器"></a>6 延续——迭代器</h4><h4 id="7-延续——功能扩展"><a href="#7-延续——功能扩展" class="headerlink" title="7 延续——功能扩展"></a>7 延续——功能扩展</h4><h4 id="8-延续——参数处理"><a href="#8-延续——参数处理" class="headerlink" title="8 延续——参数处理"></a>8 延续——参数处理</h4><h4 id="9-涅槃——名字空间"><a href="#9-涅槃——名字空间" class="headerlink" title="9 涅槃——名字空间"></a>9 涅槃——名字空间</h4><h3 id="2-3-破解jQuery选折起接口"><a href="#2-3-破解jQuery选折起接口" class="headerlink" title="2.3 破解jQuery选折起接口"></a>2.3 破解jQuery选折起接口</h3><h4 id="1-简单但很复杂的黑洞"><a href="#1-简单但很复杂的黑洞" class="headerlink" title="1 简单但很复杂的黑洞"></a>1 简单但很复杂的黑洞</h4><h4 id="2-盘根错节的逻辑关系"><a href="#2-盘根错节的逻辑关系" class="headerlink" title="2 盘根错节的逻辑关系"></a>2 盘根错节的逻辑关系</h4><h4 id="3-jquery构造器"><a href="#3-jquery构造器" class="headerlink" title="3 jquery构造器"></a>3 jquery构造器</h4><h4 id="4-生成DOM元素"><a href="#4-生成DOM元素" class="headerlink" title="4 生成DOM元素"></a>4 生成DOM元素</h4><h4 id="5-引用DOM元素"><a href="#5-引用DOM元素" class="headerlink" title="5 引用DOM元素"></a>5 引用DOM元素</h4><h3 id="2-4-解析jQuery选择器引擎Sizzle"><a href="#2-4-解析jQuery选择器引擎Sizzle" class="headerlink" title="2.4 解析jQuery选择器引擎Sizzle"></a>2.4 解析jQuery选择器引擎Sizzle</h3><h3 id="2-5-类数组"><a href="#2-5-类数组" class="headerlink" title="2.5 类数组"></a>2.5 类数组</h3><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h3 id="5-1-事件模型"><a href="#5-1-事件模型" class="headerlink" title="5.1 事件模型"></a>5.1 事件模型</h3><h3 id="5-2-jQuery事件模型"><a href="#5-2-jQuery事件模型" class="headerlink" title="5.2 jQuery事件模型"></a>5.2 jQuery事件模型</h3><h3 id="5-3-jQuery页面初始化"><a href="#5-3-jQuery页面初始化" class="headerlink" title="5.3 jQuery页面初始化"></a>5.3 jQuery页面初始化</h3><h3 id="5-4-使用JS自定义jQ的事件方法"><a href="#5-4-使用JS自定义jQ的事件方法" class="headerlink" title="5.4 使用JS自定义jQ的事件方法"></a>5.4 使用JS自定义jQ的事件方法</h3><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h3 id="6-1-直接显示和隐藏"><a href="#6-1-直接显示和隐藏" class="headerlink" title="6.1 直接显示和隐藏"></a>6.1 直接显示和隐藏</h3><h3 id="6-2-滑动显示和隐藏"><a href="#6-2-滑动显示和隐藏" class="headerlink" title="6.2 滑动显示和隐藏"></a>6.2 滑动显示和隐藏</h3><h3 id="6-3-渐隐和渐显"><a href="#6-3-渐隐和渐显" class="headerlink" title="6.3 渐隐和渐显"></a>6.3 渐隐和渐显</h3><h3 id="6-4-自定义动画"><a href="#6-4-自定义动画" class="headerlink" title="6.4 自定义动画"></a>6.4 自定义动画</h3><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h3 id="7-1-Ajax应用的准备"><a href="#7-1-Ajax应用的准备" class="headerlink" title="7.1 Ajax应用的准备"></a>7.1 Ajax应用的准备</h3><h3 id="7-2-Ajax应用的第一个示例"><a href="#7-2-Ajax应用的第一个示例" class="headerlink" title="7.2 Ajax应用的第一个示例"></a>7.2 Ajax应用的第一个示例</h3><h3 id="7-3-从JS角度分析XMLHttpRequest对象"><a href="#7-3-从JS角度分析XMLHttpRequest对象" class="headerlink" title="7.3 从JS角度分析XMLHttpRequest对象"></a>7.3 从JS角度分析XMLHttpRequest对象</h3><h3 id="7-4-从jQ角度分析XMLHttpRequest对象"><a href="#7-4-从jQ角度分析XMLHttpRequest对象" class="headerlink" title="7.4 从jQ角度分析XMLHttpRequest对象"></a>7.4 从jQ角度分析XMLHttpRequest对象</h3><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h3 id="8-1-创建jQ插件"><a href="#8-1-创建jQ插件" class="headerlink" title="8.1 创建jQ插件"></a>8.1 创建jQ插件</h3><h3 id="8-2-创建jQ插件实战"><a href="#8-2-创建jQ插件实战" class="headerlink" title="8.2 创建jQ插件实战"></a>8.2 创建jQ插件实战</h3><h3 id="8-3-jQ-UI插件应用"><a href="#8-3-jQ-UI插件应用" class="headerlink" title="8.3 jQ UI插件应用"></a>8.3 jQ UI插件应用</h3><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h3 id="9-1-检测浏览器"><a href="#9-1-检测浏览器" class="headerlink" title="9.1 检测浏览器"></a>9.1 检测浏览器</h3><h3 id="9-2-字符串处理"><a href="#9-2-字符串处理" class="headerlink" title="9.2 字符串处理"></a>9.2 字符串处理</h3><h3 id="9-3-数组处理"><a href="#9-3-数组处理" class="headerlink" title="9.3 数组处理"></a>9.3 数组处理</h3><h3 id="9-4-多库共存"><a href="#9-4-多库共存" class="headerlink" title="9.4 多库共存"></a>9.4 多库共存</h3><h3 id="9-5-数据缓存"><a href="#9-5-数据缓存" class="headerlink" title="9.5 数据缓存"></a>9.5 数据缓存</h3><h3 id="9-6-数据队列"><a href="#9-6-数据队列" class="headerlink" title="9.6 数据队列"></a>9.6 数据队列</h3><h3 id="9-7-内核工具"><a href="#9-7-内核工具" class="headerlink" title="9.7 内核工具"></a>9.7 内核工具</h3><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2><h3 id="10-1-案例背景介绍"><a href="#10-1-案例背景介绍" class="headerlink" title="10.1 案例背景介绍"></a>10.1 案例背景介绍</h3><h3 id="10-2-网站设计思路"><a href="#10-2-网站设计思路" class="headerlink" title="10.2 网站设计思路"></a>10.2 网站设计思路</h3><h3 id="10-3-结构设计"><a href="#10-3-结构设计" class="headerlink" title="10.3 结构设计"></a>10.3 结构设计</h3><h3 id="10-4-样式设计"><a href="#10-4-样式设计" class="headerlink" title="10.4 样式设计"></a>10.4 样式设计</h3><h3 id="10-5-网站脚本设计"><a href="#10-5-网站脚本设计" class="headerlink" title="10.5 网站脚本设计"></a>10.5 网站脚本设计</h3><p style="text-align:right">2018.1. 星期 P</p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
      </categories>
  </entry>
  <entry>
    <title>锋利的jQuery 第2版</title>
    <url>/pdf/jslib/%E9%94%8B%E5%88%A9%E7%9A%84jQuery%202nd/</url>
    <content><![CDATA[<!-- 读： 2017.6.27 二 09：20 -->
<p style="text-align:right">2018.7.3 星期二 10:20</p>

<h2 id="一-认识jQuery"><a href="#一-认识jQuery" class="headerlink" title="一 认识jQuery"></a>一 认识jQuery</h2><h3 id="1-1-JavaScript和JavaScript库"><a href="#1-1-JavaScript和JavaScript库" class="headerlink" title="1.1 JavaScript和JavaScript库"></a>1.1 JavaScript和JavaScript库</h3><h3 id="1-2-加入jQuery"><a href="#1-2-加入jQuery" class="headerlink" title="1.2 加入jQuery"></a>1.2 加入jQuery</h3><h3 id="1-3-jQ代码的编写"><a href="#1-3-jQ代码的编写" class="headerlink" title="1.3 jQ代码的编写"></a>1.3 jQ代码的编写</h3><h3 id="1-4-jQ对象和DOM对象"><a href="#1-4-jQ对象和DOM对象" class="headerlink" title="1.4 jQ对象和DOM对象"></a>1.4 jQ对象和DOM对象</h3><h3 id="1-5-解决jQ和其他库的冲突"><a href="#1-5-解决jQ和其他库的冲突" class="headerlink" title="1.5 解决jQ和其他库的冲突"></a>1.5 解决jQ和其他库的冲突</h3><h3 id="1-6-jQ开发工具和插件"><a href="#1-6-jQ开发工具和插件" class="headerlink" title="1.6 jQ开发工具和插件"></a>1.6 jQ开发工具和插件</h3><h2 id="二-jQ选择器"><a href="#二-jQ选择器" class="headerlink" title="二 jQ选择器"></a>二 jQ选择器</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h3><h3 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2 优势"></a>2.2 优势</h3><h3 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h3><h3 id="2-4-应用jQ改写示例"><a href="#2-4-应用jQ改写示例" class="headerlink" title="2.4 应用jQ改写示例"></a>2.4 应用jQ改写示例</h3><h3 id="2-5-一些注意事项"><a href="#2-5-一些注意事项" class="headerlink" title="2.5 一些注意事项"></a>2.5 一些注意事项</h3><h3 id="2-6-案例研究-某网站品牌列表的效果"><a href="#2-6-案例研究-某网站品牌列表的效果" class="headerlink" title="2.6 案例研究-某网站品牌列表的效果"></a>2.6 案例研究-某网站品牌列表的效果</h3><h3 id="2-7-其他选择器"><a href="#2-7-其他选择器" class="headerlink" title="2.7 其他选择器"></a>2.7 其他选择器</h3><h2 id="三-jQ中的DOM操作"><a href="#三-jQ中的DOM操作" class="headerlink" title="三 jQ中的DOM操作"></a>三 jQ中的DOM操作</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><h3 id="3-2-操作"><a href="#3-2-操作" class="headerlink" title="3.2 操作"></a>3.2 操作</h3><h3 id="3-3-案例研究-某网站的超链接和图片提示效果"><a href="#3-3-案例研究-某网站的超链接和图片提示效果" class="headerlink" title="3.3 案例研究-某网站的超链接和图片提示效果"></a>3.3 案例研究-某网站的超链接和图片提示效果</h3><h2 id="四-jQ中的事件和动画"><a href="#四-jQ中的事件和动画" class="headerlink" title="四 jQ中的事件和动画"></a>四 jQ中的事件和动画</h2><h3 id="4-1-事件"><a href="#4-1-事件" class="headerlink" title="4.1 事件"></a>4.1 事件</h3><h3 id="4-2-动画"><a href="#4-2-动画" class="headerlink" title="4.2 动画"></a>4.2 动画</h3><h3 id="4-3-视频展示效果实例"><a href="#4-3-视频展示效果实例" class="headerlink" title="4.3 视频展示效果实例"></a>4.3 视频展示效果实例</h3><h2 id="五-jQ对表单、表格的操作及更多应用"><a href="#五-jQ对表单、表格的操作及更多应用" class="headerlink" title="五 jQ对表单、表格的操作及更多应用"></a>五 jQ对表单、表格的操作及更多应用</h2><h3 id="5-1-表单应用"><a href="#5-1-表单应用" class="headerlink" title="5.1 表单应用"></a>5.1 表单应用</h3><p>单行文本框，多行文本框，复选框，下拉，表单验证</p>
<h3 id="5-2-表格应用"><a href="#5-2-表格应用" class="headerlink" title="5.2 表格应用"></a>5.2 表格应用</h3><p>变色，展开关闭，内容筛选</p>
<h3 id="5-3-其他应用"><a href="#5-3-其他应用" class="headerlink" title="5.3 其他应用"></a>5.3 其他应用</h3><p>网页字体大小， 网页选项卡，网页换肤</p>
<h2 id="六-jQ与Ajax的应用"><a href="#六-jQ与Ajax的应用" class="headerlink" title="六 jQ与Ajax的应用"></a>六 jQ与Ajax的应用</h2><h3 id="6-1-Ajax的优势和不足"><a href="#6-1-Ajax的优势和不足" class="headerlink" title="6.1 Ajax的优势和不足"></a>6.1 Ajax的优势和不足</h3><h3 id="6-2-Ajax的XMLHttpRequest对象"><a href="#6-2-Ajax的XMLHttpRequest对象" class="headerlink" title="6.2 Ajax的XMLHttpRequest对象"></a>6.2 Ajax的XMLHttpRequest对象</h3><h3 id="6-3-安装Web环境-AppServ"><a href="#6-3-安装Web环境-AppServ" class="headerlink" title="6.3 安装Web环境-AppServ"></a>6.3 安装Web环境-AppServ</h3><h3 id="6-4-编写第一个Ajax例子"><a href="#6-4-编写第一个Ajax例子" class="headerlink" title="6.4 编写第一个Ajax例子"></a>6.4 编写第一个Ajax例子</h3><h3 id="6-5-jQuery中Ajax"><a href="#6-5-jQuery中Ajax" class="headerlink" title="6.5 jQuery中Ajax"></a>6.5 jQuery中Ajax</h3><h3 id="6-6-序列化元素"><a href="#6-6-序列化元素" class="headerlink" title="6.6 序列化元素"></a>6.6 序列化元素</h3><h3 id="6-7-jQ中Ajax全局事件"><a href="#6-7-jQ中Ajax全局事件" class="headerlink" title="6.7 jQ中Ajax全局事件"></a>6.7 jQ中Ajax全局事件</h3><h3 id="6-8-基于jQuery的Ajax聊天室程序"><a href="#6-8-基于jQuery的Ajax聊天室程序" class="headerlink" title="6.8 基于jQuery的Ajax聊天室程序"></a>6.8 基于jQuery的Ajax聊天室程序</h3><h2 id="七-jQ插件的使用和写法"><a href="#七-jQ插件的使用和写法" class="headerlink" title="七 jQ插件的使用和写法"></a>七 jQ插件的使用和写法</h2><h3 id="7-1-表单验证-validation"><a href="#7-1-表单验证-validation" class="headerlink" title="7.1 表单验证-validation"></a>7.1 表单验证-validation</h3><h3 id="7-2-表单-form"><a href="#7-2-表单-form" class="headerlink" title="7.2 表单-form"></a>7.2 表单-form</h3><h3 id="7-3-模态窗口-simpleModal"><a href="#7-3-模态窗口-simpleModal" class="headerlink" title="7.3 模态窗口-simpleModal"></a>7.3 模态窗口-simpleModal</h3><h3 id="7-4-管理cookie-cookie"><a href="#7-4-管理cookie-cookie" class="headerlink" title="7.4 管理cookie-cookie"></a>7.4 管理cookie-cookie</h3><h3 id="7-5-jQuery-UI"><a href="#7-5-jQuery-UI" class="headerlink" title="7.5 jQuery UI"></a>7.5 jQuery UI</h3><h3 id="7-6-编写"><a href="#7-6-编写" class="headerlink" title="7.6 编写"></a>7.6 编写</h3><h2 id="八-用jQ打造个性网站"><a href="#八-用jQ打造个性网站" class="headerlink" title="八 用jQ打造个性网站"></a>八 用jQ打造个性网站</h2><h3 id="8-1-案例背景介绍"><a href="#8-1-案例背景介绍" class="headerlink" title="8.1 案例背景介绍"></a>8.1 案例背景介绍</h3><h3 id="8-2-网站材料"><a href="#8-2-网站材料" class="headerlink" title="8.2 网站材料"></a>8.2 网站材料</h3><h3 id="8-3-网站结构"><a href="#8-3-网站结构" class="headerlink" title="8.3 网站结构"></a>8.3 网站结构</h3><p>文件，网页，界面</p>
<h3 id="8-4-网站的-X-HTML"><a href="#8-4-网站的-X-HTML" class="headerlink" title="8.4 网站的(X)HTML"></a>8.4 网站的(X)HTML</h3><h3 id="8-5-网站的样式"><a href="#8-5-网站的样式" class="headerlink" title="8.5 网站的样式"></a>8.5 网站的样式</h3><h3 id="8-6-网站的脚本-jQuery"><a href="#8-6-网站的脚本-jQuery" class="headerlink" title="8.6 网站的脚本(jQuery)"></a>8.6 网站的脚本(jQuery)</h3><h2 id="九-jQuery-Mobile"><a href="#九-jQuery-Mobile" class="headerlink" title="九 jQuery Mobile"></a>九 jQuery Mobile</h2><h3 id="9-1-HTML-5简介"><a href="#9-1-HTML-5简介" class="headerlink" title="9.1 HTML 5简介"></a>9.1 HTML 5简介</h3><h3 id="9-2-jQuery-Mobile简介"><a href="#9-2-jQuery-Mobile简介" class="headerlink" title="9.2 jQuery Mobile简介"></a>9.2 jQuery Mobile简介</h3><h3 id="9-3-主要特征"><a href="#9-3-主要特征" class="headerlink" title="9.3 主要特征"></a>9.3 主要特征</h3><h3 id="9-4-使用"><a href="#9-4-使用" class="headerlink" title="9.4 使用"></a>9.4 使用</h3><h3 id="9-5-其他框架"><a href="#9-5-其他框架" class="headerlink" title="9.5 其他框架"></a>9.5 其他框架</h3><h2 id="零-jQ的各个版本的变化"><a href="#零-jQ的各个版本的变化" class="headerlink" title="零 jQ的各个版本的变化"></a>零 jQ的各个版本的变化</h2><h3 id="0-1-发展历史"><a href="#0-1-发展历史" class="headerlink" title="0.1 发展历史"></a>0.1 发展历史</h3><h3 id="0-2-各个版本新增方法"><a href="#0-2-各个版本新增方法" class="headerlink" title="0.2 各个版本新增方法"></a>0.2 各个版本新增方法</h3><h2 id="一-jQ性能优化和技巧"><a href="#一-jQ性能优化和技巧" class="headerlink" title="一 jQ性能优化和技巧"></a>一 jQ性能优化和技巧</h2><h3 id="1-1-性能优化"><a href="#1-1-性能优化" class="headerlink" title="1.1 性能优化"></a>1.1 性能优化</h3><h3 id="1-2-技巧"><a href="#1-2-技巧" class="headerlink" title="1.2 技巧"></a>1.2 技巧</h3><p>附录A 关于 $(document).ready()函数<br>附录B Firebug<br>附录C Ajax的XMLHttpRequest对象的属性和方法<br>附录D jQuery $.ajax()方法的参数<br>附录E jQuery加载并解析XML<br>附录F 插件API<br>附录G jQuery速查表</p>
<p style="text-align:right">10：31 </p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
      </categories>
  </entry>
  <entry>
    <title>PHP和MySQL WEB开发</title>
    <url>/pdf/ser/PHP%E5%92%8CMySQL%20WEB%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p style="text-align:right">2018.7.3 星期二 10:35</p>

<p># 第一篇 使用PHP    </p>
<h2 id="一-PHP快速入门"><a href="#一-PHP快速入门" class="headerlink" title="一 PHP快速入门"></a>一 PHP快速入门</h2><h2 id="二-数据的存储与检索"><a href="#二-数据的存储与检索" class="headerlink" title="二 数据的存储与检索"></a>二 数据的存储与检索</h2><h2 id="三-使用数组"><a href="#三-使用数组" class="headerlink" title="三 使用数组"></a>三 使用数组</h2><h2 id="四-字符串操作与正则表达式"><a href="#四-字符串操作与正则表达式" class="headerlink" title="四 字符串操作与正则表达式"></a>四 字符串操作与正则表达式</h2><h2 id="五-代码宠用与函数编写"><a href="#五-代码宠用与函数编写" class="headerlink" title="五 代码宠用与函数编写"></a>五 代码宠用与函数编写</h2><h2 id="六-面向对象的PHP"><a href="#六-面向对象的PHP" class="headerlink" title="六 面向对象的PHP"></a>六 面向对象的PHP</h2><h2 id="七-错误和异常处理"><a href="#七-错误和异常处理" class="headerlink" title="七 错误和异常处理"></a>七 错误和异常处理</h2><p># 第二篇 使用MySQL    </p>
<h2 id="八-设计Web数据库"><a href="#八-设计Web数据库" class="headerlink" title="八 设计Web数据库"></a>八 设计Web数据库</h2><h2 id="九-创建Web数据库"><a href="#九-创建Web数据库" class="headerlink" title="九 创建Web数据库"></a>九 创建Web数据库</h2><h2 id="零-使用MySQL数据库"><a href="#零-使用MySQL数据库" class="headerlink" title="零 使用MySQL数据库"></a>零 使用MySQL数据库</h2><h2 id="一-使用PHP从Web访问MySQL数据"><a href="#一-使用PHP从Web访问MySQL数据" class="headerlink" title="一 使用PHP从Web访问MySQL数据"></a>一 使用PHP从Web访问MySQL数据</h2><h2 id="二-MySQL高级管理"><a href="#二-MySQL高级管理" class="headerlink" title="二 MySQL高级管理"></a>二 MySQL高级管理</h2><h2 id="三-MySQL高级编程"><a href="#三-MySQL高级编程" class="headerlink" title="三 MySQL高级编程"></a>三 MySQL高级编程</h2><p># 第三篇 电子商务与安全性    </p>
<h2 id="四-运营一个电子商务网站"><a href="#四-运营一个电子商务网站" class="headerlink" title="四 运营一个电子商务网站"></a>四 运营一个电子商务网站</h2><h2 id="五-电子商务的安全性"><a href="#五-电子商务的安全性" class="headerlink" title="五 电子商务的安全性"></a>五 电子商务的安全性</h2><h2 id="六-Web应用的安全"><a href="#六-Web应用的安全" class="headerlink" title="六 Web应用的安全"></a>六 Web应用的安全</h2><h2 id="七-使用PHP和MySQL实现身份验证"><a href="#七-使用PHP和MySQL实现身份验证" class="headerlink" title="七 使用PHP和MySQL实现身份验证"></a>七 使用PHP和MySQL实现身份验证</h2><h2 id="八-使用PHP和MySQL实现安全事务"><a href="#八-使用PHP和MySQL实现安全事务" class="headerlink" title="八 使用PHP和MySQL实现安全事务"></a>八 使用PHP和MySQL实现安全事务</h2><p># 第四篇 PHP的高级技术    </p>
<h2 id="九-与文件系统和服务器的交互"><a href="#九-与文件系统和服务器的交互" class="headerlink" title="九 与文件系统和服务器的交互"></a>九 与文件系统和服务器的交互</h2><h2 id="零-使用网路函数和协议函数"><a href="#零-使用网路函数和协议函数" class="headerlink" title="零 使用网路函数和协议函数"></a>零 使用网路函数和协议函数</h2><h2 id="一-日期和时间的管理"><a href="#一-日期和时间的管理" class="headerlink" title="一 日期和时间的管理"></a>一 日期和时间的管理</h2><h2 id="二-创建图像"><a href="#二-创建图像" class="headerlink" title="二 创建图像"></a>二 创建图像</h2><h2 id="三-在PHP中使用会话控制"><a href="#三-在PHP中使用会话控制" class="headerlink" title="三 在PHP中使用会话控制"></a>三 在PHP中使用会话控制</h2><h2 id="四-其他游泳的特性"><a href="#四-其他游泳的特性" class="headerlink" title="四 其他游泳的特性"></a>四 其他游泳的特性</h2><p># 第五篇 创建实用的PHP和MySQL项目    </p>
<h2 id="五-在大型项目中使用PHP和MySQ"><a href="#五-在大型项目中使用PHP和MySQ" class="headerlink" title="五 在大型项目中使用PHP和MySQ"></a>五 在大型项目中使用PHP和MySQ</h2><h2 id="六-调试"><a href="#六-调试" class="headerlink" title="六 调试"></a>六 调试</h2><h2 id="七-建立用户身份验证机制和个性化设置"><a href="#七-建立用户身份验证机制和个性化设置" class="headerlink" title="七 建立用户身份验证机制和个性化设置"></a>七 建立用户身份验证机制和个性化设置</h2><h2 id="八-创建一个购物车"><a href="#八-创建一个购物车" class="headerlink" title="八 创建一个购物车"></a>八 创建一个购物车</h2><h2 id="九-创建一个基于Web的电子邮件服务系统"><a href="#九-创建一个基于Web的电子邮件服务系统" class="headerlink" title="九 创建一个基于Web的电子邮件服务系统"></a>九 创建一个基于Web的电子邮件服务系统</h2><h2 id="零-创建一个邮件列表管理器"><a href="#零-创建一个邮件列表管理器" class="headerlink" title="零 创建一个邮件列表管理器"></a>零 创建一个邮件列表管理器</h2><h2 id="一-创建一个Web论坛"><a href="#一-创建一个Web论坛" class="headerlink" title="一 创建一个Web论坛"></a>一 创建一个Web论坛</h2><h2 id="二-生成PDF格式的个性化文档"><a href="#二-生成PDF格式的个性化文档" class="headerlink" title="二 生成PDF格式的个性化文档"></a>二 生成PDF格式的个性化文档</h2><h2 id="三-使用XML和SOAP来连接Web服务"><a href="#三-使用XML和SOAP来连接Web服务" class="headerlink" title="三 使用XML和SOAP来连接Web服务"></a>三 使用XML和SOAP来连接Web服务</h2><h2 id="四-用用Ajax构建Web2-0应用"><a href="#四-用用Ajax构建Web2-0应用" class="headerlink" title="四 用用Ajax构建Web2.0应用"></a>四 用用Ajax构建Web2.0应用</h2><p>附录A 安装PHP及MySQL<br>附录B Web资源   </p>
<p style="text-align:right">10：44 </p>]]></content>
      <categories>
        <category>pdf</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-1_jQ起步</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%201%20%E7%AB%A0%20jQ%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<p style="text-align:right;">2018.1.8 21:22</p><br>清华大学出版社  朱印华 著<br><br>## 前言<br>2006年到现在，不到4年时间===》现在2010<br>学习中两种意识：<br>1. 执行效率是编写脚本的第一要务<br>Sizzle选择器<br>2. 理解jQuery设计模式和工作机制是学习和提升jQuery开发水平的关键<br>仅4000多行<br>### 关于本书<br>设计模式、实现机制、一般用法、扩展应用、实战演练<br>10章<br>1. jQ起步，js极其框架发展<br>2. jQ解密技术，jQ原型设计思路和模式<br>3. 高效选择的技巧与原理，jQ的css选择器<br>4. 文档对象<br>5. 事件封装机制与解析<br>6. 动画效果设计及其高效实践<br>7. Ajax异步通信高效实践<br>8. 高效开发和使用插件<br>9. jQ辅助工具<br>10. 使用jQ打造Ajax异步交互式动态网站<br><br>### 读者对象<br>### 本书约定 P6<br>1.3.2.js<br>### 关于作者<br><br><br># 目录<br>## 第 1 章 jQ起步<br>### 1.1 认识jQuery<br>略<br>### 1.2 jQuery初步体验<br>略<br>### 1.3 jQuery核心特性<br>#### 1 jQuery构造函数<br>jQuery(expression,context),jQuery(html),jQuery(elements),jQuery(fn)<br>#### 2 jQuery链式语法<br>根据情况 使用（链式）<br>#### 3 jQuery选择器<br>选择，过滤，两者<br>#### 4 jQuery扩展性<br><br><br>## 第 2 章 jQ解密技术<br>### 2.1 jQuery框架设计概述<br>#### 1 设计目标　<br>#### 2 目标实现<br><br>### 2.2 jQuery原型技术分解<br>#### 1 起源——原型继承<br>#### 2 生命——返回实例<br>#### 3 学步——分隔作用域<br>#### 4 生长——跨域访问<br>#### 5 成熟——选择器<br>#### 6 延续——迭代器<br>#### 7 延续——功能扩展<br>#### 8 延续——参数处理<br>#### 9 涅槃——名字空间<br><br>### 2.3 破解jQuery选折起接口<br>### 2.4 解析jQuery选择器引擎Sizzle<br>### 2.5 类数组<br>## 第 3 章 高效选择的技巧与原理<br>## 第 4 章 文档对象的操作及高效实践<br>## 第 5 章 事件封装机制与解析<br>## 第 6 章 动画效果设计及其高效实践<br>## 第 7 章 Ajax异步通信高效实践<br>## 第 8 章 高效开发和使用插件<br>## 第 9 章 jQ辅助工具<br>## 第 10 章 使用jQ打造Ajax异步交互式动态网站<br><br># 目录<br>## 第 1 章 jQ起步<br>## 第 2 章 jQ解密技术<br>## 第 3 章 高效选择的技巧与原理<br>## 第 4 章 文档对象的操作及高效实践<br>## 第 5 章 事件封装机制与解析<br>## 第 6 章 动画效果设计及其高效实践<br>## 第 7 章 Ajax异步通信高效实践<br>## 第 8 章 高效开发和使用插件<br>## 第 9 章 jQ辅助工具<br>## 第 10 章 使用jQ打造Ajax异步交互式动态网站<br><br><p style="text-align:right;"></p>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-2_jQ解密技术</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%202%20%E7%AB%A0%20jQ%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h3 id="1-1-认识jQuery"><a href="#1-1-认识jQuery" class="headerlink" title="1.1 认识jQuery"></a>1.1 认识jQuery</h3><h3 id="1-2-jQuery初步体验"><a href="#1-2-jQuery初步体验" class="headerlink" title="1.2 jQuery初步体验"></a>1.2 jQuery初步体验</h3><h3 id="1-3-jQuery核心特性"><a href="#1-3-jQuery核心特性" class="headerlink" title="1.3 jQuery核心特性"></a>1.3 jQuery核心特性</h3><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h3 id="2-1-jQuery框架设计概述"><a href="#2-1-jQuery框架设计概述" class="headerlink" title="2.1 jQuery框架设计概述"></a>2.1 jQuery框架设计概述</h3><h4 id="1-设计目标"><a href="#1-设计目标" class="headerlink" title="1 设计目标　"></a>1 设计目标　</h4><p>选择和操作：选择什么、如何选择、怎么操作、操作什么<br>学习榜样：css选择器，XPath（很多高级XML应用的基础）</p>
<h4 id="2-目标实现"><a href="#2-目标实现" class="headerlink" title="2 目标实现"></a>2 目标实现</h4><p>属性、元素、内容、样式、事件、通信</p>
<p>选择、操作、扩展<br>执行效率、可用性、兼容性、实用性　</p>
<h3 id="2-2-jQuery原型技术分解"><a href="#2-2-jQuery原型技术分解" class="headerlink" title="2.2 jQuery原型技术分解"></a>2.2 jQuery原型技术分解</h3><h4 id="1-起源——原型继承"><a href="#1-起源——原型继承" class="headerlink" title="1 起源——原型继承"></a>1 起源——原型继承</h4><pre><code>var $=jQuery=function(){}
jQuery.fn=jQuery.prototype={
    jquery:&quot;1.3.2&quot;,
    siez:funciton(){}
}
</code></pre><p>// INCLUDE:2.2_.html    </p>
<h4 id="2-生命——返回实例"><a href="#2-生命——返回实例" class="headerlink" title="2 生命——返回实例"></a>2 生命——返回实例</h4><h4 id="3-学步——分隔作用域"><a href="#3-学步——分隔作用域" class="headerlink" title="3 学步——分隔作用域"></a>3 学步——分隔作用域</h4><h4 id="4-生长——跨域访问"><a href="#4-生长——跨域访问" class="headerlink" title="4 生长——跨域访问"></a>4 生长——跨域访问</h4><h4 id="5-成熟——选择器"><a href="#5-成熟——选择器" class="headerlink" title="5 成熟——选择器"></a>5 成熟——选择器</h4><h4 id="6-延续——迭代器"><a href="#6-延续——迭代器" class="headerlink" title="6 延续——迭代器"></a>6 延续——迭代器</h4><h4 id="7-延续——功能扩展"><a href="#7-延续——功能扩展" class="headerlink" title="7 延续——功能扩展"></a>7 延续——功能扩展</h4><pre><code>jQuery.extend=jQuery.fn.extend=function(obj){
    for(var prop in obj){
        this[prop]=obj[prop]
    }
    return this;
}
</code></pre><h4 id="8-延续——参数处理"><a href="#8-延续——参数处理" class="headerlink" title="8 延续——参数处理"></a>8 延续——参数处理</h4><h4 id="9-涅槃——名字空间"><a href="#9-涅槃——名字空间" class="headerlink" title="9 涅槃——名字空间"></a>9 涅槃——名字空间</h4><pre><code>;(function(){
    var
        window=this,
        undefined,
        _jQuery=window.jQuery,
        _$=window.$,
        jQuery=window.jQuery=window.$=function(){},
        isSimple=/^.[^:#\[\.,]*$/;
    jQuery.fn=jQuery.prototype={
        init:function () {

        }
    }
})()
</code></pre><p style="text-align:right;">23：23</p>

<p style="text-align:right;">2018.1.9 二 22：16</p>

<h3 id="2-3-破解jQuery选择器接口"><a href="#2-3-破解jQuery选择器接口" class="headerlink" title="2.3 破解jQuery选择器接口"></a>2.3 破解jQuery选择器接口</h3><h4 id="1-简单但很复杂的黑洞"><a href="#1-简单但很复杂的黑洞" class="headerlink" title="1 简单但很复杂的黑洞"></a>1 简单但很复杂的黑洞</h4><h4 id="2-盘根错节的逻辑关系"><a href="#2-盘根错节的逻辑关系" class="headerlink" title="2 盘根错节的逻辑关系"></a>2 盘根错节的逻辑关系</h4><h4 id="3-jquery构造器"><a href="#3-jquery构造器" class="headerlink" title="3 jquery构造器"></a>3 jquery构造器</h4><pre><code>init:function(selector,context){
    selector=selector||document
    if(selector.nodeType){

    }
    if(typeof selector==&apos;string&apos;){
        //quickExpr=/  /
        var match=quickExpr.exec(selector)
        if(){}else if(){}

        //6
        return this.setArray()
    }
}
</code></pre><h4 id="4-生成DOM元素"><a href="#4-生成DOM元素" class="headerlink" title="4 生成DOM元素"></a>4 生成DOM元素</h4><pre><code>jQuery.extend({
    clean:function(element,context,fragment){

    }
})
</code></pre><h4 id="5-引用DOM元素"><a href="#5-引用DOM元素" class="headerlink" title="5 引用DOM元素"></a>5 引用DOM元素</h4><pre><code>jQuery.each({
    parent:function(elem){ return elem.parentNode},
    parents:function(elem){return jQuery.dir(elem,&quot;parentNode&quot;)},
    next:function(elem){return jQuery.nth(elem,2,&quot;nextSibling&quot;)},
    prev:function(elem){return jQuery.nth(elem,2,&quot;previousSibling&quot;)},
    nextAll:function(elem){return jQuery.(elem,&quot;nextSibling&quot;)},
    prevAll:function(elem){return jQuery.(elem,)},
    sibling:function(elem){return jQuery.(elem,)},
    children:function(elem){return jQuery.sibling(elem.firstChild)},
    contents:function(elem){return jQuery.(elem,)},
},function(name,fn){
    jQuery.fn[name]=function(selector){

        return this.pushStack(jQuery.unique(ret),name,selector)
    }
})

jQuery.dir=funciton(elem,dir){}
jQuery.nth=funciton(elem,dir){}
jQuery.sibling=funciton(elem,dir){}
</code></pre><h3 id="2-4-解析jQuery选择器引擎Sizzle"><a href="#2-4-解析jQuery选择器引擎Sizzle" class="headerlink" title="2.4 解析jQuery选择器引擎Sizzle"></a>2.4 解析jQuery选择器引擎Sizzle</h3><h4 id="1-回顾css的选择器"><a href="#1-回顾css的选择器" class="headerlink" title="1 回顾css的选择器"></a>1 回顾css的选择器</h4><h4 id="2-解析jQuery选择器引擎的设计思路"><a href="#2-解析jQuery选择器引擎的设计思路" class="headerlink" title="2 解析jQuery选择器引擎的设计思路"></a>2 解析jQuery选择器引擎的设计思路</h4><h4 id="3-选择器和过滤器"><a href="#3-选择器和过滤器" class="headerlink" title="3 选择器和过滤器"></a>3 选择器和过滤器</h4><p>$(“div.red:nth-child(odd)[title=bar]#wrap p”)<br>p,div,.red,nth,title,#wrap</p>
<h4 id="4-Sizzle引擎结构"><a href="#4-Sizzle引擎结构" class="headerlink" title="4 Sizzle引擎结构"></a>4 Sizzle引擎结构</h4><p>1000，jQuery框架的1/4,独立空间，外界无法访问<br>一个构造器Sizzle;三个核心函数matches,find,filter;一个表达对象selectors</p>
<p>jQuery.find=Sizzle<br>jQuery.filter=Sizzle.filter<br>jQuery.expr=Sizzle.selectors<br>jQuery.expr[“:”]=jQuery.expr.filters</p>
<h4 id="5-Sizzle-构造器"><a href="#5-Sizzle-构造器" class="headerlink" title="5 Sizzle 构造器"></a>5 Sizzle 构造器</h4><h4 id="6-Sizzle-选择器"><a href="#6-Sizzle-选择器" class="headerlink" title="6 Sizzle 选择器"></a>6 Sizzle 选择器</h4><h4 id="7-Sizzle-过滤器"><a href="#7-Sizzle-过滤器" class="headerlink" title="7 Sizzle 过滤器"></a>7 Sizzle 过滤器</h4><p>主要两部分：过滤函数-jQuery.filter；过滤表达式对象</p>
<h4 id="8-jquery-选择器应用优化"><a href="#8-jquery-选择器应用优化" class="headerlink" title="8 jquery 选择器应用优化"></a>8 jquery 选择器应用优化</h4><p>id&gt;tag&gt;class  但，实际开发中class频率最高</p>
<ol>
<li>多用id</li>
<li>少直接用class  用复合tag.class(当然应摒除冗余部分，对不必要的复合表达式简化：#id2#id1、tag#id1</li>
<li>多用父子，少用嵌套 parent&gt;child代替parent child</li>
<li>缓存jQuery对象<h3 id="2-5-类数组"><a href="#2-5-类数组" class="headerlink" title="2.5 类数组"></a>2.5 类数组</h3><h4 id="1-定义类数组"><a href="#1-定义类数组" class="headerlink" title="1 定义类数组"></a>1 定义类数组</h4>makeArray：把类数组对象的元素全部推进数组对象<br>setArray：把类数组对象的元素全部推进当前jQuery对象中<br>pushStack：把类数组对象的元素全部推进当前jQuery对象中(新建了一个jQuery对象，有保存了对原对象的引用)<h4 id="2-操作类数组"><a href="#2-操作类数组" class="headerlink" title="2 操作类数组"></a>2 操作类数组</h4>定位、查找、复制、删除等。注意：由于类数组的操作对象是集合，所以这与类数组包含的DOM元素操作是两个不同的概念</li>
<li>定位元素<br>get(),index();get(index),eq(index)<br>其他函数：inArray</li>
<li>复制元素<br>slice()<br>其他函数：merge(first,second)</li>
<li>添加元素<br>add()</li>
<li>过滤元素<br>filter(selector),not(selector)<br>filter:jQuery.grep(elems,callback,inv)+jQuery.multiFilter(expr,elemes,not)<br>not建立在filter之上，执行效率更高</li>
<li>映射元素<br>each(),map()</li>
</ol>
<h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-3_高效选择的技巧与原理</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%203%20%E7%AB%A0%20%E9%AB%98%E6%95%88%E9%80%89%E6%8B%A9%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><p>1.1 认识jQuery<br>1.2 jQuery初步体验<br>1.3 jQuery核心特性  </p>
<h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h3 id="2-1-jQuery框架设计概述"><a href="#2-1-jQuery框架设计概述" class="headerlink" title="2.1 jQuery框架设计概述"></a>2.1 jQuery框架设计概述</h3><p>1 设计目标　<br>2 目标实现  </p>
<h3 id="2-2-jQuery原型技术分解"><a href="#2-2-jQuery原型技术分解" class="headerlink" title="2.2 jQuery原型技术分解"></a>2.2 jQuery原型技术分解</h3><p>1 起源——原型继承<br>2 生命——返回实例<br>3 学步——分隔作用域<br>4 生长——跨域访问<br>5 成熟——选择器<br>6 延续——迭代器<br>7 延续——功能扩展<br>8 延续——参数处理<br>9 涅槃——名字空间   </p>
<h3 id="2-3-破解jQuery选折起接口"><a href="#2-3-破解jQuery选折起接口" class="headerlink" title="2.3 破解jQuery选折起接口"></a>2.3 破解jQuery选折起接口</h3><p>1 简单但很复杂的黑洞<br>2 盘根错节的逻辑关系<br>3 jquery构造器<br>4 生成DOM元素<br>5 引用DOM元素  </p>
<h3 id="2-4-解析jQuery选择器引擎Sizzle"><a href="#2-4-解析jQuery选择器引擎Sizzle" class="headerlink" title="2.4 解析jQuery选择器引擎Sizzle"></a>2.4 解析jQuery选择器引擎Sizzle</h3><h3 id="2-5-类数组"><a href="#2-5-类数组" class="headerlink" title="2.5 类数组"></a>2.5 类数组</h3><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h3 id="3-1-选择器是什么"><a href="#3-1-选择器是什么" class="headerlink" title="3.1 选择器是什么"></a>3.1 选择器是什么</h3><h4 id="1-从css选择器说起"><a href="#1-从css选择器说起" class="headerlink" title="1 从css选择器说起"></a>1 从css选择器说起</h4><p>4伪类 5伪对象 6用户界面-4 7结构性-4 8其他（:not(s),:target-4</p>
<h4 id="2-jQuery盗了谁的版"><a href="#2-jQuery盗了谁的版" class="headerlink" title="2 jQuery盗了谁的版"></a>2 jQuery盗了谁的版</h4><p>cssQuery</p>
<h4 id="3-认识cssQuery选择器"><a href="#3-认识cssQuery选择器" class="headerlink" title="3 认识cssQuery选择器"></a>3 认识cssQuery选择器</h4><h4 id="4-使用cssQuery选择器"><a href="#4-使用cssQuery选择器" class="headerlink" title="4 使用cssQuery选择器"></a>4 使用cssQuery选择器</h4><h4 id="5-初步接触jQuery选择器"><a href="#5-初步接触jQuery选择器" class="headerlink" title="5 初步接触jQuery选择器"></a>5 初步接触jQuery选择器</h4><p>解决两大难题：支持css1，css2，css3；支持不同类型的主流浏览器<br>永远返回一个数组对象，所以 if($(‘tr’).length&gt;0)</p>
<p>简单、包含、筛选、内容、属性、表单</p>
<h3 id="3-2-简单选择器"><a href="#3-2-简单选择器" class="headerlink" title="3.2 简单选择器"></a>3.2 简单选择器</h3><p> #id element .class * selector1,selector2,selector3</p>
<h4 id="1-选择指定ID元素"><a href="#1-选择指定ID元素" class="headerlink" title="1 选择指定ID元素"></a>1 选择指定ID元素</h4><ol start="3">
<li>执行效率比较分析<br>jquery用时长 </li>
<li>jQuery方法应用解析<br><div id="a.b">div1</div><br><div id="a:b">div1</div><br><div id="[div]">div1</div><br>$(“#a\.b”)  $(“#a\:b”)  $(“#\{div\}”)<br>document.getElementById(“a.b”)  a:b  [div]</li>
</ol>
<h4 id="2-选择指定类型"><a href="#2-选择指定类型" class="headerlink" title="2 选择指定类型"></a>2 选择指定类型</h4><ol start="3">
<li>——   jQuery用时多，而且更严重 <h4 id="3-选择指定类"><a href="#3-选择指定类" class="headerlink" title="3 选择指定类"></a>3 选择指定类</h4></li>
<li>—— 自定义的不如jQuery<br><p style="text-align:right">2018.1.10 00:26 P113&lt;/&gt;<br></p><p style="text-align:right">2018.1.10 21:36&lt;/&gt;</p></li>
</ol>
<h4 id="4-选择所有元素及其优化"><a href="#4-选择所有元素及其优化" class="headerlink" title="4 选择所有元素及其优化"></a>4 选择所有元素及其优化</h4><p>更高效的方法：结合两者<br>    var all=document.getElementByTagName(“*”)<br>    $(all).css(“color”,”red”)</p>
<h4 id="5-选择多组元素及其实现"><a href="#5-选择多组元素及其实现" class="headerlink" title="5 选择多组元素及其实现"></a>5 选择多组元素及其实现</h4><h3 id="3-3-关系选择器"><a href="#3-3-关系选择器" class="headerlink" title="3.3 关系选择器"></a>3.3 关系选择器</h3><h4 id="1-层级选择器"><a href="#1-层级选择器" class="headerlink" title="1 层级选择器"></a>1 层级选择器</h4><p>选择器 、子选择器&gt;、相邻选择器+、兄弟选择器~</p>
<h4 id="2-层级选择器的实现方法"><a href="#2-层级选择器的实现方法" class="headerlink" title="2 层级选择器的实现方法"></a>2 层级选择器的实现方法</h4><pre><code>var Expr=Sizzle.selectors={
    relative:{
        &quot;+&quot;:function(){},
        &quot;&gt;&quot;:funciton(){},

    }
}
function dirNodeCheck(dir,cur,doneName,checkSet,nodeCheck,isXML){}
function dirCheck(dir,cur,doneName,checkSet,nodeCheck,isXML){}
</code></pre><h4 id="3-子元素选择器"><a href="#3-子元素选择器" class="headerlink" title="3 子元素选择器"></a>3 子元素选择器</h4><p>:nth-child  :first-child  :last-child   :only-child</p>
<h4 id="4-子元素选择器的实现方法"><a href="#4-子元素选择器的实现方法" class="headerlink" title="4 子元素选择器的实现方法"></a>4 子元素选择器的实现方法</h4><pre><code>var Expr=Sizzle.selectors={
    order:[&quot;ID&quot;,&quot;NAME&quot;,&quot;TAG&quot;],
    match:{
        ID:/  /,CLASS://,NAME://,

    }
}
</code></pre><h3 id="3-4-过滤选择器"><a href="#3-4-过滤选择器" class="headerlink" title="3.4 过滤选择器"></a>3.4 过滤选择器</h3><h4 id="1-定位过滤器"><a href="#1-定位过滤器" class="headerlink" title="1 定位过滤器"></a>1 定位过滤器</h4><p>:first,:last,:not,:even,:odd,:eq,:gt,:lt,:header,:animated</p>
<h4 id="2-定位过滤器的实现方法"><a href="#2-定位过滤器的实现方法" class="headerlink" title="2 定位过滤器的实现方法"></a>2 定位过滤器的实现方法</h4><pre><code>var Expr=Sizzle.selectors={
    setFilters:{
        first:function(elem,i){return i===0},

    },
    filter:{
        POS:function(elem,match,i,array){
            var name=match[2],filter=Expr.setFilters[name]
            if(filter){
                return filter(elem,i,match,array)
            }
        }
    }
}
</code></pre><h4 id="3-内容过滤器"><a href="#3-内容过滤器" class="headerlink" title="3 内容过滤器"></a>3 内容过滤器</h4><p>:contains,:empty,:has,:parent</p>
<h4 id="4-内容过滤器的实现方法"><a href="#4-内容过滤器的实现方法" class="headerlink" title="4 内容过滤器的实现方法"></a>4 内容过滤器的实现方法</h4><pre><code>var Expr=Sizzle.selectors={
    filters:{
        parent:function(elem){return !!elem.firstChild},
        empty:function(elem){return !elem.firstChild},
        has:function(elem,i,match){},


        PSEUDO:function(elem,match,i,array){
            var name=match[1],filter=Expr.filters[name]
            if(filter){}
            else if(name===&quot;contains&quot;){}
            else if(name===&quot;not&quot;){return true}
        }
    }
}
</code></pre><h4 id="5-可见过滤器"><a href="#5-可见过滤器" class="headerlink" title="5 可见过滤器"></a>5 可见过滤器</h4><p>:hidden,:visible</p>
<h4 id="6-可见过滤器的实现方法"><a href="#6-可见过滤器的实现方法" class="headerlink" title="6 可见过滤器的实现方法"></a>6 可见过滤器的实现方法</h4><p>Sizzle.selectors.filters.hidden=function(elem){return elem.offsetWidth===0||elem.offsetHeight===0}<br>Sizzle.selectors.filters.visible=function(elem){return }<br>Sizzle.selectors.filters.animated=function(elem){return jQuery.grep(…)}</p>
<h3 id="3-5-属性选择器"><a href="#3-5-属性选择器" class="headerlink" title="3.5 属性选择器"></a>3.5 属性选择器</h3><h4 id="1-使用属性选择器"><a href="#1-使用属性选择器" class="headerlink" title="1 使用属性选择器"></a>1 使用属性选择器</h4><p>[a],[a=v],!=,^=,$=,*=,[a1][a2][aN] </p>
<h4 id="2-使用属性选择器的实现方法"><a href="#2-使用属性选择器的实现方法" class="headerlink" title="2 使用属性选择器的实现方法"></a>2 使用属性选择器的实现方法</h4><h3 id="3-6-表单选择器"><a href="#3-6-表单选择器" class="headerlink" title="3.6 表单选择器"></a>3.6 表单选择器</h3><h4 id="1-基本表单选择器"><a href="#1-基本表单选择器" class="headerlink" title="1 基本表单选择器"></a>1 基本表单选择器</h4><p>:input,:text,:password,:radio,:checkbox,:submit,:image,:reset,:button,:file,:hidden</p>
<h4 id="2-高级表单选择器"><a href="#2-高级表单选择器" class="headerlink" title="2 高级表单选择器"></a>2 高级表单选择器</h4><p>:enable,:disable,:checked,:selected</p>
<h4 id="3-表单选择器的实现方法"><a href="#3-表单选择器的实现方法" class="headerlink" title="3 表单选择器的实现方法"></a>3 表单选择器的实现方法</h4><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-5_事件封装机制与解析</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%205%20%E7%AB%A0%20%E4%BA%8B%E4%BB%B6%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h3 id="5-1-事件模型"><a href="#5-1-事件模型" class="headerlink" title="5.1 事件模型"></a>5.1 事件模型</h3><h4 id="1-0级事件模型"><a href="#1-0级事件模型" class="headerlink" title="1 0级事件模型"></a>1 0级事件模型</h4><h4 id="2-事件模型中的Event对象"><a href="#2-事件模型中的Event对象" class="headerlink" title="2 事件模型中的Event对象"></a>2 事件模型中的Event对象</h4><h4 id="3-事件模型中的冒泡现象"><a href="#3-事件模型中的冒泡现象" class="headerlink" title="3 事件模型中的冒泡现象"></a>3 事件模型中的冒泡现象</h4><h4 id="4-事件流控制与默认事件动作"><a href="#4-事件流控制与默认事件动作" class="headerlink" title="4 事件流控制与默认事件动作"></a>4 事件流控制与默认事件动作</h4><h4 id="5-2级DOM标准事件模型"><a href="#5-2级DOM标准事件模型" class="headerlink" title="5 2级DOM标准事件模型"></a>5 2级DOM标准事件模型</h4><p>addEventListener(type,function,useCapture)</p>
<ol>
<li>注册事件</li>
<li>事件传播</li>
<li>销毁事件<h4 id="6-IE事件模型"><a href="#6-IE事件模型" class="headerlink" title="6 IE事件模型"></a>6 IE事件模型</h4></li>
</ol>
<h3 id="5-2-jQuery事件模型"><a href="#5-2-jQuery事件模型" class="headerlink" title="5.2 jQuery事件模型"></a>5.2 jQuery事件模型</h3><h4 id="1-绑定事件"><a href="#1-绑定事件" class="headerlink" title="1 绑定事件"></a>1 绑定事件</h4><h4 id="2-注销事件"><a href="#2-注销事件" class="headerlink" title="2 注销事件"></a>2 注销事件</h4><h4 id="3-jQuery事件模型中的Event对象"><a href="#3-jQuery事件模型中的Event对象" class="headerlink" title="3 jQuery事件模型中的Event对象"></a>3 jQuery事件模型中的Event对象</h4><h4 id="4-jQuery事件触发"><a href="#4-jQuery事件触发" class="headerlink" title="4 jQuery事件触发"></a>4 jQuery事件触发</h4><h4 id="5-jQuery事件切换"><a href="#5-jQuery事件切换" class="headerlink" title="5 jQuery事件切换"></a>5 jQuery事件切换</h4><ol>
<li>使用toggle()切换</li>
<li>使用hover()切换<h4 id="6-jQuery事件委派"><a href="#6-jQuery事件委派" class="headerlink" title="6 jQuery事件委派"></a>6 jQuery事件委派</h4>live(),die()<h4 id="7-jQuery事件命名空间"><a href="#7-jQuery事件命名空间" class="headerlink" title="7 jQuery事件命名空间"></a>7 jQuery事件命名空间</h4>$().unbind(“.a”) $().trigger(“click!”)<h4 id="8-jQuery多事件绑定"><a href="#8-jQuery多事件绑定" class="headerlink" title="8 jQuery多事件绑定"></a>8 jQuery多事件绑定</h4><h4 id="9-jQuery自定义事件"><a href="#9-jQuery自定义事件" class="headerlink" title="9 jQuery自定义事件"></a>9 jQuery自定义事件</h4></li>
</ol>
<h3 id="5-3-jQuery页面初始化"><a href="#5-3-jQuery页面初始化" class="headerlink" title="5.3 jQuery页面初始化"></a>5.3 jQuery页面初始化</h3><h4 id="1-使用jQuery的ready-方法"><a href="#1-使用jQuery的ready-方法" class="headerlink" title="1 使用jQuery的ready()方法"></a>1 使用jQuery的ready()方法</h4><p>$(document).ready(function(a){})//一个参数a—引用jQuery函数，并<br>JQuery(function($){})<br>$(function(){})</p>
<p>$(function(me){me(‘div’).text(‘jQ函数别名’)})//默认$,或jQuery<br>不能和原生的load同用</p>
<h4 id="2-ready事件的触发时机"><a href="#2-ready事件的触发时机" class="headerlink" title="2 ready事件的触发时机"></a>2 ready事件的触发时机</h4><p>$(window).load()</p>
<h4 id="3-初始化事件的多次调用"><a href="#3-初始化事件的多次调用" class="headerlink" title="3 初始化事件的多次调用"></a>3 初始化事件的多次调用</h4><p>load，第一次被第二次覆盖了<br>如果多个文件，ready可以无限多次调用</p>
<h4 id="4-使用JS自定义的addLoadEvent"><a href="#4-使用JS自定义的addLoadEvent" class="headerlink" title="4 使用JS自定义的addLoadEvent"></a>4 使用JS自定义的addLoadEvent</h4><p>轻松实现多次调用load事件<br>    function addLoadEvent(func){<br>        var oldOnload=window.onload<br>        if(typeof window.onload!=’function’){<br>            window.onload=func<br>        }else{<br>            window.onload=function(){<br>                oldOnload();<br>                func()<br>            }<br>        }<br>    }</p>
<h3 id="5-4-使用JS自定义jQ的事件方法"><a href="#5-4-使用JS自定义jQ的事件方法" class="headerlink" title="5.4 使用JS自定义jQ的事件方法"></a>5.4 使用JS自定义jQ的事件方法</h3><h4 id="1-JS与jQ的执行效率比较"><a href="#1-JS与jQ的执行效率比较" class="headerlink" title="1 JS与jQ的执行效率比较"></a>1 JS与jQ的执行效率比较</h4><p>原生比库执行效率更高（选择器，和事件模型）<br>load更好，不用担心兼容，且两者可以混合使用<br>浏览器兼容性很大差异的鼠标事件，jQ</p>
<h4 id="2-自定义ready-方法"><a href="#2-自定义ready-方法" class="headerlink" title="2 自定义ready()方法"></a>2 自定义ready()方法</h4><p>DOMContentLoaded;IE,onreadystatechange–document.readyState===’complete’<br>注销，避免反复触发</p>
<p>针对IE，模拟DOMContentLoaded事件的方法：判断document是否可以滚动</p>
<h4 id="3-自定义bind-方法"><a href="#3-自定义bind-方法" class="headerlink" title="3 自定义bind()方法"></a>3 自定义bind()方法</h4><p>DOMextend(“bind”,function(type,data,fn){<br>    var _this=_this<br>    if(_this.addEventListener){<br>        _this.addEventListener(type,function(event){<br>            event.datas=data<br>            fn(event)<br>        },false)<br>    }else{<br>        _this.attachEvent(“on”+type,function(){<br>            var event=window.event<br>        })<br>    }<br>    return _this<br>})</p>
<h4 id="4-自定义one-方法"><a href="#4-自定义one-方法" class="headerlink" title="4 自定义one()方法"></a>4 自定义one()方法</h4><p>bind基础上添加注销行为</p>
<p style="text-align:right">2018.1.12 星期五 00：11 P242</p>


<h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h3 id="6-1-直接显示和隐藏"><a href="#6-1-直接显示和隐藏" class="headerlink" title="6.1 直接显示和隐藏"></a>6.1 直接显示和隐藏</h3><h3 id="6-2-滑动显示和隐藏"><a href="#6-2-滑动显示和隐藏" class="headerlink" title="6.2 滑动显示和隐藏"></a>6.2 滑动显示和隐藏</h3><h3 id="6-3-渐隐和渐显"><a href="#6-3-渐隐和渐显" class="headerlink" title="6.3 渐隐和渐显"></a>6.3 渐隐和渐显</h3><h3 id="6-4-自定义动画"><a href="#6-4-自定义动画" class="headerlink" title="6.4 自定义动画"></a>6.4 自定义动画</h3><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>犀利开发—jQuery内核详解与实践-4_文档对象的操作及高效实践</title>
    <url>/pdf/jslib/%E7%8A%80%E5%88%A9%E5%BC%80%E5%8F%91-jQuery%E5%86%85%E6%A0%B8%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E7%AC%AC%204%20%E7%AB%A0%20%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="第-1-章-jQ起步"><a href="#第-1-章-jQ起步" class="headerlink" title="第 1 章 jQ起步"></a>第 1 章 jQ起步</h2><h2 id="第-2-章-jQ解密技术"><a href="#第-2-章-jQ解密技术" class="headerlink" title="第 2 章 jQ解密技术"></a>第 2 章 jQ解密技术</h2><h2 id="第-3-章-高效选择的技巧与原理"><a href="#第-3-章-高效选择的技巧与原理" class="headerlink" title="第 3 章 高效选择的技巧与原理"></a>第 3 章 高效选择的技巧与原理</h2><h2 id="第-4-章-文档对象的操作及高效实践"><a href="#第-4-章-文档对象的操作及高效实践" class="headerlink" title="第 4 章 文档对象的操作及高效实践"></a>第 4 章 文档对象的操作及高效实践</h2><h3 id="4-1-DOM标准"><a href="#4-1-DOM标准" class="headerlink" title="4.1 DOM标准"></a>4.1 DOM标准</h3><h4 id="1-分解DOM"><a href="#1-分解DOM" class="headerlink" title="1 分解DOM"></a>1 分解DOM</h4><h4 id="2-HTML-DOM"><a href="#2-HTML-DOM" class="headerlink" title="2 HTML DOM"></a>2 HTML DOM</h4><h4 id="3-DOM-Core"><a href="#3-DOM-Core" class="headerlink" title="3 DOM Core"></a>3 DOM Core</h4><p>Netscape document.layers[“id”]<br>微软 document.all[“id”]<br>0级DOM<br>1998.10 DOM Level1 </p>
<h4 id="4-DOM文档树"><a href="#4-DOM文档树" class="headerlink" title="4 DOM文档树"></a>4 DOM文档树</h4><h3 id="4-2-创建节点"><a href="#4-2-创建节点" class="headerlink" title="4.2 创建节点"></a>4.2 创建节点</h3><p>元素、属性、文档、注释</p>
<h4 id="1-创建元素"><a href="#1-创建元素" class="headerlink" title="1 创建元素"></a>1 创建元素</h4><ol>
<li>jQ实现</li>
<li>JS实现</li>
<li>实现方法比较：JS执行效率差距明显<h4 id="2-创建文本"><a href="#2-创建文本" class="headerlink" title="2 创建文本"></a>2 创建文本</h4></li>
<li>var txt=document.createTextNode(“dom稳定度) </li>
<li>差距进一步拉大<h4 id="3-创建属性"><a href="#3-创建属性" class="headerlink" title="3 创建属性"></a>3 创建属性</h4></li>
<li>JS</li>
</ol>
<p>综上：虽然jQ方法简易，去拖延了代码的执行效率。建议多用JS直接操作DOM</p>
<h3 id="4-3-插入元素"><a href="#4-3-插入元素" class="headerlink" title="4.3 插入元素"></a>4.3 插入元素</h3><ol>
<li><p>jQuery实现</p>
<ol>
<li>节点内部插入内容：append,appendTo,prepend,prependTo</li>
<li>节点外部插入内容：after,before,insertAfter,insertBefore</li>
<li>插入内容的破坏性<br>1.3.2中，appendTo,prependTo,insertAfter,insertBefore</li>
</ol>
</li>
<li><p>JS实现 </p>
</li>
<li>自定义JS扩展DOM功能函数<br> var DOMextend=function(name,fn){<pre><code>if(!document.all){//非IE
    eval(&quot;HTMLElement.prototype.&quot;+name+&quot;=fn&quot;);
}else{
    var _createElement=document.createElement
    document.createElement=function(tag){
        var _elem=_createElement(tag)
        eval(&quot;_elem.&quot;+name+&quot;=fn&quot;)
        return _elem
    }
    var _getElementById=document.getElementById
    document.getElementById=function(id){
        ..
        return _elem
    }
    var _getElementByTagName=
}
</code></pre> }</li>
<li>使用JS自定义appendTo,prependTo方法<br> DOMextend(“appendTo”,function(e){<pre><code>var _this=_this
e.appendChild(this)
return _this
</code></pre> })    </li>
<li>使用JS自定义after,before方法    </li>
<li>使用JS自定义insertAfter,insertBefore方法<br> DOMextend(“insertBefore”,function(e){<pre><code>var _this=this
e.parentNode.insertBefore(_this,e)
return _this
</code></pre> })</li>
</ol>
<h3 id="4-4-删除元素"><a href="#4-4-删除元素" class="headerlink" title="4.4 删除元素"></a>4.4 删除元素</h3><ol>
<li>jQ实现<br>remove,empty    </li>
<li>JS实现</li>
<li>使用JS自定义的empty方法</li>
</ol>
<h3 id="4-5-复制元素"><a href="#4-5-复制元素" class="headerlink" title="4.5 复制元素"></a>4.5 复制元素</h3><ol>
<li>jQ实现<br>clone,不复制事件（onclick复制），需要传参true    </li>
<li>JS实现<br>预定义了cloneNode() 参数：true，是否包括原节点的属性和子节点</li>
</ol>
<h3 id="4-6-替换元素"><a href="#4-6-替换元素" class="headerlink" title="4.6 替换元素"></a>4.6 替换元素</h3><ol>
<li>jQ实现<br>replaceWith,replaceAll</li>
<li>JS实现<br>预定义了replaceChild(将，被)</li>
<li>使用JS自定义的replaceWith和replaceAll方法 </li>
</ol>
<h3 id="4-7-包裹元素"><a href="#4-7-包裹元素" class="headerlink" title="4.7 包裹元素"></a>4.7 包裹元素</h3><ol>
<li>jQ实现</li>
<li>JS实现</li>
<li>使用JS自定义wrap,wrapAll,wrapInner的方法  </li>
</ol>
<h3 id="4-8-操作属性"><a href="#4-8-操作属性" class="headerlink" title="4.8 操作属性"></a>4.8 操作属性</h3><h4 id="1-设置属性"><a href="#1-设置属性" class="headerlink" title="1 设置属性"></a>1 设置属性</h4><ol>
<li>jQ实现</li>
<li>JS实现</li>
<li>执行效率比较：js块，动态设置的多考虑dom<br>用法角度，jq灵活，可以批量设置attr({src:,alt:})<h4 id="2-获取属性"><a href="#2-获取属性" class="headerlink" title="2 获取属性"></a>2 获取属性</h4><h4 id="3-删除属性"><a href="#3-删除属性" class="headerlink" title="3 删除属性"></a>3 删除属性</h4></li>
</ol>
<h3 id="4-9-操作类样式"><a href="#4-9-操作类样式" class="headerlink" title="4.9 操作类样式"></a>4.9 操作类样式</h3><h4 id="1-追加样式"><a href="#1-追加样式" class="headerlink" title="1 追加样式"></a>1 追加样式</h4><ol start="2">
<li>JS<br> setAttribute(“class”,a+” cls”)<h4 id="2-移除样式"><a href="#2-移除样式" class="headerlink" title="2 移除样式"></a>2 移除样式</h4></li>
<li>JS<br>正则匹配，替换为空<h4 id="3-切换样式"><a href="#3-切换样式" class="headerlink" title="3 切换样式"></a>3 切换样式</h4><h4 id="4-判断样式"><a href="#4-判断样式" class="headerlink" title="4 判断样式"></a>4 判断样式</h4></li>
</ol>
<h3 id="4-10-操作HTML、文本和值"><a href="#4-10-操作HTML、文本和值" class="headerlink" title="4.10 操作HTML、文本和值"></a>4.10 操作HTML、文本和值</h3><h4 id="1-读写HTML字符串"><a href="#1-读写HTML字符串" class="headerlink" title="1 读写HTML字符串"></a>1 读写HTML字符串</h4><h4 id="2-读写文本内容"><a href="#2-读写文本内容" class="headerlink" title="2 读写文本内容"></a>2 读写文本内容</h4><h4 id="3-读写表单值"><a href="#3-读写表单值" class="headerlink" title="3 读写表单值"></a>3 读写表单值</h4><p style="text-align:right;">2018.1.11 四 0：21 P182</p><br><p style="text-align:right;">2018.1.11 四 22.31 </p>

<h3 id="4-11-操作样式表"><a href="#4-11-操作样式表" class="headerlink" title="4.11 操作样式表"></a>4.11 操作样式表</h3><h4 id="1-通用CSS样式读写方法"><a href="#1-通用CSS样式读写方法" class="headerlink" title="1 通用CSS样式读写方法"></a>1 通用CSS样式读写方法</h4><p>行内-style，内部，外部：stylesheets</p>
<h4 id="2-绝对偏移位置"><a href="#2-绝对偏移位置" class="headerlink" title="2 绝对偏移位置"></a>2 绝对偏移位置</h4><h4 id="3-相对偏移位置"><a href="#3-相对偏移位置" class="headerlink" title="3 相对偏移位置"></a>3 相对偏移位置</h4><h4 id="4-扩展DOM操作函数"><a href="#4-扩展DOM操作函数" class="headerlink" title="4 扩展DOM操作函数"></a>4 扩展DOM操作函数</h4><h4 id="5-元素的宽和高"><a href="#5-元素的宽和高" class="headerlink" title="5 元素的宽和高"></a>5 元素的宽和高</h4><h3 id="4-12-元素遍历操作"><a href="#4-12-元素遍历操作" class="headerlink" title="4.12 元素遍历操作"></a>4.12 元素遍历操作</h3><ol>
<li>jQ实现 </li>
<li>JS实现</li>
</ol>
<h2 id="第-5-章-事件封装机制与解析"><a href="#第-5-章-事件封装机制与解析" class="headerlink" title="第 5 章 事件封装机制与解析"></a>第 5 章 事件封装机制与解析</h2><h2 id="第-6-章-动画效果设计及其高效实践"><a href="#第-6-章-动画效果设计及其高效实践" class="headerlink" title="第 6 章 动画效果设计及其高效实践"></a>第 6 章 动画效果设计及其高效实践</h2><h2 id="第-7-章-Ajax异步通信高效实践"><a href="#第-7-章-Ajax异步通信高效实践" class="headerlink" title="第 7 章 Ajax异步通信高效实践"></a>第 7 章 Ajax异步通信高效实践</h2><h2 id="第-8-章-高效开发和使用插件"><a href="#第-8-章-高效开发和使用插件" class="headerlink" title="第 8 章 高效开发和使用插件"></a>第 8 章 高效开发和使用插件</h2><h2 id="第-9-章-jQ辅助工具"><a href="#第-9-章-jQ辅助工具" class="headerlink" title="第 9 章 jQ辅助工具"></a>第 9 章 jQ辅助工具</h2><h2 id="第-10-章-使用jQ打造Ajax异步交互式动态网站"><a href="#第-10-章-使用jQ打造Ajax异步交互式动态网站" class="headerlink" title="第 10 章 使用jQ打造Ajax异步交互式动态网站"></a>第 10 章 使用jQ打造Ajax异步交互式动态网站</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>jslib</category>
        <category>犀利开发-jQuery内核详解与实践</category>
      </categories>
  </entry>
  <entry>
    <title>2018 英语单词</title>
    <url>/ins/ens/characters-2018/</url>
    <content><![CDATA[<a id="more"></a> 
<h2 id="2018-11"><a href="#2018-11" class="headerlink" title="2018.11"></a>2018.11</h2><p>thumbnail: 缩略图<br>thumb: 拇指</p>
<h2 id="2018-1"><a href="#2018-1" class="headerlink" title="2018.1"></a>2018.1</h2><ol>
<li>mandatory:强制性<br> mandator:委托人<br> mandatory field：必填项</li>
<li>addon：加上 （se：可以理解为插件；Is mediasoup a native addon?）<br> addon domain：插件域</li>
<li>legacy:n,遗产<br> legacy system:遗留系统   legacy components:传统组件  </li>
<li>kick:n,踢、脚、冲劲儿；v,踢、踹、蹴</li>
<li>simulcast:同播<br> simultaneous:同时</li>
<li>transmission:n,传输、传动、变数器、投射<br> trans-:反<br> mission:n,任务、使命、代表团、使馆、差、传道部；v,传道</li>
<li>util:罗马尼亚语：有帮助</li>
<li>wildcard:通配符</li>
<li>convention:n,公约、惯例、大会、常规、习俗、框框、套</li>
<li>glossary:n,词汇表</li>
<li>stats/stat:统计<br>prescription:n,处方、药方、方剂、时效、法令</li>
<li>profile:n,轮廓、剖面、侧面、侧影、侧面像、外貌、总则、翼部面</li>
<li>simulate:n,模拟<br>simultaneous:adj,同时<br>simulcast:同播<br>cast:v,投（射）、抛、撒、撇、下、付；n,铸件、抛掷、辗转</li>
<li>patch:n,补丁、傻瓜、瑕；v,补、补缀、打补丁</li>
<li>dispatch:v,调度、派遣、发送、打发、发行。。。n,牒、特派、电讯、诛戮 </li>
<li>forward:n,前锋；v,发送、促进、发；adj,前边的、前面的、前头的、先头的；adv,向前、前、在前   </li>
</ol>
<h2 id="2018-2"><a href="#2018-2" class="headerlink" title="2018.2"></a>2018.2</h2><h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><ol>
<li>Penalty：名词：罚款, 惩罚, 刑罚</li>
<li>Extensive LMS Compatibility<br>广泛的LMS兼容性</li>
</ol>
<h3 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h3><p><a href="https://www.ispringsolutions.com/ispring-quizmaker" target="_blank" rel="noopener">https://www.ispringsolutions.com/ispring-quizmaker</a></p>
<h4 id="1-单词灵活翻译，比如：first-class-features-while-plus-pinpoint-accurate"><a href="#1-单词灵活翻译，比如：first-class-features-while-plus-pinpoint-accurate" class="headerlink" title="1 单词灵活翻译，比如：first-class;features;while,plus; pinpoint accurate"></a>1 单词灵活翻译，比如：first-class;features;while,plus; pinpoint accurate</h4><p>Carefully developed by our first-class team of developers, iSpring Quiz Maker features an easy to use, intuitive interface, while providing an industry leading quiz toolbox. Plus, our renowned conversion engine provides pinpoint accurate reproduction of all effects on any screen and any device.<br>由我们的一流开发团队精心开发，iSpring Quiz Maker具有易于使用的直观界面，同时提供行业领先的测验工具箱。 另外，我们着名的转换引擎可以在任何屏幕和任何设备上精确复制所有效果。</p>
<ol>
<li>quiz:</li>
<li>intuitive:</li>
<li>renowned:</li>
<li>pinpoint:</li>
</ol>
<h4 id="2-翻译符合中文习惯，先翻译介词，最后接动词和主语，比如：后半句先翻译via，第一句先翻译的from…to"><a href="#2-翻译符合中文习惯，先翻译介词，最后接动词和主语，比如：后半句先翻译via，第一句先翻译的from…to" class="headerlink" title="2 翻译符合中文习惯，先翻译介词，最后接动词和主语，比如：后半句先翻译via，第一句先翻译的from…to"></a>2 翻译符合中文习惯，先翻译介词，最后接动词和主语，比如：后半句先翻译via，第一句先翻译的from…to</h4><p>Cover the educational process from top to bottom: deliver and track your content to your learners via any SCORM/AICC/ Tin Can-compliant LMS.<br>从上到下涵盖教育过程：通过任何符合SCORM / AICC / Tin Can标准的LMS向学习者传递和跟踪您的内容。</p>
<h4 id="3-准确短句，with只属于and后句"><a href="#3-准确短句，with只属于and后句" class="headerlink" title="3 准确短句，with只属于and后句"></a>3 准确短句，with只属于and后句</h4><p>Spice up your surveys and engage your audience with various forms of media.<br>为您的调查做好准备并通过各种形式的媒体吸引您的观众。</p>
<h4 id="4-符合第二条规律"><a href="#4-符合第二条规律" class="headerlink" title="4 符合第二条规律"></a>4 符合第二条规律</h4><p>Make your quizzes more captivating and engrossing by adding video clips and Flash movies.<br>通过添加视频剪辑和Flash电影，让您的测验更加迷人和充满活力。</p>
<ol>
<li>captivating:</li>
<li>engrossing:</li>
<li>clip:n,夹、修剪、弹夹;v,修剪、卡、剪、缩减、撱、<br>clips:剪辑<h4 id="5-单词可以有多种翻译，比如：compose。类第一条"><a href="#5-单词可以有多种翻译，比如：compose。类第一条" class="headerlink" title="5 单词可以有多种翻译，比如：compose。类第一条"></a>5 单词可以有多种翻译，比如：compose。类第一条</h4>Equations<br>Compose formulas in MS Equation Editor and instantly insert them into your quiz.<br>在MS公式编辑器中 编写 公式并立即将它们插入到测验中。</li>
<li>equations:方程</li>
<li>formulas:式, 公式, 配方</li>
<li>compose:v，撰写、组成、构成、编写、组合、合成、作曲、构、组、赋、编、写<h4 id="6-多个语句，翻译要连贯"><a href="#6-多个语句，翻译要连贯" class="headerlink" title="6 多个语句，翻译要连贯"></a>6 多个语句，翻译要连贯</h4>Reward your e-learners for a correct answer, prompt them to try again, and provide them with more insight that will ultimately lead to the right answer.<br>奖励您的电子学习者以获得正确的答案，提示他们再试一次，并为他们提供更多的见解，最终导致正确的答案。<h4 id="7-长句子的翻译，可以拆分成几句。先翻译的介词from，注意and前后的断句"><a href="#7-长句子的翻译，可以拆分成几句。先翻译的介词from，注意and前后的断句" class="headerlink" title="7 长句子的翻译，可以拆分成几句。先翻译的介词from，注意and前后的断句"></a>7 长句子的翻译，可以拆分成几句。先翻译的介词from，注意and前后的断句</h4>Choose from 11 graded and 12 survey question types to let your learners study in an engaging, entertaining way.<br>从11个分级和12个调查问题类型中进行选择，让您的学习者以吸引人的，有趣的方式进行学习。</li>
<li>Comprehensive Question Variety<br>综合问题品种<h4 id="8-长句翻译"><a href="#8-长句翻译" class="headerlink" title="8 长句翻译"></a>8 长句翻译</h4>Creating branching scenarios allows you to arrange personalized e-learner paths within every quiz.<br>创建分支场景允许您在每个测验中安排个性化的电子学习者路径。</li>
<li>scenarios<h4 id="9-foster-the-engagement"><a href="#9-foster-the-engagement" class="headerlink" title="9 foster the engagement"></a>9 foster the engagement</h4>If a student answers correctly, you can foster the engagement by asking more challenging questions.<br>如果学生正确回答，你可以通过提出更具挑战性的问题来  促进交流。</li>
<li>foster：动词：培育, 养育, 扶植</li>
<li>engagement：名词：订婚, 婚约, 约会</li>
</ol>
<h4 id="0-短句-断句翻译"><a href="#0-短句-断句翻译" class="headerlink" title="0 短句 断句翻译"></a>0 短句 断句翻译</h4><p>Set up the same scoring rules for the entire test, or, when appropriate, treat each question individually, thereby assessing the question difficulty.<br>为整个测试设置相同的评分规则，或者在适当的时候分别处理每个问题，从而评估问题的难度。</p>
<h4 id="1-短单词断句，第一、二个单词和后面的句子"><a href="#1-短单词断句，第一、二个单词和后面的句子" class="headerlink" title="1 短单词断句，第一、二个单词和后面的句子"></a>1 短单词断句，第一、二个单词和后面的句子</h4><p>Rest assured that your tests will execute flawless playback and reporting inside any SCORM/AICC compatible LMS.<br>请放心，您的测试将在任何兼容SCORM / AICC的LMS内执行完美的播放和报​​告。</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>ens</category>
      </categories>
      <tags>
        <tag>ens</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 揭秘(CSS Secrets)</title>
    <url>/pdf/css/CSS%E6%8F%AD%E7%A7%98/</url>
    <content><![CDATA[<a id="more"></a>
<!-- <p style="text-align:right">好像上上周11.7看过，这周补笔记+巩固</p> -->
<p style="text-align:right">2017.11.19 日 22：44</p><br>[希］Lea Verou  著<br>CSS魔法  译<br>人民邮电出版社出版发行<br>2016年 4 月北京第 1 次印刷<br>8章266页    47 篇攻略，并根据主题的不同收入 7 章之中<br><br>## 本书是怎样炼成的<br>通俗地说，这本书在技术上是自产自销的。它<strong>完全用 HTML5 写成</strong>，并 用 到 了 一 些 由 O’Reilly 的 HTMLBook 标 准<a href="http://oreillymedia.github.io/HTMLBook）定义的" target="_blank" rel="noopener">http://oreillymedia.github.io/HTMLBook）定义的</a> data- 属性。这意味着你在这本书里看到的每样东西（包括布局、图片、颜色等）都是由 CSS 渲染出的 HTML。大量图片是由SVG 生成的，或者是由 SCSS 函数生成的 SVG data URI。书中为数不多的数学公式是在LaTeX 中写成的，然后转换成 MathML。有一点可能会让你意想不到，书中的所有页码、章节号、攻略编号都是由纯粹的 CSS 计数器生成的。<br><br>目前 O’Reilly 出版的绝大多数图书都是以这种方式制作出来的。O’Reilly 专门为这件事搭建了一个叫作 Atlas（<a href="http://atlas.oreilly.com）的系统。Atlas" target="_blank" rel="noopener">http://atlas.oreilly.com）的系统。Atlas</a> 最美好的地方在于，它并不只是供 O’Reilly 官方专用的，对公众<br>也开放。<br>## 这本书适合谁<br>正在由中级向高级进阶的 CSS 开发者<br>## 本书的格式和约定<br>有很多优秀的网站提供了及时有效的浏览器兼容性信息。推荐如下：<br>1. Can I Use…?（<a href="http://caniuse.com）" target="_blank" rel="noopener">http://caniuse.com）</a><br>1. WebPlatform.org（<a href="http://webplatform.org）" target="_blank" rel="noopener">http://webplatform.org）</a><br>1. Mozilla Developer Network（<a href="http://developer.mozilla.org）" target="_blank" rel="noopener">http://developer.mozilla.org）</a><br>1. 维基百科上的“浏览器排版引擎对比（CSS 兼容性） ”词条（<a href="http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets)）" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets)）</a><br><br>举例来说，当我们像上面那样指定一个渐变色作为背景的时候，应该在前面添加一行实色背景的声明。添加实色的一个好方法是取渐变色的平均色值<br><br>不过，有些时候不太可能只通过样式的层叠就提供完善的回退样式。这时别忘了你还有一招，可以使用 Modernizr（<a href="http://modernizr.com/）这样的工具来给根元素（" target="_blank" rel="noopener">http://modernizr.com/）这样的工具来给根元素（</a><html>）添加一些辅助类，比如 textshadow 或 no-textshadow 等。这样你就可以针对支持或不支持某些特性的浏览器来分别编写样式了，就像这样：<br><br>    h1 { color: gray; }<br><br>    .textshadow h1 {<br>        color: transparent;<br>        text-shadow: 0 0 .3em gray;<br>    }<br><br>如果你想尝试使用的某个 CSS 特性非常新，还可以试试用 @supports规则来实现回退，可以将其视作浏览器“原生”的 Modernizr。比如说，上面的代码还可以这样写：<br>    h1 { color: gray; }<br><br>    @supports (text-shadow: 0 0 .3em gray) {<br>        h1 {<br>            color: transparent;<br>            text-shadow: 0 0 .3em gray;<br>        }<br>    }<br>但在眼下，还必须慎用 @supports。在上面的例子中，我们想要的文本投影效果只会在那些支持 text-shadow 且同时支持 @supports 规则的浏览器中生效。这个范围明显比我们所期望的要窄。<br><br>最后，同样值得一提的是，即使你不打算使用 Modernizr，也可以自己写一小段 JavaScript 代码来实现相同的功能——做一些特性检测然后给根元素加一些辅助类。如果要检测某个样式属性是否被支持，核心思路就是在任一元素的 element.style 对象上检查该属性是否存在：<br><br>    function testProperty(property) {<br>        var root = document.documentElement;<br>        if (property in root.style) {<br>            root.classList.add(property.toLowerCase());<br>            return true;<br>        }<br>        root.classList.add(‘no-‘ + property.toLowerCase());<br>        return false;<br>    }<br><br>如果我们想要检测某个具体的属性值是否支持，那就需要把它赋给对应的属性，然后再检查浏览器是不是还保存着这个值。很显然，这个过程会改变元素的样式，因此我们需要一个隐藏元素：<br><br>    function testValue(id, value, property) {<br>        var dummy = document.createElement(‘p’);<br>        dummy.style[property] = value;<br><br>        if (dummy.style[property]) {<br>            root.classList.add(id);<br>            return true;<br>        }<br><br>        root.classList.add(‘no-‘ + id);<br>        return false;<br>    }<br><br>如果要检测选择符和 @ 规则的支持情况，则会稍稍复杂一些。不过原理也很简单，在解析 CSS 代码时，浏览器总会丢弃它自己无法识别的部分，因此我们可以动态地应用样式并检查它是否生效，以此来判断浏览器是否可以识别某个特性。当然，我们也要清楚地认识到，<strong>浏览器可以解析某个 CSS特性并不代表它已经实现（或正确实现）了这个特性</strong>。<br><br>## 第1 章 引言<br>### 1.1 Web 标准：是敌还是友<br>#### 1 标准的制定过程<br>#### 2 CSS3、CSS4 以及其他传说<br>因此，我们决定跨出一步，将 CSS 打散到多个不同的规范（模块）中，每个模块都可以独立更新版本。这其中，那些延续 CSS 2.1 已有特性的模块会升级到 3 这个版本号。比如以下模块：<br>1. CSS 语法（<a href="http://w3.org/TR/css-syntax-3）" target="_blank" rel="noopener">http://w3.org/TR/css-syntax-3）</a><br>1. CSS 层叠与继承（<a href="http://w3.org/TR/css-cascade-3）" target="_blank" rel="noopener">http://w3.org/TR/css-cascade-3）</a><br>1. CSS 颜色（<a href="http://w3.org/TR/css3-color）" target="_blank" rel="noopener">http://w3.org/TR/css3-color）</a><br>1. 选择符（<a href="http://w3.org/TR/selectors）" target="_blank" rel="noopener">http://w3.org/TR/selectors）</a><br>1. CSS 背景与边框（<a href="http://w3.org/TR/css3-background）" target="_blank" rel="noopener">http://w3.org/TR/css3-background）</a><br>1. CSS 值与单位（<a href="http://w3.org/TR/css-values-3）" target="_blank" rel="noopener">http://w3.org/TR/css-values-3）</a><br>1. CSS 文本排版（<a href="http://w3.org/TR/css-text-3）" target="_blank" rel="noopener">http://w3.org/TR/css-text-3）</a><br>1. CSS 文本装饰效果（<a href="http://w3.org/TR/css-text-decor-3）" target="_blank" rel="noopener">http://w3.org/TR/css-text-decor-3）</a><br>1. CSS 字体（<a href="http://w3.org/TR/css3-fonts）" target="_blank" rel="noopener">http://w3.org/TR/css3-fonts）</a><br>1. CSS 基本 UI 特性（<a href="http://w3.org/TR/css3-ui）" target="_blank" rel="noopener">http://w3.org/TR/css3-ui）</a><br><br>此外，如果某个模块是前所未有的新概念，那它的版本号将从 1 开始。比如下面这些：<br>1. CSS 变形（<a href="http://w3.org/TR/css-transforms-1）" target="_blank" rel="noopener">http://w3.org/TR/css-transforms-1）</a><br>1. 图像混合效果（<a href="http://w3.org/TR/compositing-1）" target="_blank" rel="noopener">http://w3.org/TR/compositing-1）</a><br>1. 滤镜效果（<a href="http://w3.org/TR/filter-effects-1）" target="_blank" rel="noopener">http://w3.org/TR/filter-effects-1）</a><br>1. CSS 遮罩（<a href="http://w3.org/TR/css-masking-1）" target="_blank" rel="noopener">http://w3.org/TR/css-masking-1）</a><br>1. CSS 伸缩盒布局（<a href="http://w3.org/TR/css-flexbox-1）" target="_blank" rel="noopener">http://w3.org/TR/css-flexbox-1）</a><br>1. CSS 网格布局（<a href="http://w3.org/TR/css-grid-1）" target="_blank" rel="noopener">http://w3.org/TR/css-grid-1）</a><br><br>尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过。这一点跟 CSS 2.1 或更早的 CSS 1 不一样。真正的情况是，绝大多数编辑在提到这个词时，指的是一个非正式的集合，它包括 CSS 规范第三版（Level 3）再加上一些版本号还是 1 的新规范。<br>#### 3 冰与火之歌：浏览器前缀<br>显然，把每个声明都重复五遍是相当枯燥的，而且很难维护。因此出现<br>某个工具来把这项工作自动化只是个时间问题。<br><br>1. 像 CSS3, Please!（<a href="http://css3please.com）和" target="_blank" rel="noopener">http://css3please.com）和</a> pleeease（<a href="http://pleee-ase.io/playground.html）这样的网站允许你把无前缀的" target="_blank" rel="noopener">http://pleee-ase.io/playground.html）这样的网站允许你把无前缀的</a> CSS 代码粘贴进去，它们会自动帮你把必要的前缀都加好。这类网站是“前缀危<br>机”所催生出的第一批工具，很快就过气了，因为跟其他方案相比，它们的使用成本太高了。<br>1. Autoprefixer（<a href="https://github.com/ai/autoprefixer）采用" target="_blank" rel="noopener">https://github.com/ai/autoprefixer）采用</a> Can I Use… （<a href="http://caniuse.com）的数据库来判断哪些前缀是需要添加的；此外，它是在本地完成编译的，类似预处理器。" target="_blank" rel="noopener">http://caniuse.com）的数据库来判断哪些前缀是需要添加的；此外，它是在本地完成编译的，类似预处理器。</a><br>1. 我自己开发的 -prefix-free（<a href="http://leaverou.github.io/prefixfree）会在浏览器中进行特性检测，来决定哪些前缀是需要的。它的好处在于几乎不需要更新，因为其所有信息都是用一份属性清单在真实的浏览器环境中跑出来的结果。" target="_blank" rel="noopener">http://leaverou.github.io/prefixfree）会在浏览器中进行特性检测，来决定哪些前缀是需要的。它的好处在于几乎不需要更新，因为其所有信息都是用一份属性清单在真实的浏览器环境中跑出来的结果。</a><br>1. 类 似 Stylus（<a href="http://stylus-lang.com/）" target="_blank" rel="noopener">http://stylus-lang.com/）</a> 、LESS（<a href="http://lesscss.org）" target="_blank" rel="noopener">http://lesscss.org）</a> 或Sass（<a href="http://sass-lang.com）的预处理器并不自带任何加前缀的方法，但很多人开发过一些能为常用属性加前缀的" target="_blank" rel="noopener">http://sass-lang.com）的预处理器并不自带任何加前缀的方法，但很多人开发过一些能为常用属性加前缀的</a> mixin；社区中也有一些库提供了这类 mixin。<br><br>最近，浏览器厂商已经很少以前缀的方式来实验性地实现新特性了。取而代之的是，这些实验性特性需要通过<strong>配置开关来启用</strong>，<br>### 1.2 CSS 编码技巧<br>#### 1 尽量减少代码重复<br>在实践中，代码可维护性的最大要素是<strong>尽量减少改动时要编辑的地方</strong>。<br><strong>当某些值相互依赖时，应该把它们的相互关系用代码表达出来</strong>。<code>font-size: 20px; line-height: 1.5;</code><br>1. 代码易维护 vs. 代码量少  不可兼得<br>2. currentColor  CSS 中有史以来的第一个变量<br>    &gt; 可能有人会争论说 em 单位才是 CSS 中的第一个变量，因为它引用了font-size 的值。其实大多数百分比数值也扮演了类似的角色，只不过它们的工作方式不是很起眼。<br>3. 继承<br><br>#### 2 相信你的眼睛，而不是数字<br>#### 3 关于响应式网页设计<br>然而对于今后的 CSS 改动来说，每个媒体查询都会增加成本，而这种成本是不应轻易上升的。<br><br>这并不是说媒体查询是一种不良实践。只要用对了，它就是利器。但是，你只应该把它作为最后的手段。<br><br>下面还有一些建议，可能会帮你避免不必要的媒体查询。<br>1. 使用百分比长度来取代固定长度。如果实在做不到这一点，也应该尝试使用与视口相关的单位（vw、vh、vmin 和 vmax） ，它们的值解析为视口宽度或高度的百分比。<br>1. 当你需要在较大分辨率下得到固定宽度时，使用 max-width 而不是width，因为它可以适应较小的分辨率，而无需使用媒体查询。<br>1. 不要忘记为替换元素（比如 img、object、video、iframe 等）设置一个 max-width，值为 100%。<br>1. 假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化，background-size: cover 这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张大图缩小显示往往是不太明智的。<br>1. 当图片（或其他元素）以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局（即 Flexbox）或者 display: inline-block加上常规的文本折行行为，都可以实现这一点。<br>1. 在使用多列文本时，指定 column-width（列宽）而不是指定column-count（列数） ，这样它就可以在较小的屏幕上自动显示为单列布局。<br>#### 4 合理使用简写<br>合理使用简写是一种良好的防卫性编码方式，可以抵御未来的风险。当然，如果我们要明确地去覆盖某个具体的展开式属性并保留其他相关样式，那就需要用展开式<br>属性，就像我们在“尽量减少代码重复”一节中为了得到按钮的其他颜色版本所做的那样。<br><br>其实我们可以从 CSS 的“列表扩散规则”那里得到好处。它的意思是说，<strong>如果只为某个属性提供一个值，那它就会扩散并应用到列表中的每一项</strong>。因此，我们可以把这些重复的值从简写属性中抽出来写成一个展开式属性：<br><br>    background: url(tr.png) top right,<br>                url(br.png) bottom right,<br>                url(bl.png) bottom left;<br>    background-size: 2em 2em;<br>    background-repeat: no-repeat;<br>#### 5 我应该使用预处理器吗<br>不过，预处理器也不是完美无缺的。<br><br>&gt; 怪异的简写语法<br>在 background 简写属性中指定 background-size时，需要同时提供一个 background-position 值（哪怕它的值就是其初始值也需要写出来） ，而且还要使用一个斜杠（/）作为分隔。为什么有些简写的语法如此怪异？<br>这通常都是为了消除歧义。在这个例子中，top right 显然是background-position，而 2em 2em 是background-size，不管它们的顺序如何。但是，请设想一下 50% 50% 这样的值，它到底是 background-size 还是 background-position 呢？<br>对绝大多数的简写属性来说，并没有这样的歧义问题，因而简写属性的多个值往往可以随意排列。不过，我还是建议你养成随手查阅语法的好习惯，<br><br>或者在未来，说不定预处理器最受欢迎的那些特性都被加入了原生 CSS 中。很惊讶吗？没错，很多受预处理器启发的特性都已经以各种方式融入到原生 CSS 中了。<br><br>请注意，这些原生特性通常比预处理器提供的版本要强大得多，因为它们是动态的<br>1(①不要忘了这样的原生 CSS 特性也可以通过脚本来操纵。比如说，你可以用 JS 来改变一个变量的值)。举个例子，预处理器完全不知道如何完成 100% - 50px 这样的计算，因为在页面真正被渲染之前，百分比值是无法解析的。但是，原生CSS 的 calc() 在计算这样的表达式时没有任何压力。与此类似，下面这样的变量玩法在预处理器中是不可能做到的：<br><br>    ul { –accent-color: purple; }<br>    ol { –accent-color: rebeccapurple; }<br>    li { background: var(–accent-color); }<br><p style="text-align:right">11.19 23：34</p>

<h2 id="第2-章-背景与边框"><a href="#第2-章-背景与边框" class="headerlink" title="第2 章 背景与边框"></a>第2 章 背景与边框</h2><h3 id="1-半透明边框"><a href="#1-半透明边框" class="headerlink" title="1  半透明边框"></a>1  半透明边框</h3><h3 id="2-多重边框"><a href="#2-多重边框" class="headerlink" title="2　多重边框"></a>2　多重边框</h3><h3 id="3-灵活的背景定位"><a href="#3-灵活的背景定位" class="headerlink" title="3　灵活的背景定位"></a>3　灵活的背景定位</h3><h3 id="4-边框内圆角"><a href="#4-边框内圆角" class="headerlink" title="4　边框内圆角"></a>4　边框内圆角</h3><h3 id="5-条纹背景"><a href="#5-条纹背景" class="headerlink" title="5　条纹背景"></a>5　条纹背景</h3><h3 id="6-复杂的背景图案"><a href="#6-复杂的背景图案" class="headerlink" title="6  复杂的背景图案"></a>6  复杂的背景图案</h3><h3 id="7-伪随机背景"><a href="#7-伪随机背景" class="headerlink" title="7　伪随机背景"></a>7　伪随机背景</h3><h3 id="8-连续的图像边框"><a href="#8-连续的图像边框" class="headerlink" title="8　连续的图像边框"></a>8　连续的图像边框</h3><h2 id="第3-章-形状"><a href="#第3-章-形状" class="headerlink" title="第3 章 形状"></a>第3 章 形状</h2><h3 id="9-自适应的椭圆"><a href="#9-自适应的椭圆" class="headerlink" title="9   自适应的椭圆"></a>9   自适应的椭圆</h3><h3 id="10-平行四边形"><a href="#10-平行四边形" class="headerlink" title="10　平行四边形"></a>10　平行四边形</h3><h3 id="11-菱形图片"><a href="#11-菱形图片" class="headerlink" title="11　菱形图片"></a>11　菱形图片</h3><h3 id="12-切角效果"><a href="#12-切角效果" class="headerlink" title="12　切角效果"></a>12　切角效果</h3><h3 id="13-梯形标签页"><a href="#13-梯形标签页" class="headerlink" title="13　梯形标签页"></a>13　梯形标签页</h3><h3 id="14-简单的饼图"><a href="#14-简单的饼图" class="headerlink" title="14　简单的饼图"></a>14　简单的饼图</h3><h2 id="第4-章-视觉效果"><a href="#第4-章-视觉效果" class="headerlink" title="第4 章 视觉效果"></a>第4 章 视觉效果</h2><h3 id="15-单侧投影"><a href="#15-单侧投影" class="headerlink" title="15  单侧投影"></a>15  单侧投影</h3><h3 id="16-不规则投影"><a href="#16-不规则投影" class="headerlink" title="16　不规则投影"></a>16　不规则投影</h3><h3 id="17-染色效果"><a href="#17-染色效果" class="headerlink" title="17　染色效果"></a>17　染色效果</h3><h3 id="18-毛玻璃效果"><a href="#18-毛玻璃效果" class="headerlink" title="18　毛玻璃效果"></a>18　毛玻璃效果</h3><h3 id="19-折角效果"><a href="#19-折角效果" class="headerlink" title="19　折角效果"></a>19　折角效果</h3><h2 id="第5-章-字体排印"><a href="#第5-章-字体排印" class="headerlink" title="第5 章 字体排印"></a>第5 章 字体排印</h2><h3 id="20-连字符断行-113"><a href="#20-连字符断行-113" class="headerlink" title="20  连字符断行 113"></a>20  连字符断行 113</h3><h3 id="21-插入换行-115"><a href="#21-插入换行-115" class="headerlink" title="21　插入换行 115"></a>21　插入换行 115</h3><h3 id="22-文本行的斑马条纹-119"><a href="#22-文本行的斑马条纹-119" class="headerlink" title="22　文本行的斑马条纹 119"></a>22　文本行的斑马条纹 119</h3><h3 id="23-调整-tab-的宽度-121"><a href="#23-调整-tab-的宽度-121" class="headerlink" title="23　调整 tab 的宽度 121"></a>23　调整 tab 的宽度 121</h3><h3 id="24-连字-123"><a href="#24-连字-123" class="headerlink" title="24　连字 123"></a>24　连字 123</h3><h3 id="25-华丽的-amp-符号-125"><a href="#25-华丽的-amp-符号-125" class="headerlink" title="25　华丽的 &amp; 符号 125"></a>25　华丽的 &amp; 符号 125</h3><h3 id="26-自定义下划线-129"><a href="#26-自定义下划线-129" class="headerlink" title="26　自定义下划线 129"></a>26　自定义下划线 129</h3><h3 id="27-现实中的文字效果-132"><a href="#27-现实中的文字效果-132" class="headerlink" title="27　现实中的文字效果 132"></a>27　现实中的文字效果 132</h3><h3 id="28-环形文字-138"><a href="#28-环形文字-138" class="headerlink" title="28　环形文字 138"></a>28　环形文字 138</h3><h2 id="第6-章-用户体验"><a href="#第6-章-用户体验" class="headerlink" title="第6 章 用户体验"></a>第6 章 用户体验</h2><h3 id="29-选用合适的鼠标光标-144"><a href="#29-选用合适的鼠标光标-144" class="headerlink" title="29　选用合适的鼠标光标 144"></a>29　选用合适的鼠标光标 144</h3><h3 id="30-扩大可点击区域-147"><a href="#30-扩大可点击区域-147" class="headerlink" title="30　扩大可点击区域 147"></a>30　扩大可点击区域 147</h3><h3 id="31-自定义复选框-149"><a href="#31-自定义复选框-149" class="headerlink" title="31　自定义复选框 149"></a>31　自定义复选框 149</h3><h3 id="32-通过阴影来弱化背景-153"><a href="#32-通过阴影来弱化背景-153" class="headerlink" title="32　通过阴影来弱化背景 153"></a>32　通过阴影来弱化背景 153</h3><h3 id="33-通过模糊来弱化背景-157"><a href="#33-通过模糊来弱化背景-157" class="headerlink" title="33　通过模糊来弱化背景 157"></a>33　通过模糊来弱化背景 157</h3><h3 id="34-滚动提示-159"><a href="#34-滚动提示-159" class="headerlink" title="34　滚动提示 159"></a>34　滚动提示 159</h3><h3 id="35-交互式的图片对比控件-164"><a href="#35-交互式的图片对比控件-164" class="headerlink" title="35　交互式的图片对比控件 164"></a>35　交互式的图片对比控件 164</h3><h2 id="第7-章-结构与布局"><a href="#第7-章-结构与布局" class="headerlink" title="第7 章 结构与布局"></a>第7 章 结构与布局</h2><h3 id="36-自适应内部元素-173"><a href="#36-自适应内部元素-173" class="headerlink" title="36　自适应内部元素 173"></a>36　自适应内部元素 173</h3><h3 id="37-精确控制表格列宽-175"><a href="#37-精确控制表格列宽-175" class="headerlink" title="37　精确控制表格列宽 175"></a>37　精确控制表格列宽 175</h3><h3 id="38-根据兄弟元素的数量来设置样式-178"><a href="#38-根据兄弟元素的数量来设置样式-178" class="headerlink" title="38　根据兄弟元素的数量来设置样式 178"></a>38　根据兄弟元素的数量来设置样式 178</h3><h3 id="39-满幅的背景，定宽的内容-182"><a href="#39-满幅的背景，定宽的内容-182" class="headerlink" title="39　满幅的背景，定宽的内容 182"></a>39　满幅的背景，定宽的内容 182</h3><h3 id="40-垂直居中-185"><a href="#40-垂直居中-185" class="headerlink" title="40　垂直居中 185"></a>40　垂直居中 185</h3><h3 id="41-紧贴底部的页脚-191"><a href="#41-紧贴底部的页脚-191" class="headerlink" title="41　紧贴底部的页脚 191"></a>41　紧贴底部的页脚 191</h3><h2 id="第8-章-过渡与动画"><a href="#第8-章-过渡与动画" class="headerlink" title="第8 章 过渡与动画"></a>第8 章 过渡与动画</h2><h3 id="42-缓动效果-196"><a href="#42-缓动效果-196" class="headerlink" title="42　缓动效果 196"></a>42　缓动效果 196</h3><h3 id="43-逐帧动画-205"><a href="#43-逐帧动画-205" class="headerlink" title="43　逐帧动画 205"></a>43　逐帧动画 205</h3><h3 id="44-闪烁效果-209"><a href="#44-闪烁效果-209" class="headerlink" title="44　闪烁效果 209"></a>44　闪烁效果 209</h3><h3 id="45-打字动画-212"><a href="#45-打字动画-212" class="headerlink" title="45　打字动画 212"></a>45　打字动画 212</h3><h3 id="46-状态平滑的动画-217"><a href="#46-状态平滑的动画-217" class="headerlink" title="46　状态平滑的动画 217"></a>46　状态平滑的动画 217</h3><h3 id="47-沿环形路径平移的动画-221"><a href="#47-沿环形路径平移的动画-221" class="headerlink" title="47　沿环形路径平移的动画 221"></a>47　沿环形路径平移的动画 221</h3><h2 id="按规范分类-230"><a href="#按规范分类-230" class="headerlink" title="按规范分类 230"></a>按规范分类 230</h2></html>]]></content>
      <categories>
        <category>pdf</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>响应式Web设计：HTML5和CSS3实战</title>
    <url>/pdf/css/%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E8%AE%BE%E8%AE%A1%EF%BC%9AHTML5%E5%92%8CCSS3%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p style="text-align:right">好像上周11.12看的，这周补笔记+巩固</p><br><p style="text-align:right">2017.11.18 六 23:20</p><br>人民邮电出版社出版发行<br>著　　　　[英] Ben Frain<br>译　　　　王永强<br>2013年 1 月北京第 1 次印刷<br>9章246页<br><br>## 前言<br>第 1章，HTML5、CSS3及响应式设计入门，定义了什么是响应式网页设计，展示了一些响应式设计的网站示例，重点强调了使用 HTML5和 CSS3的优势。<br><br>第 2 章，媒体查询：支持不同的视口，讲解了什么是媒体查询，如何实现媒体查询，以及如何针对设备能力匹配 CSS样式，将其应用于任意设计。<br><br>第 3 章，拥抱流式布局，讲解了流式布局的优点，以及如何将一个现有的固定宽度设计轻松地转换为流式布局，怎样使用 CSS框架快速搭建响应式网页。<br><br>第 4章，响应式设计中的 HTML5，探讨了使用 HTML5技术的诸多好处，比如更简洁的代码、语义化标签、离线存储，以及无障碍网页应用辅助技术。<br><br>第 5 章，CSS3：选择器、字体和颜色模式，展示了 CSS3 选择器的强大威力，可以让你轻松地指定和改变任何元素。 还讲解了通过@font-face声明来使用漂亮的网络字体， 另外讲解了新的 CSS3颜色模式如 RGB(A)和 HSL(A)。<br><br>第 6章，用 CSS3创造令人惊艳的美，展示了如何使用纯粹的 CSS3代码实现文字阴影、盒阴影和渐变效果。还涵盖了如何使用多重背景图片，以及如何通过字体文件创建图标。<br><br>第 7章，CSS3的过渡、变形和动画，讲解如何仅使用 CSS3来创建和转换屏幕上的元素，并制作动画效果。<br><br>第 8章，用 HTML5和 CSS3征服表单，阐述了在所有设备上（从最新的智能手机到桌面版浏览器）都能良好运行的跨浏览器表单开发技巧。<br><br>第 9章，解决跨浏览器问题，讲解了如何保证老版本的 Internet Explorer可响应，如何将一组链接修改成移动设备上的一个菜单，如何为高分辨率显示器提供不同内容，以及如何使用 Modernizr框架分条件地加载资源文件。<br><br>## 第 1章  HTML5、CSS3及响应式设计入门<br>1. 支持小屏幕设备的重要性、什么是移动网站设计<br>2. 什么是响应式网页设计<br>3. 优秀响应式网页实例赏析<br>4. 视口和屏幕的区别<br>5. 安装和使用修改视口的浏览器扩展程序<br>6. 使用 HTML5编写更简洁的标记<br>7. 使用 CSS3解决常见的设计问题<br>### 1.1 为什么智能手机很重要（而老版的 IE 不再重要）<br>### 1.2 响应式设计一定是最佳选择吗<br>### 1.3 响应式网页设计的定义<br>响应式网页设计（RWD，Responsive Web Design）这个术语，由伊桑·马科特（Ethan<br>Marcotte）提出。他在 A List Apart发表了一篇开创性的文章，<strong>将三种已有的开发技巧（弹<br>性网格布局、弹性图片、媒体和媒体查询）整合起来，并命名为响应式网页设计</strong>。这个<br>术语还有一堆表示相同意思的其他叫法，如流式设计、弹性布局、塑料布局、流体设计、<br>自适应布局、跨设备设计以及弹性设计。<br><br>上面仅列举了其中一部分！不过，正如马科特等人所说， <strong>真正的响应式设计方法</strong>不仅仅只是根据视口大小改变网页布局。相反，它是要从整体上颠覆我们当前设计网页的方法。<br>以往我们先是针对桌面电脑进行固定宽度设计，然后将其缩小并针对小屏幕进行内容重排；现在我们应该首先针对小屏幕进行设计，然后逐步增强针对大屏幕的设计和内容 。<br><br>### 1.5 响应式网页设计示例<br>#### 1.5.1 下载视口调试工具<br>1. Internet Explorer用户请下载安装 Microsoft Internet Explorer Developer Toolbar，下载地址<br>如下：<a href="http://www.microsoft.com/download/en/details.aspx?id=18359" target="_blank" rel="noopener">http://www.microsoft.com/download/en/details.aspx?id=18359</a><br><br>2. 如果你在使用 Safari，虽然 ResizeMe（<a href="http://web.me.com/aaronholla/Safari_Extensions/" target="_blank" rel="noopener">http://web.me.com/aaronholla/Safari_Extensions/</a><br>ResizeMe.html）的功能类似且免费，但我最爱 Resize（<a href="http://resizeSafari.com）" target="_blank" rel="noopener">http://resizeSafari.com）</a><br><br>3. Firefox 用户请下载 Firesizer（<a href="https://addons.mozilla.org/en-US/firefox/addon/firesizer/）" target="_blank" rel="noopener">https://addons.mozilla.org/en-US/firefox/addon/firesizer/）</a><br><br>4. Chrome 请下载 Windows Resizer（<a href="https://chrome.google.com/webstore/detail/kkelicaakdan" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/kkelicaakdan</a><br>hinjdeammmilcgefonfh）<br><br>不喜欢使用浏览器扩展？还有一个方法：我写了个简单 HTML页面来显示浏览器窗口的当前视口高度和宽度。 页面用了 jQuery框架， 获取当前的视口的高度和宽度并显示出来。你可以在浏览器新标签页中打开这个页面，调整窗口大小，然后切回你要测试的页面查看<br>效果。这个超级简单的“What size is my viewport page?”页面地址如下：<a href="http://benfrain.com/easily-display-the-viewport-size-of-your-page-for-responsive-designs/" target="_blank" rel="noopener">http://benfrain.com/easily-display-the-viewport-size-of-your-page-for-responsive-designs/</a><br><br><br>### 1.6 为什么 HTML5 很优秀<br>#### 1.6.1 省时省力<br>1. 我写页面的时候从来不会手工敲出文档类型声明<br>2. type 属性不再是必需的。链接 CSS文件与此类似(单双引号也可以省)<br>（但 HTML5 并 不介意，这 样的代码照 样能够通过 W3C 的 HTML5 验证 工 具（<a href="http://validator.w3.org/）的验证。）" target="_blank" rel="noopener">http://validator.w3.org/）的验证。）</a><br>#### 1.6.2 新增了语义化标签元素<br>假如看到一个结束标签，你会立即明白哪个标签结束了，不用注释。<br>####<br>####<br><br>### 1.7 CSS3 为响应式设计和更多创新奠定了基础<br>&gt; CSS3是在 CSS 2基础上按模块构建的，以 CSS 2.1标准为核心。每个模块都会增加功能或是替换 CSS 2.1 标准中已有章节。CSS 工作组的设想是新的 CSS 模块不会与 CSS 2.1标准冲突，这些模块只会追加新功能，改进已有规定。<br>#### 1.7.1 底线：CSS3 不破坏任何东西<br><br>#### 1.7.2 CSS3 如何解决日常设计问题<br>界面元素创建圆角效果:滑动门技术  （<a href="http://www.alistapart.com/articles/slidingdoors/）来实现，即将一张背景图片放在另一张后面。" target="_blank" rel="noopener">http://www.alistapart.com/articles/slidingdoors/）来实现，即将一张背景图片放在另一张后面。</a><br><br>不再需要渐变背景图片<br>### 1.8 看呐，不用图片<br>“渐进增强”<br>#### CSS3 还带来了什么<br>### 1.9 HTML5 和 CSS3 现在就能用吗<br>以我的经验，一开始通常会问自己以下问题:<br>### 1.10 响应式网页设计不是灵丹妙药<br>### 1.11 引导客户：网站不必在所有浏览器中表现一致<br>### 1.12 小结<br><br>## 第 2 章  媒体查询：支持不同的视口<br>1.  理解为什么响应式设计需要媒体查询<br>1.  如何构造 CSS3媒体查询<br>1.  我们能够检测哪些设备特性<br>1.  编写第一个 CSS3媒体查询<br>1.  为特定视口设定 CSS样式<br>1.  如何在 iOS和 Android设备上使用媒体查询<br>### 2.1 现在就能使用媒体查询<br>&gt; W3C对规范有一套完整的审批流程（如果你有空， 可以去看看该流程的官方说明，地址：<a href="http://www.w3.org/2005/10/Process-20051014/tr）" target="_blank" rel="noopener">http://www.w3.org/2005/10/Process-20051014/tr）</a> ，从工作 草 案 （ Working Draft ， WD ） ， 到 候 选 推 荐 标 准 （ Candidate Recommendation ， CR ）， 再 到 提 议 推 荐 标 准 （ Proposed Recommendation，PR） ，几年之后，才能成为 W3C 推荐标准（REC） 。<br>&gt;<br>&gt; 所以那些相对成熟的模块使用起来比较安全。比如，<br>### 2.2 为什么响应式设计需要媒体查询<br>#### 2.2.1 媒体查询语法<br>    @media screen and (max-width: 550px) { }<br>    <link rel="stylesheet" media="screen and (orientation: portrait)" href="portrait- 
    screen.css"><br><br>    @import url(“phone.css”) screen and (max-width:360px);<br>切记，使用 CSS 的@import 方式会增加 HTTP 请求（这会影响加载速度） ，所以请谨慎使用该方法。<br>#### 2.2.2  媒体查询能检测那些特性<br>1. width：视口宽度。<br>1. device-width：渲染表面的宽度（对我们来说，就是设备屏幕的宽度） 。<br>1. orientation：检查设备处于横向还是纵向。<br>1. aspect-ratio：基于视口宽度和高度的宽高比。一个 16∶9 比例的显示屏可以这样定义 aspect-ratio: 16/9。<br>1. device-aspect-ratio：和 aspect-ratio 类似，基于设备渲染平面宽度和高度的宽高比。<br>1. color：每种颜色的位数。例如 min-color: 16 会检测设备是否拥有 16位颜色。<br>1. color-index：设备的颜色索引表中的颜色数。值必须是非负整数。<br>1. monochrome：检测单色帧缓冲区中每像素所使用的位数。值必须是非负整数，如monochrome: 2。<br>1. resolution：用来检测屏幕或打印机的分辨率，如 min-resolution: 300dpi。还可以接受每厘米像素点数的度量值，如 min-resolution: 118dpcm。<br>1. scan：电视机的扫描方式，值可设为 progressive（逐行扫描）或 interlace（隔行扫描） 。 如 720p HD电视 （720p的 p即表明是逐行扫描） 匹配 scan: progressive，而 1080i HD 电视（1080i中的 i表明是隔行扫描）匹配 scan: interlace。<br>1. grid：用来检测输出设备是网格设备还是位图设备。<br>#### 2.2.3 用媒体查询改造我们的设计<br>层叠<br>#### 2.2.4 加载媒体查询的最佳方法<br>因此，将不同媒体查询的样式保存到独立的文件中没有太大好处（个人喜好或为便于组织代码除外） 。使用多个独立的文件会增加用于页面渲染的 HTTP请求数量，从而导致页面加载变慢。<br><br>Respond.js（<a href="https://github.com/scottjehl/Respond）是为" target="_blank" rel="noopener">https://github.com/scottjehl/Respond）是为</a> Internet Explorer 8及更低版本增加媒体查询支持的最快的JavaScript工具，但它目前无法解析 CSS的@import 命令。因此，<br>建议在已有的样式表中追加媒体查询样式。使用如下语法即可在已有样式表中加入媒体查询：<br><br>    @media screen and (max-width: 768px) {/<em>样式</em>/}<br>### 2.3 我们的第一个响应式设计<br> <a href="http://www.andthewinnerisnt.com/" target="_blank" rel="noopener">http://www.andthewinnerisnt.com/</a><br>#### 2.3.1 我们的设计是固定宽度的，不要惊讶<br>&gt; 我在 HTML 4页面中使用的重置样式，是在 Eric Meyer 的原版<a href="http://meyerweb.com/eric/tools/css/reset/）基础上加上了我的一些个人偏好及技巧，这些技巧是我从另外一些天才如" target="_blank" rel="noopener">http://meyerweb.com/eric/tools/css/reset/）基础上加上了我的一些个人偏好及技巧，这些技巧是我从另外一些天才如</a> Dan Cederholm （<a href="http://simplebits.com）的代码里学来的" target="_blank" rel="noopener">http://simplebits.com）的代码里学来的</a><br>&gt;<br>&gt; 我 觉 得 针 对 HTML5 文 档 有 更 好 的 选 择 ， 如normalize.css（<a href="http://necolas.github.com/normalize.css/）" target="_blank" rel="noopener">http://necolas.github.com/normalize.css/）</a> ，第 4章会详细介绍。<br>#### 2.3.2 响应式设计中要保证图片尽可能精简<br>不过，所有这些问题都可以使用 HTML5 和 CSS3 来解决。使用 HTML5<br>和 CSS3，而不再是简单插入图片（如我们以前做过的那样） ，会使网站与我们的响应式目标步调一致。  时刻谨记，我们要保证代码和数据都尽可能精简，以便为带宽有限的用户提供愉悦的体验。<br>#### 2.3.3 小视口下的内容剪切<br>### 2.4 阻止移动浏览器自动调整页面大小<br>iOS 和 Android 浏览器都基于 WebKit（<a href="http://www.webkit.org/）核心。这两种浏览器以及很多其他浏览器（如" target="_blank" rel="noopener">http://www.webkit.org/）核心。这两种浏览器以及很多其他浏览器（如</a> Opera Mobile） ，都支持用 viewport meta元素覆盖默认的画布缩放设置。只需要在 HTML的<head><meta name="generator" content="Hexo 3.9.0">标签中插入一个<meta>标签。<meta>标签中可以设置<br>&gt;安装 iOS 模拟器和 Android 模拟器<br>虽然真机测试无可替代， 但还是可以使用Android和iOS模拟器。 Windows、Linux和 Mac版的 Android模拟器都可以免费下载， Android软件开发工具包（SDK）也可以免费安装。下载地址是 <a href="http://developer.android.com/sdk/。" target="_blank" rel="noopener">http://developer.android.com/sdk/。</a> 不过得使用命令行安装，需要你有一颗勇敢的心①。iOS 模拟器是 Xcode开发包（在 Mac App Store中免费下载）的一部分，只能在 Mac OS X上使用。一旦安装了 Xcode，你就可以在这个路径下找到模拟器：~/Developer/Platforms/iPhoneSimulator.platform/Developer/Applications iOS Simulator.app<br>### 2.5 针对不同视口宽度修正设计<br>### 2.6 响应式设计中内容始终优先<br>这样无疑是坚决贯彻“内容优先”原则的合理做法<br>### 2.7 媒体查询只是必要条件之一<br>#### 我们需要流动布局<br>换句话说，它不能适应未来的变化。目前的情形是，页面捕捉到媒体查询设置的断点，然后布局发生变化。但在捕捉到下一个视口断点之前，页面静止不变。<br>我们需要比这更好的策略。针对各种视口的排列组合编写对应的 CSS 样式，无法兼容未来可能出现的设备；而一个完美的设计，往往能在一定程度上适应未来的发展。<br>在这点上我们目前的解决方案尚不完备。目前的效果更像是一个自适应设计，而不是我们想要的真正的响应式设计。我们的设计应该在突变之前保持灵动。要做到这点，需要将呆板的固定布局修改成<strong>灵活的流动布局</strong>。<br>### 2.8 小结<br><br>## 第 3 章  拥抱流式布局<br>1. 理解为什么响应式设计需要百分比布局<br>1. 将元素的固定像素宽度转换为百分比宽度<br>1. 将文字的固定像素大小转换为等量的相对尺寸<br>1. 理解如何找到任意元素的上下文<br>1. 学习如何使图片平滑缩放<br>1. 学习如何为不同的大小的屏幕提供不同的图片<br>1. 学习如何让媒体查询与弹性图片及流式布局协同工作<br>1. 使用 CSS网格系统从头创建一个响应式布局<br>### 3.1 固定布局经不起未来考验<br>因为每次有新东西出来，只要用户要求修改网站，就可以借机收一次费。但是，这种方法不是一种完全兼容未来的网页制作方法。未来，还会出现更多<br>大小不一的视口，我们需要一些适应未知设备的方法。<br>### 3.2 为什么响应式设计需要百分比布局<br>&gt; 百分比布局和媒体查询和谐共处<br>&gt; 事实上，这种网页设计新方法做到了两全其美：使用百分比布局创建流动的弹性界面，同时使用媒体查询来限制元素的变动范围。将这两者组合到一起构成了响应<br>式设计的核心，基于此可以创造出真正完美的设计。<br>### 3.3 将网页从固定布局修改为百分比布局<br>#### 3.3.1 需要牢记的公式<br>#### 3.3.2 设置百分比元素的上下文<br>&gt; 这些数字能四舍五入吗？<br>一些响应式设计技术的批评者（如这篇文章：<a href="http://tripleodeon.com/2010/10/not-a-mobile-web-merely-a-320px-wide-one/）认为在样式表中输入诸如.550724638" target="_blank" rel="noopener">http://tripleodeon.com/2010/10/not-a-mobile-web-merely-a-320px-wide-one/）认为在样式表中输入诸如.550724638</a> 这样的数字很愚蠢。你可能也会疑惑，为什么不将这些小数四舍五入？但支持者们认为，这样做可以提供更加精确的结果。为浏览器提供更加精确的结果可以使其显示效果更加精准。<br>顺便说一下，学过数学的人都应该知道黄金分割率（<a href="http://en.wikipedia.org/wiki/Golden_ratio）" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Golden_ratio）</a> 。黄金分割率是一个很早就被发现且广泛应用于各学科的数学比例，其比值大约为 1:1.61803398874989（如果你想知道保留 10000位小数的黄金分割数，请访问这里：<a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/" target="_blank" rel="noopener">http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/</a> Fibonacci/ phi10000dps.txt） 。怎么看它都不是一个简洁的数字，但是它非常重要。黄金分割率的测量都能做到如此精确，那我相信网页设计同样做得到。<br><br>等等，这不是我们想要的效果。导航链接没再折成两行，但很明显导航链接之间的间距不对。导航链接看上去像一个字典里查不到的长单词……<br>#### 3.3.3 必须时刻牢记上下文<br>这种情况很常见，不过我们有很多方法解决这个问题。我们可以给li标签设置一个明确的宽度值，这个值必须得是一个固定像素宽度或者是一个相对于其包裹元素（#navigation div）的百分比值，但这两种值都无法保证li中的文字灵活可变。<br><br>此外我们可以修改li现在的 CSS代码，将 inline-block 改为 inline：<br>使用 display: inline;（这样可以阻止li元素渲染为块级元素）还可以使导航在不支持 inline-block 的老版本 Internet Explorer（版本 6和 7）中水平显示。<br>不过，我是inline-block 的粉丝，因为它允许我们在现代浏览器中有效的控制外边距和内边距，所以我会让li标签继续保持 inline-blocks 状态（一会可以给 IE6 和 IE7 追加一个覆写样式） ，然后将（没有明确的上下文的）a标签上的百分比外间距挪到li上来。<br><br>我准备先将文字大小从像素尺寸修改为相对单位 em。完成这个工作之后，我们就会注意到另外一个被忽略的问题 ，即让图片随着页面的变化缩放。<br>### 3.4 用 em 替换 px<br>### 3.5 弹性图片<br>    img,object,video,embed { //ie7+<br>        max-width: 100%;<br>    }<br>这些多媒体元素都可以自动缩放了。但是，对于采用的iframe显示视频的网站（比如YouTube） ，这个技术还不行，我们会在第 4 章解决这个问题。眼下，还是专注于图片的缩放问题吧，因为不论何种多媒体元素，原理都是相通的。<br><br>使用这种方法有几个需要斟酌的问题。第一，要提前准备一张足够大的图片，以备大视口使用。但这也就引出了第二个，同时也是非常重要的问题，即无论视口多大，什么设备，都得下载超大图片。可能对某些设备来说，图片大小只要原始图片的 25%就好了。另外，在某些情况下，你还不得不因此而考虑带宽限制。<br>我们呆会儿再说第二个问题，先把图片缩放问题说完。<br>#### 3.5.1 让图片随视口缩放<br>#### 3.5.2 为特定图片指定特定规则<br>    img {<br>        max-width: 100%;<br>    }<br>    .sideBlock img {<br>        max-width: 45%;<br>    }<br>#### 3.5.3 给弹性图片设置阈值<br>    .oscarMain {<br>        float: left;<br>        margin-top: -28px;<br>        width: 28.9398281%; /<em> 698 ÷ 202 </em>/  //3.5.2<br>        max-width: 202px;  //3.5.3<br>    }<br>#### 3.5.4 超级全能的 max-width 属性<br>另一种限制页面无限制扩张的方法是给最外层的#wrapper div 设置max-width 属性，<br>### 3.6 为不同的屏幕尺寸提供不同的图片<br>我们曾指出图片缩放存在一定的问题。图片尺寸必须比其显示尺寸更大以保证渲<br>染效果，否则的话图片可能看起来很糟糕。基于这个原因，图片文件的体积就永远比实际显示所需的大。<br><br>很多人都在研究这个问题，尝试为较小的屏幕尺寸提供较小的图片。第一个著名的例子是 Filament Group的 “响应式图片”（<a href="http://filamentgroup.com/lab/responsive_images_experi" target="_blank" rel="noopener">http://filamentgroup.com/lab/responsive_images_experi</a>_<br>menting_with_context_aware_image_sizing/） 。<br><br>不过最近，我已经转而使用 Matt Wilcox 的“自适应图片” （<a href="http://adaptive-images.com）了。Filament" target="_blank" rel="noopener">http://adaptive-images.com）了。Filament</a> Group的解决方案需要对图片标签做一定修改。Matt Wilcox的解决方案则不需要，而且他的方案会根据标签中已经设定的全尺寸图片自动创建各种尺寸的图片。这种解决方案允许基于一组屏幕尺寸断点，根据用户需要为其提供不同的图片。接下来我们就看一看如何利用该技术实现图片自适应。<br><br>#### 设置自适应图片<br>实现 Adaptive Images解决方案需要 Apache 2、PHP 5.x和 GD库，也就是说<strong>需要 Web服务器端编程</strong>。首先，<br>#### 把背景图片放在其他地方<br>但是在使用自适应图片方案时，建议将那些用于CSS的背景图片（或者那些你不想被缩放的图片）放在另一个目录。自适应图片方案默认为此创建的目录是assets。<br><br>### 3.7 流动网格布局和媒体查询的默契配合<br>你看到了，我们根据视口宽度来改变文字大小，结果就是这组导航链接在 769 像素到无穷大的视口中<strong>都会显示在一行</strong>。这是媒体查询和流动布局和谐共存的又一证据：<strong>媒体查询约束流动布局的变动范围，而流动布局则简化了从一组媒体查询样式过渡到另一组的改变过程</strong>。<br><br>### 3.8 CSS 网格系统<br>褒贬不一.  但同时我也很欣赏它们在快速搭建界面布局上的价值。<br>1. Semantic (<a href="http://semantic.gs)；" target="_blank" rel="noopener">http://semantic.gs)；</a><br>1. Skeleton (<a href="http://getskeleton.com)；" target="_blank" rel="noopener">http://getskeleton.com)；</a><br>1. Less Framework (<a href="http://lessframework.com)；" target="_blank" rel="noopener">http://lessframework.com)；</a><br>1. 1140 CSS Grid (<a href="http://cssgrid.net)；" target="_blank" rel="noopener">http://cssgrid.net)；</a><br>1. Columnal (<a href="http://www.columnal.com)。" target="_blank" rel="noopener">http://www.columnal.com)。</a><br>这些框架中，我个人最喜欢 Columnal 网格系统，因为它有一套内置的集成了媒体查询的流动网格布局，而且它使用了与 960.gs 框架类似的 CSS 命名，960.gs 框架是一套广为开发者和设计师所熟知的非常流行的固定宽度网格系统。<br>#### 使用网格系统快速搭建网站<br>但 Columnal 网格系统最大只支持<br>12列，所以我们将 PSD中的 16列改为 12列。<br>### 3.9 小结<br>响应式设计的 <strong>“移动优先”</strong> （mobile first）思想使它很适宜采纳最简洁、最有效和最具语义的代码。(ar:和本章内容没有关系)<br><br>## 第 4章  响应式设计中的 HTML5<br>1. HTML5的那些部分我们现在就能用？<br>1. 如何编写 HTML5网页<br>1. HTML5的精简之道<br>1. HTML中的废弃零件<br>1. HTML5中的全新语义化元素<br>1. 使用无障碍网页应用技术（WAI-ARIA）来增强语义，支持辅助技术<br>1. 嵌入媒体<br>1. 可响应的 HTML5和 iFrame视频<br>1. 让网站支持离线使用<br>### 4.1 HTML5 的哪些部分现在就能用<br> IE9！当前 HTML 标准草案的内容最终未必全都会出现在 W3C 推荐标准中，但其中有很大一部分新特性现在已经可以用了。<br>#### 4.1.1 大多数网站可以用 HTML5 编写<br>&gt; 什么是腻子脚本？<br>腻子脚本（polyfill）这个词由 Remy Sharp提出，意指使用腻子来补平老版<br>本浏览器的缺陷。因此，腻子脚本具体指的是一段能给老版本浏览器带来新特性的 JavaScript代码。值得注意的是，腻子脚本会给你的代码里追加多余的代码。因此，就算你添加 3个腻子脚本可以让 Internet Explorer 6中网站的渲染效果与其他浏览器一模一样，也并不意味着你一定要这么做<br>#### 4.1.2 腻子脚本和 Modernizr<br>&gt; 想找一种编写优秀 HTML5 代码的捷径？可以考虑 HTML5 样板文件<br>如果你时间紧迫，但却需要一个好的项目起点，可以考虑使用 HTML5样板文件（<a href="http://html5boilerplate.com/）" target="_blank" rel="noopener">http://html5boilerplate.com/）</a> 。样板文件是一个预先做好的融合了“最佳实践”HTML5文件，包含一些基本样式（如之前提到过的normalize.css） 、polyfill和一些必要的工具如 Modernizr。它还包含一个自动合并 CSS和 JS文件、自动删除注释以生成生产环境代码的构建工具。强烈推荐！<br><br>### 4.2 如何编写 HTML5 网页<br>W3C验证器（<a href="http://validator.w3.org/）" target="_blank" rel="noopener">http://validator.w3.org/）</a><br>&gt; HTML5 文档类型为什么这么简短?<br>HTML5的&lt;!DOCTYPE html&gt;文档类型如此简短，目的是以简洁的方式告诉浏览器用 “标准模式” 渲染页面。 这种简洁高效的思想渗透在HTML5的方方面面。<br><br>&gt; 你会说汉语吗?<br>根据 W3C的定义<a href="http://dev.w3.org/html5/spec/Overview.html#attr-lang）" target="_blank" rel="noopener">http://dev.w3.org/html5/spec/Overview.html#attr-lang）</a> ，lang属性用来指定页面元素内容和元素属性值的主语言。如果你的网页不是英语内容， 你最好设定正确的页面语言。 例如对于中文网页， HTML标签应该是。完整的语言列表请见这个网址：<a href="http://www.iana.org/" target="_blank" rel="noopener">http://www.iana.org/</a> assignments/language-subtag-registry。<br><br>最后，..<br>字符编码通常都是 UTF-8，除非你有特殊理由才可能使用其他编码。<br>#### 4.2.1 HTML5 的精简之道<br>这样同样有效。没有结束标签的斜线，没有引号，大小写混杂。甚至，省略head&gt;元素，页面依然有效。XHTML 1.0对这种情况会怎么说呢？<br>#### 4.2.2 HTML5 标签的合理写法<br>对我而言，那些看似多余的字符（用于闭合的斜线和属性值两边的引号）可以提高代码的可读性。因此在编写 HTML5 文档时我倾向于在老式编写风格（这样风格的代码在HTML5 中依然有效，不过可能在验证器或类似检查工具中会产生一些警告）和 HTML5的极简主义之间找到一个平衡。举例说明，以上节的 CSS链接为例，我会这样写：<code>&lt;link href=&quot;CSS/main.css&quot; rel=&quot;stylesheet&quot;/&gt;</code><br>我闭合了标签，使用了引号，但删除了 type 属性。关键是找到一种你自己满意的风格。HTML5不会训斥你，也不会在课堂上批评你糟糕的标签代码，更不会因为你的代码没通过验证而罚你站墙角。<br>#### 4.2.3 伟大的a&gt;标签万岁<br>#### 4.2.4 HTML 的废弃零件<br>你的情况可能和我差不多。如果你好奇，可以在后面这个网址找到完整<br>的非保留废弃零件列表：<a href="http://dev.w3.org/html5/spec/Overview.html#non-conforming-features。" target="_blank" rel="noopener">http://dev.w3.org/html5/spec/Overview.html#non-conforming-features。</a><br>比较常见的非保留废弃零件有 strike、 enter、 font、 acronym、 frame 和 frameset。<br><br>### 4.3 HTML5 的全新语义化元素<br>语义化是给我们的标签赋予意义的过程。为什么语义化很重要？很高兴你问这个问题。<br>#### 4.3.1 section&gt;<br>#### 4.3.2 nav&gt;<br>#### 4.3.3 article&gt;<br>article&gt;元素与section&gt;元素很容易混淆。<br>#### 4.3.4 aside&gt;<br>#### 4.3.5 hgroup&gt;<br>HTML5 的大纲结构算法<br>HTML5允许每个section&gt;容器有自己独立的大纲结构。 这样你就不必总想着现在是几级标题了。例如在一个博客中，博文的标题可以使用h1&gt;标签，同时博客内容的标题也可以包含h1&gt;标签。请见如下代码：<br>1. <a href="http://gsneders.html5.org/outliner/" target="_blank" rel="noopener">http://gsneders.html5.org/outliner/</a><br>1. <a href="http://hoyois.github.com/html5outlier/" target="_blank" rel="noopener">http://hoyois.github.com/html5outlier/</a><br>#### 4.3.6 header&gt;<br>由于header&gt;元素<strong>不计入大纲结构，所以不能用它来划分内容结构</strong>，而是应该用它来包含对区域内容的介绍说明。实际使用中，header&gt;可用作网站头部的“刊头”区域，也可用作对其他内容如article&gt;元素的简要介绍。<br>#### 4.3.7 footer&gt;<br>#### 4.3.8 address&gt;<br>address&gt;元素用于明确地标注离其最近的article&gt;或body&gt;祖先元素的联系信息。<br>为避免产生混淆，请记住ddress&gt;中一般不放具体的邮政地址，除非相应内容确实需要联系地址。而邮政地址和其他可能会改变的联系信息应该使用p&gt;标签来包裹。<br><br>### 4.4 HTML5 结构元素的实际用法<br>&gt; 注意 HTML5 中的元素复用<br>请注意， HTML5页面中可能会有多个\<header>、 \<footer>和\<aside><br>元素，你可能需要为每一个都编写特定的样式。<br><br>需要谨记的是，使用\<section>的目的不是为了美化样式，而是为了标识一个鲜明独立的内容块。一个内容块（section）一般都应该带有标题，这恰好符合我们的需求（用于独立标识） 。考虑到 HTML5的大纲结构，我们可以将上面代码中的\<h4>标签改为\<h1>，这样 HTML5就会为文档生成一个精确的大纲：<br>#### 网站的主体内容怎么办<br>你可能会觉得有点奇怪：没有一个专门的元素用来标记页面主体内容。其实逻辑是这样的，既然可以界定除主体内容之外的其他元素，那么剩下的元素自然就是页面的主体了。<br><br>### 4.5 HTML5 的文本级语义元素<br>除了前面讲过的结构元素，HTML5 还修订了一些被称之为行内元素的标签。HTML5 标准中称这些标签为文本级语义元素<a href="http://dev.w3.org/html5/spec/Overview.html#text-level-" target="_blank" rel="noopener">http://dev.w3.org/html5/spec/Overview.html#text-level-</a><br>semantics） 。<br>#### 4.5.1 b&gt;<br>过去，人们通常利用\<b>元素为文本添加样式，但它的实际用途其实是“给文本加粗” 。<br>不过现在你可以正式地将其仅用作样式钩子了，因为现在 HTML5标准对\<b>的定义是：<br>#### 4.5.2 em&gt;<br>#### 4.5.3 i&gt;<br>HTML5标准中对<i>的描述如下：<br>&gt; ……一小段有不同语态或语气的文字，或者是样子上与普通文章有所差异以便<br>标明不同特点的文字。<br><br>简单地说，它不仅仅是用来给某些文字加斜体效果的。<br>#### 4.5.4 在页面中应用文本层语义元素<br>&gt; 文本层语义元素的默认样式<br>根据过去对\<b>标签的用法，很多浏览器仍会将其渲染为粗体。所以你可以根据实际情况在相关的 CSS代码中重定义其默认样式。<br><br>想要全面了解，请查看 HTML5标准中的相关章节，地址如下：<br><a href="http://dev.w3.org/html5/spec/Overview.html#text-level-semantics" target="_blank" rel="noopener">http://dev.w3.org/html5/spec/Overview.html#text-level-semantics</a><br><br>### 4.6 遵循 WAI-ARIA 实现无障碍站点<br> Web Accessibility Initiative - Accessible Rich Internet Applications<br> 本书着眼点不在于全面讲解无障碍网页应用技术（想要全面了解，请查看 <a href="http://www.w3.org/WAI/intro/aria）" target="_blank" rel="noopener">http://www.w3.org/WAI/intro/aria）</a> ，但我们可以采纳其中一部分容易实施的技术，将其应用到 HTML5网站中，以方便残障用户。<br>### ARIA 的地标角色<br>    <nav role="navigation"><br>1. application：用来定义用作网页应用的区域。<br>1. banner：用来定义一个站点级别（而不是某个特定文档的）的区域。如网站的头部和logo。<br>1. complementary：用来定义一个对页面主要区域进行补充说明的区域。在And the winner isn’t…这个网站中，UNSUNG HEROES和 OVERHYPED NONSENSE区域就可以定义为 complementary。<br>1. contentinfo：用来定义与页面主要内容相关的信息区域。例如页脚的网站版权信息区域。<br>1. form：你猜都能猜到，定义表单！但注意，如果表单用于搜索，则请使用search 来替代。<br>1. main：定义页面的主体内容。<br>1. navigation：用来定义链向当前文档或相关文档的导航链接。<br>1. search：用来定义一个用于搜索的区域。<br>&gt; 无障碍网页应用技术进阶<br>无障碍网页应用技术并非只有地标角色。想要做进阶应用，请参阅完整<br>的角色列表及其简要使用说明：<a href="http://www.w3.org/TR/wai-aria/roles#role_definitions。" target="_blank" rel="noopener">http://www.w3.org/TR/wai-aria/roles#role_definitions。</a><br><br>&gt; 使用非可视桌面阅读器（NVDA）免费测试网站可访问性<br>如果你是在 Windows平台上开发且想使用屏幕阅读器测试网站的可访<br>问性，可以免费使用 NVDA。软件的官方地址如下：<a href="http://www.nvda-project.org/。" target="_blank" rel="noopener">http://www.nvda-project.org/。</a><br><br>&gt; 为使用了无障碍技术的元素设置样式<br>和其他属性一样，可以直接使用属性选择器来为其设置样式。如，使用nav[role=”navigation”] {}可以为导航区域设置样式。<br><br>### 4.7 在 HTML5 中嵌入媒体<br>正如你所预想，IE8及更低版本都不支持 HTML5视频和音频。不过给微软的“先天不足”的浏览器提供备用解决方案也很简单，稍后我们会讨论这个问题。<br>### 4.8 用 HTML5 的方法为页面添加视频或音频<br>#### 4.8.1 提供备用的媒体源文件<br>#### 4.8.2 针对老版本浏览器的备用方案<br>    <video width="640" height="480" controls autoplay reload="auto" loop poster="myVideoPoster.jpg"><br>        <source src="video/myVideo.mp4" type="video/mp4"><br>        <source src="video/myVideo.ogv" type="video/ogg"><br>        <object width="640" height="480" type="application/x-shockwave-flash" data="myFlashVideo.SWF"><br>            <param name="movie" value="myFlashVideo.swf"><br>            <param name="flashvars" value="controlbar=over&amp;image=myVideoPoster.jpg&amp; file=video/myVideo.mp4"><br>            <img src="http://you img base url/myVideoPoster.jpg?e=1585218234&token=your qiniu access key:Me25vvX2U9FFUapMq2USReCDRNM=" width="640" height="480" alt="__TITLE__" title="No video playback capabilities, please download the video below"><br>        </object><br>        <p>  <b>Download Video:</b><br>            MP4 Format:  <a href="myVideo.mp4">“MP4”</a><br>            Ogg Format:  <a href="myVideo.ogv">“Ogg”</a><br>        </p><br>    </video><br>#### 4.8.3 和标签的用法基本一致<br>### 4.9 响应式视频<br>然后在 CSS中追加如下代码：video { max-width: 100%; height: auto; }<br>这种方法对本页面中的视频文件很有用，但它不能解决使用 iframe 嵌入的视频的响应问题 （拜YouTube、 Vimeo等等视频网站所赐） 。<br><br>但截至目前我见过的最简单的办法是使用一个名为 FitVids的 jQuery小插件。<br>### 4.10 离线 Web 应用<br>虽然 HTML5 中的大量新特性对我们的响应式设计没有明显帮助（如地理定位 API） ，但离线 Web 应用应该还有点用处。<br>#### 4.10.1 离线 Web 应用概述<br>离线Web应用的运行机制是每个需要离线使用的网页都指定一个后缀名为.manifest的文本文件。这个文本文件罗列了该网页离线使用时所需的所有资源文件（HTML、图片JavaScript等等） 。支持离线 Web应用的浏览器会自动读取.manifest 文件，下载文件中所罗列的资源文件，并将其缓存在本地以备网络断开时使用。简单吧？那我们来动手试一试……<br>#### 4.10.2 让网页可离线使用<br>    <html lang="en" manifest="/offline.manifest" 该文件的文件名随意，但后缀名建议使用.manifest。> 你必须在每一个准备离线使用的页面的HTML标签中都追加manifest=<br>“/offline.manifest”属性。<br><br>如果使用的是 Apache服务器，你可能还需要修改一下.htaccess 文件，追加一行代码：AddType text/cache-manifest .manifest 这样就保证了.manifest 文件拥有正确的 MIME类型，即 text/cache-manifest。在.htaccess 文件中还可以加入以下代码：<br><br>    <files offline.manifest><br>        ExpiresActive On<br>        ExpiresDefault “access”<br>    </files><br>添加上面这几行代码， 可以阻止浏览器缓存缓存文件。 你没看错。 因为 offline.manifest是一个静态文件，浏览器默认就会缓存 offline.manifest 文件。所以上面这几行代码就是让服务器告诉浏览器不要这么干！<br>现在我们需要给 offline.manifest 填充内容。 即通知浏览器那些文件是用作离线存储的。And the winner isn’t…网站的 offline.manifest 文件内容如下：<br><br>    CACHE MANIFEST<br>    #v1<br><br>    CACHE:<br>    basic_page_layout_ch4.html<br>    css/main.css<br>    img/atwiNavBg.png<br>    img/kingHong.jpg<br>    img/midnightRun.jpg<br>    img/moulinRouge.jpg<br>    img/oscar.png<br>    img/wyattEarp.jpg<br>    img/buntingSlice3Invert.png<br>    img/buntingSlice3.png<br><br>    NETWORK:<br>    <em><br><br>    FALLBACK:<br>    //offline.html<br>#### 4.10.3 理解 manifest 文件<br>manifest 文件必须以 CACHE MANIFEST 开头。第二行就是一句注释，注明了 manifest 文件的版本号。这句注释的用途稍后详细介绍。<br><br>CACHE:部分罗列了所有离线使用所需的文件。 这些文件的路径都是相对 offline.manifest而言的，所以文件路径可能需要根据情况稍作修改。使用绝对路径也是可以的。<br><br>NETWORK:部分罗列了所有不需要被缓存的文件。你可以将其看成是一个“在线白名单” 。此处罗列的文件在网络畅通的情况下都会直接跳过缓存。如果你想网站内容在网络畅通的情况下及时更新（而不是仅在离线缓存中查找） ，可以在此处使用</em>。星号被称为在线白名单通配符。<br><br>FALLBACK:部分使用/字符定义了一个 URL模板。它的作用是访问每个页面时都会问“缓存中有这个页面吗？” ， 如果有则显示缓存页面， 如果没有则显示指定的 offline.html 文件。<br>#### 4.10.4 页面被自动加载到离线缓存<br>根据实际情况，还有一种更简单的办法来设置 offline.manifest 文件。任何指定了离线 manifest 文件的页面（就是在标签中追加了manifest=”/offline.manifest”的页面）在被用户访问时都会被自动加入到本地缓存。浏览器会缓存用户访问过的每一个网页以确保这些网页在离线状态下仍可访问。简化的 manifest文件如下：<br><br>    CACHE MANIFEST<br>    # Cache Manifest v1<br>    FALLBACK:<br>    //offline.html<br>    NETWORK:<br>    *<br>选择使用这个方法时有一点需要注意， 这种方法只会下载和缓存用户访问的 HTML页面，不会缓存页面内引入的图片、 JavaScript或者其他资源文件。 如果这些资源文件是必需的，那么请按照上节中的方法在 CACHE:部分专门声明这类文件。<br>#### 4.10.5 版本注释的用途<br>对网站内容或任何资源文件做了修改之后， 你必须得对 offline.manifest 文件也做点修改并将其重新上传服务器。这样就能让服务器为浏览器提供新版本文件，而浏览器则会下载该新版本文件并再次触发离线存储进程。<br>我效仿了 Mark Pilgrim 的例子（来自著名的《畅游 HTML5》 一书） ，在offline.manifest 文件的头部加了一句注释，每次修改网站都会对应地修改该版本号：<br>&gt; 作者此处说得不是很清楚。补充一下：如果开发者对网站内容或资源做了修改，那么也得通知浏览器更新缓存文件，否则浏览器仍然会使用之前已有的缓存文件。而通知浏览器更新缓存文件的方式通常是更新 manifest 文件，浏览器如果发现 manifest 文件发生了变化，就会更新缓存文件。大多数情况下manifest 中的缓存文件清单不会发生变化，那我们就通过修改注释的方式来改变 manifest文件，注释中的版本号，既能触发文件变化，又能指明当前版本，一举两得。其实注释中还可以加入更新时间等更详细信息，有助于维护。文中提到的《畅游 HTML5》 ，参见 <a href="http://diveintohtml5.com/。——译者注" target="_blank" rel="noopener">http://diveintohtml5.com/。——译者注</a><br>#### 4.10.6 离线访问网站<br>#### 4.10.7 离线 Web 应用的故障诊断<br>### 4.11 小结<br><p style="text-align:right">11.18 02:20</p><br><p style="text-align:right">2017.11.19 日 11:20</p>

<h2 id="第-5-章-CSS3：选择器、字体和颜色模式"><a href="#第-5-章-CSS3：选择器、字体和颜色模式" class="headerlink" title="第 5 章  CSS3：选择器、字体和颜色模式"></a>第 5 章  CSS3：选择器、字体和颜色模式</h2><ol>
<li>CSS3给前端开发人员带来了什么   </li>
<li>快速而便捷的 CSS3技巧（多列布局和文字换行）   </li>
<li>CSS规则解析   </li>
<li>私有前缀的来源和用法  </li>
<li>新的 CSS3选择器的工作原理   </li>
<li>使用@font-face 设定字体    </li>
<li>如何使用带有透明度的 RGB和 HSL颜色模式   <h3 id="5-1-CSS3-给前端开发人员带来了什么"><a href="#5-1-CSS3-给前端开发人员带来了什么" class="headerlink" title="5.1 CSS3 给前端开发人员带来了什么"></a>5.1 CSS3 给前端开发人员带来了什么</h3><h4 id="5-1-1-Internet-Explorer-6-到-8-对-CSS3-的支持"><a href="#5-1-1-Internet-Explorer-6-到-8-对-CSS3-的支持" class="headerlink" title="5.1.1 Internet Explorer 6 到 8 对 CSS3 的支持"></a>5.1.1 Internet Explorer 6 到 8 对 CSS3 的支持</h4>除少数例外（如@font-face） ，老版本的 IE（IE 6、7、8）几乎不支持 CSS3的新特性。<br>那么我们可以在设计开发中使用 CSS3吗？和以前一样，答案依然是： “看情况。 ”<br>就我个人而言，目前我主要将 CSS3用作增强网站，而不是用它提供基本功能。我非常喜欢页面元素在不同的浏览器中看起来有点差异，相信你和你的客户也是这样。<blockquote>
<p>各版本 Internet Explorer对 CSS 2.1和 CSS3特性的支持情况，请见如下<br>网址：<a href="http://msdn.microsoft.com/en-us/library/cc351024%28v=vs.85%29.aspx（或" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/cc351024%28v=vs.85%29.aspx（或</a> <a href="http://tinyurl.com/495756c）" target="_blank" rel="noopener">http://tinyurl.com/495756c）</a> </p>
</blockquote>
<h4 id="5-1-2-使用-CSS3-设计和开发页面"><a href="#5-1-2-使用-CSS3-设计和开发页面" class="headerlink" title="5.1.2 使用 CSS3 设计和开发页面"></a>5.1.2 使用 CSS3 设计和开发页面</h4><h3 id="5-2-CSS-规则解析"><a href="#5-2-CSS-规则解析" class="headerlink" title="5.2 CSS 规则解析"></a>5.2 CSS 规则解析</h3><h3 id="5-3-私有前缀及其用法"><a href="#5-3-私有前缀及其用法" class="headerlink" title="5.3 私有前缀及其用法"></a>5.3 私有前缀及其用法</h3><blockquote>
<p>可快速编辑 CSS3 前缀的代码片段和 JavaScript 方案<br>建立包含所有必需的私有前缀属性的代码片段会带来极大便利。这样你就可以直接粘贴代码而不用每次都重新输入。很多代码编辑程序（或者集成开发环境） 带有代码片段功能， 这样在开发 CSS3时能节省很多时间。<br>也有可以为 CSS文件自动追加前缀的 JavaScript方案， 比如“-prefix-free” ，很不错的解决方案，网址是<a href="http://leaverou.github.com/prefixfree/。" target="_blank" rel="noopener">http://leaverou.github.com/prefixfree/。</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>什么时候可以使用特定的 CSS3 和 HTML5 特性？<br>随着对 CSS3 研究的不断深入，我衷心建议大家去看看这个网站 http://<br>caniuse.com，在这里你可以知道当前浏览器对特定 CSS3和 HTML5特性的<br>支持程度。除了显示浏览器的特性支持情况之外（可按特性搜索） ，它还提<br>供了来自于 <a href="http://gs.statcounter.com的最近的全球浏览器使用率统计" target="_blank" rel="noopener">http://gs.statcounter.com的最近的全球浏览器使用率统计</a></p>
</blockquote>
<h3 id="5-4-快速而有效的-CSS-技巧"><a href="#5-4-快速而有效的-CSS-技巧" class="headerlink" title="5.4 快速而有效的 CSS 技巧"></a>5.4 快速而有效的 CSS 技巧</h3><h4 id="5-4-1-CSS3-多栏布局"><a href="#5-4-1-CSS3-多栏布局" class="headerlink" title="5.4.1 CSS3 多栏布局"></a>5.4.1 CSS3 多栏布局</h4><h5 id="增加栏位间隙和分割线"><a href="#增加栏位间隙和分割线" class="headerlink" title="增加栏位间隙和分割线"></a>增加栏位间隙和分割线</h5><h4 id="5-4-2-文字换行"><a href="#5-4-2-文字换行" class="headerlink" title="5.4.2 文字换行"></a>5.4.2 文字换行</h4><p>CSS3 使用了一个简单的声明解决了这个问题，凑巧的是老版本 IE 均支持该声明，甚至可以追溯到 IE 5.5！<code>word-wrap: break-word;</code> </p>
<h3 id="5-5-CSS3-的新增选择器及其用法"><a href="#5-5-CSS3-的新增选择器及其用法" class="headerlink" title="5.5 CSS3 的新增选择器及其用法"></a>5.5 CSS3 的新增选择器及其用法</h3><h4 id="5-5-1-CSS3-属性选择器"><a href="#5-5-1-CSS3-属性选择器" class="headerlink" title="5.5.1 CSS3 属性选择器"></a>5.5.1 CSS3 属性选择器</h4><ol>
<li>CSS3 的子字符串匹配属性选择器  三种匹配模式分别是</li>
<li>一个活生生的例子 <blockquote>
<p>HTML5 中的 ID 值可以用数字开头<br>如果你还不习惯 HTML5，可能会认为 ID 值以数字开头是无效的，因为HTML 4.01 是这样规定的。HTML5 取消了这个限制，HTML 的 ID 命名方面唯一需要记住的是名字中间不能有空格且保证在页面中唯一。详细信息请参阅<a href="http://dev.w3.org/html5/spec/Overview.html#the-id-attribute。" target="_blank" rel="noopener">http://dev.w3.org/html5/spec/Overview.html#the-id-attribute。</a></p>
</blockquote>
<h4 id="5-5-2-CSS3-结构伪类"><a href="#5-5-2-CSS3-结构伪类" class="headerlink" title="5.5.2 CSS3 结构伪类"></a>5.5.2 CSS3 结构伪类</h4></li>
<li>:last-child 选择器 </li>
<li>nth-child 选择器 </li>
<li><p>理解 nth 规则的作用<br> 而数值表达式对我们来说有点不好理解，我们来分析一下。为了便于理解，我们从括号内表达式的右边开始分析。例如我想确定(2n+3)会选择那些元素，就从右边开始（即从第 3 个元素开始） ，然后就知道它是从这个元素开始每两个元素选择一个。<br> 数值表达式中也可以使用负数，例如:nth-child(3n-2)，即表示从倒数第 2 个元素开始然后每三个元素选择一个。</p>
<p> child 和 last-child 的区别在于，last-child 是从文档节点树的末尾开始算。比如:nth-last-child(-n+3)就是从倒数第 3个元素开始， 向后选择之后的所有元素 （因为使用了-n，所以方向是向后） 。</p>
</li>
</ol>
<p>最后，我们来看看:nth-last-of-type。   </p>
<blockquote>
<p>CSS3 的计数方式和 jQuery 不太一样<br>如果你经常使用 jQuery就会知道，jQuery中的计数是从 0开始的。比如在 jQuery 中使用整数 1 来选择元素，实际上会选中第二个元素。但在CSS3中，计数从 1开始，所以整数 1会匹配第一个元素。 </p>
<ol start="4">
<li>否定（:not）选择器  </li>
</ol>
</blockquote>
<p>除此之外，CSS3还有很多其他选择器。如果你在开发 Web应用，那完整的 UI元素状态伪类列表<a href="http://www.w3.org/TR/selectors/#UIstates）则值得一读，它对你极有帮助，例如可以让你根据元素被选中与否来应用样式规则。" target="_blank" rel="noopener">http://www.w3.org/TR/selectors/#UIstates）则值得一读，它对你极有帮助，例如可以让你根据元素被选中与否来应用样式规则。</a> </p>
<h4 id="5-5-3-对伪元素的修正"><a href="#5-5-3-对伪元素的修正" class="headerlink" title="5.5.3 对伪元素的修正"></a>5.5.3 对伪元素的修正</h4><p>CSS3要求对伪元素使用两个冒号以便与伪类进行区别。因此刚才的例子应该改写为 p::first-letter。<strong>但注意 Internet Explorer 8及更低版本的 IE无法<br>识别两个冒号的语法，它们只识别一个冒号</strong>。</p>
<p><strong>:first-line 对响应式设计来说好用吗</strong><br>于是，在响应式设计中就有了一种方法，不需要修改标签代码，即可方便地将文本第一行内容（即浏览器渲染出来的第一行，不是标签代码中的第一行）显示得与众不同。 </p>
<h3 id="5-6-自定义网页字体"><a href="#5-6-自定义网页字体" class="headerlink" title="5.6 自定义网页字体"></a>5.6 自定义网页字体</h3><p>多年来我们一直被迫使用一组单调乏味的 Web 安全字体。当网页设计中确实需要一些优雅的字体时， 我们通常都是使用图片来替代， 并对元素使用text-indent 规则将实际的文本移出视口范围。<br>曾有一些稍微高级点的备选方案，来为网页增加更加个性的字体效果。sIFR（<a href="http://www.mikeindustries.com/blog/sifr/）和" target="_blank" rel="noopener">http://www.mikeindustries.com/blog/sifr/）和</a> Cufón（<a href="http://cufon.shoqolate.com/generate/）都使用" target="_blank" rel="noopener">http://cufon.shoqolate.com/generate/）都使用</a> Flash和 JavaScript来重建文本元素，然后使用自定义字体来显示内容。但是在响应式设计中，</p>
<h4 id="5-6-1-font-face-规则"><a href="#5-6-1-font-face-规则" class="headerlink" title="5.6.1 @font-face 规则"></a>5.6.1 @font-face 规则</h4><p>@font-face 规则在 CSS2中已经存在（但随后在 CSS 2.1中被删除） 。IE 4甚至对其提供了部分支持（真的，不骗你） ！</p>
<p>但浏览器厂商对不同的字体格式和具体实现仍在争论。如Embedded OpenType（EOT）字体是 Internet Explorer的首选格式（其他浏览器都不支持） ，其他浏览器更钟爱常见的 TrueType格式（TTF） ，还有 Scalable Vector Graphics (SVG)以及 Web Open Font Format (WOFF)。使用@font-face 为网页设定字体时，可谓喜忧参半。</p>
<h4 id="5-6-2-使用-font-face-嵌入网页字体"><a href="#5-6-2-使用-font-face-嵌入网页字体" class="headerlink" title="5.6.2 使用@font-face 嵌入网页字体"></a>5.6.2 使用@font-face 嵌入网页字体</h4><p>首先我们得有字体。 网上有很多很棒的字体资源站点， 有免费的也有收费的。 虽然 Google也提供了免费的网页字体，且基本上都可使用@font-face 规则 （<a href="http://www.google.com/webfonts）" target="_blank" rel="noopener">www.google.com/webfonts）</a> ，但我个人最喜欢 Font Squirrel  （<a href="http://www.fontsquirrel.com）" target="_blank" rel="noopener">www.fontsquirrel.com）</a> 。另外还有 Typekit<br>（<a href="http://www.typekit.com）" target="_blank" rel="noopener">www.typekit.com）</a> 和 Font Deck（<a href="http://www.fontdeck.com）上也有一些非常优秀的付费字体。" target="_blank" rel="noopener">www.fontdeck.com）上也有一些非常优秀的付费字体。</a>  </p>
<h3 id="5-7-帮帮我，标题模糊怎么办"><a href="#5-7-帮帮我，标题模糊怎么办" class="headerlink" title="5.7 帮帮我，标题模糊怎么办"></a>5.7 帮帮我，标题模糊怎么办</h3><p>后来，我发现导致该问题的原因是字体粗细。除非显式声明 font-weight 属性，否则大多数浏览器都会为标题元素应用标准的 font-weight （一般都是 700） 。 因此解决方法就是始终为应用了@font-face 字体的标题元素设定 font-weight 属性。</p>
<p>唯一需要注意的，是在响应式设计中使用该技术时要考虑到字体文件大小。</p>
<blockquote>
<p>真正的响应式字体单位还不能广泛使用<br>当前的 CSS3 字体模块工作草案中引入了视口相对字体（<a href="http://www.w3" target="_blank" rel="noopener">http://www.w3</a>.<br>org/ TR/ css3-values/#viewport-relative-lengths） 。 相对单位 vw （视口宽度） 、vh（视口高度）和 vm（视口最小边长，即 vm 和 vh 中较小的一个）在获得浏览器广泛支持之后，能为我们节省大量开发时间。悲哀的是目前<br>除了 IE 9之外，其他浏览器都不支持视口相对单位。</p>
</blockquote>
<h3 id="5-8-新的-CSS3-颜色格式和透明度"><a href="#5-8-新的-CSS3-颜色格式和透明度" class="headerlink" title="5.8 新的 CSS3 颜色格式和透明度"></a>5.8 新的 CSS3 颜色格式和透明度</h3><h4 id="5-8-1-RGB-颜色"><a href="#5-8-1-RGB-颜色" class="headerlink" title="5.8.1 RGB 颜色"></a>5.8.1 RGB 颜色</h4><h4 id="5-8-2-HSL-颜色"><a href="#5-8-2-HSL-颜色" class="headerlink" title="5.8.2 HSL 颜色"></a>5.8.2 HSL 颜色</h4><p>除了 RGB，CSS3还可使用 HSL（色相、饱和度、亮度）模式来声明颜色。</p>
<blockquote>
<p>HSL 不是 HSB<br>不要错误地认为图片编辑软件如 Photoshop中显示的 HSB（色相、饱和度、明度）值就是 HSL——它们不一样①！<br>HSL模式基于一个 360°的色相环，第一个数字代表色相，其后的两个值分别表示饱和度和亮度，值为百分比，用于改变基础的色相。<br>Young Guys Can Be Messy Rascals 60黄，绿 青 蓝 洋红 360红</p>
</blockquote>
<h4 id="5-8-3-针对-IE6、IE7-和-IE8-提供备用颜色值"><a href="#5-8-3-针对-IE6、IE7-和-IE8-提供备用颜色值" class="headerlink" title="5.8.3 针对 IE6、IE7 和 IE8 提供备用颜色值"></a>5.8.3 针对 IE6、IE7 和 IE8 提供备用颜色值</h4><p>你可能都猜到了，版本 9 以下的 IE 浏览器不支持 RGB 和 HSL。</p>
<h4 id="5-8-4-透明通道"><a href="#5-8-4-透明通道" class="headerlink" title="5.8.4 透明通道"></a>5.8.4 透明通道</h4><h3 id="5-9-小结"><a href="#5-9-小结" class="headerlink" title="5.9 小结"></a>5.9 小结</h3><h2 id="第-6章-用-CSS3创造令人惊艳的美"><a href="#第-6章-用-CSS3创造令人惊艳的美" class="headerlink" title="第 6章  用 CSS3创造令人惊艳的美"></a>第 6章  用 CSS3创造令人惊艳的美</h2><ol>
<li>使用 CSS3制作文字阴影   </li>
<li>使用 CSS3制作盒阴影（即元素投影）   </li>
<li>使用 CSS3制作渐变背景      </li>
<li>使用 CSS3的多重背景图片       </li>
<li>使用 CSS3背景渐变来制作图案     </li>
<li>使用 CSS3的@font-face 规则来制作节省带宽的图标     <h3 id="6-1-文字阴影"><a href="#6-1-文字阴影" class="headerlink" title="6.1 文字阴影"></a>6.1 文字阴影</h3><h4 id="6-1-1-HEX、HSL-或-RGB-颜色都可以"><a href="#6-1-1-HEX、HSL-或-RGB-颜色都可以" class="headerlink" title="6.1.1 HEX、HSL 或 RGB 颜色都可以"></a>6.1.1 HEX、HSL 或 RGB 颜色都可以</h4><h4 id="6-1-2-px、em-或-rem-都行"><a href="#6-1-2-px、em-或-rem-都行" class="headerlink" title="6.1.2 px、em 或 rem 都行"></a>6.1.2 px、em 或 rem 都行</h4>我个人其实很少用 em 或 rem 作为阴影大小的单位。因为阴影一般都比较小，一个或两个像素的阴影，在所有视口中的效果都很不错。 <h4 id="6-1-3-取消文字阴影"><a href="#6-1-3-取消文字阴影" class="headerlink" title="6.1.3 取消文字阴影"></a>6.1.3 取消文字阴影</h4><h5 id="左上方阴影"><a href="#左上方阴影" class="headerlink" title="左上方阴影"></a>左上方阴影</h5>使用负值<h4 id="6-1-4-制作浮雕文字阴影效果"><a href="#6-1-4-制作浮雕文字阴影效果" class="headerlink" title="6.1.4 制作浮雕文字阴影效果"></a>6.1.4 制作浮雕文字阴影效果</h4>这种效果一般最适合应用在非白色背景的深色文字上，搭配以高亮颜色（如纯白色或类似颜色）的阴影。<blockquote>
<p>想要最好的浮雕文字效果，我有诀窍：不要模糊，不要水平阴影，仅在垂直方向设置 1或 2像素的“白影”即可。 </p>
</blockquote>
<h4 id="6-1-5-多重文字阴影"><a href="#6-1-5-多重文字阴影" class="headerlink" title="6.1.5 多重文字阴影"></a>6.1.5 多重文字阴影</h4>只需将两组值使用逗号分隔开即可<h3 id="6-2-盒阴影"><a href="#6-2-盒阴影" class="headerlink" title="6.2 盒阴影"></a>6.2 盒阴影</h3>但是，盒阴影的的跨浏览器支持并不好，所以明智的做法是使用浏览器私有前缀<h4 id="6-2-1-内阴影"><a href="#6-2-1-内阴影" class="headerlink" title="6.2.1 内阴影"></a>6.2.1 内阴影</h4> box-shadow:inset 0 0 40px #000000; <h4 id="6-2-2-多重阴影"><a href="#6-2-2-多重阴影" class="headerlink" title="6.2.2 多重阴影"></a>6.2.2 多重阴影</h4>这样两组阴影就会按照代码中的先后顺序从上到下应用到元素上。换句话说，就是代码中先声明的规则，在浏览器中会覆盖下面的规则。 <h4 id="6-3-背景渐变"><a href="#6-3-背景渐变" class="headerlink" title="6.3 背景渐变"></a>6.3 背景渐变</h4><h5 id="6-3-1-线性背景渐变"><a href="#6-3-1-线性背景渐变" class="headerlink" title="6.3.1 线性背景渐变"></a>6.3.1 线性背景渐变</h5>背景渐变唯一美中不足的是它不像其他一些 CSS3 特性那样被广泛支持。比如 IE 9 就没有对它的原生支持（微软承诺在 IE 10中支持） 。</li>
</ol>
<p>作为老版本浏览器的降级方案，最好先定义一个固定背景颜色，</p>
<h5 id="分解线性渐变语法"><a href="#分解线性渐变语法" class="headerlink" title="分解线性渐变语法"></a>分解线性渐变语法</h5><h4 id="6-3-2-径向背景渐变"><a href="#6-3-2-径向背景渐变" class="headerlink" title="6.3.2 径向背景渐变"></a>6.3.2 径向背景渐变</h4><h5 id="分解径向渐变语法"><a href="#分解径向渐变语法" class="headerlink" title="分解径向渐变语法"></a>分解径向渐变语法</h5><pre><code>background: radial-gradient(center, ellipse cover, #ffffff 72%, #dddddd 100%); 
</code></pre><ol>
<li>closest-side： （渐变形状是圆形时） 以距离中心点最近的一边为渐变半径， 或者 （渐变形状是椭圆形时）以距离中心点最近的水平或垂直边为渐变半径。   </li>
<li>closest-corner：以距离中心点最近的一角为渐变半径。 </li>
<li>farthest-side：和 closest-side 正好相反， （渐变形状是圆形时）以距离中心点最远的一边为渐变半径，或者（渐变形状是椭圆形时）以距离中心点最远的水平或垂直边为渐变半径。   </li>
<li>farthest-corner：以距离中心点最远的一角为渐变半径。   </li>
<li>cover：和 farthest-corner 完全一样。   </li>
<li><p>contain：和 closest-side 完全一样。    </p>
<blockquote>
<p>制作完美 CSS3 渐变的简便方法<br>如果写出一个 CSS3 渐变对你来说有点难度，那你可以考虑使用在线渐变生成器。我个人最喜欢的渐变生成器是 <a href="http://www.colorzilla.com/" target="_blank" rel="noopener">http://www.colorzilla.com/</a><br>gradient-editor/。 它的用户界面风格很像图像处理软件， 你可以选择颜色、过渡点、渐变风格（线性渐变或径向渐变） ，甚至可以选择自己喜欢的<br>颜色空间（HEX、RGB(A)、HSL(A)） 。这个在线渐变生成器还会加载一些预置的渐变供你选用和修改。如果这些还不足以打动你，须知它还提供了可选的代码设置，用来修正 IE 9，让它显示渐变效果，而且还为老版本浏览器提供了备用的背景颜色。还是不动心？它还能基于已有的图片直接生成渐变，这个功能怎么样？我想这下总该打动你了。       </p>
</blockquote>
<h4 id="6-3-3-重复渐变"><a href="#6-3-3-重复渐变" class="headerlink" title="6.3.3 重复渐变"></a>6.3.3 重复渐变</h4><p> background: repeating-linear-gradient(90deg, #ffffff 0px, hsla(0, 1%, 50%,0.1) 5px);<br> background: repeating-radial-gradient(2px 2px, ellipse,  </p>
<pre><code>hsla(0,0%,100%,1) 2px, hsla(0,0%,95%,1) 10px,  
hsla(0,0%,93%,1) 15px, hsla(0,0%,100%,1) 20px);     
</code></pre><h4 id="6-4-背景渐变图案"><a href="#6-4-背景渐变图案" class="headerlink" title="6.4 背景渐变图案"></a>6.4 背景渐变图案</h4><p>CSS 高手 Lea Verou 收集了一系列 CSS3 背景渐变图案，具体请见<a href="http://lea.verou.me/css3patterns/。" target="_blank" rel="noopener">http://lea.verou.me/css3patterns/。</a> </p>
<h4 id="6-5-CSS3-的响应性"><a href="#6-5-CSS3-的响应性" class="headerlink" title="6.5 CSS3 的响应性"></a>6.5 CSS3 的响应性</h4><h4 id="6-6-组合使用-CSS3-属性"><a href="#6-6-组合使用-CSS3-属性" class="headerlink" title="6.6 组合使用 CSS3 属性"></a>6.6 组合使用 CSS3 属性</h4><p>还有最后一个问题，原始设计图中的那两个尖括号（即 HTML中的\&raquo;）使用了与按钮文字不一样的字体。但在此处为这么一个特殊符号专门引入一种字体不太划算，所以我准备将这个符号用一个内联标签包裹起来，然后增大它的字号。</p>
<h4 id="6-7-多重背景图片"><a href="#6-7-多重背景图片" class="headerlink" title="6.7 多重背景图片"></a>6.7 多重背景图片</h4><p>有一种很常见的设计需求，就是制作一个顶部和底部使用不同背景图片的页面。<br>除了 IE 8及更低版本外，其他浏览器均支持该特性。语法如下：</p>
<p> background:  </p>
<pre><code>url(&apos;../img/1.png&apos;) center, 
url(&apos;../img/2.png&apos;), 
url(&apos;../img/3.png&apos;) left bottom, black; 
</code></pre><h5 id="6-7-1-背景图片大小"><a href="#6-7-1-背景图片大小" class="headerlink" title="6.7.1 背景图片大小"></a>6.7.1 背景图片大小</h5></li>
<li>auto：使用图片的原始大小；   </li>
<li>cover：按照原始图片的长宽比缩放图片以填充整个元素区域；   </li>
<li>contain：按照原始图片的长宽比缩放图片以使其较长的一边适应元素大小。<h5 id="6-7-2-背景图片位置"><a href="#6-7-2-背景图片位置" class="headerlink" title="6.7.2 背景图片位置"></a>6.7.2 背景图片位置</h5><h5 id="6-7-3-背景属性的缩写语法"><a href="#6-7-3-背景属性的缩写语法" class="headerlink" title="6.7.3 背景属性的缩写语法"></a>6.7.3 背景属性的缩写语法</h5>可以使用缩写语法将各种背景属性组合起来。但是以我的经验看，这样会产生捉摸不定的结果。所以我更倾向于使用普通写法，先声明多重背景图片，然后声明背景大小，最后声明背景位置。       <h4 id="6-8-更多-CSS-特性"><a href="#6-8-更多-CSS-特性" class="headerlink" title="6.8 更多 CSS 特性"></a>6.8 更多 CSS 特性</h4><h4 id="6-9-可缩放图标：响应式设计中的完美选择"><a href="#6-9-可缩放图标：响应式设计中的完美选择" class="headerlink" title="6.9 可缩放图标：响应式设计中的完美选择"></a>6.9 可缩放图标：响应式设计中的完美选择</h4>@font-face图标就是将字符做成常用图标的特定字体。以往我们都是使用很多单独的图标图片，或者将图标图片组合成一张很大的雪碧图，而@font-face 图标则可以让你只用一种字体就涵盖所有要用的图标（这样就只需要一个 http 请求，唔哈哈！ ） 。另外，因为使用的是字体，所以图标就可以完美缩放了——这与响应式设计真可谓天作之合。Fico 上就有很好的@font-face图标，详情请见 <a href="http://fico.lensco.be/。" target="_blank" rel="noopener">http://fico.lensco.be/。</a><h4 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h4></li>
</ol>
<h2 id="第-7章-CSS3的过渡、变形和动画"><a href="#第-7章-CSS3的过渡、变形和动画" class="headerlink" title="第 7章  CSS3的过渡、变形和动画"></a>第 7章  CSS3的过渡、变形和动画</h2><ol>
<li>什么是 CSS3过渡以及如何使用它    </li>
<li>如何编写 CSS3过渡以及它的缩写语法    </li>
<li>CSS3过渡时间函数（ease、cubic-bezier等）       </li>
<li>响应式网站中有趣的过滤效果       </li>
<li>什么是 CSS3变换以及如何使用它        </li>
<li>理解不同的 2D变换（scale、rotate、skew,、translate 等）       </li>
<li>尝试 3D变换          </li>
<li>CSS3动画效果（使用关键帧）      <h3 id="7-1-什么是-CSS3-过渡以及如何使用它"><a href="#7-1-什么是-CSS3-过渡以及如何使用它" class="headerlink" title="7.1 什么是 CSS3 过渡以及如何使用它"></a>7.1 什么是 CSS3 过渡以及如何使用它</h3><h4 id="7-1-1-过渡相关的属性"><a href="#7-1-1-过渡相关的属性" class="headerlink" title="7.1.1 过渡相关的属性"></a>7.1.1 过渡相关的属性</h4></li>
<li><p>过渡的简写语法   </p>
<pre><code>transition: all 1s ease 0s; 
</code></pre><p>使用简写语法时要注意，声明中的第一个时间值总被应用给transition-duration，第二个时间值总被应用给 transition-delay。</p>
<blockquote>
<p>过渡的局限性<br>使用过渡时有一点需要说明，即有些属性无法实现过渡，尽管规范上说它应该可以（即使在最新的工作草案 <a href="http://dev.w3.org/csswg/css3-transitions/中也这么说）" target="_blank" rel="noopener">http://dev.w3.org/csswg/css3-transitions/中也这么说）</a> 。例如，background-gradient 属性就无法过渡。 但理论上所有 CSS属性都是可以过渡的（<a href="http://www.w3.org/TR/css3-transitions/" target="_blank" rel="noopener">http://www.w3.org/TR/css3-transitions/</a> #properties-from-css-） 。   </p>
</blockquote>
</li>
<li><p>在不同时间段内过渡不同属性<br>当一条规则要实现多个属性过渡时，这些属性不必步调一致。看看下面这段代码： </p>
<pre><code>#content a { 
    /*……其他样式……*/ 
    transition-property: border, color, text-shadow; 
    transition-duration: 2s, 3s, 8s;  
}  
</code></pre></li>
<li>理解过渡调速函数<br>还是请读者直接看这里吧 <a href="http://cubic-bezier.com/。" target="_blank" rel="noopener">http://cubic-bezier.com/。</a>     <h4 id="7-1-2-响应式网站中的有趣过渡"><a href="#7-1-2-响应式网站中的有趣过渡" class="headerlink" title="7.1.2 响应式网站中的有趣过渡"></a>7.1.2 响应式网站中的有趣过渡</h4></li>
</ol>
<h3 id="7-2-CSS3-的-2D-变形"><a href="#7-2-CSS3-的-2D-变形" class="headerlink" title="7.2 CSS3 的 2D 变形"></a>7.2 CSS3 的 2D 变形</h3><p>现在如果你尝试在 Safari 浏览器中添加这种规则，须注意它需要应用该规则的原始元素必须以块状显示。示例如下：</p>
<h4 id="我们能做哪些变形"><a href="#我们能做哪些变形" class="headerlink" title="我们能做哪些变形"></a>我们能做哪些变形</h4><ol>
<li>scale：用来缩放元素（放大或缩小）   </li>
<li>translate：在屏幕上移动元素（上下左右四个方向）   </li>
<li>rotate：按照一定角度旋转元素（单位为度  ）<br>括号中的值只能以度为单位（如 90deg） 。</li>
<li>skew：沿 X和 Y轴对元素进行斜切<br>第一个值是 X轴上的斜切 （本例中是 10度） ， 第二个值是 Y轴上的斜切 （本例中是 2度） 。省略第二个值意味着仅有的值只会应用在 X轴上（水平方向） 。</li>
<li><p>matrix：允许你以像素精度来控制变形效果   </p>
<pre><code>transform: matrix(1.678, -0.256, 1.522, 2.333, -51.533, -1.989); 
</code></pre><p>它基本上能让你将若干变形效果（scale、rotate、skew等等）组合成单个声明。<br>而且在你看了规范文档之后就会发现问题更难，要完全理解矩阵你得了解相关的数学知识：<a href="http://www.w3.org/TR/css3-2d-transforms/#cssmatrix-interface。" target="_blank" rel="noopener">http://www.w3.org/TR/css3-2d-transforms/#cssmatrix-interface。</a></p>
<h4 id="傻瓜化的矩阵变形工具"><a href="#傻瓜化的矩阵变形工具" class="headerlink" title="傻瓜化的矩阵变形工具"></a>傻瓜化的矩阵变形工具</h4><p>如果你的数学也不太好，我建议你访问这里：<a href="http://www.useragentman.com/matrix/。" target="_blank" rel="noopener">http://www.useragentman.com/matrix/。</a>  </p>
</li>
<li>transform-origin 属性 <h3 id="7-3-尝试-CSS3-的-3D-变形"><a href="#7-3-尝试-CSS3-的-3D-变形" class="headerlink" title="7.3 尝试 CSS3 的 3D 变形"></a>7.3 尝试 CSS3 的 3D 变形</h3>但最新的 IE10都还不支持该特性。尽管缺少“桌面版”浏览器的广泛支持，但多亏了移动平台浏览器基本都是 Webkit血统，所以 3D变形在 Android（V3以后的版本）和 iOS（所有版本）上均被支持。 <h4 id="7-3-1-分析-3D-变形效果"><a href="#7-3-1-分析-3D-变形效果" class="headerlink" title="7.3.1 分析 3D 变形效果"></a>7.3.1 分析 3D 变形效果</h4>第一个要点是在父级元素上设置透视。这样就开启了 3D场景：<br>透视的值越大，就表示你的视点与 3D场景之间的景深越大。因此，如果想要一点隐约的3D 效果，就增大透视值；如果想要非常明显的 3D 效果，则减小透视值。 （3D 效果的立体程度，取决于 3D场景与观察者之间的距离。 ） </li>
</ol>
<p>.Qcontainer 类中添加的透视声明只会应用到其第一个子元素上（即本例中的 class为.film 的 div） 。 因此， 为了延续父元素的透视， 我们给.film 元素设定了 preserve-3d（这样可以设置一个 3D场景） 。 </p>
<p>还好， 我们可以用一点传统的CSS代码为非Webkit核心浏览器提供一个合理的降级方案：  z-index</p>
<pre><code>.Qcontainer {  
    -webkit-perspective: 200; 
} 
.film { 
    -webkit-transform-style: preserve-3d; 
} 
.Qcontainer:hover .film { 
    -webkit-transform: rotateY(180deg); 
} 
.face { 
    position: absolute; 
    -webkit-backface-visibility: hidden; 
}
.back { 
    -webkit-transform: rotateY(180deg); 
    background: #3b3b3b; 
    background: -webkit-linear-gradient(top,  
                            rgba(0,0,0,0.65) 0%,  
                            rgba(0,0,0,0) 100%); 
} 
//降级
z-index
</code></pre><h4 id="7-3-2-3D-变形尚未成熟"><a href="#7-3-2-3D-变形尚未成熟" class="headerlink" title="7.3.2 3D 变形尚未成熟"></a>7.3.2 3D 变形尚未成熟</h4><p>目前，我依然使用 jQuery或类似技术来制作这类变形效果。 </p>
<blockquote>
<p>想了解 W3C有关 CSS 3D变形的最新进展，请见这里：<a href="http://dev.w3.org/" target="_blank" rel="noopener">http://dev.w3.org/</a><br>csswg/css3-3d-transforms/。</p>
</blockquote>
<h3 id="7-4-CSS3-动画效果"><a href="#7-4-CSS3-动画效果" class="headerlink" title="7.4 CSS3 动画效果"></a>7.4 CSS3 动画效果</h3><p>IE 10也决定加入该行列。   </p>
<h4 id="组合使用-CSS3-变形和动画"><a href="#组合使用-CSS3-变形和动画" class="headerlink" title="组合使用 CSS3 变形和动画"></a>组合使用 CSS3 变形和动画</h4><h3 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h3><h2 id="第-8章-用-HTML5和-CSS3征服表单"><a href="#第-8章-用-HTML5和-CSS3征服表单" class="headerlink" title="第 8章  用 HTML5和 CSS3征服表单"></a>第 8章  用 HTML5和 CSS3征服表单</h2><p> 在表单域中插入占位符文字<br> 在需要时禁用表单域的自动完成功能<br> 将特定表单域设置为必填项<br> 使用不同类型的输入框，如电子邮箱、电话号码和 URL。<br> 制作数字输入滑动条以方便选择数值<br> 使用日期和颜色选择器<br> 学习如何使用正则表达式定义表单值验证规则<br> 为落后的浏览器添加腻子脚本<br> 使用 CSS3轻松灵活地美化 HTML5表单      </p>
<h3 id="8-1-HTML5-表单"><a href="#8-1-HTML5-表单" class="headerlink" title="8.1 HTML5 表单"></a>8.1 HTML5 表单</h3><h4 id="8-1-1-理解-HTML5-表单中的元素"><a href="#8-1-1-理解-HTML5-表单中的元素" class="headerlink" title="8.1.1 理解 HTML5 表单中的元素"></a>8.1.1 理解 HTML5 表单中的元素</h4><p>然后包含一个 HTML5的 hgroup，用于显示表单标题和说明文字：<br>表单中的三块子区域都使用带有 legend 标签的 fieldset 来包裹： </p>
<h4 id="8-1-2-placeholder"><a href="#8-1-2-placeholder" class="headerlink" title="8.1.2 placeholder"></a>8.1.2 placeholder</h4><h4 id="8-1-3-required"><a href="#8-1-3-required" class="headerlink" title="8.1.3 required"></a>8.1.3 required</h4><p>我们的例子中还追加了一个等价的 WAI-ARIA属性：aria-required=”true”。</p>
<h4 id="8-1-4-autofocus"><a href="#8-1-4-autofocus" class="headerlink" title="8.1.4 autofocus"></a>8.1.4 autofocus</h4><p>使用该属性时要小心。如果有多个表单域都被追加了 autofocus 属性，则会造成跨浏览器混乱。 </p>
<p>还有一点需要注意，有些用户会使用空格键让网页内容向下滚动。如果网页的表单中含有带 autofocus 属性的表单域，则会阻止空格键的默认行为，这时敲击空格键会向已聚焦的输入框中输入空格。显然，这会让用户很懊恼。 </p>
<h4 id="8-1-5-autocomplete"><a href="#8-1-5-autocomplete" class="headerlink" title="8.1.5 autocomplete"></a>8.1.5 autocomplete</h4><p>这不仅仅能保护敏感数据 （例如银行账户） ， 还可以让你确保用户用心填写表单，手工输入一些值。<code>autocomplete=&quot;off&quot;</code>   </p>
<p>我们也可以通过给表单本身（不是 fieldset）设置属性来禁用整个表单的自动完成功能。</p>
<h4 id="8-1-6-list（及对应的-datalist-元素）"><a href="#8-1-6-list（及对应的-datalist-元素）" class="headerlink" title="8.1.6 list（及对应的 datalist 元素）"></a>8.1.6 list（及对应的 datalist 元素）</h4><h4 id="8-1-7-HTML5-的新输入类型"><a href="#8-1-7-HTML5-的新输入类型" class="headerlink" title="8.1.7 HTML5 的新输入类型"></a>8.1.7 HTML5 的新输入类型</h4><p>这些新的输入类型最赞的一点，就是在那些不支持新特性的浏览器中，它们会被降级显示为一个标准的文本输入框。此外还有很多很有用的腻子脚本</p>
<ol>
<li>email<br>此外，<strong>许多触摸屏设备（如 Android、iPhone等等）会根据输入类型改变键盘模式</strong>。</li>
<li>number<br>超出范围的数字会（应该）得到特殊对待。浏览器的具体实现也不相同，</li>
<li>url </li>
<li>tel<br>不过好的一点就是，和对待 email 和 url 类型一样，触摸屏设备为这种类型贴心地提供了数字键盘以便完成输入。 <blockquote>
<p>电话号码的输入格式和验证规则，不同地区可能有所不同。不提供统一验证也可以理解。——译者注 </p>
</blockquote>
</li>
<li>search </li>
<li>pattern <blockquote>
<p>学习正则表达式<br><a href="http://en.wikipedia.org/wiki/Regular_expressions。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Regular_expressions。</a></p>
</blockquote>
</li>
<li>color<br>悲剧的是，目前很少有浏览器支持该特性，好像只有 Opera（v11）支持。如果浏览器默认的颜色选择器中没有所需的颜色， 点击下方的 Other…按钮就会打开操作系统默认的颜色选择器： <h4 id="8-1-8-日期和时间输入类型"><a href="#8-1-8-日期和时间输入类型" class="headerlink" title="8.1.8 日期和时间输入类型"></a>8.1.8 日期和时间输入类型</h4></li>
<li>date</li>
<li>month </li>
<li>week </li>
<li>time </li>
<li><p>datetime 和 datetime-local<br> 日期时间选择器会生成一个由日期、时间和时区组成的值，日期与时间之间用 T 分割，使用 Z 表示协调世界时，使用正负值表示时区偏移。协调世界时的 2009年 10月 25日显示如下：<br> 2009-10-25T05:05:00Z </p>
<p> 协调世界时（UTC）与格林尼治标准时（GMT）在大多数实际应用中基本一样。时区偏移则很好理解，比如，北京时间比格林尼治标准时提前 8小时（UTC +8） ，反映到输入值上，效果如下：<br> 2009-10-25T05:05:00+8:00 </p>
<p> datetime-local 输入类型和 datetime 几乎完全一样，只是省略了时区信息。</p>
<blockquote>
<p>修改步增值<br> 你可以使用 step 属性来修改各种输入类型控制按钮的步增值。比如，要<br> 将时间的步增值改为 4个小时，将 step的属性值设为 14400秒（4×60×60） 即可。将 datetime的步增值改为 4小时的示例代码如下：<br> <code>&lt;input id=&quot;datetime&quot; type=&quot;datetime&quot; name=&quot;datetime&quot; step=&quot;14400&quot;&gt;</code></p>
</blockquote>
</li>
<li>range<br>range 输入类型最大的一个问题是它从来不给用户显示当前的输入值。虽然滑动条仅被设计用来选择模糊的数值， 但我还是经常想看看它的当前值。 使用 HTML5目前无法解决这个问题，但是如果你确实需要显示滑动条的当前输入值，可以通过 JavaScript来实现。<h3 id="8-2-如何给不支持新特性的浏览器打补丁"><a href="#8-2-如何给不支持新特性的浏览器打补丁" class="headerlink" title="8.2 如何给不支持新特性的浏览器打补丁"></a>8.2 如何给不支持新特性的浏览器打补丁</h3>前面把 HTML5表单的功能吹上了天， 但要想实际使用则还有两个非常麻烦的问题： 一是支持表单新特性的浏览器在具体实现上有所不同；二是对完全不支持新特性的浏览器如何处理。万幸的是，Web社区一如既往地拿出了解决办法。</li>
</ol>
<p>回到第 4 章，我提过一个非常棒的 JavaScript 框架叫做 Modernizr（<a href="http://www.modernizr.com）" target="_blank" rel="noopener">http://www.modernizr.com）</a> ，用于向缺少 HTML5/CSS3特性支持的浏览器打补丁。由 Alexander Farkas编写的“Webshims Lib”（<a href="http://afarkas.github.com/webshim/demos/）就是构建于" target="_blank" rel="noopener">http://afarkas.github.com/webshim/demos/）就是构建于</a> Moderniz和无处不在的 jQuery之上的，它可用于插入表单补丁（也可以为其他 HTML5特性打补丁） ，从而使不支持新特性的浏览器可以处理 HTML5 表单。最值得称道的一点是，<strong>它利用了Modernizr 的加载功能，能做到只加载实际所需的补丁</strong>。如果在原生支持 HTML5 新特性的浏览器中查看网页，则仅会给网页加入一丁点儿冗余代码。而对于老版本浏览器，虽然它们需要加载更多的代码（因为它们本身能力不足） ，但通过相关 JavaScript 方法的辅助，它们能提供基本一致的用户体验。<br><a href="http://github.com/aFarkas/webshim/downloads" target="_blank" rel="noopener">http://github.com/aFarkas/webshim/downloads</a></p>
<h3 id="8-3-使用-CSS3-美化-HTML5-表单"><a href="#8-3-使用-CSS3-美化-HTML5-表单" class="headerlink" title="8.3 使用 CSS3 美化 HTML5 表单"></a>8.3 使用 CSS3 美化 HTML5 表单</h3><h4 id="针对表单的-CSS3-伪类选择器"><a href="#针对表单的-CSS3-伪类选择器" class="headerlink" title="针对表单的 CSS3 伪类选择器"></a>针对表单的 CSS3 伪类选择器</h4><p> input:required：选择必填表单域；<br> input:focus:invalid：选择当前聚焦的且含有非法输入值的表单域；<br> input:focus:valid：选择当前聚焦的且含有合法输入值的表单域。   </p>
<h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><h2 id="第-9章-解决跨浏览器问题"><a href="#第-9章-解决跨浏览器问题" class="headerlink" title="第 9章  解决跨浏览器问题"></a>第 9章  解决跨浏览器问题</h2><p> 渐进增强和优雅降级之间的根本区别<br> 如何让老版本 Internet Explorer支持响应式设计<br> 何如使用 Modernizr按需加载 CSS文件<br> 何如使用 Modernizr按需加载 JavaScript补丁文件<br> 如何将超长导航列表在小视口中转换为选择菜单<br> 如何为高分辨率（视网膜）显示屏提供匹配图片  </p>
<p>Internet Explorer 8 中的效果惨不忍睹，因为它不支持\<aside>、\<header>、\<nav>和\<footer>等 HTML5元素，这自然就引入了本章的主题——解决跨浏览器问题。 </footer></nav></header></aside></p>
<h3 id="9-1-渐进增强与优雅降级"><a href="#9-1-渐进增强与优雅降级" class="headerlink" title="9.1 渐进增强与优雅降级"></a>9.1 渐进增强与优雅降级</h3><p>优雅降级指的是为现代浏览器制作网站，然后保证为某些老版本浏览器提供基本可用的体验。</p>
<p>渐进增强与优雅降级恰好相反。渐进增强以恪守 Web标准的标签为基础，意味着它在所有浏览器中均可用。然后通过 CSS 样式和必要的 JavaScript 来为更先进的浏览器提供渐进式的增强体验。</p>
<h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p>目前，渐进增强被普遍认为是开发网站的最佳实践。然而，冰冷的现实是，我虽然打心眼里喜欢渐进增强并用它来制作网站，但很多情况下可以说我是用优雅降级的方式来做的。怎么会这样呢？ </p>
<h3 id="9-2-该不该修复老版本-IE"><a href="#9-2-该不该修复老版本-IE" class="headerlink" title="9.2 该不该修复老版本 IE"></a>9.2 该不该修复老版本 IE</h3><p>因为我只是告诉你能这么做，并不代表你应该这么做！ </p>
<p>此外，即使不使用补丁（我们稍后会谈谈这个话题） ，以我的经验，为了能让 IE6 和 IE7（以及少量 IE8 和 IE9）的页面渲染效果尽可能与现代标准浏览器类似，开发、测试和配置专属 CSS 代码所花费的时间，至少也和为现代浏览器提供渐进增强所花费的时间一样多——这很让人不爽！你和你的客户就准备这样用掉开发时间？ </p>
<h4 id="9-2-1-统计数据（再看看世界的变化）"><a href="#9-2-1-统计数据（再看看世界的变化）" class="headerlink" title="9.2.1 统计数据（再看看世界的变化）"></a>9.2.1 统计数据（再看看世界的变化）</h4><p>结论就是：老弱的 IE（6、7、8）的使用率正在不断减少，而现代浏览器（包括桌面版和移动版）的使用率则正在不断增加。 </p>
<h4 id="9-2-2-个人选择"><a href="#9-2-2-个人选择" class="headerlink" title="9.2.2 个人选择"></a>9.2.2 个人选择</h4><p>目前我个人的态度是，针对全新制作的网站，要确保其在最新版本的 IE（编写本书时最新版本是 IE9）以及前一个版本（IE8）中效果完美。而针对老版本 IE的布局和样式调整则由于需要额外的时间，所以另行商议。 </p>
<h3 id="9-3-前端的瑞士军刀：Modernizr"><a href="#9-3-前端的瑞士军刀：Modernizr" class="headerlink" title="9.3 前端的瑞士军刀：Modernizr"></a>9.3 前端的瑞士军刀：Modernizr</h3><p>那它到底做了什么？既能给老版本浏览器打补丁，又能保证新浏览器渐进增强的用户体验，它是怎么做到的，而我们又如何使其听任差遣呢？好好听着…… </p>
<p>第一步，下载 Modernizr（<a href="http://www.modernizr.com）" target="_blank" rel="noopener">http://www.modernizr.com）</a> 。 </p>
<h4 id="9-3-1-使用Modernizr辅助修正样式问题"><a href="#9-3-1-使用Modernizr辅助修正样式问题" class="headerlink" title="9.3.1 使用Modernizr辅助修正样式问题"></a>9.3.1 使用Modernizr辅助修正样式问题</h4><h4 id="9-3-2-使用Modernizr让老版本IE支持HTML5-元素"><a href="#9-3-2-使用Modernizr让老版本IE支持HTML5-元素" class="headerlink" title="9.3.2 使用Modernizr让老版本IE支持HTML5 元素"></a>9.3.2 使用Modernizr让老版本IE支持HTML5 元素</h4><h4 id="9-3-3-给IE6、7、8-追加min-max媒体查询功能"><a href="#9-3-3-给IE6、7、8-追加min-max媒体查询功能" class="headerlink" title="9.3.3 给IE6、7、8 追加min/max媒体查询功能"></a>9.3.3 给IE6、7、8 追加min/max媒体查询功能</h4><p>我选择的给老版本 IE添加媒体查询支持的垫片脚本，仅支持追加min/max-width 媒体查询功能。还有很多类似的垫片脚本，可以追加很多媒体查询特性。但对于响应式设计来说，Scott Jehl开发的 Respond.js使用简单、速度快，我一直用得很顺手。<br>Respond.js（<a href="https://github.com/scottjehl/Respond）可以独立于" target="_blank" rel="noopener">https://github.com/scottjehl/Respond）可以独立于</a> Modernizr 使用——只需将其引入到需要的页面，然后就如其作者 Scott Jehl所说： “撬开 IE，击掌相庆。 ”</p>
<p>不错，我们现在给 IE添加了垫片脚本，使其可以支持 min-width 和 max-width，但有一个问题：垫片脚本在每一种浏览器中都会被加载——不论它们需要与否。一种解决办法就是将脚本文件链接放置在 IE条件注释中，像下面这样： </p>
<pre><code>&lt;!--[if lte IE 8]&gt; 
        &lt;script src=&quot;js/respond.min.js&quot;/&gt;&lt;/script&gt; 
&lt;![endif]--&gt; 
</code></pre><h4 id="9-3-4-使用Modernizr按需加载资源"><a href="#9-3-4-使用Modernizr按需加载资源" class="headerlink" title="9.3.4 使用Modernizr按需加载资源"></a>9.3.4 使用Modernizr按需加载资源</h4><p>Modernizr中包含一个名为 YepNope.js的小型 JavaScript库文件（<a href="http://yepnopejs.com/）。使用方法很简单：" target="_blank" rel="noopener">http://yepnopejs.com/）。使用方法很简单：</a> </p>
<pre><code>Modernizr.load({ 
    test: Modernizr.mq(&apos;only all&apos;), //检测的是浏览器是否支持媒体查询：
    nope: &apos;js/respond.min.js&apos; 
}); 

Modernizr.load({ 
    test: Modernizr.mq(&apos;only all&apos;), 
    yep: &apos;js/pass.js&apos;, 
    nope: [&apos;js/respond.min.js&apos;, &apos;fail-polyfill.js&apos;, &apos;fail.css&apos;] , 
    both: &apos;js/for-all.js&apos; 
}); 
</code></pre><blockquote>
<p>下载垫片脚本<br>下面的这个 github库中有很多有用的垫片脚本：<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills。" target="_blank" rel="noopener">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills。</a></p>
</blockquote>
<h3 id="9-4-必要时将导航链接转换为下拉菜单"><a href="#9-4-必要时将导航链接转换为下拉菜单" class="headerlink" title="9.4 必要时将导航链接转换为下拉菜单"></a>9.4 必要时将导航链接转换为下拉菜单</h3><p>我想在浏览器视口小于一定宽度时，将这些导航链接转换为一个下拉菜单。你可以自己编 写 一 段 代 码 来 做 这 件 事 。 可 敬 的 Chris Coyier 写 过 一 篇 文 章 来 讲 怎 么 做（<a href="http://css-tricks.com/convert-menu-to-dropdown/）" target="_blank" rel="noopener">http://css-tricks.com/convert-menu-to-dropdown/）</a> 。 不过， 你还可以选择别人已经写好的脚本。为了简便起见，我就选了个现成的脚本。  </p>
<p>首先下载 Responsive Menu脚本（<a href="https://github.com/mattkersley/Responsive-Menu）" target="_blank" rel="noopener">https://github.com/mattkersley/Responsive-Menu）</a> ，</p>
<pre><code>Modernizr.load([ 
{ 
    test: Modernizr.mq(&apos;only all&apos;), 
    nope: &apos;js/respond.min.js&apos; 
}, 
{ 
    // 如果 max-width 等于 600px，则加载菜单转换脚本 
    test: Modernizr.mq(&apos;only screen and (max-width: 600px)&apos;), 
    yep : [&apos;js/jquery-1.7.1.js&apos;, &apos;js/jquery.mobilemenu.js&apos;], 
    complete : function () { 
    // 资源完全加载后运行 
    $(document).ready(function(){ 

        $(&apos;#mainNav&apos;).mobileMenu({ 
        switchWidth: 600,                   //转换宽度 (用 px 表示) 
        topOptionText: &apos;Select a page&apos;,     //第一个选项的内容 
        indentString: &apos;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;  //缩进嵌套选项的字符串 
        }); 
    }); 

    } 
} 
]); 
</code></pre><h3 id="9-5-高分辨率设备（未来趋势）"><a href="#9-5-高分辨率设备（未来趋势）" class="headerlink" title="9.5 高分辨率设备（未来趋势）"></a>9.5 高分辨率设备（未来趋势）</h3><pre><code>@media all and (-webkit-min-device-pixel-ratio : 1.5) { 
    #container header[role=&quot;banner&quot;] .logo a { 
        background-image: url(&quot;../img/logo2@x2.png&quot;); 
    } 
} 
</code></pre><p>使用这个技巧时需要慎重。图片尺寸越大，文件体积也越大，所需的加载时间会更长，所以再重申一遍：你可以这么做，但不一定应该这么做。 </p>
<p>另外，如果浏览器支持可缩放矢量图形（SVG） ，那使用该技术替代图片可以解决我们目前面临的很多图片缩放问题。顾名思义，可缩放矢量图形能生成可任意缩放但显示清晰的矢量图片。不过，媒体查询和 SVG对嵌入在页面中的高分辨率图片无能为力。在这种情况下你需要考虑基于 JavaScript的解决方案。    </p>
<h3 id="9-6-小结"><a href="#9-6-小结" class="headerlink" title="9.6 小结"></a>9.6 小结</h3><p style="text-align:right">14:00</p></html></nav></b></i></b></b></h1></h4></section></aside></footer></header></head>]]></content>
      <categories>
        <category>pdf</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>2017英语单词</title>
    <url>/ins/ens/characters-2017/</url>
    <content><![CDATA[<p>2017年11月 集合<br><a id="more"></a></p>
<ol>
<li>character:字符、字、人物、性格、品质….</li>
<li>barrage:弹幕（danmu），阻塞<br> bar:酒吧（间）、栅、块、沙洲、。。；v，拦、阻挡、关进<br> rage:n&amp;v,愤怒、怒气/火，</li>
<li>scrub:v,擦洗、刷洗、摩擦。。n，摩擦、刷子、鬃、灌木丛、<br> rub:v,擦、搓揉、摩擦、蹭;n,摩擦、困难、难点；</li>
<li>manifest:v,表现、表面、昭示；n，舱单、货单；adj，明显的，明白的<br> fest:(巨星)，后缀：in nouns denoting a festival or large gathering of a specified kind.    </li>
<li>manipulate：v，操作/纵、摆弄<br> 无法拆分</li>
<li>prospective:adj,预期、有希望    prosperous:adj<br> prospect:n,展望、前/远景、前程；v，指望、探矿、查勘</li>
<li>flourish:v,繁荣、兴盛/旺、舞、摇；n，华饰<br> flour:n,面粉、面、白面</li>
<li>integrate:v,整合、结合、统一、合成、联系、合流<br> grate: n,繁重而累人的<br> migrate:v,迁移、转移、迁徙、移民/居、迁飞</li>
<li>apostle:n,师徒   a post 一个帖子；a post office 一个邮局<br> le，后缀，，post：n，职位，岗位，柱子，邮件；v，邮寄，公告，音信<br>apostate：n&amp;adj，背教者，变节者 </li>
<li>tribe：部落  </li>
<li>compress：v，压缩，压紧，压碎  compressor：压缩机</li>
<li>pseudo:n,欺人者；adj，冒充的<br>pseudonym:n,笔名，假名   pseudoscience：伪科学</li>
<li>rail：n,（铁）轨，扶手，栅；v，抱怨，以横木围栏    </li>
<li>pipe：n，管（子），导管，烟斗，竖笛；v，吹笛<br>pipeline：n，管道，传输途径；v，传输途径</li>
<li>asset：n，财富–a useful or valuable thing, person, or quality.<br>wealth：n，</li>
<li>tamper:v，篡改，玩弄，削弱，管闲事；n，夯<br>tamp:v，夯，砸，韩（?）<br>ample:adj，充足/分，丰满，足够，博，广<br>amplify:v,放/扩大，衍<br>amped up：加快了</li>
<li>span:n,跨度，广度，翼展</li>
<li>recursive:递归<br>cursive：草书；   recur：v，复发，回到，溯；</li>
</ol>
]]></content>
      <categories>
        <category>ins</category>
        <category>ens</category>
      </categories>
      <tags>
        <tag>ens</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构</title>
    <url>/pdf/ex/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<!-- 读：~2017.3 -->
<p style="text-align:right">2018. 星期 00:00</p>

<p>数据结构绪论    算法<br>线性表    栈与队列   串    树  图<br>查找 排序  </p>
<h2 id="一-数据结构绪论"><a href="#一-数据结构绪论" class="headerlink" title="一 数据结构绪论"></a>一 数据结构绪论</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二 算法"></a>二 算法</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><h2 id="三-线性表"><a href="#三-线性表" class="headerlink" title="三 线性表"></a>三 线性表</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h2 id="四-栈与队列"><a href="#四-栈与队列" class="headerlink" title="四 栈与队列"></a>四 栈与队列</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h2 id="五-串"><a href="#五-串" class="headerlink" title="五 串"></a>五 串</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><h2 id="六-树"><a href="#六-树" class="headerlink" title="六 树"></a>六 树</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><h3 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h3><h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3><h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3><h3 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h3><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><h2 id="七-图"><a href="#七-图" class="headerlink" title="七 图"></a>七 图</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h3><h3 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><h2 id="八-查找"><a href="#八-查找" class="headerlink" title="八 查找"></a>八 查找</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h3><h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h2 id="九-排序"><a href="#九-排序" class="headerlink" title="九 排序"></a>九 排序</h2><h3 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h3><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><h3 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h3><h3 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h3><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p style="text-align:right">12：54 </p>


]]></content>
      <categories>
        <category>pdf</category>
        <category>ex</category>
      </categories>
  </entry>
  <entry>
    <title>Burned Brain 目录</title>
    <url>/ins/burnedBrain/Burned%20brain%20%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>2017.10.24 星期二  22：31止<br>共58个audios （1-52=52，1-5=5，直播回听-45.5）<br>有文档（包括只有配图） 共计47(5+7*3+11+10)篇：52-（1，14，15，46，49）</p>
<p>1申一帆：3天记忆400页GRE单词，学霸之路其实可以复制  2016-12-24<br>2李威：中国首个世界记忆力锦标赛团体冠军是这样获得的2016-12-24<br>3王昱珩：观察与联想，帮助我拥有最好的记忆力2016-12-24<br>4贾立平：不止是魔方，我的记忆技巧助你成为多才多艺的“学霸”2016-12-24<br>5【发刊词】李威：最强大脑的记忆力，你也可以拥有2016-12-26<br>【试听课】1. 大脑只开发10%？你所熟悉的大脑谬论！2016-12-26<br>（以上，都没有内容）</p>
<ol start="2">
<li>揭秘“身体定桩记忆法”，实战记忆中华56民族2016-12-29</li>
<li>记忆的决定因素和类型：通过多感官达成记忆2017-01-05</li>
<li>记忆的四大规律：跳开那些记忆的“雷区”2017-01-10</li>
<li>记忆知识的分类：找到最适合的记忆方法2017-01-13</li>
<li>配对联想法：攻克一一对应记忆难题2017-01-17</li>
<li>单词宝典：记忆英语单词的十种方法2017-01-20</li>
<li>单词宝典：申一帆的单词记忆秘笈——字母编码法2017-01-24</li>
<li>单词宝典：字母组合编码法——想象力比知识更重要2017-01-27    </li>
<li>单词宝典：记忆单词的“野路子”——谐音法+拼音法2017-01-31</li>
<li>单词宝典： 熟词+熟词法&amp;词中词法&amp;字母换位法2017-02-03</li>
<li>单词宝典：词根词缀应该怎么记？2017-02-07</li>
<li>单词宝典：词根词缀应该怎么用？2017-02-10</li>
<li>水哥开讲：记忆力的最佳伙伴——观察力与想象力2017-02-14</li>
<li>想象与联想角度2017-02-17</li>
<li>诗词记忆法则：串联记忆法与图像记忆法</li>
<li>知识虽孤立，妙趣串联之——有效串联的三种方法</li>
<li>记忆宫殿法之“地点定桩法”</li>
<li>记忆宫殿法之“人物定桩法”2017-03-04</li>
<li>记忆宫殿法之“身体定桩法”2017-03-07</li>
<li>记忆宫殿法之“标题定桩法”</li>
<li>记忆宫殿法之“数字定桩法”</li>
<li>记忆宫殿法之“熟语定桩法”</li>
<li>记忆宫殿法之“配图定位法”</li>
<li>期中梳理：如何选择正确的记忆策略</li>
<li>巧记圆周率前60位</li>
<li>隐藏在数字中的密码2017-03-31</li>
<li>历史年代轻松记2017-04-04</li>
<li>日期信息巧记忆</li>
<li>巧记生活中的长数据</li>
<li>达人记忆养成计划：字词达人</li>
<li>达人记忆养成计划：常识达人</li>
<li>古诗词记忆之场景记忆法</li>
<li>地点定桩法和思维导图法记忆古诗词</li>
<li>实战案例：数字定桩法记忆春江花月夜2017-04-28</li>
<li>词语转换的六种方法2017-05-02</li>
<li>解锁神技能：长篇文章和书籍记忆</li>
<li>学科记忆专题——历史</li>
<li>学科记忆专题——地理</li>
<li>学科记忆专题——政治</li>
<li>玩转魔方：你需要听懂这一课2017-05-19</li>
<li>学科记忆专题——数学2017-05-23</li>
<li>学科记忆专题——化学2017-05-26</li>
<li>综合实战案例——搞定医学知识记忆难题2017-05-31</li>
<li>娱乐场实用手册——速记扑克秘诀2017-06-02<br>【直播回听】烧脑天团首次公开课2017-06-06</li>
<li>综合实战案例——攻克司法考试记忆难题2017-06-07</li>
<li>学科记忆专题——物理2017-06-10</li>
<li>如何快速记住书籍内容要点2017-06-13</li>
<li>答疑课2017-06-17</li>
<li>学科记忆专题——生物2017-06-21</li>
<li>综合实战案例——图形记忆的技巧2017-06-25</li>
<li>超级记忆力的进阶与提升2017-06-27</li>
</ol>
<p>记了也没有东西</p>
<ol start="14">
<li>水哥开讲：记忆力的最佳伙伴——观察力与想象力2017-02-14</li>
</ol>
<p>没有记的：（没有实际内容）</p>
<ol start="15">
<li>想象与联想角度   没有内容</li>
<li>玩转魔方：你需要听懂这一课<br>【直播回听】烧脑天团首次公开课</li>
<li>答疑课</li>
</ol>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>8学科2实战10篇</title>
    <url>/ins/burnedBrain/8%E5%AD%A6%E7%A7%912%E5%AE%9E%E6%88%9810%E7%AF%87/</url>
    <content><![CDATA[<h2 id="38-学科记忆专题——历史"><a href="#38-学科记忆专题——历史" class="headerlink" title="38. 学科记忆专题——历史"></a>38. 学科记忆专题——历史</h2><p>1、中华文明源远流长，被华夏儿女尊称为“人文初祖”的是<br>      A.蚩尤   B.黄帝  C.尧  D.禹</p>
<p>2、我国古典文学灿烂辉煌。下列文学家及其作品出现时间最早的是<br>　A.曹雪芹《红楼梦》 B.李白《早发白帝城》<br>　C.关汉卿《窦娥冤》 D.苏轼《念奴娇·赤壁怀古》</p>
<p>朝代歌：<br>三皇五帝始 尧舜禹相传夏商与西周 东周分两段春秋和战国 一统秦两汉三分魏蜀吴 二晋前后沿南北朝并立 隋唐五代传宋元明清后 皇朝至此完</p>
<p>3、这个条约并不是由相互平等谈判达成，而是一场战争后强加给中国，并使中国完全沦为半殖民地。这个条约是（）<br>A.《南京条约》  B.《北京条约》 C.《马关条约》 D.《辛丑条约》</p>
<p>中国完全沦为半殖民地半封建社会的条约是《辛丑条约》。《辛丑条约》，亦称《辛丑各国和约》、《北京议定书》，是清朝在义和团运动失败、八国联军攻入北京后签定的一个不平等条约。 条约签定于光绪二十七年（1901年）七月二十五日，辛丑年，故名辛丑条约。因条约签订日为阳历9月7日，因此有“九七国耻”一说。</p>
<p>《辛丑条约》是中国近代史上赔款数目最庞大、主权丧失最严重的不平等条约。条约规定：<br>1)     中国赔款价息合计9.8亿两白银（详情为赔偿4.5亿白银，分39年还清，本息共计约9.8亿两），<br>2)     划定北京东交民巷为使馆界，允许各国驻兵保护，不准中国人在界内居住；<br>3)     清政府保证严禁人民参加反帝运动；<br>4)     清政府拆毁天津大沽口到北京沿线设防的炮台，允许列强各国派驻兵驻扎北京到山海关铁路沿线要地。</p>
<p>4、“淮海战役是人民群众用小车推出来的”。我们要缅怀淮海战役，应该选择去下列哪个城市？<br>A.锦州     B.北京　C.徐州     D.南京</p>
<p>辽沈战役：1948年9月12日开始，同年11月2日结束，共历时52天。主要在沈阳、长春、锦州等地。</p>
<p>淮海战役：1948年11月6日开始，1949年1月10日结束，共历时65天。中国人民解放军华东、中原野战军在以徐州为中心，东起海州，西迄商丘，北起临城(今枣庄市薛城)，南达淮河的广大地区。</p>
<p>平津战役：1948年12月5日开始，1949年1月31日结束，共64天。控制北平、天津及华北大片地区。</p>
<h2 id="39-学科记忆专题——地理"><a href="#39-学科记忆专题——地理" class="headerlink" title="39. 学科记忆专题——地理"></a>39. 学科记忆专题——地理</h2><p>1、我国年降水量最多的地方是（　　）<br>  A．台湾的火烧寮 B．吐鲁番盆地  C．曾母暗沙 D．   珠江三角洲</p>
<p>2、玛雅文明是产生在哪个大洲的文明？（ 美洲  ）  </p>
<p>3、山东、山西两省的“山”是指（ 太行山  ）</p>
<p>4、青海省是长江和黄河的发源地，被称为“江河之源”</p>
<p>5、图中A点的坐标是（　　）<br>　   A．60°N.60°W     B．60°S.60°   C   60°N.60°E       D．   60°S.60°E<br><img src="http://you img base url/images/390经纬度.png?e=1585218234&token=your qiniu access key:fVVVN7k0TjosOm99J_uGEHgAD50=" alt></p>
<p>6、今日考试时，武汉大致处于哪个节气附近（　　）<br>　   A．春分     B．夏至        C．秋分        D．   冬至</p>
<p>7、我国是海陆兼备的国家，拥有约18000千米的海岸线，请写出我国临海的省级行政单位简称．</p>
<p>我国海岸线绵长，临海的省区有14个，自北向南依次为：辽宁、河北、天津、山东、江苏、上海、浙江、福建、台湾、广东、香港、澳门、海南、广西，其简称依次是辽、冀、津、鲁、苏、沪或申、浙、闽、台、粤、港、澳、琼、桂．</p>
<p>8、危害世界的四大自然灾害是<strong>___</strong>、<strong><strong>_</strong></strong>、<strong><strong>__</strong></strong> 和火山爆发。<br>（旋风、水灾、地震）</p>
<p>9、影响气候的因素主要有纬度因素、海陆因素、地形地势因素、洋流因素及人类活动等。</p>
<p>1.飞船国 波黑<br><img src="http://you img base url/images/391飞船国波黑.jpg?e=1585218234&token=your qiniu access key:D8OQH03e-NgFNFWODqENlTclZes=" alt><br><img src="http://you img base url/images/392下腰国比利时.jpg?e=1585218234&token=your qiniu access key:FL4sudOrjelcWPLiu3vZFqArvNg=" alt><br><img src="http://you img base url/images/393土豆国匈牙利.jpg?e=1585218234&token=your qiniu access key:jq4F9tIloVHDGs23eRk1rNAJC5E=" alt><br><img src="http://you img base url/images/394蝌蚪国挪威.jpg?e=1585218234&token=your qiniu access key:JDdwHqPZn06p3eSUxOrJpZ357cM=" alt><br><img src="http://you img base url/images/395火龙国英国.jpg?e=1585218234&token=your qiniu access key:dvEyPTgrYMPPzyVWKiiluQN6pMA=" alt><br><img src="http://you img base url/images/396.猫头鹰国法国.jpg?e=1585218234&token=your qiniu access key:q2hwcJU4EtKfnVTiM9rbx1smDiw=" alt><br><img src="http://you img base url/images/397毛毛虫国葡萄牙.jpg?e=1585218234&token=your qiniu access key:e5V22OIjpybHNxRAuzjiFRYW-7I=" alt><br><img src="http://you img base url/images/398便便猪国俄罗斯.jpg?e=1585218234&token=your qiniu access key:Be1zoAi9iyfaWhHRnyVUW1RXO54=" alt></p>
<h2 id="40-学科记忆专题——政治"><a href="#40-学科记忆专题——政治" class="headerlink" title="40. 学科记忆专题——政治"></a>40. 学科记忆专题——政治</h2><p>1、实现全面建设小康社会奋斗目标的新要求:<br>1)    增强发展协调性，努力实现经济又好又快发展。<br>2)    扩大社会主义民主，更好保障人民权益和社会公平正义。<br>3)    加强文化建设，明显提高全民族文明素质。<br>4)    加快发展社会事业，全面改善人民生活。<br>5)        建设生态文明，基本形成节约能源资源和保护生态环境的产业结构、增长方式、消费模式。</p>
<p>2、树立正确的消费观念<br>①量入为出，适度消费（我们要在自己的经济承受能力之内进行消费，但也不提倡过于节俭。）<br>②避免盲从，理性消费（我们要避免跟风随大流，避免情绪化消费，避免重物质消费轻精神消费。）<br>③保护环境，绿色消费（绿色消费以保护消费者健康和节约资源为主旨，符合人的健康和环境保护标准的各种消费行为的总称。绿色消费的核心是可持续消费。）<br>④勤俭节约，艰苦奋斗。（勤俭节约，艰苦奋斗是中华民族的传统美德和优良作风。一个没有艰苦奋斗精神作支撑的民族，难以自立自强；一个没有艰苦奋斗精神的人，难以战胜困难，成就事业。）</p>
<p>3、主权国家享有的权利：<br>①独立权，主权国家拥有按照自己的意志处理内政、外交事务而不受他国控制和干涉的权利。<br>②平等权，主权国家不论大小、强弱，也不论政治、经济、意识形态和社会制度有何差异，在国际法上的地位一律平等。<br>③自卫权，主权国家拥有保卫自己的生存和独立的权利。<br>④管辖权，主权国家对其领域内的一切人和物具有管辖的权利。管辖权对公民的管理和保护包括居住国外的侨民，对物的管理包括了驻外的使馆等。</p>
<p>4、劳动者权利：</p>
<p>平等就业和选择职业的权利；</p>
<p>取得劳动报酬的权利；</p>
<p>休息、休假的权利；</p>
<p>获得劳动安全卫生保护的权利；</p>
<p>接受职业技能培训的权利；</p>
<p>享受社会保险和福利的权利；</p>
<p>提请劳动争议处理的权利。 </p>
<p>5、生产与消费的关系</p>
<p>消费反作用于生产：①消费是生产的目的。②消费所形成的新的需要，对生产的调整和升级起着导向作用。③一个新的消费热点的出现，往往能够带动一个产业的出现和成长。④消费为生产创造出新的劳动力，提高劳动力的质量，提高劳动者的积极性。</p>
<h2 id="42-学科记忆专题——数学2017-05-23"><a href="#42-学科记忆专题——数学2017-05-23" class="headerlink" title="42. 学科记忆专题——数学2017-05-23"></a>42. 学科记忆专题——数学2017-05-23</h2><p>今天，我就主要介绍一下我自己认为学习数学过程中最重要的几个技巧。</p>
<p>第一个技巧，是使用口诀记忆关键知识点。</p>
<p>第二个技巧，是利用函数图像理解数学公式。</p>
<p>第三个技巧，是用公式推导掌握数学公式。</p>
<p>第四个技巧，是梳理脉络，制作图表。<br><img src="http://you img base url/images/421数学.jpg?e=1585218234&token=your qiniu access key:Ez_JLJVIFLEQ0_ljOyyHiXfYPjw=" alt><br><img src="http://you img base url/images/422数学.jpg?e=1585218234&token=your qiniu access key:glzzBacaBV3AUch3foElZ2qwLAw=" alt></p>
<h2 id="43-学科记忆专题——化学2017-05-26"><a href="#43-学科记忆专题——化学2017-05-26" class="headerlink" title="43. 学科记忆专题——化学2017-05-26"></a>43. 学科记忆专题——化学2017-05-26</h2><blockquote>
<p>化学研究的是物质的组成/性质/和变化规律，相比于数学，化学的知识更直观更容易理解，但是在学习化学的过程中，需要记忆的东西会比数学公式更多，所以利用一些记忆的技巧来提高效率是十分必要的，否则对于一般人来说，记忆的负担太重。今天我们就来介绍几个适用于记忆化学知识的方法。</p>
</blockquote>
<p>第一个方法，叫做精简法。</p>
<p>化学实验中，每个实验都有很多步骤需要记忆，这些步骤需要记忆得非常准确，否则轻则实验失败，重则影响人身安全。这些实验步骤已经被标好了1234，所以自己不需要再去总结，只要把每一个步骤，能用最精炼的一个字或者几个字来表示，就大大减少了记忆量<br>以用CO还原氧化铜的实验步骤为例。<br>第一步，先通一氧化碳。<br>第二步，点燃酒精灯进行加热。<br>第三步，试验完毕后，先熄灭酒精灯。<br>第四步，等到室温时再停止通一氧化碳。<br>第五步，处理尾气，防止CO污染环境。<br>我们从每一句中，提取最能代表这一句内容的动词。最后把实验步骤变为，一通，二点，三灭，四停，五处理。<br>这样，我们只需要记住这12345，就可以轻松回忆出完整版的实验步骤。<br>第二种，叫谐音法。</p>
<p>化学元素种类繁多，如果直接记忆名字，难度会很大。在很多时候，需要利用谐音，将化学元素转化为日常生活中常见的词语进行记忆。谐音法很灵活，而且非常适合记忆化学元素。<br>比如记忆元素周期表，这是每一个中学生都经历过的，首先反复读几遍，按周期分成一句一句的，然后去联想谐音。<br>比如第四周期，钾钙镓锗砷硒溴氪，可以转化为加盖夹着（给瓶子加个盖子被夹着了）深吸休克（深吸一口气然后休克了）。<br>再比如记忆地壳中的元素，地壳中的主要元素是氧 硅 铝，按照谐音转化之后就是养闺女，这样记忆起来就更加生动，不容易忘记。</p>
<p>还有很多地方都可以用到谐音法，大家可以自行尝试一下，这是一个比较有趣而且可靠的方法。</p>
<p>第三个方法，是将第一第二种方法结合使用。</p>
<p>以化学中固体加热制氧的步骤<br>为例。一共分为7个步骤。<br>（1）检查装置的气密性；（2）将高锰酸钾装入试管中，在管口塞一团棉花并用带导管的塞子塞紧；（3）用铁架台和铁夹把盛有药品的试管固定起来；（4）给试管点火加热；（5）用排水集气法收集一瓶氧气；（6）导管移离水面；（7）用灯帽盖灭酒精灯。<br>首先将这七个步骤的每一步中提取一个字，精简之后变为 查（检查的查） 装（装入的装） 定（固定的定） 点（点火的点） 收（收集的收） 离（移动离开的离） 熄（熄灭的熄）<br>再利用谐音法，将这句话变为，茶庄定点收利息。<br>这样，记住茶庄定点收利息这句话，就可以记住固体加热制氧的七个步骤。<br>第四个方法，是利用口诀记忆。</p>
<p>在化学学习过程中，会有很多常用的口诀帮助我们记忆。</p>
<p>比如在化学中非常重要的一个知识就是化合价，在计算题中经常出现，化合价的记忆也让很多人十分头疼，在这里我们举一个例子，利用口诀来记忆常见元素的化合价。</p>
<p>一价钾钠氢与银，二价镁钙钡与锌，三价金属元素铝，157变价氯，245氮，硫46，35有磷，24碳，12铜，23铁，2467锰特别。</p>
<p>口诀记忆法的好处就是朗朗上口，容易提高记忆的兴趣，适合记忆比较枯燥的内容。<br>第五个方法，是总结规律。</p>
<p>将一些散乱的知识点进行梳理，总结，并且做好笔记，可以使得自己记忆目标明确，条理清楚，而且复习起来会很容易。</p>
<p>以元素周期表为例，通过总结元素周期表中的规律，也可以帮助我们记忆一些很重要的知识点。</p>
<p>1，最外层电子书从1递增到8<br>2，元素的金属性逐渐减弱，非金属性逐渐增强<br>3，最高氧化物对应的水化物碱性逐渐减弱，酸性逐渐增强。<br>4，元素的最高正化合价从正1增加到正7，负化合价从第四主族开始，从负4到负1.<br>5元素的原子半径逐渐缩小。</p>
<p>掌握了这五条规律之后，只要知道不同元素在元素周期表的位置，就可以直接对比他们的金属性，水化物的PH值大小，原子半径大小，或者判断化学方程式中某元素的化合价是否正确。而不需要记住这些内容。</p>
<p>所以适当总结规律也是减少记忆量的一种方法。</p>
<h2 id="47-学科记忆专题——物理2017-06-10"><a href="#47-学科记忆专题——物理2017-06-10" class="headerlink" title="47. 学科记忆专题——物理2017-06-10"></a>47. 学科记忆专题——物理2017-06-10</h2><blockquote>
<p>各位喜马拉雅的朋友们大家好，我是贾立平，今天要和大家分享的内容是，如何记忆物理知识。<br>物理学作为一门自然科学 , 发展到今天已形成了自身严密而又系统的知识结构。 物理学的最终目的是要解释整个世界，所研究的内容包含万事万物，从具体到抽象 , 从宏观到微观 , 从现象到规律 , 从理论到实践 。学好物理需要理论联系实践，注意不同情况下的变化，形成完整的知识体系。但是由于物理中需要记忆的内容很多而且有些不容易理解，运用一些记忆的技巧能帮我们提高学习的效率。我总结了一些物理学习中的记忆技巧，找了一些实例来帮助理解，接下来我们就一条一条进行讲解。</p>
</blockquote>
<p>第一个方法是谐音法，在物理学习中同样可以使用，主要可以用于记忆一些公式和数值。</p>
<p>比如初中物理中电路功率计算公式 W= UIt。通过谐音可以转化为，大不了，又挨踢。</p>
<p>有些公式很难理解或推导出来，也可以用谐音法记忆。比如高中物理中单摆运动的近似周期公式为：T=2π√(L/g)。其中，L为摆长，g为当地的重力加速度。2π谐音为“2拍”，根号谐音为“更好”，L/g谐音为“常触及”。想成为了让单摆有很好的运动周期，要两次拍动（2拍），这样能更好的常触及到它的运动周期。</p>
<p>一般超音速飞机的“超音速”指的是超出声音在1个标准大气压和15℃的空气中速度，约为340米／秒. 想到用超音速的耳光扇（3）司令（40）</p>
<p>钨的熔点是3410摄氏度，可以转化为“屋（钨）里有仨（3）死（4）尸（10）”</p>
<p>再比如三个宇宙速度</p>
<p>第一宇宙速度，7.9<br>第二宇宙速度，11.2<br>第三宇宙速度，16.7</p>
<p>可以转化为两个人的三句对话<br>吃点酒（酒鬼向店家要酒）<br>要一点儿（店家不给，酒鬼耍赖，说就要一点）<br>要留点吃（店家很无奈，说要留点自己吃）</p>
<p>第二个方法，是要点记忆法。</p>
<p>物理学习过程中，我们会遇到很多定理定律，这些定理和定律的记忆肯定让很多人都非常头疼，其原因还是在于记忆量太大。对于定理和定律的记忆，我推荐使用要点记忆法，就是抓住一个定理和定律中最关键的要点，通过要点推出其他内容，这样大大缩减了记忆量，而且对定理和定律的理解会更加透彻，因为这不是对内容本身的死记硬背，这里包括了我们在头脑中对信息的抽象和加工。</p>
<p>在加速度和质量一定的情况下，物体加速度的大小跟作用力成正比，跟物体的质量成反比，且与物体质量的倒数成正比。加速度的方向跟作用力的方向相同。牛顿第二运动定律可以用比例式来表示，即  或  ；也可以用等式来表示，即F=kma，其中k是比例系数；只有当F以牛顿、m以千克、a以m/s2为单位时，F=ma成立。</p>
<p><img src="http://you img base url/images/47物理.jpg?e=1585218234&token=your qiniu access key:xIIGt-oh_CuA7UlJ4ZQMKd54bp0=" alt><br>五个要点只有十几个字，通过这五个要点组合出的内容，会比硬记牛顿定律更灵活更省事，而且不管考题怎么变，我们都记忆掌握了这个定律的核心，绝不会出错。</p>
<p>第三个方法，是比较记忆法。比较记忆法的好处，是可以同时记忆两个或者以上的知识点，而且可以避免发生概念上的混淆，因为通过比较，我们实际记忆的关键点在于相同的地方和不同的地方，而这些地方正好又是容易出错的地方，所以这个方法对于物理概念的学习非常有用。</p>
<p>比较记忆法有两个规则，一个是异中求同，一个是同中求异。<br>有一个例子，比如对电场线和磁感线两个概念加以比较 ,其相同点: ①都是形象曲线 , 实际不存在 ;② 其曲线上的任一 点切线方向表示电场或磁场的方向 , 其疏密程度表示 电场或磁 场的大小 ; ③两 根 电场线或磁感线均不能相交 ; ④电场线 和磁 感线均可 用 实验方法模拟形状 。 其不同点 : ①电场线描述电场 , 磁感线描述磁场 ; ②电场线是一条不封闭曲线 , 而磁感线是一条封闭曲线 :</p>
<p>通过对比，我们不仅能够记住这两个概念，而且不容易混淆。</p>
<p>再比如 质量与重力：<br>①质量是指物体中所含物质的多少，重力是指物体所受地球的引力；<br>②质量只有大小没有方向，是标量，重力是既有大小又有方向的矢量；<br>③质量在哪里大小都不变，重力随位置而变化；<br>④质量用天平称，重力要用弹簧秤量；<br>⑤质量单位一般用千克表示，重力单位一般用牛顿表示。<br>通过以上两个例子我们可以看出，用比较法记忆物理知识主要是针对一些容易混淆的概念。</p>
<p>第四个方法，是口诀记忆法。关于口诀记忆法我们已经不陌生了，在数学和化学中都讲到过，物理学习中也有很多好用的口诀，可以帮助我们记忆得更加牢固，口诀记忆法的最大好处是提升学习兴趣。</p>
<p>比如凸透镜的成像规律可以用以下的口诀记忆，一旦理解透彻 ，将会事半功倍。</p>
<p>口诀是：一倍焦距分虚实，二倍焦距分大小 ；物远像近小，物近像远大；二倍焦距等倒实，焦点以内正大虚。</p>
<p>对于前两句都能够理解 ：物体与凸透镜的距离大于一倍焦距 ，成实像 ，小于一倍焦距 ，成虚像 ，等于一倍焦距，不成像 ；<br>物体与凸透镜的距离大于二倍焦距 ，成缩小的像，小于二倍 焦距 ，成放大的像。<br>最后两句也比较好理解：物体位于二倍焦距这个特殊的点时，成等大 、等距倒立的实像 ，而位于焦点以内 ，成正立放大的虚像 ，这也是放大镜的应用。</p>
<p>这个口诀的精髓在于中间两句，它有两层含义。<br>第一层含义指的是物距与相距的关 系 ：当物体在远处 (大于二倍焦距)时 ，像在近处 (一倍焦距和二倍焦距之间)，这时 候成缩小、倒立的实像，这是照相机的工作 原理 ；当物体在近处 ( 一倍焦距和二倍焦距 之间 )时 ，像在远处 ( 大于二倍焦距)，成 放大倒立的实像 ， 这是电影放映机的工作原理 。<br>这样就把凸透镜成像规律的表格包含在 了其中。</p>
<p>第二层含义是从动态的变化层面来说 的：当物体远离凸透镜时 ，像就像凸透镜靠 近 ，而且像会变小 ；当物体靠近凸透镜时，像就远离凸透镜而且越来越大 。<br>理解了这 两层含义 ，在做题的时候，无论题目里出现了远 、近 、大或者是小的字眼，都可以对应的找到相应的口诀来解题 。</p>
<p>以上例子都是帮助大家理解方法，学会之后可以应用在其他知识点上，希望能对大家有帮助。</p>
<h2 id="50-学科记忆专题——生物2017-06-21"><a href="#50-学科记忆专题——生物2017-06-21" class="headerlink" title="50. 学科记忆专题——生物2017-06-21"></a>50. 学科记忆专题——生物2017-06-21</h2><p>一、配对联想法</p>
<p>1、缺少维生素引起的疾病</p>
<p>维生素A：夜盲症</p>
<p>维生素B1：脚气病</p>
<p>维生素C：坏血病（牙龈萎缩、出血等）</p>
<p>维生素D：佝偻病</p>
<p>2、矿质元素（氮N、磷P、钾K）的作用</p>
<p>缺氮：植株矮小,叶色发黄。 </p>
<p>缺磷：植株暗绿带红。 </p>
<p>缺钾：植株长得矮小,叶片上也带了许多褐斑。</p>
<p>3、糖类中的还原糖（如葡萄糖、果糖、麦芽糖）与斐林试剂发生作用，生成砖红色沉淀。</p>
<p>脂肪可以被苏丹红Ⅲ染成橘黄色（或被苏丹红Ⅳ染液染成红色）。</p>
<p>淀粉遇碘变蓝色。</p>
<p>蛋白质与双缩脲试剂发生作用，产生紫色反应。</p>
<p>二、串联记忆法</p>
<p>1、人体常见内分泌腺：胰岛、性腺、甲状腺、肾上腺、下丘脑、垂体。</p>
<p>助记：姨姓贾，肾下垂。</p>
<p>2、植物细胞和动物细胞的区别：植物细胞比动物细胞多了细胞壁、叶绿体、液泡</p>
<p>2、植物矿质元素中的微量元素：Mo Cl B Ni Zn Fe Cu Mn</p>
<p>助记：木驴碰裂新铁桶，猛！</p>
<p>3、能吸收二氧化硫的植物：柳杉、月季、美人蕉、菊花、丁香、银杏、洋槐</p>
<p>助记：美人六月喝样坏菊花，影响健康。</p>
<p>4、科学家根据细胞内有无核膜为界限的细胞核，把细胞分为真核细胞和原核细胞两大类。 </p>
<p>原核生物：细菌（球、杆、螺旋、弧菌、乳酸菌）、衣原体、蓝藻、支原体（没有细胞壁，</p>
<p>最小的细胞生物）、放线菌、立克次氏体 </p>
<p>真核生物：植物、动物、真菌（蘑菇、酵母菌、霉菌、大型真菌） </p>
<p>病毒非真非原。</p>
<p>三、场景记忆法</p>
<p>1、食物的消化的大致过程：</p>
<p>淀粉在口腔开始消化，被消化成麦芽糖；蛋白质在胃开始消化；脂肪在小肠开始消化，这三种物质要到小肠才彻底消化完全。 </p>
<p> 2、蛋白质的功能 </p>
<ol>
<li><p>构成细胞和生物体结构的重要物质（肌肉毛发） </p>
</li>
<li><p>催化细胞内的生理生化反应） </p>
</li>
<li><p>运输载体（血红蛋白） </p>
</li>
<li><p>传递信息，调节机体的生命活动（胰岛素） </p>
</li>
<li><p>免疫功能（ 抗体）</p>
</li>
</ol>
<p>四、简化记忆法</p>
<p>显微镜使用部分</p>
<p>顺口溜： 一取二放，三安装。四转低倍，五对光。六上玻片，七下降。八升镜筒，细观赏。看完低倍，转高倍。九退整理，后归箱。 </p>
<p>1、取镜时可概括为：右握左托略偏左</p>
<p>即：右手握住镜臂，左手托住镜座，把显微镜放在实验台偏左的位置。 点评：七个字就把取镜的全部要点包括进去,记忆起来就轻松多了。 </p>
<p>2、对光时可概括为：三转三找</p>
<p>即：一转转换器，找低倍镜；二转遮光器，找大光圈；三转反光镜，找光源。  点评：四个字包括了显微镜对光中转动的部件、顺序和物镜、光圈的选择。很多同学在做实验中不知所措，无从下手。理解了这四个字的含义就能驾轻就熟了。 </p>
<p>3、观察时可概括为：放→压→降→升→调</p>
<p>即：在载物台上放上标本→用压片夹压住标本→把物镜降到最低处（侧视物镜）→缓缓上升物镜（上视目镜）→调节准焦螺旋</p>
<p>点评：五个字就把观察显微镜物像时具体步骤和注意点都表示出来，大家再也不会无所适从了。</p>
<p>4、移动标本时可概括为：偏哪往哪移</p>
<p>即：使用显微镜观察时，如果物像不在视野中央，偏什么方向就向什么方向移动标本。</p>
<p>点评：由于显微镜呈的是倒像，才会出现这个现象。这五个字，为大家在解此类题目时提供了一条安全而快速的绿色通道。</p>
<h2 id="44-综合实战案例——搞定医学知识记忆难题2017-05-31"><a href="#44-综合实战案例——搞定医学知识记忆难题2017-05-31" class="headerlink" title="44. 综合实战案例——搞定医学知识记忆难题2017-05-31"></a>44. 综合实战案例——搞定医学知识记忆难题2017-05-31</h2><p>一、串联记忆法</p>
<p>1、心经相关内容<br>功效：解决情志方面的问题，心理，思虑，神智，睡眠，感情纠葛。是调解心理，安定神智的经络。<br>极泉：腋窝中点。调节心率，治疗两肋痛。探知心血管功能的要穴，用拨动。<br>少海：肘横纹边沿处（靠里）。调解心脏，交通心肾，减缓心率降低血压。<br>灵道：腕横纹上1.5寸，贴着骨头边沿揉。防治心脏早搏，慢性心脏病，减缓心率，平静心神。<br>阴郗（xī）：腕横纹上0.5寸。防治五心烦热，小便频数。<br>神门：掌横纹凹陷处。安定心神，增强睡眠，泄心火。可增强胃动力。防止老年痴呆。治疗晕车。增强通便能力。<br>少府：手握拳小指对着的位置。主治先天性心脏病。轻揉按摩可增强心脏功能。降心火，防治暴喑，中风说不出话。<br>少冲：小指内侧指甲旁。防治急症，癫狂，昏厥。<br><img src="http://you img base url/images/44医学经脉.jpg?e=1585218234&token=your qiniu access key:Uwal87_-95AXts7CEj2pKhR6zWY=" alt><br>2、风寒感冒药方：紫苏玉屏风散</p>
<p>黄芪（qí）15克、白术15克、防风12克、生姜6克、紫苏10克。加水煎煮取汁，1日分3次服。</p>
<p>3、人体八种必须氨基酸</p>
<p>缬（xié）氨酸、异亮氨酸、苯（běn）丙氨酸、蛋氨酸、亮氨酸、色氨酸、苏氨酸、赖氨酸</p>
<p>记忆方法一：笨蛋亮亮赖在姐姐的宿舍里不走。（苯蛋亮亮赖缬苏色）</p>
<p>记忆方法二：来一些胆量去本宿舍（赖异缬蛋亮苯苏色）</p>
<p>记忆方法三：但挟一本亮色书来（蛋缬异苯亮色苏赖）</p>
<p>4、与慢性支气管炎相鉴别的疾病</p>
<p>“爱惜阔小姐”</p>
<p>“爱”——肺癌</p>
<p>“惜”——矽肺及其他尘肺</p>
<p>“阔”——支气管扩张</p>
<p>“小”——支气管哮喘</p>
<p>“姐”——肺结核</p>
<p>二、简化记忆法</p>
<p>1、眼球的结构</p>
<p>一孔（瞳孔）、二体（晶状体、玻璃体）、三层膜（外膜、中膜、内膜）</p>
<p>2、重度哮喘的处理：</p>
<p>“一补二纠氨茶碱、氧疗两素兴奋剂”</p>
<p>“一补”——补液</p>
<p>“二纠”——纠正酸中毒、纠正电解质紊乱</p>
<p>“氨茶碱”——氨茶碱静脉注射或静脉滴注</p>
<p>“氧疗”——氧疗</p>
<p>“两素”——糖皮质激素、抗生素</p>
<p>“兴奋剂”——β2受体兴奋剂雾化吸入 </p>
<p>三、化整为零记忆法</p>
<p> 如刺激神经引起肌肉收缩过程较复杂，可分解为神经冲动产生和传导，神经肌肉接头兴奋传递和骨骼肌细胞兴奋收缩耦联3个部分来记忆。</p>
<p>四、口诀记忆法</p>
<p>“如何记忆12对脑神经</p>
<p>一嗅二视三动眼，</p>
<p>四划五叉六外展，</p>
<p>七面八听九舌咽，</p>
<p>迷走及副舌下全。</p>
<h2 id="46-综合实战案例——攻克司法考试记忆难题2017-06-07"><a href="#46-综合实战案例——攻克司法考试记忆难题2017-06-07" class="headerlink" title="46. 综合实战案例——攻克司法考试记忆难题2017-06-07"></a>46. 综合实战案例——攻克司法考试记忆难题2017-06-07</h2><p>一、配对联想法</p>
<p>1、《中华人民共和国未成年人保护法》是于（C ）正式施行的。</p>
<p>A、1991年1月1曰B、1991年9月4曰</p>
<p>C、1992年1月1曰D、1999年11月1曰</p>
<p>2、《中华人民共和国义务教育法》是在（A ）颁布的。</p>
<p>A、1986年B、1978年</p>
<p>3、在刑事诉讼中，强制未被关押的犯罪嫌疑人、被告人到指定地点接受讯问的强制方法是(C )</p>
<p>  A.逮捕 B.拘留</p>
<p>  C.拘传 D.传唤</p>
<p>4、第一次规定“重罪十条”：《北齐律》    第一次规定“十恶”：《唐律疏议》</p>
<p>二、串联记忆法</p>
<p>1、应当减轻或者免除处罚的情形：防卫过当、避险过当、胁从犯</p>
<p>《刑法》第二十条第二款规定：正当防卫明显超过必要限度造成重大损害的，应当负刑事责任，但是应当减轻或者免除处罚。</p>
<p>《刑法》第二十一条第二款规定：紧急避险超过必要限度造成不应有的损害的，应当负刑事责任，但是应当减轻或者免除处罚。</p>
<p>《刑法》第二十八条规定：对于被胁迫参加犯罪的，应当按照他的犯罪情节减轻处罚或者免除处罚。</p>
<p>险、防、胁</p>
<p>2、证人应当出庭的除外规定</p>
<p>《民事诉讼法》第七十三条规定：经人民法院通知，证人应当出庭作证。有下列情形之一的，经人民法院许可，可以通过书面证言、视听传输技术或者视听资料等方式作证：</p>
<p>（一）因健康原因不能出庭的；</p>
<p>（二）因路途遥远，交通不便不能出庭的；</p>
<p>（三）因自然灾害等不可抗力不能出庭的；</p>
<p>（四）其他有正当理由不能出庭的。</p>
<p>3、简易程序的除外规定</p>
<p>《民事诉讼法司法解释》第二百五十七条规定：</p>
<p>下列案件，不适用简易程序：</p>
<p>（一）起诉时被告下落不明的；</p>
<p>（二）发回重审的；</p>
<p>（三）当事人一方人数众多的；</p>
<p>（四）适用审判监督程序的；</p>
<p>（五）涉及国家利益、社会公共利益的；</p>
<p>（六）第三人起诉请求改变或者撤销生效判决、裁定、调解书的；</p>
<p>（七）其他不宜适用简易程序的案件。</p>
<p>三、情境记忆</p>
<p>《民事诉讼法》第63条第一款规定：证据包括：</p>
<p>　　（一）当事人的陈述；</p>
<p>　　（二）书证；</p>
<p>　　（三）物证；</p>
<p>　　（四）视听资料；</p>
<p>　　（五）电子数据；</p>
<p>　　（六）证人证言；</p>
<p>　　（七）鉴定意见；</p>
<p>　　（八）勘验笔录。</p>
<p>四、口诀记忆</p>
<p>关于逮捕<br>三证三期一徒刑，一批一决一执行，通知/讯问各一日，不妥释放发证明。<br>注：“三期”：重病/怀孕/哺乳，与劳动法“三期”区分。</p>
<p>五、理解记忆</p>
<p>抢夺罪定罪量刑的标准</p>
<p>《刑法》第二百六十七条第一款规定：抢夺公私财物，数额较大的，处三年以下有期徒刑、拘役或者管制，并处或者单处罚金；数额巨大或者有其他严重情节的，处三年以上十年以下有期徒刑，并处罚金；数额特别巨大或者有其他特别严重情节的，处十年以上有期徒刑或者无期徒刑，并处罚金或者没收财产。</p>
<p>《最高人民法院、最高人民检察院关于办理抢夺刑事案件适用法律若干问题的解释》第一条规定：抢夺公私财物价值一千元至三千元以上、三万元至八万元以上、二十万元至四十万元以上的，应当分别认定为刑法第二百六十七条规定的“数额较大”“数额巨大”“数额特别巨大”。</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>其它方法和总结7篇</title>
    <url>/ins/burnedBrain/%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95%E5%92%8C%E6%80%BB%E7%BB%937%E7%AF%87/</url>
    <content><![CDATA[<h2 id="17-知识虽孤立，妙趣串联之——有效串联的三种方法"><a href="#17-知识虽孤立，妙趣串联之——有效串联的三种方法" class="headerlink" title="17. 知识虽孤立，妙趣串联之——有效串联的三种方法"></a>17. 知识虽孤立，妙趣串联之——有效串联的三种方法</h2><p>1、直接串联法<br>1）购物清单<br>牙膏、番茄、猪肉、餐巾纸、电池、水杯、洗洁精、圆珠笔、拖把、袜子、可口可乐、土豆、刮胡刀、方便面、牙签<br>2）中国十大古典悲剧<br>《窦娥冤》、《赵氏孤儿》、《精忠旗》、《清忠谱》、《桃花扇》、《汉宫秋》、《琵琶记》、《娇红记》、《长生殿》、《雷峰塔》<br>窦娥冤屈极了，心里很不服，赵氏孤儿送给她一面精忠旗，在上面写下了清忠谱，窦娥回赠他一把桃花扇，上面有汉宫秋天的美景。孤儿给她弹起了琵琶，让她撒起娇并且脸红起来，他们一起手牵手跑进了长生殿，然后爬上了雷峰塔。</p>
<p>2、抽字串联法<br>1）武侠小说作家金庸先生代表作品：《飞狐外传》、《雪山飞狐》、《连城诀》、《天龙八部》、《射雕英雄传》、《白马啸西风》、《鹿鼎记》、《笑傲江湖》、《书剑恩仇录》、《神雕侠侣》、《侠客行》、《倚天屠龙记》、《碧血剑》、《鸳鸯刀》。<br>抽字串联： “飞雪连天射白鹿，笑书神侠倚碧鸳”</p>
<p>2）清朝的皇帝（入关后）：<br>顺治、康熙、雍正、乾隆、嘉庆、道光、咸丰、同治、光绪、宣统<br>抽字串联：康雍乾   嘉道咸   同光宣（康用钱     加道咸     铜光宣）</p>
<p>3）我国的四大石窟：云冈石窟、龙门石窟、麦积山石窟和莫高窟<br>抽字串联：“云龙卖馍”<br>4）莎士比亚四大悲剧：《哈姆雷特》、《奥赛罗》、《李尔王》、《麦克白》，抽字串联：“哈罗，李白”</p>
<p>3、故事串联<br>1）记忆秦灭六国的行后顺序：韩、赵、魏、楚、燕、齐</p>
<p>2）记忆中华56民族<br>土家族(土家族)有个美丽的姑娘哈尼(哈尼族)，上完了俄文课(鄂温克族)回到蒙古包(蒙古族)里，正在榻榻耳(塔塔尔族) 上拉二胡(拉祜族)，她的老爹哈萨克(哈萨克族)冲进来对女儿说：“女儿大事不好了，阁老(仡佬族)的儿子恶人春(鄂伦春族)相中了你！要娶你呢！”<br> “就是那个每天戴着帽子是蓝色(毛南族)的独眼龙(独龙族)？女儿不依(布依族)，我跟他们拼了！”<br>“可儿克制(柯尔克孜族)吧，爹也不让(布朗族)他们碰你，一直拖着，今天时间超限了(朝鲜族)，眼看就要来抢(羌族)亲了，时间紧迫(景颇族)，你还是快逃吧！”<br>哈尼听老爹的话逃走了，激怒(基诺族)了阁老，保安(保安族)阿昌(阿昌族)狠狠地打哈萨克的耳光，哈萨克说：“为吾儿(维吾尔)打我耳(达斡尔族)我不怕，总之别想知道我女儿的动向(东乡族)！”<br>打了耳光仍然扑灭(普米族)不了怒(怒族)火，他们把老爹关进了木牢(仫佬族)。<br>哈妮大汗(汉族)淋漓地爬上高山(高山族)，山上空气稀薄(锡伯族)，她极渴(塔吉克族)，品德高昂(德昂族)的穷小子门巴(门巴族)路过看到可怜的姑娘，就舀(瑶族)了点水(水族)她，哈尼喝着(赫哲族)水醒了过来，门巴看她饿又烧螺丝(俄罗斯族)给她吃。<br>俩人赊(畲族)了点梨树(傈僳族)苗(苗族)，在土(土族)里挖(佤族)了个洞(侗族)种下去，树越长越壮(壮族)，很快就挂了果，成熟的白(白族)梨(黎族)纷纷往下落，落吧(珞巴族)落吧，落满(满族)了屋子与别克车(乌孜别克族)，他们把梨子换了满满一(彝族)袋(傣族)金(京族)子，他们从藏(藏族)身之地回(回族)到家乡，才知道阁老吃鱼骨(裕固族)卡死了，他儿子因为偷吃沙拉(撒拉族)被人拿西瓜(纳西族)砸死了。哈尼与门巴从牢里救出了老爹，从此过起了幸福的日子。 </p>
<h2 id="25-期中梳理：如何选择正确的记忆策略"><a href="#25-期中梳理：如何选择正确的记忆策略" class="headerlink" title="25. 期中梳理：如何选择正确的记忆策略"></a>25. 期中梳理：如何选择正确的记忆策略</h2><p><img src="http://you img base url/images/25记忆策略.png?e=1585218234&token=your qiniu access key:VoGeC6m3grVeb7OnptrEkYJEUJY=" alt><br>中国十大古典悲剧</p>
<p>《窦娥冤》（关汉卿）、《赵氏孤儿》（纪君祥） 、《精忠旗》（冯梦龙）、《清忠谱》（李玉）、《桃花扇》（孔尚任）、《汉宫秋》（马致远）、《琵琶记》（高则诚）、《娇红记》（孟称舜）、《长生殿》（洪升）、《雷峰塔》（方成培）<br>故事串联法:</p>
<p>窦娥冤屈极了，心里很不服，赵氏孤儿送给她一面精忠旗，在上面写下了清忠谱，窦娥回赠他一把桃花扇，上面有汉宫秋天的美景。孤儿给她弹起了琵琶，让她撒起娇并且脸红起来，他们一起手牵手跑进了长生殿，然后爬上了雷峰塔。</p>
<p>抽字串联法:</p>
<p>雷峰塔旁边的汉宫的长生殿里面窦娥正娇红着脸弹琵琶，赵氏孤儿用印着旗谱的桃花扇给她扇风。</p>
<h2 id="36-词语转换的六种方法2017-05-02"><a href="#36-词语转换的六种方法2017-05-02" class="headerlink" title="36. 词语转换的六种方法2017-05-02"></a>36. 词语转换的六种方法2017-05-02</h2><p>词语转化想象的六种方法：</p>
<p>熟词转化：《雷峰塔》作者方成培<br>望文生义：《娇红记》作者孟称舜<br>指代：沙琪玛是中国满族的一种特色糕点。<br>倒序：伊拉克首都是巴格达<br>增减字：《长生殿》作者洪升<br>谐音：“英国文学之父”是杰弗里·乔叟<br>记忆方法：叔忘带倒增鞋</p>
<p>运用：莱索托是世界上平均海拔最高的国家。<br>练习：中国十大古典喜剧<br>《救风尘》 ──元朝关汉卿<br>《西厢记》 ──元朝王实甫<br>《看钱奴》──元朝郑延玉<br>《中山狼》 ──明朝康海<br>《墙头马上》 ──元朝白朴<br>《李逵负荆》──元朝康进云<br>《幽闺记》──元朝施君美<br>《绿牡丹》 ──明朝吴炳<br>《玉簪记》 ──明朝高濂<br>《风筝误》 ──清朝李渔 </p>
<h2 id="37-解锁神技能：长篇文章和书籍记忆"><a href="#37-解锁神技能：长篇文章和书籍记忆" class="headerlink" title="37. 解锁神技能：长篇文章和书籍记忆"></a>37. 解锁神技能：长篇文章和书籍记忆</h2><p>出师表</p>
<p>先帝创业未半而中道崩殂(cú)，今天下三分，益州疲(pí)弊，此诚危急存亡之秋也。然侍卫之臣不懈(xiè)于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗(yí)德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞(sè)忠谏之路也。</p>
<p>宫中府中，俱为一体，陟(zhì )罚臧(zāng)否(pǐ)，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</p>
<p>侍中、侍郎郭攸(yōu)之、费祎(yī)、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗(wèi)陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨(bì)补阙漏，有所广益。</p>
<p>将军向宠，性行（xíng）淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行(háng )阵和睦，优劣得所。</p>
<p>亲贤臣，远小人，此先汉所以兴隆也;亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓（huán）、灵也。侍中、尚书、长(zhǎng)史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</p>
<p>臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻(wén)达于诸侯。先帝不以臣卑（bēi）鄙（bǐ），猥(wěi)自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间,尔来二十有(yòu)一年矣!</p>
<p>先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙(sù)夜忧叹，恐托付不效，以伤先帝之明，故五月渡（dù）泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶(shù)竭驽(nú)钝，攘(rǎng)除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</p>
<p>愿陛下托臣以讨贼兴复之效，不效,则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎(jiù)。陛下亦宜自谋，以咨诹(zōu)善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激!</p>
<p>今当远离，临表涕零，不知所云。</p>
<h2 id="48-如何快速记住书籍内容要点2017-06-13"><a href="#48-如何快速记住书籍内容要点2017-06-13" class="headerlink" title="48. 如何快速记住书籍内容要点2017-06-13"></a>48. 如何快速记住书籍内容要点2017-06-13</h2><p>案例一、容易记住内容的案例</p>
<p>企业战略分析方法-SWOT</p>
<p>S （strengths）是优势</p>
<p>W （weaknesses）是劣势</p>
<p>O （opportunities）是机会</p>
<p>T （threats）是威胁</p>
<p>目标管理的原则-SMART</p>
<p>S——Specific：具体,目标必须是具体的</p>
<p>M——Measurable：可测量,目标必须是可以衡量的</p>
<p>A——Attainable：可实现,目标必须是可以达到的</p>
<p>R——Relevant：相关,目标必须和其他目标具有相关性</p>
<p>T——Time-based：时效,目标必须具有明确的截止期限</p>
<p>高效能人士的七个习惯</p>
<p>习惯一：积极主动</p>
<p>习惯二：以终为始</p>
<p>习惯三：要事第一</p>
<p>习惯四：双赢思维</p>
<p>习惯五：知彼解己</p>
<p>习惯六：统合综效</p>
<p>习惯七：不断更新                 </p>
<p>案例二：如何成为一个更好的交谈者呢？Celeste Head lee用自己真实的感受声情并茂的在TED演讲中带来了十个实用的建议。</p>
<p>第一条：不要三心二意</p>
<p>第二条：不要好为人师。</p>
<p>第三条：使用开放式问题</p>
<p>第四条：顺其自然</p>
<p>第五条：如果你不知道，就说你不知道</p>
<p>第六条：不要把自己的经历和他人比较</p>
<p>第七条：别重复自己的话</p>
<p>第八条：少说废话</p>
<p>第九条：为理解而不是为了回应的认真倾听</p>
<p>第十条：简明扼要。</p>
<p>方法一：分段整理</p>
<p>听：为理解而不是为了回应的认真倾听、不要三心二意</p>
<p>说：顺其自然、使用开放式问题、简明扼要、少说废话、如果你不知道，就说你不知道</p>
<p>禁：别重复自己的话、不要把自己的经历和他人比较、不要好为人师</p>
<p>方法二：有效串联</p>
<p>喜欢三心二意和好为人师的人，自然不知道倾听他人简明扼要的问题，也总是重复废话。</p>
<p>方法三：场景记忆</p>
<p>唐僧：简明扼要、少说废话</p>
<p>孙悟空：好为人师、三心二意</p>
<p>猪八戒：和他人比较、重复自己的话</p>
<p>沙僧：不知道、开放式问题</p>
<p>白龙马：认真倾听、顺其自然</p>
<p>案例三：三十六计</p>
<p>金蝉脱壳、抛砖引玉、借刀杀人、以逸待劳、擒贼擒王、趁火打劫、关门捉贼、 浑水摸鱼、打草惊蛇、瞒天过海、反间计、笑里藏刀、顺手牵羊、调虎离山、李代桃僵、指桑骂槐、隔岸观火、树上开花、暗渡陈仓、走为上、假痴不癫、欲擒故纵、釜底抽薪、空城计、苦肉计、远交近攻、反客为主、上屋抽梯、偷梁换柱、无中生有、美人计、借尸还魂、声东击西、围魏救赵、连环计、假道伐虢。</p>
<p>方法一：分段记忆</p>
<p>胜战计</p>
<p>瞒天过海、围魏救赵、借刀杀人、以逸待劳、趁火打劫、声东击西</p>
<p>敌战计</p>
<p>无中生有、暗度陈仓、隔岸观火、笑里藏刀、李代桃僵、顺手牵羊</p>
<p>攻战计<br>打草惊蛇、借尸还魂、调虎离山、欲擒姑纵、抛砖引玉、擒贼擒王</p>
<p>混战计</p>
<p>釜底抽薪、混水摸鱼、金蝉脱壳、关门捉贼、远交近攻、假道伐虢<br>并战计</p>
<p>偷梁换柱、指桑骂槐、假痴不癫、上屋抽梯、树上开花、反客为主</p>
<p>败战计</p>
<p>美人计、空城计、反间计、苦肉计、连环计、走为上</p>
<p>方法二：串联记忆</p>
<p>金玉檀公策，借以擒劫贼，鱼蛇海间笑，羊虎桃桑隔，树暗走痴故，釜空苦远客，屋梁有美尸，击魏连伐虢。</p>
<h2 id="51-综合实战案例——图形记忆的技巧2017-06-25"><a href="#51-综合实战案例——图形记忆的技巧2017-06-25" class="headerlink" title="51. 综合实战案例——图形记忆的技巧2017-06-25"></a>51. 综合实战案例——图形记忆的技巧2017-06-25</h2><p>如何有效的记忆图形</p>
<p>记忆包括识记、保持、再认或提取三个过程。如果想要好的识记效果，需要你找到要记忆信息的特点并在大脑中留下深刻的印象，所以好的观察和想象能力极其重要。今天讲图形记忆问题，也算是回到课程的原点来验证大家对高效记忆方法的掌握程度。今天将通过地图、二维码和人脸三个素材来进行讲解。<br>无论是哪类图形，既可以从整体来观察，也可以通过局部来观察，最终以是否便于想象和记忆来选择使用的观察的角度。比如“内蒙古”的地图，从整体上观察，看起来像一只“牧羊犬”，想到内蒙古的羊特别多，需要很多牧羊犬。所以一看到“牧羊犬”形的地图，就知道是“内蒙古”的地图。<br><img src="http://you img base url/images/511图形记忆.png?e=1585218234&token=your qiniu access key:pWqcWpLu3xP7_nRHMPYJDcNyURs=" alt><br>河北省的地图整体上进行观察更合适，看起来像“手套”、“钩子”、“问号”、“张开的嘴”。但从便于联想的角度，想象为“张开的嘴”是更好的。因为“河北”可以想成“喝西北风”，这样就容易和这个形状联系在一起了。<br><img src="http://you img base url/images/512图形记忆.png?e=1585218234&token=your qiniu access key:tpgXwo9gx4SPyvWad-ZbrTvE4iE=" alt><br>关于安徽省的地图，从整体上可以想成一个暗色的徽章，也可以从局部上出发，观察右边突出的一小块，想到安徽黄山上的迎客松，这样也很容易对应起来。<br><img src="http://you img base url/images/513图形记忆.png?e=1585218234&token=your qiniu access key:L8nkLA7be6xP4GWJbJnPci0fpOs=" alt></p>
<p>在电视节目中，有非常多难以理解的图形记忆项目，比如说记忆二位码。你用手机扫描时，能够显示对应的内容为“狗”、“鹅”、“老虎”。因为二维码的内部形状比较分散，整理观察比较困难，所以选择局部观察想象是比较合适的方式。在这里我们选择观察最左下角的位置。<br>第一个左下角局部看起来像一个坐着的狗，所以很容易记住这个对应的内容是狗。<br><img src="http://you img base url/images/514图形记忆.png?e=1585218234&token=your qiniu access key:fvTtwPOWWOcrC1YC5ZuiRC-Ofdw=" alt><br>第二个左下角是三个分散层叠的黑条。因为对应的内容是鹅，可以想到鹅长长的脖子。<br><img src="http://you img base url/images/515图形记忆.png?e=1585218234&token=your qiniu access key:AkZFusTK_k4mkQIb8el5EmB-qa0=" alt><br>第三个左下角看起来像一段木桩，因为对应的内容是老虎，可以想成老虎绑在木桩上。<br><img src="http://you img base url/images/516图形记忆.png?e=1585218234&token=your qiniu access key:LBiG8tXXvQagXGTesfwi82j-1LY=" alt></p>
<p>上面举地图和二维码的例子是为了让大家理解如何选择合适的观察的角度，及如何进行有效的想象。接下来讲一个生活中的例子，如何记住人名。<br>对很多人来说，要记住认识不久的人简直是生活中最困扰的记忆难题，特别是你刚到陌生的工作环境，同事和领导的名字跟脸都对不上号，尤其尴尬。<br>我们要记住一个人，关键便是用心观察，先辨识对方的脸孔特征，再透过谈话了解对方信息，从“名字+外貌+个人特性”等方面进行联想，就能牢牢记住他了。</p>
<p>1、记住对方的名字<br>记住人脸与名字的第一法则，就是“立即将对方的名字与脸孔反复输入大脑”。在社交场合中，互换名片后，多半会展开简短交流，这时就是记忆人名的关键时刻。<br>1）认真倾听对方的自我介绍；<br>假如没听清楚名字，只要说“对不起，我没听清楚你的名字”：如果对方的名字很特别，可以进一步询问“可否请教你的名字怎么写？”<br>2）大声重复对方的名字；<br> “哦，李威先生，你好，很高兴认识你！”通过“听到”“反应”“大声念出”这三个步骤，对方的名字已经在你脑海里形成了初步印象。<br>3）将对方的名字变得有意义；<br>思考你是否恰好有跟对方同名的朋友，或者有没有明星跟他的名字比较相似；<br>也可以通过望文生义、指代、倒序、增减字、谐音等方式将一些复杂的名字进行转换，变得容易记忆。<br>4）交谈的过程与结尾，提及这个名字。<br> “李威，当你说……”“李威，我以后该怎么联络你？”将对方的名字嵌入对话时的常用语中，可帮助自己记忆更深。此外，将对方姓名作为对话结尾，也可让对方对自己留下好印象，为整场交谈留下完美句点。比如“很高兴今天和你交流，李威。”<br>2、观察对方脸部特征<br>很多人都觉得自己脸盲，明明见过对方几次可是仍旧名字跟脸对不上号，有没有什么办法可以让我们快速记住人脸？<br>其实是有的，但首先你需要做一个善于观察的人。你在观察别人脸部的时候，首先要着重观察对方眼睛和口鼻的T字部位，因为人脑设定就是以这部分来辨识别人的，不要依靠对方的穿戴和发型来区别 ，毕竟很多人换了个发型你就认不出的情况是不是也常发生？<br>在进行面部特点辨别时，既要关注整理特征和感觉，也要注意细节，必要时把局部特征进行夸张。比如说鼻梁特别高、嘴唇很厚，眼睛特别大或者小、下巴上有颗痣等等。</p>
<p>3、掌握对方其它特征<br>外向的人往往比较容易让人记住，是因为他们会不断对外提供自身资讯，不知不觉就让人对他们的姓名、个性、表情、穿搭、体型特点、说话方式和语调等都有了印象。<br>如果你遇到的人没有这么外向，你想记住他就必须主动提问，让对方说出自己的职业、喜好等，最后，将所有资讯与对方说话方式和外貌联结起来，甚至私下帮对方取个绰号。当你掌握这些信息，对方就会从名字变成一个具有特征的完整个体。</p>
<p>4、对着名片回忆对方名字与脸孔<br>会面结束后，我们还可以将名片拿出来整理，将重要资讯记录在名片上，例如长相特征、说话内容、整体印象等，帮助日后回想。一般来说，在见面后的一天内和一周内进行回想是效率最高的。</p>
<h2 id="52-超级记忆力的进阶与提升2017-06-27"><a href="#52-超级记忆力的进阶与提升2017-06-27" class="headerlink" title="52. 超级记忆力的进阶与提升2017-06-27"></a>52. 超级记忆力的进阶与提升2017-06-27</h2><p>超级记忆力的进阶与提升</p>
<p>方法掌握：体系性</p>
<p>方法选择：灵活性</p>
<p>知识观察：全面性</p>
<p>知识想象：丰富性</p>
<p>记忆过程：快速性</p>
<p>记忆保持：持久性</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>地感官规分配5篇</title>
    <url>/ins/burnedBrain/%E5%9C%B0%E6%84%9F%E5%AE%98%E8%A7%84%E5%88%86%E9%85%8D5%E7%AF%87/</url>
    <content><![CDATA[<h2 id="2-揭秘“身体定桩记忆法”，实战记忆中华56民族2016-12-29"><a href="#2-揭秘“身体定桩记忆法”，实战记忆中华56民族2016-12-29" class="headerlink" title="2. 揭秘“身体定桩记忆法”，实战记忆中华56民族2016-12-29"></a>2. 揭秘“身体定桩记忆法”，实战记忆中华56民族2016-12-29</h2><p>1.头发<br>白族    蒙古族（蒙古包）  仫Mù佬lǎo族（木脑）   满族    汉族  </p>
<p>2.眼睛<br>独龙族（独眼龙）  怒族  </p>
<p>3.耳朵<br>哈尼族（honey）  维吾尔族（围我耳）  达斡尔族（打我耳）    柯尔克孜族 （可我克制）</p>
<p>4.鼻子<br>藏族   土族   土家族  瑶族（窑）</p>
<p>5.嘴巴<br>阿昌族（啊，唱）  哈萨克族（哈哈，萨克斯）    布朗族（不朗诵）  鄂温克族（俄文课）  赫哲族（喝着）  水族</p>
<p>6.脖子<br>德昂族（得到昂贵）   锡伯族（稀薄）  京族（金）        </p>
<p>7.肩膀<br>仡gē佬lǎo族（搁着老式）  朝鲜族（朝鲜族或潮湿鲜艳） 布依族 （布衣）      </p>
<p>8.手肘<br>彝族（一）   傣族（袋）   裕yù固族 （鱼骨） 撒拉族（撒啦）</p>
<p>9.手掌<br>纳西族（拿西瓜） 黎族（梨） 门族  东乡族（咚咚响）  拉祜族（拉二胡）</p>
<p>10.肚子<br>俄罗斯族（饿咯，死）   羌族（抢）  普米族（普通米）</p>
<p>11.屁股<br>塔塔尔族（榻榻米）  珞luò巴族（摞吧）   乌孜别克族（屋子别克）  景颇族（景象颇为） </p>
<p>12.膝盖<br>基诺族（诺基亚）     侗族（洞）   塔吉克族（他即刻）  佤wǎ族（哇）</p>
<p>13.小腿<br>壮族  毛南族（毛难看）    保安族   畲shē 族（ 折 shé）</p>
<p>14.双脚<br>回族   高山族  傈lì 僳sù族（梨树）  苗族   鄂伦春（鳄鱼轮流春天活动）</p>
<h2 id="3-记忆的决定因素和类型：通过多感官达成记忆2017-01-05"><a href="#3-记忆的决定因素和类型：通过多感官达成记忆2017-01-05" class="headerlink" title="3. 记忆的决定因素和类型：通过多感官达成记忆2017-01-05"></a>3. 记忆的决定因素和类型：通过多感官达成记忆2017-01-05</h2><p>你还在我身旁</p>
<p>瀑布的水逆流而上，<br>蒲公英种子从远处飘回，聚成伞的模样，<br>太阳从西边升起，落向东方。<br>子弹退回枪膛，<br>运动员回到起跑线上，<br>我交回录取通知书，忘了十年寒窗。<br>厨房里飘来饭菜的香，<br>你把我的卷子签好名字，<br>关掉电视，帮我把书包背上。<br>你还在我身旁</p>
<p><img src="http://you img base url/images/3你还在我身旁.jpg?e=1585218234&token=your qiniu access key:nbUD2Fcr5QhZS0dwln4ym___aLo=" alt></p>
<h2 id="4-记忆的四大规律：跳开那些记忆的“雷区”2017-01-10"><a href="#4-记忆的四大规律：跳开那些记忆的“雷区”2017-01-10" class="headerlink" title="4. 记忆的四大规律：跳开那些记忆的“雷区”2017-01-10"></a>4. 记忆的四大规律：跳开那些记忆的“雷区”2017-01-10</h2><p>有关记忆的四个规律<br>1、魔力之七；<br>2、前后干扰；<br>3、左右脑协同；<br>4、艾宾浩斯遗忘记忆规律。</p>
<p>杭州西湖老十景<br>三潭印月 柳浪闻莺 雷锋夕照 南屏晚钟 花港观鱼<br>苏堤春晓 断桥残雪 平湖秋月 曲院风荷 双峰插云</p>
<h2 id="5-记忆知识的分类：找到最适合的记忆方法2017-01-13"><a href="#5-记忆知识的分类：找到最适合的记忆方法2017-01-13" class="headerlink" title="5. 记忆知识的分类：找到最适合的记忆方法2017-01-13"></a>5. 记忆知识的分类：找到最适合的记忆方法2017-01-13</h2><p>一、课前作业讲解<br>举例：身体定桩法<br>头发：芭蕉罗汉<br>眼睛：长眉罗汉，看门罗汉<br>耳朵：挖耳罗汉<br>鼻子：骑象罗汉<br>嘴巴：笑狮罗汉，开心罗汉，欢喜罗汉<br>脖子：沉思罗汉<br>肩膀：降龙罗汉，伏虎罗汉<br>手肘：布袋罗汉<br>手掌：探手罗汉，举钵罗汉，托塔罗汉<br>肚子：过江罗汉<br>屁股：静坐罗汉，坐鹿罗汉<br>二、课中内容要点<br>1、没有最优的方式，只有最合适的方法</p>
<p>2、一天中需要记忆的内容举例：<br>出门：必带物品<br>坐车：记住站点名字和换乘站、记忆英语单词<br>办公室：记日程表、客户名字和长相、工作中的知识（法律、金融、会计等）<br>下班：记车牌号、吃饭地点相关信息、学习</p>
<p>3、需记忆知识分类<br>单一的知识；一对一知识；少量或中等知识；大量知识。</p>
<p>课程附件：<br>双龙站、南联站、龙城广场站、吉祥站、爱联站、大运站、荷坳站、永湖站、横岗站、塘坑站、六约站、丹竹头站、大芬站、木棉湾站、布吉站、草埔站、水贝站、田贝站、翠竹站、晒布站、老街站、红岭站、通新岭站、华新站、莲花村站、少年宫站、福田站、购物公园站、石厦站、益田站。</p>
<p>课后作业：<br>1、分析生活学习中遇到的记忆问题类型；<br>2、提出一些典型问题并思考解决方案，欢迎留言交流。</p>
<h2 id="6-配对联想法：攻克一一对应记忆难题2017-01-17"><a href="#6-配对联想法：攻克一一对应记忆难题2017-01-17" class="headerlink" title="6. 配对联想法：攻克一一对应记忆难题2017-01-17"></a>6. 配对联想法：攻克一一对应记忆难题2017-01-17</h2><p>课中内容要点<br>配对联想的步骤：<br>1、通过谐音、意义、换位等方式找到两边信息的特点；<br>2、建立转换后两边信息直接的联系；<br>3、对照还原。</p>
<p>课程附件：</p>
<p>国家首都<br>韩国——首尔<br>菲律宾——马尼拉<br>柬埔寨——金边<br>缅甸——内比都<br>尼泊尔——加德满都<br>伊拉克——巴格达</p>
<p>十大圣人<br>医圣——张仲景<br>棋圣——黄龙士<br>茶圣——陆羽<br>酒圣——杜康 </p>
<p>课后作业<br>使用配对联想法完成一些你生活学习中难以记住的一对一信息，并总结你的心得和困惑,欢迎在评论里留言。</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>单词宝典7篇</title>
    <url>/ins/burnedBrain/%E5%8D%95%E8%AF%8D%E5%AE%9D%E5%85%B87%E7%AF%87/</url>
    <content><![CDATA[<h2 id="7-单词宝典：记忆英语单词的十种方法2017-01-20"><a href="#7-单词宝典：记忆英语单词的十种方法2017-01-20" class="headerlink" title="7. 单词宝典：记忆英语单词的十种方法2017-01-20"></a>7. 单词宝典：记忆英语单词的十种方法2017-01-20</h2><p><img src="http://you img base url/images/07记忆英语单词的十种方法.jpg?e=1585218234&token=your qiniu access key:2aDiYJFl_77uAIwBcZVAi_Z5o18=" alt><br>课程内容重点：<br>1、不同英语单词记忆方法对比；<br>2、英语单词记忆三步骤【观察拼写特点和中文意思、确定记忆方法、对照还原】；<br>3、英语单词记忆方法【谐音法、拼音法、形似比较法、换位法、词中词法、熟词+熟词法、熟词+字母法、词根词缀法、字母编码法、综合法】</p>
<p>课后作业：<br>梳理十种单词记忆方法，并结合实际进行应用，总结应用中出现的问题。</p>
<p>附件（感谢烧脑四群Lee的分享）：<br>英语常用词根词缀表：<a href="http://pan.baidu.com/share/link?shareid=3586152108&amp;uk=2888042901" target="_blank" rel="noopener">http://pan.baidu.com/share/link?shareid=3586152108&amp;uk=2888042901</a></p>
<h2 id="8-单词宝典：申一帆的单词记忆秘笈——字母编码法2017-01-24"><a href="#8-单词宝典：申一帆的单词记忆秘笈——字母编码法2017-01-24" class="headerlink" title="8. 单词宝典：申一帆的单词记忆秘笈——字母编码法2017-01-24"></a>8. 单词宝典：申一帆的单词记忆秘笈——字母编码法2017-01-24</h2><p><img src="http://you img base url/&#39;images/08字母编码法.jpg&#39;?e=1585218234&token=your qiniu access key:qCtAqAFlHNL6YYJEaWqCVZJ5OV8=" alt><br>字母编码：<br>A：苹果  ；B：一支笔或者小男孩boy  ；C：月亮或者镰刀  ；D：笛子或者弟弟或者狗dog  ；E：大白鹅  ；F：斧头  ；G：鸽子或者哥哥  ；H：椅子  ；I：蜡烛  ；J：鱼钩  ；K：机关枪  ；L：木棍  ；M：汉堡薯条或者是拱桥  ；N：一扇门  ；O：鸡蛋  ；P：一面旗子  ；Q：企鹅  ；R：小草  ；S：蛇或者美女  ；T：伞  ；U：烧杯或者U型磁铁字  ；V：镊子  ；W：王冠或者水波  ；X：剪刀  ；Y：弹弓或者树杈  ；Z：闪电</p>
<p>中小学单词：<br>1）cage n.鸟笼；c 月亮+ age 年龄；月亮c上挂着一个上了年龄age的鸟笼cage；<br>2）hear  v.听；h + ear  耳朵；坐在凳子h上，耳朵ear听东西；<br>3）pear  n.梨子；p + ear  耳朵；听说旗子p上画了个例子pear；<br>4）fear   v.害怕  f斧头+ ear 耳朵；斧头f把耳朵ear砍下来了，令人害怕fear了；<br>5）heat   n.热度　　h椅子＋eat 吃；在椅子h上吃eat加热heat的食物；<br>6）beat   v.打败；b  不 + eat 吃，整天想着赢，不b吃饭eat也要打败他；<br>7）tent   n. 帐篷ten十 + t伞；十ten把伞t撑成了一个帐篷tent；<br>8）weight    n.重量  w王冠+ eight 八；王冠w重量weight是八eight克；<br>9）train    n.火车 v.训练    t伞 + rain 下雨；下雨rain了，在火车上打伞t；train还有训练的意思；我们可以想象在火车train上训练train；<br>10）brain n.大脑   b不 + rain 下雨；下雨rain不b带伞，真是没脑袋brain，brain 大脑；</p>
<p>四六级单词：<br>1）coil  n.线圈 c 月亮 + oil 油；月亮c上绕了几圈线圈coil，流了好多油；<br>2）sway  v.摇摆；s 蛇+ way 道路；一条蛇s在道路way上摇摆；<br>3）cleft  n.裂缝；c月亮 + left 左边的；月亮c的左边left有一条裂缝cleft；<br>4）bright  adj.明亮的；b 笔 + right 右边的；笔b的右边right很明亮bright；<br>5）shed  n.小屋；  she她 + d 的；她she的d小屋shed；<br>6）scar   n.伤疤；  s美女+ car 小汽车；美女s被小汽车car撞了，留下了一道伤疤scar；<br>7）spear  n.长矛；s 美女 + pear 梨子；美女s拿着长矛spear去戳梨pear；<br>8）spark  n.火花；s 美女 + park 公园；与美女s 在公园park擦出spark火花；<br>9）stake n.桩； s美女 + take 拿走；美女s拿走take了桩stake子；<br>10）lever  n.杠杆  l木棍 + ever 曾经；这根木棍l曾经ever当过杠杆lever用；</p>
<p>出国单词：<br>1）liver  n.肝脏；live + r；肝脏上面居住live着一颗小草r；<br>2）stony adj.冷酷无情的；  s死 + tony 托尼；该死s的tony，太冷酷无情了；<br>3）clay  n.粘土；c 月亮+ lay 躺；月亮躺在粘土上；<br>4）treason  n.谋反；叛国；  t踢 + reason 原因；踢t他的原因reason是他谋反叛国；<br>5）plush  adj.豪华的；   plus加 + h 椅子；又是iPhone 6 plus又是黄金做的椅子h，真是豪华！Plush还有长毛毯的意思，就想象这把黄金椅子上披着一条长毛毯！<br>6）stray  v.走失；s 美女 + tray 盘子；美女s找盘子tray的时候走失stray了；<br>7）strap  n.带子；v.捆扎；s美女 + trap 陷阱；美女s掉到陷阱trap里了，用袋子strap捆扎strap；<br>8）dwell  v.居住   d弟弟 + well 好；弟弟d居住dwell地很好well；<br>9）scent  v.闻到；n.香味；  s美女 + cent 美分；美女s 闻到scent一美分cent的硬币上有香味scent；<br>10）scrape  v.刮；擦；  scrap废屑 + e 鹅；废屑scrap堆在e身上，需要刮一刮scrape</p>
<h2 id="9-单词宝典：字母组合编码法——想象力比知识更重要2017-01-27"><a href="#9-单词宝典：字母组合编码法——想象力比知识更重要2017-01-27" class="headerlink" title="9. 单词宝典：字母组合编码法——想象力比知识更重要2017-01-27"></a>9. 单词宝典：字母组合编码法——想象力比知识更重要2017-01-27</h2><p><img src="http://you img base url/images/09字母组合编码法.jpg?e=1585218234&token=your qiniu access key:E3I49tHOGmMAMg5zPpa3dkb8drM=" alt><br>中小学单词：<br>1.ant  n.蚂蚁； an 一个；t 伞；有一只蚂蚁打着一把伞；ant 蚂蚁 （an 元音）<br>2.ache  n/v 疼痛；  a 一个 + che 车；一辆车撞上来了，撞的好痛啊！ ache 疼痛；<br>3.busy   a.忙碌的；  bus 公共汽车 + y 发音，歪；公共汽车上的人都忙歪了，非常忙；busy 忙碌的；<br>4.hippo  n.河马  hi 嗨 + pp 屁屁 + o 圆；hi，河马的屁屁好圆；hippo 河马；<br>5.seal   n.海豹  sea 海 + l 木棍；海豹嘴里咬着一根木棍在海里游来游去；（我们也可以想象海豹的胡须像木棍）； seal 海豹；<br>6.inch    n.少量；v.缓慢移动； in 在···里面 + ch 彩虹； 在彩虹里面一点点移动，一次移动少量距离； inch v.缓慢移动；n.少量；<br>7.beach  n.海滩；  b 男孩 + each 每个； 放学了每个小男孩都去海滩玩；beach 海滩；<br>8.peach  n.桃子    p 旗子 + each 每个； 每个旗子代表的队伍都可以人手发一个桃子 peach 桃子；<br>9.chant   n.圣歌（sheng）； ch 彩虹 + ant 蚂蚁；彩虹上有只蚂蚁在唱圣歌；chant 圣歌；<br>10.scorpion n.蝎子；  scor 分数 + pi 屁 + on 在···上面；我们可以想到一个场景，老师说，你看看试卷上的这屁大点分数，再考不好就用蝎子哲你，你怕不怕；scorpion 蝎子；</p>
<p>四六级单词：<br>1.coma    n.昏迷；  com 来 + a 苹果；来了一个苹果，把我砸晕砸昏迷了；coma 昏迷；<br>2.combat  v.战斗    com 来 + bat 蝙蝠； 来了一个蝙蝠，同他战斗；combat 战斗；<br>3.cord    n.绳索；v.用绳索捆绑；  cor 果核 + d 笛子； 有个果核被绳索捆绑在笛子上了；<br>4.cork    n.软木塞；v.用软木塞塞；  cor 果核 + k 机关枪；有个果核突然变成了软木塞，塞住了机关枪； cork 软木塞；用软木塞塞；<br>5.hatch   v.孵化    hat 帽子 + ch 彩虹；帽子上面孵化出了一条彩虹；hatch 孵化；<br>6.overt   a.明显的；公开的；  over 在···上面 + t 伞；就在那把伞上面，很明显，然后想象伞打开，公开的。 overt 明显的；公开的；<br>7.compose   v.镇定； com 来 + pose 姿势；来来来，摆个pose，镇定一下；compose 镇定；<br>8.fatigue   n.疲劳   fa 爸爸 + ti 提 + gue 鼓鹅；爸爸提着好多胖胖的鼓鹅，很疲惫；fatigue 疲劳；（发音 fe 而不是fa）<br>9.brow    n.眉毛；  bro 兄弟 + 字母 w；好囧啊，这兄弟的眉毛都长成字母w的形状啦； brow 眉毛<br>10.scorn  v.鄙视   scor 分数 + n 门；老师一脸鄙视，说，下次再考这点分数，就别进门了；scorn 鄙视；</p>
<p>出国单词：<br>1.abiding  a.永久的；   a 一个 + bid 【bɪd】 投标 + ing 一直；一个人在投标，一直在投标；abiding 永久的；</p>
<ol start="2">
<li>exotic  a.外来的、异国的；吸引人的；   exo 很有名的组合名 + tic 体操；想象exo居然在做体操，太吸引人了，这个团队不会是外国版exo吧；外来的；exotic 外来的、异国的；吸引人的；<br>3.antibiotic   n.抗生素；抗菌素；a.抗菌的；   anti 反 + bio 生物 + tic 体操；体操运动员比赛的时候不能吃抗生素；antibiotic 抗生素；抗菌的；  其中tic 也是名词、动词后缀<br>4.intact  a.完好无损的；  in 在···里面 + tact 接触；保存在里面，不让任何人接触，就是完好无损的。  intact  完好无损的；<br>5.gallant [ˈgælənt]  a.勇敢的；   ga 鸭子 + ll 高跷 + ant 蚂蚁；鸭子踩着高跷和蚂蚁战斗，我们可以想象蚂蚁非常大，蚂蚁怪兽，所以鸭子踩高跷去战斗非常勇敢；gallant 勇敢的（联想中的逻辑与非逻辑）<br>6.trench   n.沟渠  tr 铁人 + en 摁 + ch 彩虹；铁人摁了一下按钮，便有一道彩虹出现在沟渠上；trench 沟渠；<br>7.fortnight  n.十四天，两个星期；  for 为了 + t 伞 + night 晚上；为了买到那把伞，他居然连晚上都在排队等啊等，等了两个星期；fort–fourteen，十四，十四个晚上就是十四天，两个星期；fortnight 十四天，两个星期；<br>8.brogue  n.土音，土腔；  bro 兄弟 + gue 鼓鹅；兄弟说话嘴巴跟个鼓鹅一样，老是鼓着，发音真是土；brogue n.土音，土腔； （发音 brou，而不是 bro）<br>9.peep  v.偷窥    pp 屁屁，ee 一双眼睛； 屁屁中间有双眼睛，当然是偷窥咯； peep 偷窥；<br>10.exuberant  a.兴高采烈的；充满生气的；   ex 前任 + uber 优步 + ant 蚂蚁；前任坐uber的时候发现一只兴高采烈的蚂蚁在车窗上向她打招呼，很有活力；exuberant 兴高采烈的；充满生气的；</li>
</ol>
<p><img src="http://you img base url/images/09艾宾浩斯遗忘曲线.jpg?e=1585218234&token=your qiniu access key:g55vqjG3Oo_9JIsBUIe-QisuyYY=" alt></p>
<h2 id="10-单词宝典：记忆单词的“野路子”——谐音法-拼音法2017-01-31"><a href="#10-单词宝典：记忆单词的“野路子”——谐音法-拼音法2017-01-31" class="headerlink" title="10. 单词宝典：记忆单词的“野路子”——谐音法+拼音法2017-01-31"></a>10. 单词宝典：记忆单词的“野路子”——谐音法+拼音法2017-01-31</h2><p><img src="http://you img base url/images/10谐音法+拼音法.jpg?e=1585218234&token=your qiniu access key:f7PLmqVgWETN0dEWfyt_KM935xU=" alt><br>中小学单词：</p>
<p>谐音法：<br>1.issue  n.问题；（杂志、报刊的）一期；v.发行  谐音“一休”；想象聪明的一休很会解决问题，发行了一期杂志专门描述他解决问题的方法； issue 问题；发行；杂志、报刊的一期；<br>2.title  n.标题；   谐音“抬头”；想象抬头一看，就看到大标题了； title n.标题<br>3.lung  n.肺；     谐音“狼”；联想到狼心狗肺，lung 肺<br>4.mud  n.泥；烂泥；   谐音“妈的”，想象教练批评学员，说了一句，妈的，烂泥扶不上墙；（现实生活中可不要骂人哦）mud 泥；烂泥；（强化 是u不是a）<br>5.bud  n.芽；v.发芽；   谐音“爸的”；刚刚有个妈的；现在有个爸的，想象烂泥上居然长出了芽；bud 芽；发芽； （强化 是u不是a）</p>
<p>拼音法：<br>1.yeti  n.雪人；   拼音“液体”；想象雪人融化了，流了好多液体出来。  yeti 雪人；<br>2.data  n.数据；   拼音“打他”，他居然抢走了我的数据线，我要打他。  data 数据；<br>3.dawn  n.黎明；破晓；  拼音“da–大；wn–蜗牛”；每到黎明、破晓的时候，这只大蜗牛就是早起觅食；  dawn  n.黎明；破晓；<br>4.damage  v.破坏；损坏    拼音“dama–大妈；ge—歌”；大妈唱歌很难听，破坏力很强；damage 损坏，破坏；<br>5.language  n.语言   拼音，烂瓜哥，“langua—烂瓜；ge—哥”；想象有个卖烂瓜的小哥，各种语言都说的很6。 language n.语言</p>
<p>大学四六级单词：</p>
<p>谐音法：<br>1.confess  v.坦白；忏悔 谐音“肯反思”；他坦白自己的错误，肯反思，肯忏悔。 confess 坦白，忏悔；<br>2.fantasy  n.想象，幻想；谐音“范特西”，周杰伦有个专辑，“依然范特西”，它的形容词fantastic 极好的；可以想象周杰伦的专辑极好的；fantasy 想象；fantastic 极好的（郎朗上口  加入情感，一听到或者一读到这个单词，就有一种极好的感觉；类似的单词还有 excellent、fabulous ）<br>3.marsh  n.沼泽   谐音“妈洗”，妈妈在洗东西；想象妈妈在沼泽旁边洗衣服，好危险是不是。 marsh 沼泽。<br>4.mark  v.做记号；n.污点； 谐音“马克”，大家可以想象做记号用的马克笔，马克笔做记号的时候弄出了污点；  mark  做记号；污点；<br>5.jar  n.广口瓶；罐子   谐音 “驾儿”，想象骑着一匹马，在广口瓶或者罐子里面喊着，驾，驾，驾儿；  jar 广口瓶；罐子   </p>
<p>拼音法：<br>1.lad  n.小伙子   拼音“辣的”；这个小伙子喜欢吃辣的东西，想象他是湖南或者四川人，脖子上还挂着一圈辣椒。  lad 小伙子  （注意发音，英美）<br>2.sheer  a.十足的；陡峭的； she 她  er 拼音“儿”，她儿子是个十足的笨蛋，那么陡峭的山说爬就爬，也不顾危险。  sheer  十足的；陡峭的；<br>3.fade  v.褪色    fa 头发；de 的； 可以想象头发褪色的； fade 褪色  （强化一下，发音 ei 而不是a）<br>4.limit  n.极限；   拼音：limi 厘米； t 伞；只有一厘米长的小伞，小到极限了，不能再短于一厘米了；  limit  极限；<br>5.waist  n.腰；腰部     拼音 wai 外，st 石头；他腰的外面挂着一块石头； waist 腰；腰部；</p>
<p>出国单词：</p>
<p>谐音法：<br>1.hermit  n.隐士；小甜饼；   谐音“何觅他”，到哪里去找他呢？隐士躲在深山老林里，哪里找得到呢？hermit 隐士；隐士躲着干嘛，吃他喜欢吃的小甜饼；hermit 隐士；小甜饼。<br>2.drizzle  n.毛毛雨；v.下毛毛雨   谐音“追着我”；天空下毛毛雨，追着我。  drizzle  毛毛雨； 下毛毛雨<br>3.mordant  a.有腐蚀性的；尖酸的，讽刺的； 谐音“莫等它”；莫，不要，不要等它的意思；想象不要一瓶有腐蚀性的硫酸泼了，赶紧处理，不要等它腐蚀了桌子。mordant 有腐蚀性的；尖酸的；  （acid 酸；尖酸的讽刺的；caustic 腐蚀性的 ；尖酸讽刺的；可以想象尖酸刻薄的话就像硫酸一样有腐蚀性）<br>4。mantle  n.披风；外层  谐音“馒头”，想象馒头的外层披着一个披风，白馒头，黑披风，相当帅气。  mantle  外层，披风； （两个小技巧：1.根据发音恢复字母拼写；tle 头；2.根据出图容易程度，调换单词意思的顺序 外层有个披风 外层、披风）<br>5.mansion  n.大厦   谐音“门神”，想象大厦大门口站着一个门神；  mansion 大厦；</p>
<p>拼音法：<br>1.wan  a.苍白的；虚弱的    拼音“碗”；他被从天而降的一个大碗砸中脑袋，现在脸色苍白，非常虚弱；  wan 苍白的；虚弱的；<br>2.bandit n.强盗   ban 搬 dit 地铁； 想象强盗把抢来的赃物都搬到地铁上了。  bandit 强盗<br>3.obscure  a.令人费解的；v.使难以理解；  拼音 ob–欧巴；s–美女；cure–治疗； 欧巴看到一个美女中了一种奇怪的毒，就去治疗她；嘴里说着，怎么会中这种毒呢，太令人费解了。  obscure 费解的；使难以理解；<br>4.sanguine  a.乐观的；充满自信的；  拼音：三鬼呢，san–三 gui–鬼 ne–呢；想象一个人乐观自信的说，刚刚的三个小鬼呢，都被我打跑了。 sanguine a.乐观的；充满自信的；<br>5.luxurious  a.豪华的；奢华的；  luxu–鲁迅；rious–Rio鸡尾酒；想象鲁迅买了一栋豪华的大房子，里面堆满了rio鸡尾酒； luxurious 豪华的，奢华的；</p>
<h2 id="11-单词宝典：-熟词-熟词法-amp-词中词法-amp-字母换位法2017-02-03"><a href="#11-单词宝典：-熟词-熟词法-amp-词中词法-amp-字母换位法2017-02-03" class="headerlink" title="11. 单词宝典： 熟词+熟词法&amp;词中词法&amp;字母换位法2017-02-03"></a>11. 单词宝典： 熟词+熟词法&amp;词中词法&amp;字母换位法2017-02-03</h2><p><img src="http://you img base url/images/11.jpg?e=1585218234&token=your qiniu access key:cF_21rZEl6cE6QWEEjbxXihgTD8=" alt><br>中小学单词：</p>
<p>熟词+熟词法<br>1.eggplant  n.茄子   egg 鸡蛋；plant 植物；长得像鸡蛋的植物，就是茄子，想像鸡蛋和茄子的共同点，底下很圆，很光滑；  eggplant  茄子<br>2.mooncake  n.月饼；  moon 月亮；cake 蛋糕；  做的像月亮的蛋糕，就是月饼 mooncake 月饼；<br>3.doorbell   n.门铃  door 门 + bell 铃铛；门上的铃铛，就是门铃； doorbell 门铃；<br>4.headache  n.头痛   head 头 + ache 疼痛；头有些疼痛，就是头痛；headache 头痛；<br>5.backpack  n.双肩背包 back 背 + pack 包；背上背的包，就是双肩背包，backpack 双肩背包；<br>6.footprint  n.脚印   foot 脚 + print 印子，打印；脚踩下留的印子，就是脚印；footprint 脚印；</p>
<p>词中词法：（就是一个单词里面包含另一个单词，多的部分可以是字母、字母组合，甚至也可以是单词）<br>7.boast  v.吹嘘；自吹自擂   boat 船；s 美女；船上有个美女在自吹自擂； boast 吹嘘，自吹自擂；<br>8.trip    n.旅游   tip  建议；r 草；建议旅游的时候去草比较多的地方，风景好一些； trip 旅游；<br>9.chat    v.聊天   cat 猫，h 椅子；我坐在椅子上和猫聊天； chat 聊天；<br>10.beggar n.乞丐    bar 酒吧；egg 鸡蛋；酒吧里有个乞丐在讨鸡蛋； beggar 乞丐（beggar是beg的名词形式）；</p>
<p>字母换位法：（既可以全部调换字母，也可以部分调换字母）<br>11.evil a.邪恶的；   live 居住，生活； 居住live的单词字母全部反序，倒过来就是邪恶的； evil 邪恶的；<br>12.rood  n.十字架  door 门；调换顺序，反过来，门反过来，门的背后有个十字架；rood 十字架；</p>
<p>大学四六级单词：</p>
<p>熟词+熟词法：<br>1.teamwork n.团队合作；  team 团队； work 工作；一个团队在一起完成工作，就是团队合作；teamwork 团队合作<br>2.overestimate   v.过高估计  over 超过，高于；estimate 估计；作出高于···的评价，就是过高估计；overestimate 过高估计</p>
<ol start="3">
<li>database  n.数据库  data 数据，base 基础；可以操作很多数据的基础，就是得有个数据库，database 数据库；<br>4.counteract  v.抵消，中和； counter n.计数器；a.相反的  act 作用；起到相反的作用，就是抵消，中和；counteract 抵消；中和；<br>5.undergraduate  n.大学本科生； under 在···下面；graduate 毕业生； undergraduate 大学本科生；<br>6.mainstream  n.主流；a.主流的   main  主要的； stream 河流； 主要的河流，合起来就是主流的；mainstream 主流；主流的（汉语和英语的转换也很有意思）</li>
</ol>
<p>词中词法：<br>7.stir  v.搅拌   sir–先生；t–伞； 先生拿着一把伞在杯子里搅拌；stir 搅拌；<br>8.fame n.名声；   flame  n.火焰；多了一个l，像火炬；想像有个人，名声很好，被选中当奥运火炬手，火炬上面有火焰； fame 名声；flame 火焰；</p>
<p>字母换位法：<br>9.doom  n.厄运；v.注定（失败）；   mood  n.心情； 有厄运，注定要失败，所以心情不好；  doom 厄运；注定（失败）<br>10.pit   n.井    tip 建议；小费；  服务员不小心把收到的小费扔到井里了； pit 井；</p>
<p>出国单词：</p>
<p>熟词+熟词法：<br>1.twofold  a.两倍的   two 两，两个 + fold 折叠；折叠成两倍，twofold 两倍的；<br>2.highlight  v.强调；突出  high 高的； light 光；高的光，用高光打亮，就是强调突出，也可以想像记号笔把重要的文字涂色； highlight 强调，突出；<br>3.topsoil  n.表层土  top 顶部，盖； soil 土壤； 最顶部的土壤，就是表层土 topsoil 表层土；<br>4.overexploit  v.过度开发；  over 超过，高于；  exploit 开发；开发程度过高，就是过度开发；overexploit  过度开发；<br>5.counterproductive  a.反生产的；使达不到预期的  counter n.计数器；a.相反的；productive a.生产的；有效率的； 与生产的、有效率的 相反，就是 反生产的，没有效率的，达不到预期的； counterproductive  反生产的；使达不到预期的；<br>6.socialphobia  n.社交恐惧症  social 社交的；phobia n.恐惧 恐惧社交，就是社交恐惧症；socialphobia社交恐惧症</p>
<p>词中词法：<br>7.germ  n.细菌；微生物；胚芽；  gem n.宝石；r-小芽，胚芽； 宝石中间长了一个胚芽r，上面还有好多细菌微生物； germ 细菌；微生物；胚芽；<br>8.pamper  v.溺爱；  paper–纸张；m–妈妈；这孩子长这么大，用纸擦屁股都要妈妈擦，妈妈简直太溺爱他了； pamper 溺爱</p>
<p>字母换位法：<br>9.reed  n.芦苇；（read同音）   deer 鹿；有一只鹿钻到芦苇里去了；  reed 芦苇<br>10.teem  v.充满，富于；（指水、雨等）暴降、倾注； （team同音） meet 相遇；两个人相遇的时候雨水暴降，街道上都是水； teem 充满，富于；（指水、雨等）暴降、倾注。</p>
<h2 id="12-单词宝典：词根词缀应该怎么记？2017-02-07"><a href="#12-单词宝典：词根词缀应该怎么记？2017-02-07" class="headerlink" title="12. 单词宝典：词根词缀应该怎么记？2017-02-07"></a>12. 单词宝典：词根词缀应该怎么记？2017-02-07</h2><p>1.词根的记忆<br><img src="http://you img base url/images/12词根词缀.png?e=1585218234&token=your qiniu access key:w3pRZWr9p2zARmHauLo5vyWiwSo=" alt><br>2.前缀的记忆<br>3.后缀的记忆</p>
<h2 id="13-单词宝典：词根词缀应该怎么用？2017-02-10"><a href="#13-单词宝典：词根词缀应该怎么用？2017-02-10" class="headerlink" title="13. 单词宝典：词根词缀应该怎么用？2017-02-10"></a>13. 单词宝典：词根词缀应该怎么用？2017-02-10</h2>]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>记忆宫殿7篇</title>
    <url>/ins/burnedBrain/%E8%AE%B0%E5%BF%86%E5%AE%AB%E6%AE%BF7%E7%AF%87/</url>
    <content><![CDATA[<h2 id="18-记忆宫殿法之“地点定桩法”"><a href="#18-记忆宫殿法之“地点定桩法”" class="headerlink" title="18. 记忆宫殿法之“地点定桩法”"></a>18. 记忆宫殿法之“地点定桩法”</h2><p>中国十大名著<br>1．红楼梦 （清） 曹雪芹；<br>2．水浒传 （明） 施耐庵；<br>3．三国演义 （明） 罗贯中；<br>4．西游记 （明） 吴承恩；<br>5．镜花缘 （清） 李汝珍；<br>6．儒林外史 （清） 吴敬梓；<br>7．封神演义 （明） 许仲琳；<br>8．聊斋志异 （清） 蒲松龄；<br>9．官场现形记 （清） 李宝嘉；<br>10．东周列国志 （明） 冯梦龙；<br><img src="http://you img base url/images/18地点定桩法1.png?e=1585218234&token=your qiniu access key:qHk3wYkNob4s2vBaOczetDSUSlY=" alt></p>
<p>飞龙篇<br>曹植<br>晨游泰山。云雾窈窕。忽逢二童。颜色鲜好。<br>乘彼白鹿。手翳芝草。我知真人。长跪问道。<br>西登玉台。金楼复道。授我仙药。神皇所造。<br>教我服食。还精补脑。寿同金石。永世难老。<br><img src="http://you img base url/images/18地点定桩法2.png?e=1585218234&token=your qiniu access key:jNt6ZJrCJGvR7ZwDEp5EBB2_6Dc=" alt></p>
<p>找地点黄金五法则</p>
<ol>
<li>熟悉</li>
<li>顺序</li>
<li>特征</li>
<li>适中</li>
<li>固定</li>
</ol>
<h2 id="19-记忆宫殿法之“人物定桩法”2017-03-04"><a href="#19-记忆宫殿法之“人物定桩法”2017-03-04" class="headerlink" title="19. 记忆宫殿法之“人物定桩法”2017-03-04"></a>19. 记忆宫殿法之“人物定桩法”2017-03-04</h2><p>八荣八耻</p>
<p>爷爷：以热爱祖国为荣、以危害祖国为耻，<br>奶奶：以服务人民为荣、以背离人民为耻，<br>外公：以崇尚科学为荣、以愚昧无知为耻，<br>外婆：以辛勤劳动为荣、以好逸恶劳为耻，<br>丈夫：以团结互助为荣、以损人利己为耻，<br>妻子：以诚实守信为荣、以见利忘义为耻，<br>儿子：以遵纪守法为荣、以违法乱纪为耻，<br>女儿：以艰苦奋斗为荣、以骄奢淫逸为耻。</p>
<p>《再别康桥》</p>
<p>如来佛<br>轻轻的我走了，<br>正如我轻轻的来；<br>我轻轻的招手，<br>作别西天的云彩。</p>
<p>观世音<br>那河畔的金柳，<br>是夕阳中的新娘，<br>波光里的艳影，<br>在我的心头荡漾。</p>
<p>唐僧<br>软泥上的青荇，<br>油油的在水底招摇；<br>在康河的柔波里，<br>我甘心做一条水草!</p>
<p>孙悟空<br>那榆荫下的一潭，<br>不是清泉，是天上虹；<br>揉碎在浮藻间，<br>沉淀着彩虹似的梦。</p>
<p>猪八戒<br>寻梦？撑一支长篙，<br>向青草更青处漫溯，<br>满载一船星辉，<br>在星辉斑斓里放歌。</p>
<p>沙和尚<br>但我不能放歌,<br>悄悄是别离的笙箫；<br>夏虫也为我沉默，<br>沉默是今晚的康桥！</p>
<p>白龙马<br>悄悄的我走了，<br>正如我悄悄的来；<br>我挥一挥衣袖，<br>不带走一片云彩。</p>
<h2 id="20-记忆宫殿法之“身体定桩法”2017-03-07"><a href="#20-记忆宫殿法之“身体定桩法”2017-03-07" class="headerlink" title="20. 记忆宫殿法之“身体定桩法”2017-03-07"></a>20. 记忆宫殿法之“身体定桩法”2017-03-07</h2><p>匆匆(朱自清)</p>
<p>(对应：头发)<br>燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢：现在又到了哪里呢？ </p>
<p>（对应：手）<br>我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，也没有影子。我不禁头涔涔而泪潸潸了。 </p>
<p>（对应：肚子）<br>去的尽管去了，来的尽管来着；去来的中间，又怎样地匆匆呢？早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去。我觉察他去的匆匆了，伸出手遮挽时，他又从遮挽着的手边过去，天黑时，我躺在床上，他便伶伶俐俐地从我身上跨过，从我脚边飞去了。等我睁开眼和太阳再见，这算又溜走了一日。我掩着面叹息。但是新来的日子的影儿又开始在叹息里闪过了。 </p>
<p>（对应：脚）<br>在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？<br>    你聪明的，告诉我，我们的日子为什么一去不复返呢？</p>
<h2 id="21-记忆宫殿法之“标题定桩法”"><a href="#21-记忆宫殿法之“标题定桩法”" class="headerlink" title="21. 记忆宫殿法之“标题定桩法”"></a>21. 记忆宫殿法之“标题定桩法”</h2><p>《南京条约》的主要内容<br>南：割香港岛给英国<br>京：赔款2100万元<br>条：开放广州，厦门，福州，宁波，上海五处为通商口岸（广下福宁上）<br>约：英商进出口货物缴纳的税款，中国须同英国商定。</p>
<p>原始社会半坡氏族时期的社会生活情况<br>半：普遍使用磨制石器，使用磨制石器的时代叫新石器时代，他们还使用弓箭。<br>坡：原始农业已有发展，种植粮食粟。我国是最早培植粟的国家，已学会养猪狗鸡牛羊。<br>氏：已使用陶器。<br>族：已学会建造房屋，过着定居的生活，已形成村落。</p>
<h2 id="22-记忆宫殿法之“数字定桩法”"><a href="#22-记忆宫殿法之“数字定桩法”" class="headerlink" title="22. 记忆宫殿法之“数字定桩法”"></a>22. 记忆宫殿法之“数字定桩法”</h2><p>短歌行（曹操）</p>
<p>（1：树）</p>
<p>对酒当歌，人生几何！</p>
<p>譬如朝露，去日苦多。</p>
<p>译文：一边喝酒一边高歌，人生短促日月如梭。</p>
<p>好比晨露转瞬即逝，失去的时日实在太多！</p>
<p>（2：鹅）</p>
<p>慨当以慷，忧思难忘。</p>
<p>何以解忧？惟有杜康。</p>
<p>译文：席上歌声激昂慷慨，忧郁长久填满心窝。<br>靠什么来排解忧闷？唯有狂饮方可解脱。</p>
<p>（3：耳朵）</p>
<p>青青子衿（jīn），悠悠我心。</p>
<p>但为君故，沉吟至今。</p>
<p>译文：那穿着青领（周代学士的服装）的学子哟，你们令我朝夕思慕。<br>只是因为您的缘故，让我沉痛吟诵至今。</p>
<p>（4：帆船）</p>
<p>呦呦（yōu）鹿鸣，食野之苹。</p>
<p>我有嘉宾，鼓瑟吹笙。</p>
<p>译文：阳光下鹿群呦呦欢鸣，悠然自得啃食在绿坡。<br>一旦四方贤才光临舍下，我将奏瑟吹笙宴请嘉宾。</p>
<p>（5：钩子）</p>
<p>明明如月，何时可掇（duō）？</p>
<p>忧从中来，不可断绝。</p>
<p>译文：当空悬挂的皓月哟，什么时候才可以拾到；<br>我久蓄于怀的忧愤哟，突然喷涌而出汇成长河。</p>
<p>（6：哨子）</p>
<p>越陌度阡，枉用相存。</p>
<p>契（qì）阔谈（yàn），心念旧恩。</p>
<p>译文：远方宾客踏着田间小路，一个个屈驾前来探望我。<br>彼此久别重逢谈心宴饮，争着将往日的情谊诉说。</p>
<p>（7：镰刀）</p>
<p>月明星稀， 乌鹊南飞。</p>
<p>绕树三匝（zā）， 何枝可依？</p>
<p>译文：月光明亮星光稀疏，一群寻巢乌鹊向南飞去。<br>绕树飞了三周却没敛翅，哪里才有它们栖身之所？</p>
<p>（8：葫芦）</p>
<p>山不厌高， 海不厌深。</p>
<p>周公吐哺（bǔ），天下归心。</p>
<p>译文：高山不辞土石才见巍峨，大海不弃涓流才见壮阔。<br>我愿如周公一般礼贤下士，愿天下的英杰真心归顺与我。</p>
<p>数字编码表</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 树</td>
<td>2 鹅</td>
<td>3 耳朵</td>
<td>4 帆船</td>
<td>5 钩子</td>
<td>6 哨子</td>
<td>7 镰刀</td>
<td>8 葫芦</td>
<td>9 淋浴头</td>
<td>10 棒球</td>
</tr>
<tr>
<td>11 筷子</td>
<td>12 椅儿</td>
<td>13 医生</td>
<td>14 钥匙</td>
<td>15 鹦鹉</td>
<td>16 石榴</td>
<td>17 显微镜</td>
<td>18 腰包</td>
<td>19 衣钩</td>
<td>20 香烟</td>
</tr>
<tr>
<td>21 鳄鱼</td>
<td>22 双胞胎</td>
<td>23 耳塞</td>
<td>24 时钟</td>
<td>25 二胡</td>
<td>26 河流</td>
<td>27 耳机</td>
<td>28 恶霸</td>
<td>29 鹅脚</td>
<td>30 三棱镜</td>
</tr>
<tr>
<td>31 鲨鱼</td>
<td>32 扇儿</td>
<td>33 砖石</td>
<td>34 三丝巾</td>
<td>35 山虎</td>
<td>36 山鹿</td>
<td>37 山鸡</td>
<td>38 妇女</td>
<td>39 三角板</td>
<td>40 司令</td>
</tr>
<tr>
<td>41 死鱼</td>
<td>42 柿儿</td>
<td>43 石山</td>
<td>44 蛇</td>
<td>45 师傅</td>
<td>46 饲料</td>
<td>47 司机</td>
<td>48 石板</td>
<td>49 湿狗</td>
<td>50 五环</td>
</tr>
<tr>
<td>51 工人</td>
<td>52 鼓儿</td>
<td>53 火山</td>
<td>54 巫师</td>
<td>55 火车</td>
<td>56 蜗牛</td>
<td>57 武器</td>
<td>58 尾巴</td>
<td>59 蜈蚣</td>
<td>60 六十大寿</td>
</tr>
<tr>
<td>61 儿童</td>
<td>62 牛儿</td>
<td>63 流沙</td>
<td>64 螺丝</td>
<td>65 尿壶</td>
<td>66 蝌蚪</td>
<td>67 油漆</td>
<td>68 喇叭</td>
<td>69 太极图</td>
<td>70 麒麟</td>
</tr>
<tr>
<td>71 鸡翼</td>
<td>72 企鹅</td>
<td>73 漆伞</td>
<td>74 骑士</td>
<td>75 西服</td>
<td>76 汽油</td>
<td>77 玫瑰</td>
<td>78 西瓜</td>
<td>79 气球</td>
<td>80 巴黎铁塔</td>
</tr>
<tr>
<td>81 白蚁</td>
<td>82 靶儿</td>
<td>83 花生</td>
<td>84 扳手</td>
<td>85 宝物</td>
<td>86 八路</td>
<td>87 白旗</td>
<td>88 人民币</td>
<td>89 芭蕉</td>
<td>90 酒瓶</td>
</tr>
<tr>
<td>91 球衣</td>
<td>92 球儿</td>
<td>93 救生圈</td>
<td>94 首饰</td>
<td>95 酒壶</td>
<td>96 酒炉</td>
<td>97 酒旗</td>
<td>98 球拍</td>
<td>99 舅舅</td>
<td>100 链条    </td>
</tr>
</tbody>
</table>
<h2 id="23-记忆宫殿法之“熟语定桩法”"><a href="#23-记忆宫殿法之“熟语定桩法”" class="headerlink" title="23. 记忆宫殿法之“熟语定桩法”"></a>23. 记忆宫殿法之“熟语定桩法”</h2><p>学而第一</p>
<p>（慈—慈祥的爷爷）<br>子曰：“学而时习之，不亦悦乎?有朋自远方来，不亦乐乎?人不知而不愠，不亦君子乎?”</p>
<p>【译文】 孔子说：“学了又时常温习和练习，不是很愉快吗？有志同道合的人从远方来，不是很令人高兴的吗？人家不了解我，我也不怨恨、恼怒，不也是一个有德的君子吗？” 　　</p>
<p>（母—母亲）<br>有子曰：“其为人也孝悌（tì）而好犯上者，鲜矣。不好犯上而好作乱者，未之有也。君子务本，本立而道生。孝悌也者，其为仁之本与?”</p>
<p>【译文】有子说：”孝顺父母，顺从兄长，而喜好触犯上层统治者，这样的人是很少见的。不喜好触犯上层统治者，而喜好造反的人是没有的。君子专心致力于根本的事务，根本建立了，治国做人的原则也就有了。孝顺父母、顺从兄长，这就是仁的根本啊！” 　</p>
<p>（手）<br>子曰：“巧言令色，鲜矣仁。”</p>
<p>【译文】孔子说：“花言巧语，装出和颜悦色的样子，这种人的仁心就很少了。” </p>
<p>（中—中午）<br>曾子曰：吾日三省乎吾身。为人谋而不忠乎?与朋友交而不信乎?传不习乎?</p>
<p>【译文】曾子说：“我每天多次反省自己，为别人办事是不是尽心竭力了呢？同朋友交往是不是做到诚实可信了呢？老师传授给我的学业是不是复习了呢？” </p>
<p>（线—线路）<br>子曰：道千乘之国，敬事而信，节用而爱人，使民以时。</p>
<p>【译文】孔子说：“治理一个拥有一千辆兵车的国家，就要严谨认真地办理国家大事而又恪守信用，诚实无欺，节约财政开支而又爱护官吏臣僚，役使百姓要不误农时”。 </p>
<p>（游—游玩）<br>子曰：弟子入则孝，出则悌，谨而信，泛爱众而亲仁，行有余力，则以学文。</p>
<p>【译文】孔子说：“弟子们在父母跟前，就孝顺父母；出门在外，要顺从师长，言行要谨慎，要诚实可信，寡言少语，要广泛地去爱众人，亲近那些有仁德的人。这样躬行实践之后，还有余力的话，就再去学习文献知识。” </p>
<p>（子—儿子）<br>子夏曰：贤贤易色，事父母，能竭其力。事君，能致其身。与朋友交，言而有信。虽曰未学，吾必谓之学矣。</p>
<p>【译文】子夏说：“一个人能够看重贤德而不以女色为重；侍奉父母，能够竭尽全力；服侍君主，能够献出自己的生命；同朋友交往，说话诚实恪守信用。这样的人，尽管他自己说没有学习过，我一定说他已经学习过了。”</p>
<p>（身—身体）<br>子曰：君子不重则不威，学则不固。主忠信，无友不如己者，过则勿惮改。</p>
<p>【译文】孔子说：“君子，不庄重就没有威严；学习可以使人不闭塞；要以忠信为主，不要同与自己不同道的人交朋友；有了过错，就不要怕改正。” </p>
<p>（上—上面）<br>曾子曰：慎终追远，民德归厚矣。</p>
<p>【译文】曾子说：“谨慎地对待父母的去世，追念久远的祖先，自然会导致老百姓日趋忠厚老实了。”<br>　　<br>（衣—衣服）<br>子禽问于子贡曰：“夫子至于是邦也，必闻其政。求之与?抑与之与?”子贡曰：“夫子温良恭俭让以得之。夫子求之也，其诸异乎人之求之与?”</p>
<p>【译文】子禽问子贡说：“老师到了一个国家，总是预闻这个国家的政事。（这种资格）是他自己求得呢，还是人家国君主动给他的呢？”子贡说：“老师温良恭俭让，所以才得到这样的资格，（这种资格也可以说是求得的），但他求的方法，或许与别人的求法不同吧？” 　　</p>
<p>（临）<br>子曰：父在，观其志。父没，观其行。三年无改于父之道，可谓孝矣。</p>
<p>【译文】 孔子说；“当他父亲在世的时候，（因为他无权独立行动），要观察他的志向；在他父亲死后，要考察他的行为；若是他对他父亲的合理部分长期不加改变，这样的人可以说是尽到孝了。” </p>
<p>（行）<br>有子曰：礼之用，和为贵。先王之道斯为美。小大由之，有所不行。知和而和，不以礼节之，亦不可行也。</p>
<p>【译文】有子说：“礼的应用，以和谐为贵。古代君主的治国方法，可宝贵的地方就在这里。但不论大事小事只顾按和谐的办法去做，有的时候就行不通。（这是因为）为和谐而和谐，不以礼来节制和谐，也是不可行的。”</p>
<p>（密）<br>有子曰：信近于义，言可复也。恭近于礼，远耻辱也。因不失其亲，亦可宗也。</p>
<p>【译文】有子说：“讲信用要符合于义，（符合于义的）话才能实行；恭敬要符合于礼，这样才能远离耻辱；所依靠的都是可靠的人，也就值得尊敬了。” </p>
<p>（密）<br>子曰：君子食无求饱，居无求安。敏于事而慎于言，就有道而正焉。可谓好学也已。</p>
<p>【译文】 孔子说：“君子，饮食不求饱足，居住不要求舒适，对工作勤劳敏捷，说话却小心谨慎，到有道的人那里去匡正自己，这样可以说是好学了。” </p>
<p>（缝）<br>子贡曰：“贫而无谄，富而无骄。何如?”子曰：“可也。未若贫而乐，富而好礼者也。”子贡曰：“诗云：如切如磋，如琢如磨。其斯之谓与?”子曰：“赐也，始可与言诗已矣。告诸往而知来者。”</p>
<p>【译文】 子贡说：“贫穷而能不谄媚，富有而能不骄傲自大，怎么样？”孔子说：“这也算可以了。但是还不如虽贫穷却乐于道，虽富裕而又好礼之人。”子贡说：“《诗》上说，‘要像对待骨、角、象牙、玉石一样，切磋它，琢磨它’，就是讲的这个意思吧？”孔子说：“赐呀，你能从我已经讲过的话中领会到我还没有说到的意思，举一反三，我可以同你谈论《诗》了。” </p>
<p>（意）<br>子曰：不患人之不己知，患不知人也。</p>
<p>【译文】 孔子说：“不怕别人不了解自己，只怕自己不了解别人。”  </p>
<p>…</p>
<h2 id="24-记忆宫殿法之“配图定位法”"><a href="#24-记忆宫殿法之“配图定位法”" class="headerlink" title="24. 记忆宫殿法之“配图定位法”"></a>24. 记忆宫殿法之“配图定位法”</h2><p>举例1：马关条约内容<br>（1）中国割让辽东半岛、台湾岛及其附属各岛屿、澎湖列岛给日本。（割三岛）<br>（2）赔偿日本2亿两白银。<br>（3）开放沙市、重庆、苏州、杭州为通商口岸。<br>（4）允许日本在中国的通商口岸投资办厂。<br><img src="http://you img base url/images/24配图定位1.png?e=1585218234&token=your qiniu access key:1z8sIFQvjUjcaswJeSWTyh9vWWQ=" alt></p>
<p>举例2：飞龙篇（曹植）<br>1晨游泰山。2云雾窈窕。3忽逢二童。4颜色鲜好。<br>5乘彼白鹿。6手翳芝草。7我知真人。8长跪问道。<br>9西登玉台。10金楼复道。11授我仙药。12神皇所造。<br>13教我服食。14还精补脑。15寿同金石。16永世难老。<br><img src="http://you img base url/images/24配图定位2.png?e=1585218234&token=your qiniu access key:nKMpKolw8z1moB44PvxZqdFDSXU=" alt></p>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>实战记忆11篇</title>
    <url>/ins/burnedBrain/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BF%8611%E7%AF%87/</url>
    <content><![CDATA[<h2 id="26-巧记圆周率前60位"><a href="#26-巧记圆周率前60位" class="headerlink" title="26. 巧记圆周率前60位"></a>26. 巧记圆周率前60位</h2><p>3.141592653589793238462643383279502884197169399375105820974944<br><img src="http://you img base url/images/26圆周率1.png?e=1585218234&token=your qiniu access key:oxyKcIfQx7JfEb59UGsGGiCE9vg=" alt><br><img src="http://you img base url/images/26圆周率2.png?e=1585218234&token=your qiniu access key:wvAogZsc5uim4i3LaMnpFApk1Cw=" alt></p>
<p>首先设想一个好酒贪杯的酒徒在山寺中狂饮，醉“死”在山沟的过程（30位）：</p>
<p>3.14159 26535897 932 384</p>
<p>山巅一寺一壶酒。儿乐：“我三壶不够吃”。“酒杀尔”，杀不死，</p>
<p>626 43383 279</p>
<p>乐而乐，死三三巴三，儿弃酒。</p>
<p>接着设想“死”者的父亲得知后的感想（15位）：</p>
<p>502 884197169399</p>
<p>吾疼儿：“白白死已够凄矣，留给山沟沟”。</p>
<p>再设想“死”者的父亲到山沟里三番五次寻找儿子的情景（15位）：</p>
<p>37510 5820974944</p>
<p>山拐我腰痛，我怕尔冻久，凄事久思思。</p>
<h2 id="27-隐藏在数字中的密码2017-03-31"><a href="#27-隐藏在数字中的密码2017-03-31" class="headerlink" title="27. 隐藏在数字中的密码2017-03-31"></a>27. 隐藏在数字中的密码2017-03-31</h2><p>数字编码的三种方式：<br>谐音：例如13谐音为医生<br>象形：例如10长得像棒球<br>意义：例如因为一包香烟有20支，所以20编码为香烟<br><img src="http://you img base url/images/27数字密码1十二星座.png?e=1585218234&token=your qiniu access key:9mVHEywNDRFueXYoleijJ-axt20=" alt></p>
<p>数字编码表<br><img src="http://you img base url/images/27数字密码2数字编码表.png?e=1585218234&token=your qiniu access key:RhTghcikXeq2yiPepiypCnncKWA=" alt></p>
<h2 id="28-历史年代轻松记2017-04-04"><a href="#28-历史年代轻松记2017-04-04" class="headerlink" title="28. 历史年代轻松记2017-04-04"></a>28. 历史年代轻松记2017-04-04</h2><p>记忆方法：<br>1、以熟记新<br>2、谐音记忆<br>3、编码记忆<br>4、串联记忆</p>
<h2 id="29-日期信息巧记忆"><a href="#29-日期信息巧记忆" class="headerlink" title="29. 日期信息巧记忆"></a>29. 日期信息巧记忆</h2><p><img src="http://you img base url/images/29常见日期.png?e=1585218234&token=your qiniu access key:tXgq29Ad0h4eNghRXC80Qus4EH8=" alt></p>
<h2 id="30-巧记生活中的长数据"><a href="#30-巧记生活中的长数据" class="headerlink" title="30. 巧记生活中的长数据"></a>30. 巧记生活中的长数据</h2><p>一、记忆电话号码的一般方法<br>(1)利用谐音<br>将87375184谐音为“不去生气，我要坐巴士“<br>将137 5132 9776谐音为“一生气 我拿一扇儿 使酒旗在气流中招展。<br>154 831 91758谐音为“一武士 白鲨鱼 就要吃尾巴。<br>(2)寻找规律<br>简化规律： 844 75342<br>对称、重复、叠加规律：135 0125 5210<br>排序规律：139 284 390 55<br>（3）找特殊数<br>1891 082 1985、1360 269 8153、189 4255 2361、138 2468 1225</p>
<p>二、银行卡号<br>招商银行：6214 8565 2624 4338   中国银行：6013 8220 0018 7771 396</p>
<p>三、车牌号记忆<br>粤 B·8KJ65，浙D·LP205，鄂 A·B314V<br>粤A 广州，粤B 深圳，粤C 珠海，粤D 汕头，粤E 佛山，粤F 韶关，粤G 湛江，粤H 肇庆，粤J 江门，粤K 茂名，粤L 惠州，粤M 梅州，粤N 汕尾，粤P 河源，粤Q 阳江，粤R 清远，粤S 东莞，粤T 中山，粤U 潮州，粤V 揭阳，粤W 云浮，粤X 顺德，粤Y 南海，粤Z港澳进入内地车辆</p>
<h2 id="31-达人记忆养成计划：字词达人"><a href="#31-达人记忆养成计划：字词达人" class="headerlink" title="31. 达人记忆养成计划：字词达人"></a>31. 达人记忆养成计划：字词达人</h2><p><img src="http://you img base url/images/31字词达人1.jpg?e=1585218234&token=your qiniu access key:RmP-U9xmQjNU4ZFxbCkAE260s8Q=" alt><br><img src="http://you img base url/images/31字词达人2.jpg?e=1585218234&token=your qiniu access key:1mAIphFJYybp__NL10OkWA6U2vI=" alt></p>
<h2 id="32-达人记忆养成计划：常识达人"><a href="#32-达人记忆养成计划：常识达人" class="headerlink" title="32. 达人记忆养成计划：常识达人"></a>32. 达人记忆养成计划：常识达人</h2><p>一、易写错字词<br>1） 不记得<br>编纂/篡    赝/膺品    蛰/蜇伏     饮鸩/鸠止渴<br>2） 偏旁或局部结构类似<br>黄粱/梁美梦     炙/灸手可热      赃/脏款    订/钉书机<br>3） 意思理解不当<br>甘拜/败下风     备/倍受关注     谈笑风生/声   一筹/愁莫展<br>4） 干扰<br>明/名信片     川/穿流不息    受益匪/非浅   声名鹊/雀起</p>
<p>二、文学常识<br>元曲四大家：<br>关汉卿、郑光祖、白朴、马致远。（白祖关马）<br>楷书四大家：<br>颜真卿、柳公权、欧阳询、赵孟頫（fǔ） ­（柳公寻真梦）<br>世界文学作品中四大吝啬鬼：<br>葛朗台、夏洛克、泼溜希金、阿巴贡。<br>我国第一部纪传体通史是《史记》（又称《太史公书》），作者是汉朝的司马迁，鲁迅称《史记》为“史家之绝唱，无韵之《离骚》”，有：本纪、世家、列传、表、书共六种文体。<br>三教九流：“三教”：儒教、佛教、道教；“九流”：儒家、道家、阴阳家、法家、名家、墨家、纵横家、杂家、农家。</p>
<h2 id="33-古诗词记忆之场景记忆法"><a href="#33-古诗词记忆之场景记忆法" class="headerlink" title="33. 古诗词记忆之场景记忆法"></a>33. 古诗词记忆之场景记忆法</h2><p>白雪歌送武判官归京</p>
<p>【作者】岑参 【朝代】唐</p>
<p>北风卷地白草折， 胡天八月即飞雪。</p>
<p>忽如一夜春风来， 千树万树梨花开。</p>
<p>散入珠帘湿罗幕， 狐裘不暖锦衾薄。</p>
<p>将军角弓不得控， 都护铁衣冷难着。</p>
<p>瀚海阑干百丈冰， 愁云惨淡万里凝。</p>
<p>中军置酒饮归客， 胡琴琵琶与羌笛。</p>
<p>纷纷暮雪下辕门， 风掣红旗冻不翻。</p>
<p>轮台东门送君去， 去时雪满天山路。</p>
<p>山回路转不见君， 雪上空留马行处。</p>
<p>译文：</p>
<p>北风席卷大地把白草吹折，胡地天气八月就纷扬落雪。<br>忽然间宛如一夜春风吹来，好像是千树万树梨花盛开。<br>雪花散入珠帘打湿了罗幕，狐裘穿不暖锦被也嫌单薄。<br>将军都护手冻得拉不开弓，铁甲冰冷得让人难以穿着。<br>沙漠结冰百丈纵横有裂纹，万里长空凝聚着惨淡愁云。<br>主帅帐中摆酒为归客饯行，胡琴琵琶羌笛合奏来助兴。<br>傍晚辕门前大雪落个不停，红旗冻僵了风也无法牵引。<br>轮台东门外欢送你回京去，你去时大雪盖满了天山路。<br>山路迂回曲折已看不见你，雪上只留下一行马蹄印迹。</p>
<h2 id="34-地点定桩法和思维导图法记忆古诗词"><a href="#34-地点定桩法和思维导图法记忆古诗词" class="headerlink" title="34. 地点定桩法和思维导图法记忆古诗词"></a>34. 地点定桩法和思维导图法记忆古诗词</h2><pre><code>沁园春-雪 (毛泽东)
</code></pre><p>（1）北国风光，千里冰封，万里雪飘。<br>（2）望长城内外，惟余莽莽；大河上下，顿失滔滔。<br>（3）山舞银蛇，原驰蜡象，欲与天公试比高。<br>（4）须晴日，看红装素裹，分外妖娆。<br>（5）江山如此多娇，引无数英雄竞折腰。<br>（6）惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。<br>（7）一代天骄，成吉思汗，只识弯弓射大雕。<br>（8）俱往矣，数风流人物，还看今朝。<br><img src="http://you img base url/images/341沁园春.png?e=1585218234&token=your qiniu access key:3a-WRlsduZnTfihldQG3hwFwrhs=" alt><br>念奴娇 赤壁怀古(苏轼)</p>
<pre><code>大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。江山如画，一时多少豪杰。    

遥想公谨当年，小乔初嫁了，雄姿英发。羽扇纶巾，谈笑间，强虏灰飞烟灭。故国神游，多情应笑我，早生华发。人生如梦，一尊还酹江月。
</code></pre><p><img src="http://you img base url/images/342念奴娇-赤壁怀古.jpg?e=1585218234&token=your qiniu access key:5aYo6xCZ6nQN3UJ0jGvN7bJUJCk=" alt></p>
<h2 id="35-实战案例：数字定桩法记忆春江花月夜2017-04-28"><a href="#35-实战案例：数字定桩法记忆春江花月夜2017-04-28" class="headerlink" title="35. 实战案例：数字定桩法记忆春江花月夜2017-04-28"></a>35. 实战案例：数字定桩法记忆春江花月夜2017-04-28</h2><p>春江花月夜</p>
<p>原文：<br>1、春江潮水连海平， 海上明月共潮生。</p>
<p>2、滟滟随波千万里， 何处春江无月明。<br>3、江流宛转绕芳甸， 月照花林皆似霰。</p>
<p>4、空里流霜不觉飞， 汀上白沙看不见。<br>5、江天一色无纤尘， 皎皎空中孤月轮。</p>
<p>6、江畔何人初见月？ 江月何年初照人？<br>7、人生代代无穷已， 江月年年只相似。</p>
<p>8、不知江月待何人， 但见长江送流水。<br>9、白云一片去悠悠， 青枫浦上不胜愁。</p>
<p>10、谁家今夜扁舟子？ 何处相思明月楼？<br>11、可怜楼上月徘徊， 应照离人妆镜台。</p>
<p>12、玉户帘中卷不去， 捣衣砧上拂还来。<br>13、此时相望不相闻， 愿逐月华流照君。</p>
<p>14、鸿雁长飞光不度， 鱼龙潜跃水成文。<br>15、昨夜闲潭梦落花， 可怜春半不还家。</p>
<p>16、江水流春去欲尽， 江潭落月复西斜。<br>17、斜月沉沉藏海雾， 碣石潇湘无限路。</p>
<p>18、不知乘月几人归， 落月摇情满江树。</p>
<p>　　释义：<br>　　春天的江潮水势浩荡，与大海连成一片，一轮明月从海上升起，好像与潮水一起涌出来。月光照耀着春江，随着波浪闪耀千万里，所有地方的春江都有明亮的月光。<br>　　江水曲曲折折地绕着花草丛生的原野流淌，月光照射着开遍鲜花的树林好像细密的雪珠在闪烁。月色如霜，所以霜飞无从觉察。洲上的白沙和月色融合在一起，看不分明。<br>　　江水、天空成一色，没有一点微小灰尘，明亮的天空中只有一轮孤月高悬空中。江边上什么人最初看见月亮，江上的月亮哪一年最初照耀着人？<br>　　人生一代代地无穷无尽，只有江上的月亮一年年地总是相像。不知江上的月亮等待着什么人，只见长江不断地一直运输着流水。<br>　　游子像一片白云缓缓地离去，只剩下思妇站在离别的青枫浦不胜忧愁。哪家的游子今晚坐着小船在漂流？什么地方有人在明月照耀的楼上相思？<br>　　可怜楼上不停移动的月光，应该照耀着离人的梳妆台。月光照进思妇的门帘，卷不走，照在她的捣衣砧上，拂不掉。<br>　　这时互相望着月亮可是互相听不到声音，我希望随着月光流去照耀着您。鸿雁不停地飞翔，而不能飞出无边的月光；月照江面，鱼龙在水中跳跃，激起阵阵波纹。<br>　　昨天夜里梦见花落闲潭，可惜的是春天过了一半自己还不能回家。江水带着春光将要流尽，水潭上的月亮又要西落。<br>　　斜月慢慢下沉，藏在海雾里，碣石与潇湘的离人距离无限遥远。不知有几人能趁着月光回家，唯有那西落的月亮摇荡着离情，洒满了江边的树林。</p>
<h2 id="45-娱乐场实用手册——速记扑克秘诀2017-06-02"><a href="#45-娱乐场实用手册——速记扑克秘诀2017-06-02" class="headerlink" title="45. 娱乐场实用手册——速记扑克秘诀2017-06-02"></a>45. 娱乐场实用手册——速记扑克秘诀2017-06-02</h2><p>一、扑克编码的方式</p>
<p>用一个两位数对每张扑克进行编码，花色和点数分开编码。</p>
<p>数字牌：花色代表两位数的十位，点数代表两位数的个位。一般黑桃用1编码，红桃用2编码，梅花用3编码，方片用4编码。例如黑桃6的编码为16，红桃3的编码为23，梅花10的编码为30，方片9的编码为49。</p>
<p>花牌：点数代表两位数的十位，花色代表两位数的个位。一般J用5编码，Q用6编码，K用7编码。黑桃用1编码，红桃用2编码，梅花用3编码，方片用4编码。所以黑桃K的编码是71，红桃Q的编码是62，方片J的编码是54。</p>
<p>二、 扑克记忆的方法</p>
<p>使用地点定桩法，一般一个地点对应两张扑克。<br><img src="http://you img base url/images/45扑克大院.jpg?e=1585218234&token=your qiniu access key:90AOJ67NrzPEhLjByuEl40gFiUg=" alt><br>举例：黑桃6（16）、红桃3（23）、方片5（45）、梅花4（34）、红桃J（52）、黑桃4（14）、黑桃10（10）、梅花K（73）、方片8（48）、红桃4（24）</p>
<p>三、 扑克提速的技巧</p>
<p>1、 熟悉编码</p>
<p>2、 熟悉连结</p>
<p>3、 熟悉地点及连结</p>
<p>4、 反馈练习</p>
]]></content>
      <categories>
        <category>ins</category>
        <category>burnedBrain</category>
      </categories>
  </entry>
  <entry>
    <title>Tree-W3</title>
    <url>/tree-w3/</url>
    <content><![CDATA[<p> The files tree is:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\csslib">csslib</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\csslib\bootstrap">bootstrap</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\csslib\bootstrap\bootstrap">bootstrap.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\csslib\bootstrap\bootstrap_1-gettingStrat">bootstrap_1-gettingStrat.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\csslib\bootstrap\bootstrap_2-css">bootstrap_2-css.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\csslib\bootstrap\bootstrap_3-components">bootstrap_3-components.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\csslib\bootstrap\bootstrap_4-javascript">bootstrap_4-javascript.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\es">es</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\es\ECMAScript6入门">ECMAScript6入门</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\14-Promise 对象">14-Promise 对象.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\17-Generator 函数的语法">17-Generator 函数的语法.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\19-async 函数">19-async 函数.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\2-let 和 const 命令">2-let 和 const 命令.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\20-Class 的基本语法">20-Class 的基本语法.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\21-Class 的继承">21-Class 的继承.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\24-Module 的加载实现">24-Module 的加载实现.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\3-变量的解构赋值">3-变量的解构赋值.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\4-字符串的扩展">4-字符串的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\6-数值的扩展">6-数值的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\7-函数的扩展">7-函数的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\8-数组的扩展">8-数组的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\9-对象的扩展">9-对象的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\_15-Iterator 和 for...of 循环">_15-Iterator 和 for…of 循环.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门\_5-正则的扩展">_5-正则的扩展.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\es\ECMAScript6入门">ECMAScript6入门.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\hexo">hexo</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\hexo\hexo文档">hexo文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\hexo\next文档">next文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\js">js</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\js\canvas教程-MDN">canvas教程-MDN.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\jslib">jslib</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\angularjs中文网_1-tutorial">angularjs中文网_1-tutorial.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\debug-npm">debug-npm.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\jslib\react文档">react文档</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档0_安装">react文档0_安装.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-11_组合 vs 继承">react文档1-11_组合 vs 继承.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-12_react编程思想">react文档1-12_react编程思想.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-3_元素渲染">react文档1-3_元素渲染.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-4_组件 &amp; Props">react文档1-4_组件 &amp; Props.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-5_State &amp; 生命周期_">react文档1-5_State &amp; 生命周期_.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-6_事件处理">react文档1-6_事件处理.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-7_条件渲染">react文档1-7_条件渲染.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-8_列表 &amp; Keys">react文档1-8_列表 &amp; Keys.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档1-concepts">react文档1-concepts.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档2-其它概念">react文档2-其它概念.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档2-深入react">react文档2-深入react.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档\react文档2-类型检查">react文档2-类型检查.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\react文档">react文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\videojs文档">videojs文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\jslib\vuejs文档">vuejs文档</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\vuejs文档\vuejs文档1-基础">vuejs文档1-基础.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\vuejs文档\vuejs文档7-深入响应式原理">vuejs文档7-深入响应式原理.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\vuejs文档\vuejs文档9-对比">vuejs文档9-对比.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\jslib\vuejs文档">vuejs文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\md">md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\1_gaishu">1_gaishu.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\2_qukuai">2_qukuai.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\3_quduan">3_quduan.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\4_qita">4_qita.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\markdown语法说明%28简体中文版%29">markdown语法说明(简体中文版).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\qitashouji">qitashouji.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\md\zhengliban">zhengliban.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\pkg">pkg</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\webpack-v3.10.0">webpack-v3.10.0.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\webpack_1-concepts">webpack_1-concepts.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\webpack_2-configuration">webpack_2-configuration.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\webpack_4-guides">webpack_4-guides.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\_webpack_5-loaders">_webpack_5-loaders.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\pkg\_webpack_6-plugins">_webpack_6-plugins.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\ser">ser</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\linux教程-runoob">linux教程-runoob.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\mediasoup文档">mediasoup文档.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\nodejs-runoob">nodejs-runoob.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\php教程-w3s">php教程-w3s.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\php面向对象-runoob">php面向对象-runoob.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\ser\python3-runoob">python3-runoob.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/w3\sql">sql</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\sql\mongodb8days">mongodb8days.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../w3\sql\SQL教程-w3c">SQL教程-w3c.md</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>Tree-Pdf/</title>
    <url>/tree-pdf/</url>
    <content><![CDATA[<p> The files tree is:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\css">css</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\css\Css布局实战">Css布局实战.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\css\CSS揭秘">CSS揭秘.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\css\DivCSS网页布局揭秘">DivCSS网页布局揭秘.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\css\别具光芒：css属性、浏览器兼容与网页布局">别具光芒：css属性、浏览器兼容与网页布局.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\css\响应式Web设计：HTML5和CSS3实战">响应式Web设计：HTML5和CSS3实战.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\des">des</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\des\WEB前端设计修炼之道">WEB前端设计修炼之道.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\des\WEB界面设计">WEB界面设计.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\es">es</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\es\ECMAScript6入门">ECMAScript6入门</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门\12_Promise对象">12_Promise对象.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门\13_异步操作">13_异步操作.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门\14_class">14_class.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门\15_Module">15_Module.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门\16_编程风格">16_编程风格.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\ECMAScript6入门">ECMAScript6入门.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\es\深入浅出ES6">深入浅出ES6.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\ex">ex</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ex\GitHub入门与实践">GitHub入门与实践.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ex\git常用命令">git常用命令.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ex\Web前端黑客技术揭秘">Web前端黑客技术揭秘.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ex\大话数据结构">大话数据结构.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\html">html</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\html\HTML与CSS权威指南">HTML与CSS权威指南.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\js">js</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\JavaScript忍者秘籍">JavaScript忍者秘籍.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\JS忍者秘籍">JS忍者秘籍.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\js\js模式">js模式</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\js模式\5_对象创建模式">5_对象创建模式.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\js模式\7_设计模式">7_设计模式.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\JS模式">JS模式.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\JS面向对象编程指南">JS面向对象编程指南.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\函数范式">函数范式.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\学习js数据结构与算法">学习js数据结构与算法.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\正则表达式30分钟入门教程">正则表达式30分钟入门教程.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\js\高效JS简化版">高效JS简化版.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\jslib">jslib</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\AngularJS权威教程">AngularJS权威教程.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\jslib\犀利开发-jQuery内核详解与实践">犀利开发-jQuery内核详解与实践</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 1 章 jQ起步">第 1 章 jQ起步.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 2 章 jQ解密技术">第 2 章 jQ解密技术.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 3 章 高效选择的技巧与原理">第 3 章 高效选择的技巧与原理.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 4 章 文档对象的操作及高效实践">第 4 章 文档对象的操作及高效实践.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 5 章 事件封装机制与解析">第 5 章 事件封装机制与解析.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 6 章 动画效果设计及其高效实践">第 6 章 动画效果设计及其高效实践.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 7 章 Ajax异步通信高效实践">第 7 章 Ajax异步通信高效实践.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 8 章 高效开发和使用插件">第 8 章 高效开发和使用插件.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践\第 9 章 jQ辅助工具">第 9 章 jQ辅助工具.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\犀利开发-jQuery内核详解与实践">犀利开发-jQuery内核详解与实践.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\jslib\锋利的jQuery 2nd">锋利的jQuery 2nd.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\opti">opti</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\opti\SEO必知必会51技">SEO必知必会51技.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\opti\Web性能权威指南">Web性能权威指南.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\opti\代码整洁之道">代码整洁之道.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\opti\编写高质量代码--Web前端开发修炼之道">编写高质量代码–Web前端开发修炼之道.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\opti\高性能网站建设指南">高性能网站建设指南.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\os">os</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\os\计算机导论">计算机导论.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\os\计算机网络基础">计算机网络基础.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\ser">ser</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ser\PHP和MySQL WEB开发">PHP和MySQL WEB开发.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ser\SQL必知必会">SQL必知必会.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../pdf\ser\数据库系统概论">数据库系统概论.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/pdf\_list.txt">_list.txt</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>Tree-Sum</title>
    <url>/tree-sum/</url>
    <content><![CDATA[<p> The files tree is:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\css">css</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\cc像素%28003%29">cc像素(003).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\css不同布局方式%28012%29">css不同布局方式(012).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\css代码组织方法%28002%29">css代码组织方法(002).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\css使用记录">css使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\css编码%28001%29">css编码(001).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\flex基础%28401%29">flex基础(401).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\css\浏览器兼容性记录%28011%29">浏览器兼容性记录(011).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\js">js</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\chrome控制台使用%28028%29">chrome控制台使用(028).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\fibonnacii%28091%29">fibonnacii(091).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\http缓存%28004%29">http缓存(004).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\iframe操作%28008%29">iframe操作(008).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js代码规范%28001%29">js代码规范(001).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js使用记录-兼容性">js使用记录-兼容性.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js使用记录">js使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js使用记录2">js使用记录2.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js内存管理%28013%29">js内存管理(013).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js复制内容到剪贴板%28007%29">js复制内容到剪贴板(007).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js字符串">js字符串.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js对象">js对象.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js常用方法">js常用方法.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js性能技巧%28005%29">js性能技巧(005).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js数据类型">js数据类型.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js数组API%28034%29">js数组API(034).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js文件操作%28009%29">js文件操作(009).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js正则表达式">js正则表达式.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js自定义log函数">js自定义log函数.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js表达式和运算符">js表达式和运算符.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\js错误处理%28004%29">js错误处理(004).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\new 操作符">new 操作符.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\onclick参数传递">onclick参数传递.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\setTimeout和setInterval">setTimeout和setInterval.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\this和call,apply,bind%28041%29">this和call,apply,bind(041).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\web存储%28014%29">web存储(014).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\全屏API%28010%29">全屏API(010).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\函数柯里化%28024%29">函数柯里化(024).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\函数节流与去抖%28024%29">函数节流与去抖(024).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\前端路由%28016%29">前端路由(016).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\文档在线预览">文档在线预览.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\滚动条操作%28025%29">滚动条操作(025).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\移动端tap事件学习%28071%29">移动端tap事件学习(071).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\移动设备软键盘操作%28072%29">移动设备软键盘操作(072).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\跨域操作%28006%29">跨域操作(006).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\跨页面通信%28015%29">跨页面通信(015).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\js\页面中特殊字符的处理">页面中特殊字符的处理.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\jsplus">jsplus</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\angularjs坑">angularjs坑.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\blob和base64%28021%29">blob和base64(021).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\bookmarklet%28015%29">bookmarklet(015).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\canvas库研究--非图表类">canvas库研究–非图表类.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\cef和debugView入门%28005%29">cef和debugView入门(005).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\fetch使用">fetch使用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\git操作">git操作.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\git文件忽略">git文件忽略.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\html使用记录">html使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\hybris开发">hybris开发.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\jquery学习">jquery学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\js模块规范%28014%29">js模块规范(014).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\layui使用记录">layui使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\mockData%28023%29">mockData(023).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\react学习">react学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\sketchpad">sketchpad.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\vjsOnWork">vjsOnWork.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\Vue和React比较">Vue和React比较.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\vue学习">vue学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\vue实用">vue实用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\webpack学习小结">webpack学习小结.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\web优化">web优化.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\yapi使用记录">yapi使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\三大框架比较">三大框架比较.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\前后端分离%28023%29">前后端分离(023).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\字符编码%28001%29">字符编码(001).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\文档注释生成库调研%28011%29">文档注释生成库调研(011).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\网络协议%28000%29">网络协议(000).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\jsplus\页面可视化编辑器设计">页面可视化编辑器设计.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\os">os</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\shell命令">shell命令.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\win+R运行程序">win+R运行程序.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\x-shell学习">x-shell学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\_x-shell学习">_x-shell学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\常用快捷键">常用快捷键.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\开机自启动">开机自启动.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\注册表百科">注册表百科.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\os\脚本语言%28023%29">脚本语言(023).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\others">others</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\chrome简单使用">chrome简单使用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\MySQL Cluster学习">MySQL Cluster学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\NSIS实用">NSIS实用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\vscode简单使用">vscode简单使用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\WebRTC研究%28015%29">WebRTC研究(015).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\_实时聊天%28090%29">_实时聊天(090).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\_微博数据研究">_微博数据研究.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\个人博客搭建技术研究">个人博客搭建技术研究.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\代理工具">代理工具.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\基于Hexo+NexT的博客搭建指导">基于Hexo+NexT的博客搭建指导.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\学习态度">学习态度.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\微博数据爬取">微博数据爬取.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\流程图软件">流程图软件.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\爬虫及SA和分词%28012%29">爬虫及SA和分词(012).md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\others\程序签名">程序签名.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\ser">ser</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\mysql学习">mysql学习.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\nginx配置">nginx配置.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\node使用">node使用.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\node库">node库.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\php使用记录">php使用记录.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\python初学">python初学.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../sum\ser\_mongoInPHP实际">_mongoInPHP实际.md</a><br>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;|__ <a href="../categories/sum\ser\_testMongo.php">_testMongo.php</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>PHP 面向对象-Runoob</title>
    <url>/w3/ser/php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-runoob/</url>
    <content><![CDATA[<p>toc and abstract.  </p>
<p>RUNOOB地址：<a href="http://www.runoob.com/php/php-oop.html" target="_blank" rel="noopener">http://www.runoob.com/php/php-oop.html</a></p>
<p style="text-align:right">2017.10.2 星期一 12:16</p>

<h2 id="一-面向对象内容"><a href="#一-面向对象内容" class="headerlink" title="一 面向对象内容"></a>一 面向对象内容</h2><p>类、对象、成员变量、成员函数、继承、父类、子类<br>多态、重载、抽象性、封装、构造函数、析构函数</p>
<h2 id="二-类定义"><a href="#二-类定义" class="headerlink" title="二 类定义"></a>二 类定义</h2><p>class关键字</p>
<h2 id="三-创建对象"><a href="#三-创建对象" class="headerlink" title="三 创建对象"></a>三 创建对象</h2><p>new运算符</p>
<h2 id="四-构造函数"><a href="#四-构造函数" class="headerlink" title="四 构造函数"></a>四 构造函数</h2><p>function _construct($par1,$par2){}</p>
<h2 id="五-析构函数"><a href="#五-析构函数" class="headerlink" title="五 析构函数"></a>五 析构函数</h2><p>function _destruct(){}</p>
<h2 id="六-继承"><a href="#六-继承" class="headerlink" title="六 继承"></a>六 继承</h2><p>extends关键字</p>
<h2 id="七-方法重写"><a href="#七-方法重写" class="headerlink" title="七 方法重写"></a>七 方法重写</h2><h2 id="八-访问控制"><a href="#八-访问控制" class="headerlink" title="八 访问控制"></a>八 访问控制</h2><p>关键字：</p>
<ul>
<li>public:公有的类成员可以在任何地方被访问。</li>
<li>protected:公有的类成员可以在任何地方被访问。</li>
<li>private：私有的类成员则只能被其定义所在的类访问。</li>
</ul>
<ol>
<li>属性的访问控制<br>类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。</li>
<li>方法的访问控制<br>类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</li>
</ol>
<h2 id="九-接口"><a href="#九-接口" class="headerlink" title="九 接口"></a>九 接口</h2><ol>
<li>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。</li>
<li>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。</li>
<li>接口中定义的所有方法都必须是公有，这是接口的特性。</li>
<li>要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 </li>
</ol>
<pre><code>// 声明一个&apos;iTemplate&apos;接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}
// 实现接口
class Template implements iTemplate
{
    private $vars = array();
    public function setVariable($name, $var)
    {
        $this-&gt;vars[$name] = $var;
    }
    public function getHtml($template)
    {
        foreach($this-&gt;vars as $name =&gt; $value) {
            $template = str_replace(&apos;{&apos; . $name . &apos;}&apos;, $value, $template);
        }
        return $template;
    }
}
</code></pre><h2 id="十-常量"><a href="#十-常量" class="headerlink" title="十 常量"></a>十 常量</h2><ul>
<li>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。</li>
<li>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。</li>
<li><p>自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。</p>
<pre><code>class MyClass
{
    const constant = &apos;常量值&apos;;
    function showConstant() {
        echo  self::constant . PHP_EOL;
    }
}
echo MyClass::constant . PHP_EOL;
$classname = &quot;MyClass&quot;;
echo $classname::constant . PHP_EOL; // 自 5.3.0 起
$class = new MyClass();
$class-&gt;showConstant();
echo $class::constant . PHP_EOL; // 自 PHP 5.3.0 起
</code></pre></li>
</ul>
<h2 id="十一-抽象类"><a href="#十一-抽象类" class="headerlink" title="十一 抽象类"></a>十一 抽象类</h2><ol>
<li>任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。</li>
<li>定义为抽象的类不能被实例化。</li>
<li>被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。</li>
<li>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；<br>另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。<br>此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。<h2 id="十二-Static-关键字"><a href="#十二-Static-关键字" class="headerlink" title="十二 Static 关键字"></a>十二 Static 关键字</h2></li>
</ol>
<ul>
<li>声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。</li>
<li>静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。</li>
<li>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。</li>
<li><p>静态属性不可以由对象通过 -&gt; 操作符来访问。</p>
<pre><code>class Foo {
    public static $my_static = &apos;foo&apos;;
    public function staticValue() {
        return self::$my_static;
    }
}
print Foo::$my_static . PHP_EOL;
$foo = new Foo();
print $foo-&gt;staticValue() . PHP_EOL;
</code></pre></li>
</ul>
<h2 id="十三-Final-关键字"><a href="#十三-Final-关键字" class="headerlink" title="十三 Final 关键字"></a>十三 Final 关键字</h2><p>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p>
<h2 id="十四-调用父类构造方法"><a href="#十四-调用父类构造方法" class="headerlink" title="十四 调用父类构造方法"></a>十四 调用父类构造方法</h2><p>PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。   </p>
<p style="text-align:right">2017.10.2 12:40</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>SQL 教程 （W3c）</title>
    <url>/w3/sql/SQL%E6%95%99%E7%A8%8B-w3c/</url>
    <content><![CDATA[<p>toc and abstract.</p>
<p>简单入门，也有一些left join等，还有函数<br><!-- 简单抄了目录，用的时候再查 --><br><!-- 《SQL必知必会》学习较多 --><br><a href="http://w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">http://w3school.com.cn/sql/index.asp</a>  </p>
<p style="text-align:right">2017.9.26 星期二 15:13</p>

<a id="more"></a>
<h2 id="一-基础教程"><a href="#一-基础教程" class="headerlink" title="一 基础教程"></a>一 基础教程</h2><h3 id="1-1-教程"><a href="#1-1-教程" class="headerlink" title="1.1 教程"></a>1.1 教程</h3><p>SQL 是用于访问和处理数据库的标准的计算机语言。<br>在本教程中，您将学到如何使用 SQL 访问和处理数据系统中的数据，这类数据库包括：Oracle, Sybase, SQL Server, DB2, Access 等等。</p>
<h3 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h3><h4 id="1-SQL-是用于访问和处理数据库的标准的计算机语言。"><a href="#1-SQL-是用于访问和处理数据库的标准的计算机语言。" class="headerlink" title="1 SQL 是用于访问和处理数据库的标准的计算机语言。"></a>1 SQL 是用于访问和处理数据库的标准的计算机语言。</h4><h4 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="什么是 SQL？"></a>什么是 SQL？</h4><p>SQL 指结构化查询语言<br>SQL 使我们有能力访问数据库<br>SQL 是一种 ANSI 的标准计算机语言   </p>
<blockquote>
<p>编者注：ANSI，美国国家标准化组织</p>
</blockquote>
<h4 id="2-SQL-是一种标准-但是…"><a href="#2-SQL-是一种标准-但是…" class="headerlink" title="2 SQL 是一种标准 - 但是…"></a>2 SQL 是一种标准 - 但是…</h4><p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。<br>SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。 </p>
<p>不幸地是，存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。<br>注释：除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的私有扩展！</p>
<h4 id="3-在您的网站中使用-SQL"><a href="#3-在您的网站中使用-SQL" class="headerlink" title="3 在您的网站中使用 SQL"></a>3 在您的网站中使用 SQL</h4><p>您需要以下要素：   </p>
<pre><code>1. RDBMS 数据库程序（比如 MS Access,SQL Server, MySQL）  
2. 服务器端脚本语言（比如 PHP 或 ASP）  
3. SQL  
4. HTML / CSS 
</code></pre><blockquote>
<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>RDBMS 指的是关系型数据库管理系统。 </p>
<p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server, IBM DB2, Oracle, MySQL 以及 Microsoft Access。  </p>
<p>RDBMS 中的数据存储在被称为表（tables）的数据库对象中。    </p>
<p>表是相关的数据项的集合，它由列和行组成。</p>
</blockquote>
<h3 id="1-3-语法"><a href="#1-3-语法" class="headerlink" title="1.3 语法"></a>1.3 语法</h3><h4 id="1-数据库表"><a href="#1-数据库表" class="headerlink" title="1 数据库表"></a>1 数据库表</h4><h4 id="2-SQL-语句"><a href="#2-SQL-语句" class="headerlink" title="2 SQL 语句"></a>2 SQL 语句</h4><pre><code>SELECT LastName FROM Persons
</code></pre><h4 id="3-重要事项"><a href="#3-重要事项" class="headerlink" title="3 重要事项"></a>3 重要事项</h4><p><strong>SQL 对大小写不敏感！</strong></p>
<h4 id="4-SQL-语句后面的分号？"><a href="#4-SQL-语句后面的分号？" class="headerlink" title="4 SQL 语句后面的分号？"></a>4 SQL 语句后面的分号？</h4><ol>
<li>某些数据库系统要求在每条 SQL 命令的末端使用分号。</li>
<li>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。</li>
<li>如果您使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。</li>
</ol>
<h4 id="5-SQL-DML-和-DDL"><a href="#5-SQL-DML-和-DDL" class="headerlink" title="5 SQL DML 和 DDL"></a>5 SQL DML 和 DDL</h4><h5 id="1-数据操作语言-DML-查询和更新"><a href="#1-数据操作语言-DML-查询和更新" class="headerlink" title="1.数据操作语言 (DML):查询和更新"></a>1.数据操作语言 (DML):查询和更新</h5><pre><code>SELECT - 从数据库表中获取数据  
UPDATE - 更新数据库表中的数据  
DELETE - 从数据库表中删除数据  
INSERT INTO - 向数据库表中插入数据  
</code></pre><h5 id="2-数据定义语言-DDL-创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。"><a href="#2-数据定义语言-DDL-创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。" class="headerlink" title="2. 数据定义语言 (DDL):创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。"></a>2. 数据定义语言 (DDL):创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</h5><pre><code>CREATE DATABASE - 创建新数据库  
ALTER DATABASE - 修改数据库  
CREATE TABLE - 创建新表  
ALTER TABLE - 变更（改变）数据库表   
DROP TABLE - 删除表  
CREATE INDEX - 创建索引（搜索键）  
DROP INDEX - 删除索引  
</code></pre><h3 id="1-4-select"><a href="#1-4-select" class="headerlink" title="1.4 select"></a>1.4 select</h3><pre><code>SELECT LastName,FirstName FROM Persons
SELECT * FROM Persons
</code></pre><h4 id="在结果集（result-set）中导航"><a href="#在结果集（result-set）中导航" class="headerlink" title="在结果集（result-set）中导航"></a>在结果集（result-set）中导航</h4><p>由 SQL 查询程序获得的结果被存放在一个结果集中。大多数数据库软件系统都允许使用编程函数在结果集中进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>
<p>类似这些编程函数不在本教程讲解之列。如需学习通过函数调用访问数据的知识，请访问我们的 ADO 教程 和 PHP 教程。</p>
<h3 id="1-5-distinct"><a href="#1-5-distinct" class="headerlink" title="1.5 distinct"></a>1.5 distinct</h3><pre><code>SELECT DISTINCT Company FROM Orders 
</code></pre><h3 id="1-6-where"><a href="#1-6-where" class="headerlink" title="1.6 where"></a>1.6 where</h3><pre><code>SELECT * FROM Persons WHERE City=&apos;Beijing&apos;
</code></pre><ul>
<li>在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</li>
<li>引号的使用:<br>SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。    </li>
</ul>
<h3 id="1-7-AND-amp-OR"><a href="#1-7-AND-amp-OR" class="headerlink" title="1.7 AND &amp; OR"></a>1.7 AND &amp; OR</h3><pre><code>SELECT * FROM Persons WHERE FirstName=&apos;Thomas&apos; AND LastName=&apos;Carter&apos;
SELECT * FROM Persons WHERE firstname=&apos;Thomas&apos; OR lastname=&apos;Carter&apos;
SELECT * FROM Persons WHERE (FirstName=&apos;Thomas&apos; OR FirstName=&apos;William&apos;) AND LastName=&apos;Carter&apos;
</code></pre><h3 id="1-8-Order-By-DESC、ASCs"><a href="#1-8-Order-By-DESC、ASCs" class="headerlink" title="1.8 Order By (DESC、ASCs)"></a>1.8 Order By (DESC、ASCs)</h3><pre><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company
SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber
SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC
SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC
</code></pre><h3 id="1-9-insert"><a href="#1-9-insert" class="headerlink" title="1.9 insert"></a>1.9 insert</h3><pre><code>//插入新的行
INSERT INTO Persons VALUES (&apos;Gates&apos;, &apos;Bill&apos;, &apos;Xuanwumen 10&apos;, &apos;Beijing&apos;)
//指定的列中插入数据
INSERT INTO Persons (LastName, Address) VALUES (&apos;Wilson&apos;, &apos;Champs-Elysees&apos;)
</code></pre><h3 id="1-0-update"><a href="#1-0-update" class="headerlink" title="1.0 update"></a>1.0 update</h3><pre><code>//更新某一行中的一个列
UPDATE Person SET FirstName = &apos;Fred&apos; WHERE LastName = &apos;Wilson&apos; 
//更新某一行中的若干列
UPDATE Person SET Address = &apos;Zhongshan 23&apos;, City = &apos;Nanjing&apos; WHERE LastName = &apos;Wilson&apos;
</code></pre><h3 id="1-1-delete"><a href="#1-1-delete" class="headerlink" title="1.1 delete"></a>1.1 delete</h3><pre><code>DELETE FROM Person WHERE LastName = &apos;Wilson&apos; 
//删除所有行:不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：
DELETE FROM table_name
DELETE * FROM table_name
</code></pre><h2 id="二-高级教程"><a href="#二-高级教程" class="headerlink" title="二 高级教程"></a>二 高级教程</h2><p>top,like,通配符,in,between,aliases,join/inner join/left join/right join/full join,union,select into,create db,create table,constraints,not null,unique,primary key,foreign key,check,default,create index,drop,alter,increment,view,date,nulls,isnull(),数据类型，服务器</p>
<h3 id="1-Top-PERCENT"><a href="#1-Top-PERCENT" class="headerlink" title="1 Top (-/PERCENT)"></a>1 Top (-/PERCENT)</h3><pre><code>SELECT TOP 2 * FROM Persons
SELECT TOP 50 PERCENT * FROM Persons
</code></pre><ul>
<li><p>MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的</p>
<pre><code>//Mysql
SELECT * FROM Persons LIMIT 5
//Oracle
SELECT * FROM Persons WHERE ROWNUM &lt;= 5
</code></pre></li>
</ul>
<h3 id="2-Like"><a href="#2-Like" class="headerlink" title="2 Like"></a>2 Like</h3><pre><code>SELECT * FROM Persons WHERE City LIKE &apos;N%&apos;
SELECT * FROM Persons WHERE City LIKE &apos;%g&apos;
SELECT * FROM Persons WHERE City LIKE &apos;%lon%&apos;
SELECT * FROM Persons WHERE City NOT LIKE &apos;%lon%&apos;
</code></pre><h3 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3 通配符"></a>3 通配符</h3><p>%  _ [charlist]  [^charlist]或者[!charlist]</p>
<pre><code>SELECT * FROM Persons WHERE City LIKE &apos;Ne%&apos;

SELECT * FROM Persons WHERE FirstName LIKE &apos;_eorge&apos;
SELECT * FROM Persons WHERE LastName LIKE &apos;C_r_er&apos;

SELECT * FROM Persons WHERE City LIKE &apos;[ALN]%&apos;
SELECT * FROM Persons WHERE City LIKE &apos;[!ALN]%&apos;
</code></pre><h3 id="4-In"><a href="#4-In" class="headerlink" title="4 In"></a>4 In</h3><pre><code>SELECT * FROM Persons WHERE LastName IN (&apos;Adams&apos;,&apos;Carter&apos;)
</code></pre><h3 id="5-Between"><a href="#5-Between" class="headerlink" title="5 Between"></a>5 Between</h3><pre><code>SELECT * FROM Persons WHERE LastName BETWEEN &apos;Adams&apos; AND &apos;Carter&apos;
SELECT * FROM Persons WHERE LastName NOT BETWEEN &apos;Adams&apos; AND &apos;Carter&apos;
</code></pre><blockquote>
<p>重要事项：不同的数据库对 BETWEEN…AND 操作符的处理方式是有差异的。某些数据库会列出介于 “Adams” 和 “Carter” 之间的人，但不包括 “Adams” 和 “Carter” ；某些数据库会列出介于 “Adams” 和 “Carter” 之间并包括 “Adams” 和 “Carter” 的人；而另一些数据库会列出介于 “Adams” 和 “Carter” 之间的人，包括 “Adams” ，但不包括 “Carter” 。<br>所以，请检查你的数据库是如何处理 BETWEEN….AND 操作符的！    </p>
</blockquote>
<h3 id="6-Aliases"><a href="#6-Aliases" class="headerlink" title="6 Aliases"></a>6 Aliases</h3><pre><code>SELECT po.OrderID, p.LastName, p.FirstName FROM Persons AS p, Product_Orders AS po WHERE p.LastName=&apos;Adams&apos; AND p.FirstName=&apos;John&apos;
//使用一个列名别名:结果列名更改了
SELECT LastName AS Family, FirstName AS Name FROM Persons
</code></pre><h3 id="7-Join-根据两个或多个表中的列之间的关系，从这些表中查询数据。"><a href="#7-Join-根据两个或多个表中的列之间的关系，从这些表中查询数据。" class="headerlink" title="7 Join: 根据两个或多个表中的列之间的关系，从这些表中查询数据。"></a>7 Join: 根据两个或多个表中的列之间的关系，从这些表中查询数据。</h3><pre><code>SELECT Persons.LastName, Persons.FirstName, rders.OrderNo
FROM Persons, Orders WHERE Persons.Id_P = Orders.Id_P
// 使用 Join 
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons INNER JOIN Orders ON Persons.Id_P = Orders.Id_P ORDER BY Persons.LastName
</code></pre><p>不同的 SQL JOIN</p>
<ul>
<li>INNER JOIN(内连接): 如果表中有至少一个匹配，则返回行</li>
<li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li>
<li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li>
<li>FULL JOIN: 只要其中一个表中存在匹配，就返回行<blockquote>
<p>注释：INNER JOIN 与 JOIN 是相同的。</p>
</blockquote>
</li>
</ul>
<h3 id="8-Inner-Join"><a href="#8-Inner-Join" class="headerlink" title="8 Inner Join"></a>8 Inner Join</h3><h3 id="9-Left-Join"><a href="#9-Left-Join" class="headerlink" title="9 Left Join"></a>9 Left Join</h3><h3 id="10-Right-Join"><a href="#10-Right-Join" class="headerlink" title="10 Right Join"></a>10 Right Join</h3><h3 id="11-Full-Join"><a href="#11-Full-Join" class="headerlink" title="11 Full Join"></a>11 Full Join</h3><h3 id="12-union-all-合并两个或多个-SELECT-语句的结果集。"><a href="#12-union-all-合并两个或多个-SELECT-语句的结果集。" class="headerlink" title="12 union (all): 合并两个或多个 SELECT 语句的结果集。"></a>12 union (all): 合并两个或多个 SELECT 语句的结果集。</h3><ul>
<li>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</li>
<li>注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</li>
<li><p>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<pre><code>SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA
SELECT E_Name FROM Employees_China UNION ALL SELECT E_Name FROM Employees_USA
</code></pre></li>
</ul>
<h3 id="13-select-into-用于创建表的备份复件"><a href="#13-select-into-用于创建表的备份复件" class="headerlink" title="13 select into: 用于创建表的备份复件"></a>13 select into: 用于创建表的备份复件</h3><pre><code>SELECT * INTO Persons_backup FROM Persons
//IN 子句可用于向另一个数据库中拷贝表：
SELECT * INTO Persons IN &apos;Backup.mdb&apos; FROM Persons
//如果我们希望拷贝某些域，可以在 SELECT 语句后列出这些域：
SELECT LastName,FirstName INTO Persons_backup FROM Persons
//也可以添加 WHERE 子句。
SELECT LastName,Firstname INTO Persons_backup FROM Persons WHERE City=&apos;Beijing&apos;
//从一个以上的表中选取数据也是可以做到的。
SELECT Persons.LastName,Orders.OrderNo INTO Persons_Order_Backup FROM Persons INNER JOIN Orders ON Persons.Id_P=Orders.Id_P
</code></pre><h3 id="14-create-db"><a href="#14-create-db" class="headerlink" title="14 create db"></a>14 create db</h3><pre><code>CREATE DATABASE my_db
</code></pre><h3 id="15-create-table"><a href="#15-create-table" class="headerlink" title="15 create table"></a>15 create table</h3><pre><code>CREATE TABLE Persons ( Id_P int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255) )
</code></pre><h3 id="16-约束-Constraints-用于限制加入表的数据的类型。"><a href="#16-约束-Constraints-用于限制加入表的数据的类型。" class="headerlink" title="16 约束 (Constraints):用于限制加入表的数据的类型。"></a>16 约束 (Constraints):用于限制加入表的数据的类型。</h3><h3 id="16-1-NOT-NULL"><a href="#16-1-NOT-NULL" class="headerlink" title="16.1 NOT NULL"></a>16.1 NOT NULL</h3><pre><code>CREATE TABLE Persons (Id_P int NOT NULL,LastName varchar255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) )
</code></pre><h3 id="16-2-UNIQUE"><a href="#16-2-UNIQUE" class="headerlink" title="16.2 UNIQUE"></a>16.2 UNIQUE</h3><p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p>
<h3 id="16-3-PRIMARY-KEY"><a href="#16-3-PRIMARY-KEY" class="headerlink" title="16.3 PRIMARY KEY"></a>16.3 PRIMARY KEY</h3><h3 id="16-4-FOREIGN-KEY"><a href="#16-4-FOREIGN-KEY" class="headerlink" title="16.4 FOREIGN KEY"></a>16.4 FOREIGN KEY</h3><h3 id="16-5-CHECK"><a href="#16-5-CHECK" class="headerlink" title="16.5 CHECK"></a>16.5 CHECK</h3><h3 id="16-6-DEFAULT"><a href="#16-6-DEFAULT" class="headerlink" title="16.6 DEFAULT"></a>16.6 DEFAULT</h3><h3 id="17-create-index"><a href="#17-create-index" class="headerlink" title="17 create index"></a>17 create index</h3><h3 id="18-drop"><a href="#18-drop" class="headerlink" title="18 drop"></a>18 drop</h3><h3 id="19-alter"><a href="#19-alter" class="headerlink" title="19 alter"></a>19 alter</h3><h3 id="20-alter"><a href="#20-alter" class="headerlink" title="20 alter"></a>20 alter</h3><h3 id="21-increment"><a href="#21-increment" class="headerlink" title="21 increment"></a>21 increment</h3><h3 id="22-view"><a href="#22-view" class="headerlink" title="22 view"></a>22 view</h3><h3 id="23-date"><a href="#23-date" class="headerlink" title="23 date"></a>23 date</h3><h3 id="24-nulls"><a href="#24-nulls" class="headerlink" title="24 nulls"></a>24 nulls</h3><h3 id="25-isnull"><a href="#25-isnull" class="headerlink" title="25 isnull()"></a>25 isnull()</h3><h3 id="26-数据类型"><a href="#26-数据类型" class="headerlink" title="26 数据类型"></a>26 数据类型</h3><p>Microsoft Access、MySQL 以及 SQL Server 所使用的数据类型和范围。<br>参考链接：<a href="http://w3school.com.cn/sql/sql_datatypes.asp" target="_blank" rel="noopener">http://w3school.com.cn/sql/sql_datatypes.asp</a></p>
<h4 id="1-Microsoft-Access-数据类型"><a href="#1-Microsoft-Access-数据类型" class="headerlink" title="1.Microsoft Access 数据类型"></a>1.Microsoft Access 数据类型</h4><p>Text  Memo  Byte  Integer  Long  Single  Double  Currency  AutoNumber  Date/Time  Yes/No  Ole-Object  Hyperlink  Lookup Wizard</p>
<h4 id="2-MySQL-数据类型"><a href="#2-MySQL-数据类型" class="headerlink" title="2.MySQL 数据类型"></a>2.MySQL 数据类型</h4><p>在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。</p>
<ul>
<li>text: CHAR(size)  VARCHAR(size) TINYTEXT TEXT BLOB  MEDIUMTEXT  MEDIUMBLOB  LONGTEXT  LONGBLOB   ENUM(x,y,z,etc.)  SET    </li>
<li>number: TINYINT(size)  SMALLINT(size)  MEDIUMINT(size)  INT(size)  BIGINT(size)  FLOAT(size,d)  DOUBLE(size,d)  DECIMAL(size,d)</li>
<li>date: DATE()  DATETIME()  TIME()  YEAR()</li>
</ul>
<h4 id="3-SQL-Server-数据类型"><a href="#3-SQL-Server-数据类型" class="headerlink" title="3.SQL Server 数据类型"></a>3.SQL Server 数据类型</h4><ul>
<li>Character 字符串：</li>
<li>Unicode 字符串：</li>
<li>Binary 类型：</li>
<li>Number 类型：</li>
<li>Date 类型：</li>
<li>其他数据类型：<h3 id="27-服务器"><a href="#27-服务器" class="headerlink" title="27 服务器"></a>27 服务器</h3>现代的 SQL 服务器构建在 RDBMS 之上。</li>
<li><h4 id="DBMS-数据库管理系统（Database-Management-System）"><a href="#DBMS-数据库管理系统（Database-Management-System）" class="headerlink" title="DBMS - 数据库管理系统（Database Management System）"></a>DBMS - 数据库管理系统（Database Management System）</h4><p>   数据库管理系统是一种可以访问数据库中数据的计算机程序。 </p>
<p>   DBMS 使我们有能力在数据库中提取、修改或者存贮信息。  </p>
<p>   不同的 DBMS 提供不同的函数供查询、提交以及修改数据。  </p>
</li>
<li><h4 id="RDBMS-关系数据库管理系统（Relational-Database-Management-System）"><a href="#RDBMS-关系数据库管理系统（Relational-Database-Management-System）" class="headerlink" title="RDBMS - 关系数据库管理系统（Relational Database          Management System）"></a>RDBMS - 关系数据库管理系统（Relational Database          Management System）</h4><p>   关系数据库管理系统 (RDBMS) 也是一种数据库管理系统，其数据库是根据数据间的关系来组织和访问数据的。  </p>
<p>   20 世纪 70 年代初，IBM 公司发明了 RDBMS。  </p>
<p>   RDBMS 是 SQL 的基础，也是所有现代数据库系统诸如 Oracle、SQL Server、IBM DB2、Sybase、MySQL 以及 Microsoft Access 的基础。</p>
</li>
</ul>
<h2 id="三-函数"><a href="#三-函数" class="headerlink" title="三 函数"></a>三 函数</h2><h3 id="functions-avg-count-first-last-max-min-sum-group-by-having-ucase-lcase-mid-round-now-format"><a href="#functions-avg-count-first-last-max-min-sum-group-by-having-ucase-lcase-mid-round-now-format" class="headerlink" title="functions-,avg,count,first,last,max,min,sum,group by-,having-,ucase,lcase,mid,round,now,format"></a>functions-,avg,count,first,last,max,min,sum,group by-,having-,ucase,lcase,mid,round,now,format</h3><h3 id="1-functions"><a href="#1-functions" class="headerlink" title="1 functions"></a>1 functions</h3><ul>
<li>合计函数（Aggregate functions）: 的操作面向一系列的值，并返回一个单一的值。<blockquote>
<p>注释：如果在 SELECT 语句的项目列表中的众多其它表达式中使用 SELECT 语句，则这个 SELECT 必须使用 GROUP BY 语句！</p>
</blockquote>
</li>
<li>Scalar 函数: 的操作面向某个单一的值，并返回基于输入值的一个单一的值。    </li>
</ul>
<h3 id="2-avg"><a href="#2-avg" class="headerlink" title="2 avg"></a>2 avg</h3><pre><code>SELECT AVG(OrderPrice) AS OrderAverage FROM Orders
SELECT Customer FROM Orders WHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders)
</code></pre><h3 id="3-count"><a href="#3-count" class="headerlink" title="3 count"></a>3 count</h3><pre><code>SELECT COUNT(Customer) AS CustomerNilsen FROM Orders WHERE Customer=&apos;Carter&apos;
//总行数
SELECT COUNT(*) AS NumberOfOrders FROM Orders
//表中不同客户的数目
SELECT COUNT(DISTINCT Customer) AS NumberOfCustomers FROM Orders
</code></pre><h3 id="4-first"><a href="#4-first" class="headerlink" title="4 first"></a>4 first</h3><pre><code>SELECT FIRST(OrderPrice) AS FirstOrderPrice FROM Orders
</code></pre><h3 id="5-last"><a href="#5-last" class="headerlink" title="5 last"></a>5 last</h3><h3 id="6-max"><a href="#6-max" class="headerlink" title="6 max"></a>6 max</h3><h3 id="7-min"><a href="#7-min" class="headerlink" title="7 min"></a>7 min</h3><h3 id="8-sum"><a href="#8-sum" class="headerlink" title="8 sum"></a>8 sum</h3><h3 id="9-group-by"><a href="#9-group-by" class="headerlink" title="9 group by-"></a>9 group by-</h3><p>用于结合合计函数，根据一个或多个列对结果集进行分组。</p>
<pre><code>//不使用的话，都5700
SELECT Customer,SUM(OrderPrice) FROM Orders GROUP BY Customer
//也可以对一个以上的列应用 GROUP BY 语句
SELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders GROUP BY Customer,OrderDate
</code></pre><h3 id="10-having"><a href="#10-having" class="headerlink" title="10 having-"></a>10 having-</h3><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</p>
<pre><code>SELECT Customer,SUM(OrderPrice) FROM Orders GROUP BY Customer HAVING SUM(OrderPrice)&lt;2000
SELECT Customer,SUM(OrderPrice) FROM Orders WHERE Customer=&apos;Bush&apos; OR Customer=&apos;Adams&apos; GROUP BY Customer HAVING SUM(OrderPrice)&gt;1500
</code></pre><h3 id="11-ucase"><a href="#11-ucase" class="headerlink" title="11 ucase"></a>11 ucase</h3><h3 id="12-lcase"><a href="#12-lcase" class="headerlink" title="12 lcase"></a>12 lcase</h3><h3 id="13-mid"><a href="#13-mid" class="headerlink" title="13 mid"></a>13 mid</h3><h3 id="14-len"><a href="#14-len" class="headerlink" title="14 len"></a>14 len</h3><h3 id="15-round"><a href="#15-round" class="headerlink" title="15 round"></a>15 round</h3><h3 id="16-now"><a href="#16-now" class="headerlink" title="16 now"></a>16 now</h3><h3 id="17-format"><a href="#17-format" class="headerlink" title="17 format"></a>17 format</h3><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><h3 id="1-快速参考"><a href="#1-快速参考" class="headerlink" title="1 快速参考"></a>1 快速参考</h3><h3 id="2-教程总结"><a href="#2-教程总结" class="headerlink" title="2 教程总结"></a>2 教程总结</h3><h2 id="五-测验"><a href="#五-测验" class="headerlink" title="五 测验"></a>五 测验</h2><p style="text-align:right">2017.9.26 二 18:14</p>


<table>
<thead>
<tr>
<th>章节</th>
<th>学习情况</th>
<th>截止日期</th>
<th>后期安排</th>
</tr>
</thead>
<tbody>
<tr>
<td>noted</td>
<td>md * 简明日志</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>coded</td>
<td>看了的部分都 coded</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>高级、函数</td>
<td>看了半块</td>
<td>2017.9.26 2</td>
<td>抽空、neededThenWork</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>w3</category>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>8天学通MongoDB</title>
    <url>/w3/sql/mongodb8days/</url>
    <content><![CDATA[<p>toc and abstract of fore4days.</p>
<!-- # 8天学通MongoDB -->
<!-- 简单入门；简要抄了前四天。后四天高级过了一下，理解没有不知道。反正没有实践过    
这几天(2018年3月）掌握了一些简单API的高级操作，主要是操作符的使用；还是和php 搭配 -->
<p><a href="http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html" target="_blank" rel="noopener">http://www.cnblogs.com/huangxincheng/archive/2012/02/18/2356595.html</a>  </p>
<p style="text-align:right">2017.9.22 星期五 17:24</p>

<a id="more"></a> 
<p>从文章链接可以大概看到发表时间</p>
<h2 id="Ⅰ-基础入门"><a href="#Ⅰ-基础入门" class="headerlink" title="Ⅰ 基础入门"></a>Ⅰ 基础入门</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h3><p>目录结构：mongodb   /bin/*.exe  GNU-AGPL–3.0  README  THIRD-PARTY-NOTICES </p>
<h3 id="2-启动-mongod-–path-E-mongodb-db"><a href="#2-启动-mongod-–path-E-mongodb-db" class="headerlink" title="2 启动  mongod –path=E:mongodb/db"></a>2 启动  mongod –path=E:mongodb/db</h3><p>先建立数据存放文件夹 mongodb/db</p>
<h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3 基本操作"></a>3 基本操作</h3><ol>
<li><p>insert</p>
<pre><code>db.person.insert({&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:20})
</code></pre></li>
<li><p>find </p>
<pre><code>db.person.find()
</code></pre></li>
<li><p>update</p>
<pre><code>db.person.update({&quot;name&quot;:&quot;jack&quot;},{&quot;name&quot;:&quot;joe&quot;,&quot;age&quot;:30})        
</code></pre></li>
<li><p>remove    (count)</p>
<pre><code>db.person.remove()
db.person.find()
db.person.count()
</code></pre></li>
</ol>
<h2 id="Ⅱ-细说增删查改"><a href="#Ⅱ-细说增删查改" class="headerlink" title="Ⅱ 细说增删查改"></a>Ⅱ 细说增删查改</h2><p>插曲：打不开mongodbl–》干掉“lock file”文件（管理方式中分享）</p>
<h3 id="一-insert操作"><a href="#一-insert操作" class="headerlink" title="一 insert操作"></a>一 insert操作</h3><p>JSON   BSON</p>
<ol>
<li><p>单条插入<br>mongo命令打开的是js shell,所以js语法同。  </p>
<pre><code>var single={.. }       
db.person.insert(single)
</code></pre></li>
<li>批量插入<br>没有提供给shell 这样的方法，可以自己写for循环,里面insert<h3 id="二-find操作"><a href="#二-find操作" class="headerlink" title="二 find操作"></a>二 find操作</h3></li>
<li><p>$gt $gte $lt $lte $ne 无 =====  &gt;,&gt;=,&lt;,&lt;=,!=,=</p>
<pre><code>db.mycol.find({&quot;likes&quot;:{$lt:50}})
</code></pre></li>
<li>无  $or  $in  $nin  ========and,or,in,notin</li>
<li>正则</li>
<li><p>$where</p>
<pre><code>db.user.find({$where:function(){return this.name==&apos;jack&apos;}})
</code></pre><h3 id="三-update操作"><a href="#三-update操作" class="headerlink" title="三 update操作"></a>三 update操作</h3></li>
<li>整体更新<br>update （上一篇的）</li>
<li><p>局部更新</p>
<ol>
<li><p>$inc   increase，没有就创建</p>
<pre><code>db.user.update({&quot;name&quot;:&quot;jack},{$inc:{&quot;age&quot;:30}})
</code></pre></li>
<li><p>$set   </p>
<pre><code>db.user.update({&quot;name&quot;:&quot;jack},{$set:{&quot;age&quot;:30}})
</code></pre></li>
</ol>
</li>
<li><p>upsert操作<br>没查到就新增一条,避免 update，add判断。。第三个参数设true</p>
<pre><code>db.user.update({&quot;name&quot;:&quot;jack},{$inc:{&quot;age&quot;:30}},true)
</code></pre></li>
<li>批量更新<br>第四个参数设为true</li>
</ol>
<h3 id="四-remove操作"><a href="#四-remove操作" class="headerlink" title="四 remove操作"></a>四 remove操作</h3><p>上一篇讲了</p>
<h2 id="Ⅲ-细说高级操作"><a href="#Ⅲ-细说高级操作" class="headerlink" title="Ⅲ 细说高级操作"></a>Ⅲ 细说高级操作</h2><p>主要包括：聚合，游标</p>
<h3 id="一-聚合"><a href="#一-聚合" class="headerlink" title="一 聚合"></a>一 聚合</h3><p>count  distinct group mapReduce  </p>
<ol>
<li><p>count   </p>
<pre><code>db.person.count()
db.person.count({&quot;age&quot;:20})
</code></pre></li>
<li><p>distinct</p>
<pre><code>db.person.distinct(&quot;age&quot;)
</code></pre></li>
<li><p>group<br>三个参数<br>过滤：两个可选参数:conditon  finalize</p>
<pre><code>db.person.group({
    &quot;key&quot;:{&quot;age&quot;:true},//分组的key
    &quot;initial&quot;:{&quot;person&quot;:[]},//每组都分享一个“初始函数”:20一个，22一个
    &quot;$reduce&quot;:function(cur,prev){
        //cur当前文档对象，  
        //prev上一次function操作的累计对象，第一次为{&quot;person&quot;:[]}。有多少文档，就调用继承
        prev.person.push(cur.name)
    },
    &quot;finalize&quot;:function(){
        out.count=out.person.length;
    },
    &quot;condition&quot;:{&quot;age&quot;:{$lt:25}}
})
//输出
[
    {
        &quot;age&quot;:20,
        &quot;person&quot;:[&quot;jack&quot;,&quot;mary&quot;],
        &quot;count&quot;:2  //可选参数
    },
    {
        &quot;age&quot;:22,
        &quot;person&quot;:[&quot;jack2&quot;,&quot;mary2&quot;,&quot;fugui&quot;],
        &quot;count&quot;:3   //可选参数
    },
    //过滤后下面的就没有了
    {
        &quot;age&quot;:26,
        &quot;person&quot;:[&quot;jack11&quot;,&quot;mary&quot;]
    }
]
</code></pre></li>
<li><p>mapReduce<br> 这玩意算是聚合函数中最复杂的了，不过复杂也好，越复杂就越灵活。</p>
<p> mapReduce其实是一种编程模型，用在分布式计算中，其中有一个“map”函数，一个”reduce“函数。</p>
<ul>
<li><p>map：<br>这个称为映射函数，里面会调用emit(key,value)，集合会按照你指定的key进行映射分组。</p>
</li>
<li><p>reduce：<br>这个称为简化函数，会对map分组后的数据进行分组简化，注意：在reduce(key,value)中的key就是</p>
<p> emit中的key，vlaue为emit分组后的emit(value)的集合，这里也就是很多{“count”:1}的数组。</p>
</li>
<li><p>mapReduce:<br>这个就是最后执行的函数了，参数为map，reduce和一些可选参数。具体看图可知：  </p>
<pre><code>function map(){
   emit(this.name,{count:1});
} 
function reduce(key,value){
   var result={count:0};
   for(var i=0;i&lt;value.length;i++){
       result.count+=value[i].count;
   }
   return result;
}

db.person.mapReduce(map,reduce,{&quot;out&quot;:&quot;collection&quot;})
{
   &quot;result&quot;:&quot;collection&quot;,//存放的集合名
   &quot;timeMillis&quot;:14,//
   &quot;counts&quot;:{
       &quot;input&quot;:7,//传入文档的个数
       &quot;emit&quot;:,7,//此函数被调用的次数
       &quot;reduce&quot;:3,//此函数被调用的次数
       &quot;output&quot;:4//最后返回文档的个数
   },
   &quot;ok&quot;:1,
}
//最后我们看一下“collecton”集合里面按姓名分组的情况。
db.collection.find()

</code></pre></li>
</ul>
</li>
</ol>
<h3 id="二-游标"><a href="#二-游标" class="headerlink" title="二 游标"></a>二 游标</h3><p>针对这样的操作，list其实并没有获取到person中的文档，<br>而是申明一个“查询结构”，<br>等我们需要的时候通过for或者next()一次性加载过来，然后让游标逐行读取，<br>当我们枚举完了之后，游标销毁，(之后我们在通过list获取时,发现没有数据返回了)</p>
<pre><code>var list=db.person.find();
list.forEach(function(x){
    print(x.name)
})
//逐个输出后
list
//没有数据返回了
</code></pre><p>当然我们的“查询构造”还可以搞的复杂点，比如分页，排序都可以加进去。<br>那么这样的“查询构造”可以在我们需要执行的时候执行，大大提高了不必要的花销。</p>
<pre><code>var single=db.person.find().sort({&quot;name&quot;,1}).skip(2).limit(2);
</code></pre><h2 id="Ⅳ-索引操作"><a href="#Ⅳ-索引操作" class="headerlink" title="Ⅳ 索引操作"></a>Ⅳ 索引操作</h2><p>CURD，通常我们又会花费50%的时间在R上面  </p>
<p>5种经典的查找，包括我们今天所说的“索引查找”</p>
<p>我们首先插入10w数据</p>
<h3 id="一-性能分析函数-explain"><a href="#一-性能分析函数-explain" class="headerlink" title="一 性能分析函数 explain"></a>一 性能分析函数 explain</h3><p>仔细看红色区域，有几个我们关心的key:<br>   cursor:       这里出现的是”BasicCursor”,什么意思呢，就是说这里的查找采用的是“表扫描”，也就是顺序查找，很悲催啊。<br>   nscanned:  这里是10w，也就是说数据库浏览了10w个文档，很恐怖吧，这样玩的话让人受不了啊。<br>   n:  这里是1，也就是最终返回了1个文档。<br>   millis:        这个就是我们最最最….关心的东西，总共耗时114毫秒。 </p>
<pre><code>db.person.find({&quot;name&quot;:&quot;hxc&quot;+1000}).explain()
</code></pre><h3 id="二-建立索引-ensureIndex"><a href="#二-建立索引-ensureIndex" class="headerlink" title="二 建立索引 ensureIndex"></a>二 建立索引 ensureIndex</h3><pre><code>db.person.ensureIndex({&quot;name&quot;:1})  //-1降序
db.person.find({&quot;name&quot;:&quot;hxc&quot;+1000}).explain()
</code></pre><h3 id="三-唯一索引"><a href="#三-唯一索引" class="headerlink" title="三 唯一索引"></a>三 唯一索引</h3><pre><code>db.person.ensureIndex({&quot;name&quot;:1},{&quot;unique&quot;:true})
db.person.insert({&quot;name&quot;:&quot;hxc&quot;,&quot;age&quot;:20})
db.person.insert({&quot;name&quot;:&quot;hxc&quot;,&quot;age&quot;:22})//报错
</code></pre><h3 id="四-组合索引"><a href="#四-组合索引" class="headerlink" title="四 组合索引"></a>四 组合索引</h3><ol>
<li><p>有时候我们的查询不是单条件的，可能是多条件</p>
<pre><code>db.person.ensureIndex({&quot;name&quot;:1,&quot;birthday&quot;:1}) 
db.person.ensureIndex({&quot;birthday&quot;:1,&quot;name&quot;:1}) 
</code></pre><p>看到上图，大家或者也知道name跟birthday的不同，建立的索引也不同，升序和降序的顺序不同都会产生不同的索引，</p>
</li>
<li><p>那么我们可以用getindexes来查看下person集合中到底生成了那些索引。</p>
<pre><code>db.person.getIndexes()
</code></pre></li>
<li><p>此时我们肯定很好奇，到底查询优化器会使用哪个查询作为操作，呵呵，还是看看效果图：   </p>
<pre><code>db.person.find({&quot;birthday&quot;:&quot;1989-3-2&quot;,&quot;name&quot;:&quot;jack&quot;}).explain()
</code></pre><p> 看完上图我们要相信查询优化器，它给我们做出的选择往往是最优的，因为我们做查询时，查询优化器会使用我们建立的这些索引来创建查询方案，</p>
<p> 如果某一个先执行完则其他查询方案被close掉，这种方案会被mongodb保存起来，</p>
</li>
<li><p>当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了hint方法让我们可以暴力执行。</p>
<pre><code>db.person.find({&quot;birthday&quot;:&quot;1989-3-2&quot;,&quot;name&quot;:&quot;jack&quot;}).hint({&quot;birthday&quot;:&quot;1989-3-2&quot;,&quot;name&quot;:&quot;jack&quot;}).explain()
</code></pre></li>
</ol>
<h3 id="五-删除索引"><a href="#五-删除索引" class="headerlink" title="五 删除索引"></a>五 删除索引</h3><p>可能随着业务需求的变化，原先建立的索引可能没有存在的必要了，</p>
<p>（可能有的人想说没必要就没必要呗，）<br>但是请记住，索引会降低CUD这三种操作的性能，因为这玩意需要实时维护，所以啥问题都要综合考虑一下，这里就把刚才建立的索引清空掉来演示一下:dropIndexes的使用。</p>
<pre><code>db.person.dropIndexes(&quot;name_1&quot;)
</code></pre><p style="text-align:right">长_天_B#805 2017.9.22五 19:24</p>

<table>
<thead>
<tr>
<th>章节</th>
<th>学习情况</th>
<th>截止日期</th>
<th>后期安排</th>
</tr>
</thead>
<tbody>
<tr>
<td>noted</td>
<td>前四天noted</td>
<td>2017.9.22</td>
<td>deSituation</td>
</tr>
<tr>
<td>coded</td>
<td>后四天coded</td>
<td>2017.9.22</td>
<td>deSituation</td>
</tr>
<tr>
<td>八天全</td>
<td>之前过了一遍</td>
<td>2017.9.*</td>
<td>———-</td>
</tr>
<tr>
<td>前四天</td>
<td>看了半块</td>
<td>2017.9.22 5</td>
<td>waitToWork</td>
</tr>
<tr>
<td>后四天</td>
<td>———</td>
<td>———</td>
<td>dework</td>
</tr>
</tbody>
</table>
<h2 id="Ⅴ-主从复制"><a href="#Ⅴ-主从复制" class="headerlink" title="Ⅴ 主从复制"></a>Ⅴ 主从复制</h2><h2 id="Ⅵ-分片技术"><a href="#Ⅵ-分片技术" class="headerlink" title="Ⅵ 分片技术"></a>Ⅵ 分片技术</h2><h2 id="Ⅶ-运维技术"><a href="#Ⅶ-运维技术" class="headerlink" title="Ⅶ 运维技术"></a>Ⅶ 运维技术</h2><h2 id="Ⅷ-驱动实践"><a href="#Ⅷ-驱动实践" class="headerlink" title="Ⅷ 驱动实践"></a>Ⅷ 驱动实践</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>sql</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>videojs在play.asp使用过程中的坑</title>
    <url>/sum/jsplus/vjsOnWork/</url>
    <content><![CDATA[<p>video.js在使用过程中遇到的一些问题</p>
<p style="text-align:right">2017.9.21 四 16:20</p>

<a id="more"></a>
<!-- 两个月前就已经开始接触videojs了 -->
<h1 id="A-videojs-documention"><a href="#A-videojs-documention" class="headerlink" title="A videojs documention"></a>A videojs documention</h1><p><a href="https://github.com/videojs/video.js/" target="_blank" rel="noopener">https://github.com/videojs/video.js/</a><br><strong>$_BLOB:</strong> <a href="https://yalhu.github.io/w3/jslib/videojs文档" target="_blank" rel="noopener">videojs文档</a></p>
<h1 id="B-videojs和play-asp"><a href="#B-videojs和play-asp" class="headerlink" title="B videojs和play.asp"></a>B videojs和play.asp</h1><h2 id="0-控制：jQuery-VS-vjs"><a href="#0-控制：jQuery-VS-vjs" class="headerlink" title="0 控制：jQuery VS vjs"></a>0 控制：jQuery VS vjs</h2><ul>
<li><p>vjs有自己的组件，事件，方法等，和jQ的性质差不多；既然是用vjs，就尽量用vjs的方法操作，API也方便（使用中发现，有优点，有缺点:页面加载完之前，是不到jQ对象的）。</p>
</li>
<li><p>vjs的<code>setTimeout ,requestAnimation</code>等方法</p>
</li>
<li><p>优点中，当然包括方便的video API ，DOM操作</p>
</li>
</ul>
<h2 id="1-多语言"><a href="#1-多语言" class="headerlink" title="1 多语言"></a>1 多语言</h2><ol>
<li><p>当时自己的多语言有点问题，==》用了vjs的多语言；<br>还有些通过<code>.el()</code>添加的dom（速度、质量等把一个vjs组件的子元素重写了），并不会引vjs用多语言，就借了其他的块相同vjs组件。</p>
</li>
<li><p>后来发现，多语言要提交给三方翻译，其他地方也要用。基于同一的理念，弃用了vjs的多语言   </p>
</li>
</ol>
<h2 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h2><ol>
<li><p>vjs有很多组件，在写menu，subtitle，quality，rate时，考虑要不要重新注册vjs组    件。<br>基于上面的元素有一些不确定性（字幕，质量等的多少没法控制，后面使用起来估计也不方便），既然有现成的，就还是用vjs的组件的，方便。</p>
</li>
<li><p>后来，准备控制条的tips时也准备注册组件，因为原生的title点击后会重新出现，而且    有些tips的内容有些许出入。<br>看了，vjs的源码，通过源码的比对，在js中重新夺回了控制权。  </p>
</li>
<li><p>menu，subtitle，quality，rate等的添加，增加了许多判断：div_index,control-bar-hold,tips,menu….</p>
</li>
<li><p>controlBar在点击的时候，是否需要保持，出现状态。<br>tips在移动设备上不需要出现。</p>
</li>
</ol>
<p>后来又做到注释—-多了组件，和前面几个menu_**是不一样的风格，考虑是不是样式/设计不用vjs的，写html的时候可以用原生、jQuery或者其他的库，只是单纯的引用vjs的API</p>
<h2 id="3-事件"><a href="#3-事件" class="headerlink" title="3 事件"></a>3 事件</h2><ol>
<li><p>勾子函数没有一次用上的  </p>
</li>
<li><p>和dashjs一起使用，mediaplay的事件监听收到限制，需要提前注册    </p>
</li>
<li>由于以上两条：本地记录播放质量，字幕等时，在播放之前就设置有点困难。<br>所以，选择了监听player的播放事件。（只有速度成功了；字幕取不到，质量无法设置）。</li>
</ol>
<h1 id="C-坑（issues）"><a href="#C-坑（issues）" class="headerlink" title="C 坑（issues）"></a>C 坑（issues）</h1><h2 id="0-vjs-基础"><a href="#0-vjs-基础" class="headerlink" title="0 vjs 基础"></a>0 vjs 基础</h2><ol>
<li><p>只有controls，才可以绑定video上 播放/暂停 事件</p>
</li>
<li><p>用js设置video宽高<code>video1.style.height=&#39;260px&#39;</code>，会阻止，video的全屏</p>
<blockquote>
<p>videojs/video.js/issues/1293</p>
</blockquote>
</li>
<li><p>tap、click事件及冒泡问题</p>
</li>
<li><p>palyer的useractive（）事件，会触发控制条出现，但随后会消失:即使移除了，vjs的vjs-user-inactive样式，其他vjs的操作，又会对useractive 重新负值。。</p>
<p> ==》自定义了arv-controlBar-hold</p>
</li>
<li>同上面一样，自定义了arv-tip-enabled<br>播放/暂停<br>移动的tap和阻止事件冒泡</li>
<li>没有animate函数(jQuery)，有requestAnimationFrame(fn),和cancel</li>
<li>重新定义的setTimeout，setInterval    </li>
<li>ios音量组件的考虑</li>
<li>移动端好像，监测不到video的事件<code>video.width(),video.currentTime()</code>,同样的pc就没有问题。最后都改成player的事件(4674)     </li>
</ol>
<h3 id="ModalDialog"><a href="#ModalDialog" class="headerlink" title="ModalDialog"></a>ModalDialog</h3><p>ModalDialog 使用出现问题：不能定义content中的内容；description 是在原有的基础加了test，而不是单独的test   </p>
<blockquote>
<p>\4463<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var modal_content = &apos;&lt;div id=&quot;do-this&quot;&gt;do this&lt;/div&gt; &lt;div id=&quot;do-that&quot;&gt;do that&lt;/div&gt;&apos;;</span><br><span class="line">// where the magic happens</span><br><span class="line">var contentEl = document.createElement(&apos;div&apos;);</span><br><span class="line">// probably better to just build the entire thing via DOM methods</span><br><span class="line">contentEl.innerHTML = modal_content;</span><br><span class="line">var ModalDialog = videojs.getComponent(&apos;ModalDialog&apos;);</span><br><span class="line">var modal = new ModalDialog(player, &#123;</span><br><span class="line">	content: contentEl,</span><br><span class="line">	temporary: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// $_sel</span><br><span class="line">arv_title.contentEl().innerHTML=&apos;&lt;b&gt;sdfs&lt;/b&gt;sdfs&apos;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="1-player没有tap事件"><a href="#1-player没有tap事件" class="headerlink" title="1 player没有tap事件"></a>1 player没有tap事件</h2><p>sol:绑定div_video,自定义tap</p>
<blockquote>
<pre><code>//自定义tap
$$(document).on(&quot;touchstart&quot;, function(e) {
    if(!$$(e.target).hasClass(&quot;disable&quot;))  
    $$&gt;e.target).data(&quot;isMoved&quot;, 0);
});
$$(document).on(&quot;touchmove&quot;, function(e) {
    if(!$$(e.target).hasClass(&quot;disable&quot;)) 
    $$(e.target).data(&quot;isMoved&quot;, 1);
});
$$(document).on(&quot;touchend&quot;, function(e) {
    if(!$$(e.target).hasClass(&quot;disable&quot;) &amp;&amp; $$(e.target).data(&quot;isMoved&quot;) == 0) 
    $$(e.target).trigger(&quot;tap&quot;);
});
</code></pre></blockquote>
<h2 id="2-事件冒泡"><a href="#2-事件冒泡" class="headerlink" title="2 事件冒泡"></a>2 事件冒泡</h2><ul>
<li>click： BUTTON，会； MENUITEM、 PROGRESS-CONTROL不会</li>
<li>tap：都冒泡          </li>
</ul>
<p>sol: e.target==this</p>
<h2 id="3-player-tap事件，在iPad中"><a href="#3-player-tap事件，在iPad中" class="headerlink" title="3 player  tap事件，在iPad中"></a>3 player  tap事件，在iPad中</h2><ul>
<li><p>\<video>有controls(true)，vjs的tap事件，才会在iPad中作用，controlBar出现；</video></p>
<blockquote>
<p>#1886 2015.2.26: Unfortunately, this is how the video element works as well. Disabling controls also disables click events, so if you want to set something like this up you’ll need to add click event handlers to the Videojs element.</p>
</blockquote>
</li>
<li><p>自定义tap，在iPad中还会触发click，其他移动设备（包括iPhone）没有这种现象<br>sol：e.preventDefault();  </p>
</li>
</ul>
<blockquote>
<p>扩展：根据解释，只有video标签 controls才能触发click等事件；而且其上的一些其他元素的事件都不能触发，只会触发video标签的<br>#642 2013.7.16: Yes, this is an iOS issue. VideoJS on iOS falls back to the native controls.<br>If the native controls on iOS are enabled, iOS will not let anyone listen to any events in the area above the video element.<br>You could remove the ‘controls’ attribute of the video element whenever you want to listen to click events and then put it back when you’re done.   </p>
</blockquote>
<h2 id="4-IOS中出现的问题"><a href="#4-IOS中出现的问题" class="headerlink" title="4 IOS中出现的问题"></a>4 IOS中出现的问题</h2><h3 id="4-1-不能播放dash，包括用了dashjs"><a href="#4-1-不能播放dash，包括用了dashjs" class="headerlink" title="4.1 不能播放dash，包括用了dashjs"></a>4.1 不能播放dash，包括用了dashjs</h3><h3 id="4-2-双控制条"><a href="#4-2-双控制条" class="headerlink" title="4.2 双控制条"></a>4.2 双控制条</h3><p>sol:    </p>
<ol>
<li><p>css</p>
<pre><code>video::-webkit-media-controls-panel-container {
  display: none !important;
}
video::-webkit-media-controls-start-playback-button {
  display:none !important;
  -webkit-appearance: none;
}
</code></pre></li>
<li><p>js：</p>
<pre><code>html5:{
        nativeControlsForTouch: false
},
</code></pre></li>
<li><p>标签属性：</p>
<pre><code>playsinline
</code></pre></li>
</ol>
<h3 id="4-3-网页开始自动播放"><a href="#4-3-网页开始自动播放" class="headerlink" title="4.3 网页开始自动播放"></a>4.3 网页开始自动播放</h3><p>设置<code>autoplay</code>并不会自动播放<br>sol： 还要加 <code>muted</code>(根据video标签的某个使用规则)</p>
<blockquote>
<p>#1364<br>#337:I am not sure how autoplay is working on an iPhone unless you’re testing with an old version of iOS (pre-6.1). Apple disables autoplay and preload on iOS:</p>
<blockquote>
<p>In Safari on iOS (for all devices, including iPad), where the user may be on a cellular network and be charged per data unit, preload and autoplay are disabled. No data is loaded until the user initiates it. This means the JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action. In other words, a user-initiated Play button works, but an onLoad=”play()” event does not.<br>Sorry, it’s not possible.</p>
</blockquote>
</blockquote>
<h3 id="4-4-点击开始播放自动进入全屏"><a href="#4-4-点击开始播放自动进入全屏" class="headerlink" title="4.4 点击开始播放自动进入全屏"></a>4.4 点击开始播放自动进入全屏</h3><p>sol： 上面的标签属性<code>playsinline</code>可以解决(好像要IOS10 及以上)</p>
<blockquote>
<p>#3761,#896</p>
</blockquote>
<h3 id="4-5-音量控制"><a href="#4-5-音量控制" class="headerlink" title="4.5 音量控制"></a>4.5 音量控制</h3><ul>
<li>ios中音量不能通过编程控制,所以就隐藏了(包括在iPhone中)<blockquote>
<p>#562 2013.6.5：the iPad does not allow us to change volume programmatically, so, the decision was made to <code>just hide the volume control altogether on</code> the iPad and other devices where programmatic volume control is not allowed.</p>
</blockquote>
</li>
<li><p>那些不支持的就自动隐藏了</p>
<blockquote>
<p>#149 2012.12.21：It would be nice if video.js automatically hid the volume/mute    controls for iOS and Chrome/Android users as they are not operational. <br><br>#336    <br><br>#347  </p>
</blockquote>
</li>
<li><p>考虑，用原生的</p>
<blockquote>
<p>#164 2012.4.5: I’ve been considering switching to use the <code>iPads native controls instead</code>, because custom controls are pretty limited. I’ll try to get that into the next release.</p>
</blockquote>
</li>
</ul>
<h3 id="4-6-IOS中的音量控制：静音可以控制，但是volemeControl看不见"><a href="#4-6-IOS中的音量控制：静音可以控制，但是volemeControl看不见" class="headerlink" title="4.6 IOS中的音量控制：静音可以控制，但是volemeControl看不见"></a>4.6 IOS中的音量控制：静音可以控制，但是volemeControl看不见</h3><ul>
<li><p>有人提出静音是可以控制的<br>sol： </p>
<pre><code>.video-js .vjs-volume-panel { display: flex !important; }
.video-js .vjs-mute-control { display: inline-block !important; }
</code></pre></li>
<li><p>但是volemeControl看不见<br>sol: 自己又重写了css，并从dom中移除  </p>
<pre><code>//js
arvplayer.controlBar.volumePanel.volumeControl.hide();
arvplayer.controlBar.volumePanel.addClass(&apos;noVolumeContr&apos;);
//css
.video-js .vjs-volume-panel.noVolCont.vjs-volume-panel-horizontal.vjs-slider-active,   
.video-js .vjs-volume-panel.noVolCont.vjs-volume-panel-horizontal:active,   
.video-js .vjs-volume-panel.noVolCont.vjs-volume-panel-horizontal:focus,   
.video-js .vjs-volume-panel.noVolCont.vjs-volume-panel-horizontal:hover{
    width:4em;
}
</code></pre></li>
</ul>
<p style="text-align:right">2017.9.21 四 19:09</p>

<h2 id="6-结合dashjs"><a href="#6-结合dashjs" class="headerlink" title="6 结合dashjs"></a>6 结合dashjs</h2><ol start="0">
<li>应用dashjs API <code>player.dash.mediaPlayer.setQualityFor(&#39;video&#39;, 2)</code><blockquote>
<p><a href="videojs-contrib-dash/issues/201">Questions work with dashjs</a>  </p>
</blockquote>
</li>
<li>初始化的过程中有时候会报错 <blockquote>
<p>Failed to set the ‘duration’ property on ‘MediaSource’: The MediaSource’s readyState is not ‘open’. #1349</p>
</blockquote>
</li>
<li>ios 中 <em>不能播放的资源</em> 会提示出现，但视频照常播放 <blockquote>
<p>/videojs/videojs-contrib-dash/issues/211</p>
</blockquote>
</li>
<li><p>dashjs 的mediaplay的事件监听受到限制，需要在player初始化之前注册</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">videojs.Html5DashJS.hook(<span class="string">'beforeinitialize'</span>, myCustomCallback);</span><br><span class="line"><span class="keyword">var</span> myCustomCallback = <span class="function"><span class="keyword">function</span>(<span class="params">arvplayer, mediaPlayer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (videojs &amp;&amp; videojs.log) &#123;</span><br><span class="line">        mediaPlayer.getDebug().setLogToBrowserConsole(<span class="literal">false</span>);</span><br><span class="line">        mediaPlayer.on(<span class="string">'log'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// videojs.log(event.message);</span></span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">    mediaPlayer.on(<span class="string">'qualityChangeRendered'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="comment">//auto 下检测初始质量及变化</span></span><br><span class="line">        ddmp(<span class="string">'mediaplayer on qulitychange rendered ...'</span>);</span><br><span class="line">        ddmp(e);</span><br><span class="line">        <span class="keyword">var</span> i=e.newQuality;</span><br><span class="line">        <span class="comment">//dlog(this)// window</span></span><br><span class="line">        <span class="keyword">if</span>(mediaPlayer.getAutoSwitchQualityFor(<span class="string">'video'</span>))&#123;</span><br><span class="line">            arv_menu_quality.$$(<span class="string">'span'</span>)[<span class="number">1</span>].innerHTML=ga_player_lang[<span class="number">15</span>]+<span class="string">' &lt;span&gt;'</span>+ga_dash_mp4[i].split(<span class="string">","</span>)[<span class="number">1</span>]+<span class="string">'p&lt;/span&gt; &gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dash文件和mp4断网，重连后的恢复，稍微有些差别 <a href="#9-断网重连">断网重连</a>    </p>
</li>
</ol>
<h2 id="7-操作系统差异"><a href="#7-操作系统差异" class="headerlink" title="7 操作系统差异"></a>7 操作系统差异</h2><h3 id="7-1-移动端"><a href="#7-1-移动端" class="headerlink" title="7.1 移动端"></a>7.1 移动端</h3><ol>
<li>所有移动设备中音量控制条，并不会随设备的音量键的变化而改变</li>
<li>移动设备监听不到video的属性和方法，都换成了player<a href="#vjs-基础">vjs 基础：列表8</a></li>
<li>移动端，监听indexImage change调用事件时，不明白为什么要用定时器</li>
<li>一直不能autoplay。除非muted。 <a href="#autoplay-policy">auto play</a></li>
</ol>
<h3 id="7-2-macos"><a href="#7-2-macos" class="headerlink" title="7.2 macos"></a>7.2 macos</h3><ol>
<li>macos safari，播放dash，.8上会出错（81是正常的），<a href="#结合dashjs">dashjs播放：列表3</a></li>
</ol>
<h3 id="7-3-windows"><a href="#7-3-windows" class="headerlink" title="7.3 windows"></a>7.3 windows</h3><p>windows  safari 已经放弃支持了</p>
<ol>
<li>windows safari，不支持h5播放；用vjs-falsh，报错</li>
</ol>
<h2 id="8-字幕位置的诡异"><a href="#8-字幕位置的诡异" class="headerlink" title="8 字幕位置的诡异"></a>8 字幕位置的诡异</h2><p>(4674)</p>
<ol>
<li>第一条字幕（0:00）有时候出现，而且位置不确定</li>
<li>控制条出现后会覆盖现有字幕，下一条字幕会出现在控制条上方，控制条消失后会下降 </li>
<li>时机：loaded<blockquote>
<p><a href="823">I need event for subtitles loaded!</a></p>
</blockquote>
</li>
</ol>
<h3 id="IOS原生字幕渲染-20180927"><a href="#IOS原生字幕渲染-20180927" class="headerlink" title="IOS原生字幕渲染 20180927"></a>IOS原生字幕渲染 20180927</h3><p>mp4文件中有字幕，和.vtt/.srt中的字幕是两回事。chrome中显示正常，不会显示两条字幕，单独播放mp4文件也没有字幕     </p>
<ol>
<li>第一条原生的字幕（和remote text track不一样）会显示，有时候还会显示两条字幕：原生和remote textTrack：<br>在loadedMetaData中 一段时间内，频繁 删除原生 tract（在video中） 节点，因为不能确定时机。   </li>
<li>在Mac OS 中字幕位置上下轮流切换：在css中用 !import写死位置</li>
</ol>
<h2 id="9-断网重连"><a href="#9-断网重连" class="headerlink" title="9 断网重连"></a>9 断网重连</h2><p>issues：  </p>
<ol>
<li>mobile和dash(<del>1450</del>)没有监测到错误。(5089)</li>
<li>ie和chrome监测到的错误代码不一样；</li>
<li>vjs-hls更新后，dahs和mp4的表现不一样<blockquote>
<p><a href="1805#issuecomment-380419750">Retry after network error</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p><a href="5089">player error event doesn’t fire and not same on different brower</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       dvjs(arvplayer.error());</span><br><span class="line">       <span class="keyword">var</span> time=arvplayer.currentTime();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">switch</span>(arvplayer.error().code)&#123;</span><br><span class="line">           <span class="comment">//\\case 1:  arvplayer.error(null).pause().load().currentTime(time).play();break;</span></span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.error(<span class="string">'tfdeu seems have debug '</span>,e);<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.error(<span class="string">'decode error'</span>);<span class="comment">//break; //Edge浏览器报3，</span></span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">               <span class="built_in">console</span>.error(<span class="string">'net error;arvplayer timer: '</span>,arvplayerTimer);</span><br><span class="line">               <span class="comment">// arvplayer.error(null); //null 虽然可以取消打叉，但是定时器无法一直触发</span></span><br><span class="line">               <span class="comment">// arvplayer.pause();</span></span><br><span class="line">               <span class="keyword">if</span>(arvplayerTimer)&#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               isArvplayerReload=<span class="literal">true</span>;	<span class="comment">// 立即显示黑屏,onseeking 需要判断</span></span><br><span class="line">               <span class="built_in">document</span>.getElementById(<span class="string">'load_video'</span>).style.display = <span class="string">'block'</span>;</span><br><span class="line">               arvplayerTimer=arvplayer.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   dplay(<span class="string">'arvplayer restart ...'</span>);</span><br><span class="line">                   <span class="comment">// document.getElementById('load_video').style.display = 'block';</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">// <span class="doctag">FIXME:</span> when replay if reconnect network, div_video click propgate:won't control video play/pause </span></span><br><span class="line">                   arvplayer.load();<span class="comment">// it's no influence on dash,but **required for mp4**</span></span><br><span class="line">                   <span class="comment">// if it is mp4, will replay video all the time when disconnect network </span></span><br><span class="line">                   <span class="comment">// **for dash, it should reload the source**</span></span><br><span class="line">                   <span class="keyword">if</span>(arvplayerCurrentSource.type==<span class="string">'application/dash+xml'</span>)&#123;</span><br><span class="line">                       arvplayer.src(arvplayerCurrentSource);</span><br><span class="line">                   &#125;</span><br><span class="line">                   arvplayer.currentTime(time);</span><br><span class="line">                   arvplayer.play();<span class="comment">// if reconnect netwrok, **replay auto**</span></span><br><span class="line">                   <span class="comment">// dplay(arvplayer.error())//不行</span></span><br><span class="line">               &#125;,<span class="number">3000</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.error(<span class="string">'can\'t play this video'</span>);<span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//\\ onSeeked();</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onPlaying</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	dvjs(<span class="string">'on playing ...'</span>);</span><br><span class="line">	<span class="keyword">if</span>(arvplayerTimer)&#123;</span><br><span class="line">		arvplayer.clearInterval(arvplayerTimer);</span><br><span class="line">		arvplayerTimer=<span class="literal">null</span>;</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'load_video'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">		isArvplayerReload=<span class="literal">false</span>;					</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onLoadeddata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//\\ document.getElementById('load_video').style.display = 'none';</span></span><br><span class="line">	<span class="keyword">if</span>(!isArvplayerReload)&#123;<span class="comment">//\\</span></span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'load_video'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onSeeked</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!isArvplayerReload)&#123;</span><br><span class="line">		<span class="built_in">document</span>.getElementById(<span class="string">'load_video'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他参考：<code>player_api.reset().src({type: &#39;application/x-mpegURL&#39;, src: String(play_path), withCredentials: false});</code>     </p>
<blockquote>
<p><a href="4044">How to reload or replay the video.(In case of Error)</a></p>
</blockquote>
<h2 id="0-custom-error-messages"><a href="#0-custom-error-messages" class="headerlink" title="0 custom error messages"></a>0 custom error messages</h2><ol>
<li><code>arvplayer.error(null);</code> <code>errorDisplay: false</code><blockquote>
<p><a href="4272">Error message with the big X</a>   </p>
</blockquote>
</li>
<li>Otherwise you can override the text by setting a new “English” translation<blockquote>
<p><a href="4718">Question: how to customize media error messages without plugins</a> </p>
</blockquote>
</li>
</ol>
<h2 id="0-autoplay-policy"><a href="#0-autoplay-policy" class="headerlink" title="0 autoplay policy"></a>0 autoplay policy</h2><p>不同浏览器的autoplay policy不一样，尤其是chrome(<del>5160</del>)。<br>移动设备，一直是禁止的。<br>静音可行，没试过<br>080530: chrome PC promise下面的代码没有进入/执行；移动端就没事。 sol：把loadeddata在ready触发，不进行判断了</p>
<ol>
<li>直播的时候，没有触发<code>onlodeadmetadata</code>事件。 <blockquote>
<p><a href="videojs-contrib-hls#1418">loadedmetadata didn’t fire and not autoplay when cross origin </a></p>
</blockquote>
</li>
<li>直播的时候，原生的和库（can-auto-play）监测到的promise是相反的；<br> 检测到false的时候，依然可以自动播放。<br> 点播没有上面提到的问题。</li>
</ol>
<p>下面均在player的ready事件中绑定<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// studio</span></span><br><span class="line">arvplayer.play();</span><br><span class="line"><span class="keyword">var</span> promise = video1.play();</span><br><span class="line"><span class="keyword">if</span> (promise !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Autoplay started!</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Autoplay was prevented.</span></span><br><span class="line">        arv_bigPlayButton.show();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//console.log('autoplay==undefined');</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// live</span></span><br><span class="line"><span class="keyword">var</span> promise = Video1.play();</span><br><span class="line"><span class="keyword">if</span> (promise !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Autoplay started!</span></span><br><span class="line">        video1.play();</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Autoplay was prevented.</span></span><br><span class="line">        onLoadeddata();</span><br><span class="line">        <span class="keyword">if</span>(video1.paused())&#123;</span><br><span class="line">            arv_bigPlayButton.show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">// 实际可以播放，但catch</span></span><br><span class="line">            video1.play();</span><br><span class="line">            <span class="keyword">if</span>(!video1.paused())&#123;</span><br><span class="line">                arvfadeOut();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">'real catch error'</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'autoplay==undefined'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://developers.google.com/web/updates/2017/09/autoplay-policy-changes" target="_blank" rel="noopener">Autoplay Policy Changes</a>     </p>
</blockquote>
<blockquote>
<p><a href="http://blog.videojs.com/autoplay-best-practices-with-video-js/" target="_blank" rel="noopener">Autoplay Best Practices with Video.js</a>  </p>
</blockquote>
<p>其它参考：</p>
<blockquote>
<p><a href="https://wordpress.org/support/topic/autoplay-is-not-working-with-desktop-chrome-v66/" target="_blank" rel="noopener">Autoplay is not working with desktop chrome v66</a>   </p>
</blockquote>
<blockquote>
<p><a href="https://www.hellojava.com/article/22752" target="_blank" rel="noopener">How to handle “Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document first.” on Desktop with Chrome 66?</a><br>回答1不清楚；回答2，浏览器配置  Chrome://flags</p>
</blockquote>
<h2 id="1-poster"><a href="#1-poster" class="headerlink" title="1 poster"></a>1 poster</h2><ol>
<li>chrome中 object-fit 适应问题<br><code>object-fit:fill | contain | cover | none | scale-down</code><br>object-fit主要适合于替换元素，比如：<code>&lt;video&gt;、&lt;object&gt;、&lt;img&gt;、&lt;input type=&quot;image&quot;&gt;、&lt;svg&gt;、&lt;svg:image&gt;、&lt;svg:video&gt;</code> 等。<del>其默认值为fill。</del><br>参考:[Html5的video标签自动填充满父div的大小]   </li>
</ol>
<p>默认为：contain。但是chrome中显示不稳定，别人电脑为fill。清空缓存并硬性重载（只有控制台打开状态才有），就正常了。   </p>
<p>属于chrome的bug：<br>[Chrome bug with CSS3 object-fit/object-position]//github.com/Fyrd/caniuse/issues/3169<br><a href="https://stackoverflow.com/questions/30700144/responsive-object-fit-cover-fix-on-chrome" target="_blank" rel="noopener">Responsive object-fit: cover fix on Chrome</a><br>.. and so on   </p>
<ol start="2">
<li>audio only的时候，手机端，开始是暂停的话可以看到poster；点击播放后就是黑色。pc 正常。ios没有测试   /Fyrd/caniuse/issues/3169  </li>
</ol>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2>]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
      <tags>
        <tag>video.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Videojs文档</title>
    <url>/w3/jslib/videojs%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>toc only .</p>
<p><a href="https://github.com/videojs/video.js/" target="_blank" rel="noopener">https://github.com/videojs/video.js/</a></p>
<p></p><p style="text-align:right">2017.9.21 三 17:50</p><br><a id="more"></a><p></p>
<!-- 2017年7月 初就已经开始知道videojs了    -->
<p>2018.4.18: 文档已经更新到7了；该文是6.12~</p>
<ol>
<li>新加的option不错，之前一直不知道可以做哪些设置；</li>
<li>vjs初始化过程中children不错；</li>
</ol>
<h2 id="A-Guides"><a href="#A-Guides" class="headerlink" title="A Guides"></a>A Guides</h2><h3 id="Guides"><a href="#Guides" class="headerlink" title="Guides"></a>Guides</h3><p>audio-tracks,component,debugging,event-target,faq,hook,languages,modal-dialog,options,player-workflows,plugins,react,setup,skins,tech,text-tracks,tracks,troubleshooting,video-tracks,videojs,webpack</p>
<h4 id="1-setup"><a href="#1-setup" class="headerlink" title="1 setup"></a>1 setup</h4><h4 id="2-tracks"><a href="#2-tracks" class="headerlink" title="2 tracks"></a>2 tracks</h4><h4 id="2-1-audio-tracks"><a href="#2-1-audio-tracks" class="headerlink" title="2.1 audio-tracks"></a>2.1 audio-tracks</h4><h4 id="3-options"><a href="#3-options" class="headerlink" title="3 options"></a>3 options</h4><h4 id="4-components"><a href="#4-components" class="headerlink" title="4 components"></a>4 components</h4><h4 id="4-1-modal-dialog"><a href="#4-1-modal-dialog" class="headerlink" title="4.1 modal-dialog"></a>4.1 modal-dialog</h4><h4 id="5-skin"><a href="#5-skin" class="headerlink" title="5 skin"></a>5 skin</h4><h4 id="6-hooks"><a href="#6-hooks" class="headerlink" title="6 hooks"></a>6 hooks</h4><h4 id="7-languages"><a href="#7-languages" class="headerlink" title="7 languages"></a>7 languages</h4><h4 id="8-tech"><a href="#8-tech" class="headerlink" title="8 tech"></a>8 tech</h4><h4 id="9-plugins"><a href="#9-plugins" class="headerlink" title="9 plugins"></a>9 plugins</h4><h4 id="10-event-target"><a href="#10-event-target" class="headerlink" title="10 event-target"></a>10 event-target</h4><h4 id="11"><a href="#11" class="headerlink" title="11 .."></a>11 ..</h4><h4 id="2degugging"><a href="#2degugging" class="headerlink" title="-2degugging"></a>-2degugging</h4><h4 id="1-faq"><a href="#1-faq" class="headerlink" title="-1 faq"></a>-1 faq</h4><h2 id="B-API"><a href="#B-API" class="headerlink" title="B API"></a>B API</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>browser,buffer,computed-style,dom,dom-data,evented,events,extend,filter-source,fn,format-time,guid,log,merge-options,obj,setup,stateful,stylesheet,text-track-list-converter,time-ranges,to-title-case,url,videos</p>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><h4 id="EventedMixin"><a href="#EventedMixin" class="headerlink" title="EventedMixin"></a>EventedMixin</h4><h4 id="statefulMixin"><a href="#statefulMixin" class="headerlink" title="statefulMixin"></a>statefulMixin</h4><table>
<thead>
<tr>
<th>章节</th>
<th>学习情况</th>
<th>截止日期</th>
<th>后期安排</th>
</tr>
</thead>
<tbody>
<tr>
<td>noted</td>
<td>md * 只有目录</td>
<td>2017.7.*</td>
<td>worked-notNeed</td>
</tr>
<tr>
<td>coded</td>
<td>基本都 coded（guides）&amp; onworking</td>
<td>2017.7.*</td>
<td>worked-notNeed</td>
</tr>
<tr>
<td>Guides</td>
<td>大部分看了&amp;coded，有了基本的掌握</td>
<td>no Date</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>API</td>
<td>worked</td>
<td>no Date</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>源码</td>
<td>worked</td>
<td>no Date</td>
<td>neededThenWork</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>w3</category>
        <category>jslib</category>
      </categories>
      <tags>
        <tag>video.js</tag>
        <tag>jslib</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法手册（完整整理版）</title>
    <url>/w3/md/zhengliban/</url>
    <content><![CDATA[<p>Markdown 语法手册（完整整理版）,又一篇markdown语法总结；比较简单/可以立即上手</p>
<p><a href="http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C</a><br><strong>$_PS:</strong> 2018.5.14查看时，显示博客已过期</p>
<p style="text-align:right;">2017.9.15 五  10:34</p>   

<a id="more"></a> 
<p>文章发表于  2015-07-27 01:18:32  </p>
<h2 id="0-目录"><a href="#0-目录" class="headerlink" title="0. 目录"></a>0. 目录</h2><h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h2><p><em>斜体</em><br>_斜体_ <em>em 斜体</em><br><strong>粗体</strong> <strong>strong</strong><br><strong><em>加粗斜体</em></strong><br><del>删除线</del></p>
<h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h2><p>由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，(？？？不懂)</p>
<h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a>3. 超链接</h2><h3 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1. 行内式"></a>3.1. 行内式</h3><h3 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2. 参考式"></a>3.2. 参考式</h3><h3 id="3-3-自动链接"><a href="#3-3-自动链接" class="headerlink" title="3.3. 自动链接"></a>3.3. 自动链接</h3><h2 id="4-锚点"><a href="#4-锚点" class="headerlink" title="4. 锚点"></a>4. 锚点</h2><p>还有下一节的注脚。这些根本上都是用锚点来实现的。<br>注意:  </p>
<ol>
<li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li>
<li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>
<p><strong>PS_QUESTION:</strong> 以下不注释掉，会hexo发布出错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法描述： </span><br><span class="line">在你准备跳转到的指定标题后插入锚点&#123;#标记&#125;，然后在文档的其它地方写上连接到锚点的链接。</span><br><span class="line"></span><br><span class="line">## 目录&#123;#index&#125;  (只有标题后有效)</span><br><span class="line">跳转到[目录](#index)   (并没有看到效果)</span><br></pre></td></tr></table></figure></p>
<h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h2><h3 id="5-1-无序列表"><a href="#5-1-无序列表" class="headerlink" title="5.1. 无序列表"></a>5.1. 无序列表</h3><h3 id="5-2-有序列表"><a href="#5-2-有序列表" class="headerlink" title="5.2. 有序列表"></a>5.2. 有序列表</h3><h3 id="5-3-定义型列表"><a href="#5-3-定义型列表" class="headerlink" title="5.3. 定义型列表"></a>5.3. 定义型列表</h3><p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)  </p>
<p>Markdown<br>:   轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</p>
<p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>
<pre><code>代码块（左侧有八个不可见的空格）

（？？这都是什么啊，不懂）
</code></pre><h3 id="5-3-列表缩进"><a href="#5-3-列表缩进" class="headerlink" title="5.3. 列表缩进"></a>5.3. 列表缩进</h3><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）<br>但是如果你懒，那也行：</p>
<h3 id="5-4-包含段落的列表"><a href="#5-4-包含段落的列表" class="headerlink" title="5.4. 包含段落的列表"></a>5.4. 包含段落的列表</h3><h3 id="5-5-包含引用的列表"><a href="#5-5-包含引用的列表" class="headerlink" title="5.5. 包含引用的列表"></a>5.5. 包含引用的列表</h3><p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：</p>
<ul>
<li>阅读的方法:      &gt;sd，行内引用还是不行<blockquote>
<p>打开书本。<br>打开电灯。</p>
</blockquote>
<h3 id="5-6-包含代码区块的引用"><a href="#5-6-包含代码区块的引用" class="headerlink" title="5.6. 包含代码区块的引用"></a>5.6. 包含代码区块的引用</h3>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</li>
<li><p>一列表项包含一个列表区块：（和不在列表项里的，缩进位置不一     样） </p>
<pre><code>&lt;代码写在这&gt;
</code></pre></li>
</ul>
<h3 id="5-7-一个特殊情况（1970-2）"><a href="#5-7-一个特殊情况（1970-2）" class="headerlink" title="5.7. 一个特殊情况（1970.2）"></a>5.7. 一个特殊情况（1970.2）</h3><h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h2><h3 id="6-1-引用的多层嵌套"><a href="#6-1-引用的多层嵌套" class="headerlink" title="6.1. 引用的多层嵌套"></a>6.1. 引用的多层嵌套</h3><h3 id="6-2-引用其它要素"><a href="#6-2-引用其它要素" class="headerlink" title="6.2. 引用其它要素"></a>6.2. 引用其它要素</h3><h2 id="7-插入图像"><a href="#7-插入图像" class="headerlink" title="7. 插入图像"></a>7. 插入图像</h2><h3 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1. 行内式"></a>7.1. 行内式</h3><h3 id="7-2-参考式"><a href="#7-2-参考式" class="headerlink" title="7.2. 参考式"></a>7.2. 参考式</h3><h2 id="8-内容目录"><a href="#8-内容目录" class="headerlink" title="8. 内容目录"></a>8. 内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。（？不明白）</p>
<h2 id="9-注脚"><a href="#9-注脚" class="headerlink" title="9. 注脚"></a>9. 注脚</h2><p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成  HTML<a href="重新写一下第二个注脚">^2</a> , 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。<br>我再一个注脚 注脚1<a href="自己添加的注脚，成功了">^idd</a>  为什么第二个 不是注释</p>
<!-- [^2]:HyperText Markup Language 超文本标记语言 -->
<pre><code>第二个注脚，不知道为什么不可以。。预览，文章最后一个也没有见生成
</code></pre><h2 id="10-LaTeX-公式"><a href="#10-LaTeX-公式" class="headerlink" title="10. LaTeX 公式"></a>10. LaTeX 公式</h2><h3 id="10-1-表示行内公式："><a href="#10-1-表示行内公式：" class="headerlink" title="10.1. $ 表示行内公式："></a>10.1. $ 表示行内公式：</h3><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。&yen;</p>
<p>$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$    </p>
<pre><code>$E=mc^2$
</code></pre><h3 id="10-2-表示整行公式："><a href="#10-2-表示整行公式：" class="headerlink" title="10.2 $$ 表示整行公式："></a>10.2 $$ 表示整行公式：</h3><p>$$\sum_{i=1}^n a_i=0$$<br>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k} $$</p>
<pre><code>公式不知道为什么没有出来
流程图，好像是需要js脚本 This should be a diagram! If you do not see it you need Javascript enabled
</code></pre><h2 id="11-流程图"><a href="#11-流程图" class="headerlink" title="11. 流程图"></a>11. 流程图</h2><p>flow<br>st=&gt;start: Start:&gt;<a href="https://www.zybuluo.com" target="_blank" rel="noopener">https://www.zybuluo.com</a><br>io=&gt;inputoutput: verification<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>sub=&gt;subroutine: Your Subroutine<br>e=&gt;end<br>st-&gt;io-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;sub-&gt;io</p>
<h2 id="12-表格"><a href="#12-表格" class="headerlink" title="12 .表格"></a>12 .表格</h2><p>1、不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>2、列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>3、第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。（两边就是中间对齐）</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>产品</th>
<th style="text-align:right">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leanote 高级账号</td>
<td style="text-align:right">60元/年</td>
</tr>
<tr>
<td>Leanote 超级账号</td>
<td style="text-align:right">120元/年</td>
</tr>
</tbody>
</table>
<pre><code>显示不一样，外边框，和内边框，应该是有还是没有？及纵方向
网页上，显示是边框都有的。vscode预览，是上面的样子
</code></pre><h2 id="13-分隔线"><a href="#13-分隔线" class="headerlink" title="13. 分隔线"></a>13. 分隔线</h2><h2 id="14-代码"><a href="#14-代码" class="headerlink" title="14. 代码"></a>14. 代码</h2><p>插入行内代码，即插入一个单词或者一句代码的情况，使用<code>code</code>这样的形式插入。<br>插入多行代码，可以使用缩进或者` code `,具体看示例。</p>
<p>注意： 缩进式插入前方必须有空行（理解：仅仅是用来区分语言语法的吧）</p>
<h3 id="14-1-行内式"><a href="#14-1-行内式" class="headerlink" title="14.1. 行内式"></a>14.1. 行内式</h3><p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<h3 id="14-2-缩进式多行代码"><a href="#14-2-缩进式多行代码" class="headerlink" title="14.2. 缩进式多行代码"></a>14.2. 缩进式多行代码</h3><pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}
</code></pre><h3 id="14-3-用六个-包裹多行代码"><a href="#14-3-用六个-包裹多行代码" class="headerlink" title="14.3. 用六个`包裹多行代码"></a>14.3. 用六个`包裹多行代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-4-HTML-原始码"><a href="#14-4-HTML-原始码" class="headerlink" title="14.4. HTML 原始码"></a>14.4. HTML 原始码</h3><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理: </p>
<pre><code>(在里面写样式，也可以。。有点bianT)
</code></pre><p><div class="footer"><br>   © 2004 Foo Corporation<br></div></p>
<table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td style="color:red">李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table>


<p>学习总结：<br>锚点，[TOC]（目录），公式，流程图 有问题<br>注脚 有小问题—-第二个写法不知道那里有问题</p>
<p style="text-align:right">2017.9.15 五 12:00</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>其他一些，收集的Markdown</title>
    <url>/w3/md/qitashouji/</url>
    <content><![CDATA[<p>其他一些markdown语法的总结</p>
<p style="text-align:right;">2017.9.15 五  12:24</p> 

<a id="more"></a> 
<h1 id="A-Markdown-编辑器语法指南"><a href="#A-Markdown-编辑器语法指南" class="headerlink" title="A Markdown 编辑器语法指南"></a>A Markdown 编辑器语法指南</h1><p><a href="https://segmentfault.com/markdown" target="_blank" rel="noopener">https://segmentfault.com/markdown</a></p>
<h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现</p>
<p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p>
<p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果</p>
<pre><code>def g(x):
    yield from range(x, 0, -1)
yield from range(x)
</code></pre><p>如你不需要代码高亮，可以用下面的方法禁用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：（因为-还有另一作用：二级标题）</p>
<p>前面的段落</p>
<hr>
<p>后面的段落</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="行内-HTML-元素"><a href="#行内-HTML-元素" class="headerlink" title="行内 HTML 元素"></a>行内 HTML 元素</h3><p>目前只支持部分段内 HTML 元素效果，包括<code>&lt;kdb&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>，如<br>键位显示:使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<p>代码块:使用 <pre></pre> 元素同样可以形成代码块</p>
<p>粗斜体<b> Markdown 在此处同样适用，如 <em>加粗</em> </b></p>
<p>符号转义:如果你的描述中需要用到 markdown 的符号，比如 _ # <em> 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # \</em> 进行避免。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。</p>
<p>http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/<br><a href="https://gist.github.com/{gist_id}" target="_blank" rel="noopener">https://gist.github.com/{gist_id}</a><br><a href="http://runjs.cn/detail/{id}" target="_blank" rel="noopener">http://runjs.cn/detail/{id}</a><br><a href="http://v.youku.com/v_show/id_{video_id}.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_{video_id}.html</a>  </p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<p>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p>
<p>$$<br>x \href{why-equal.html}{=} y^2 + 1<br>$$</p>
<p>同时也支持 HTML 属性，如：</p>
<p>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p>
<p>$$<br>(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
<h2 id="游乐场"><a href="#游乐场" class="headerlink" title="游乐场"></a>游乐场</h2><p>（这篇文章最下面，放了一个编辑器，，公式都可以输出）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">    公式可以输出了，流程图还是不行</span><br><span class="line">    扩展，不知道什么鬼，并没有预览；可能需要扩展吧</span><br></pre></td></tr></table></figure>
<h1 id="B-Markdown语法介绍"><a href="#B-Markdown语法介绍" class="headerlink" title="B Markdown语法介绍"></a>B Markdown语法介绍</h1><p><a href="https://coding.net/help/doc/project/markdown.html" target="_blank" rel="noopener">https://coding.net/help/doc/project/markdown.html</a></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>Coding 会针对每个标题，在解析时都会添加锚点id，如</p>
<p># C 锚点<br><a href="#user-content-锚点">问内链接</a>;</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="代办列表-表示列表是否勾选状态"><a href="#代办列表-表示列表是否勾选状态" class="headerlink" title="代办列表: 表示列表是否勾选状态"></a>代办列表: 表示列表是否勾选状态</h3><ul>
<li style="list-style: none"><input type="checkbox"> 不勾选</li>
<li style="list-style: none"><input type="checkbox" checked> 勾选</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github的编辑器可以，上面的游乐场不行；流程图，扩展两个地方都没有显示</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在 Markdown 中，可以制作表格，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">------------ | ------------- | ------------</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐约好像在代码块中出现过表格，发生错觉了？？有可能看错了</span><br></pre></td></tr></table></figure>
<pre><code>First Header | Second Header | Third Header
------------ | ------------- | ------------
Content Cell | Content Cell  | Content Cell
Content Cell | Content Cell  | Content Cell
</code></pre><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>\^表示上标, _表示下标。如果上下标的内容多于一个字符，要用{}把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。 例如：</p>
<p>x^{y^z}=(1+{\rm e}^x)^{-2xy^w}</p>
<p style="text-align:right">2017.9.15 五 13:10</p><br><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</code>段落缩进<br><br><p style="text-align:right">2017.9.15 五 14:32</p>  

<h1 id="C-Mastering-Markdown"><a href="#C-Mastering-Markdown" class="headerlink" title="C Mastering Markdown"></a>C Mastering Markdown</h1><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown" target="_blank" rel="noopener">https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown</a></p>
<h2 id="What-is-Markdown"><a href="#What-is-Markdown" class="headerlink" title="What is Markdown?"></a>What is Markdown?</h2><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Text  Lists  Images  Headers&amp;Quotes  Code  Extras</p>
<h2 id="Syntax-guide"><a href="#Syntax-guide" class="headerlink" title="Syntax guide"></a>Syntax guide</h2><p>….</p>
<h2 id="GitHub-Flavored-Markdown"><a href="#GitHub-Flavored-Markdown" class="headerlink" title="GitHub Flavored Markdown"></a>GitHub Flavored Markdown</h2><h3 id="1-Syntax-highlighting"><a href="#1-Syntax-highlighting" class="headerlink" title="1 Syntax highlighting"></a>1 Syntax highlighting</h3><h3 id="2-Task-Lists"><a href="#2-Task-Lists" class="headerlink" title="2 Task Lists"></a>2 Task Lists</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> @mentions, #refs, <a href>links</a>, <strong>formatting</strong>, and                 <del>tags</del> supported</li>
<li style="list-style: none"><input type="checkbox" checked> list syntax required (any unordered or ordered list supported)</li>
<li style="list-style: none"><input type="checkbox" checked> this is a complete item</li>
<li style="list-style: none"><input type="checkbox"> this is an incomplete item</li>
</ul>
<h3 id="3-Tables"><a href="#3-Tables" class="headerlink" title="3 Tables"></a>3 Tables</h3><h3 id="4-SHA-references"><a href="#4-SHA-references" class="headerlink" title="4 SHA references"></a>4 SHA references</h3><p>Any reference to a commit’s SHA-1 hash will be automatically converted into a link to that commit on GitHub.</p>
<blockquote>
<p>16c999e8c71134401a78d4d46435517b2271d6ac<br>mojombo@16c999e8c71134401a78d4d46435517b2271d6ac<br> mojombo/github-flavored-markdown@16c999e8c71134401a78d4d46435517b2271d6ac</p>
</blockquote>
<h3 id="5-Issue-references-within-a-repository"><a href="#5-Issue-references-within-a-repository" class="headerlink" title="5 Issue references within a repository"></a>5 Issue references within a repository</h3><p>Any number that refers to an Issue or Pull Request will be automatically converted into a link.    </p>
<blockquote>
<p>#1<br>  mojombo#1<br>  mojombo/github-flavored-markdown#1</p>
</blockquote>
<h3 id="6-Username-mentions"><a href="#6-Username-mentions" class="headerlink" title="6 Username @mentions"></a>6 Username @mentions</h3><h3 id="7-Automatic-linking-for-URLs"><a href="#7-Automatic-linking-for-URLs" class="headerlink" title="7 Automatic linking for URLs"></a>7 Automatic linking for URLs</h3><p>Any URL (like <a href="http://www.github.com/" target="_blank" rel="noopener">http://www.github.com/</a>) will be automatically converted into a clickable link.</p>
<h3 id="8-Strikethrough"><a href="#8-Strikethrough" class="headerlink" title="8 Strikethrough"></a>8 Strikethrough</h3><p>Any word wrapped with two tildes (like <del>this</del>) will appear crossed out. 说白了，还是删除线</p>
<h3 id="9-Emoji"><a href="#9-Emoji" class="headerlink" title="9 Emoji"></a>9 Emoji</h3><blockquote>
<p>@octocat :+1: This PR looks great - it’s ready to merge! :shipit:</p>
</blockquote>
<p style="text-align:right">2017.9.15 五 15:00</p>  ]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法说明(简体中文版) 一 概述</title>
    <url>/w3/md/1_gaishu/</url>
    <content><![CDATA[<!-- # Markdown 语法说明(简体中文版) -->
<p>toc only.</p>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></p>
<p></p><p style="text-align:right">2017.9.11 一 am</p><br><a id="more"></a> <p></p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-宗旨"><a href="#1-宗旨" class="headerlink" title="1 宗旨"></a>1 宗旨</h3><h3 id="2-兼容HTML"><a href="#2-兼容HTML" class="headerlink" title="2 兼容HTML"></a>2 兼容HTML</h3><p>Markdown文件里加HTML表格</p>
<p>这是一个普通段落。不会额外加P标签</p>
<table><br>    <tr><br>        <td>Foo</td><br>        <td>Foo</td><br>        <td>Foo</td><br>    </tr><br>    <tr><br>        <td>Foo</td><br>        <td>Foo</td><br>        <td><em> 强调无效 </em></td><br>    </tr><br></table>

<ul>
<li>强调，html区块外有效 *<br><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a><br><br><br><span>html的区段（行内）标签可以直接在md中使用</span><br><br>两个以上的空格然后回车–插入br的使用方式<del>deldeldeldeld</del></li>
</ul>
<h3 id="3-特殊字符自动转换"><a href="#3-特殊字符自动转换" class="headerlink" title="3 特殊字符自动转换"></a>3 特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。<br>&copy; AT&amp;T AT&amp;T<br>类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML<br>4 &lt; 5<br>不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<h2 id="二、区块元素"><a href="#二、区块元素" class="headerlink" title="二、区块元素"></a>二、区块元素</h2><h3 id="1-段落和换行"><a href="#1-段落和换行" class="headerlink" title="1 段落和换行"></a>1 段落和换行</h3><h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2 标题"></a>2 标题</h3><h3 id="3-区块引用Blockquotes"><a href="#3-区块引用Blockquotes" class="headerlink" title="3 区块引用Blockquotes"></a>3 区块引用Blockquotes</h3><h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4 列表"></a>4 列表</h3><h3 id="5-代码区块"><a href="#5-代码区块" class="headerlink" title="5 代码区块"></a>5 代码区块</h3><h3 id="6-分隔线"><a href="#6-分隔线" class="headerlink" title="6 分隔线"></a>6 分隔线</h3><h2 id="三、区段元素"><a href="#三、区段元素" class="headerlink" title="三、区段元素"></a>三、区段元素</h2><h3 id="1-链接"><a href="#1-链接" class="headerlink" title="1 链接"></a>1 链接</h3><h3 id="2-强调"><a href="#2-强调" class="headerlink" title="2 强调"></a>2 强调</h3><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h3><h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4 图片"></a>4 图片</h3><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-反斜杠"><a href="#1-反斜杠" class="headerlink" title="1 反斜杠"></a>1 反斜杠</h3><h3 id="2-自动链接"><a href="#2-自动链接" class="headerlink" title="2 自动链接"></a>2 自动链接</h3><h2 id="五、感谢"><a href="#五、感谢" class="headerlink" title="五、感谢"></a>五、感谢</h2><h2 id="六、Markdown免费编辑器"><a href="#六、Markdown免费编辑器" class="headerlink" title="六、Markdown免费编辑器"></a>六、Markdown免费编辑器</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法说明(简体中文版) 二 区块</title>
    <url>/w3/md/2_qukuai/</url>
    <content><![CDATA[<!-- # Markdown 语法说明(简体中文版) -->
<p>区块语法的介绍/使用</p>
<p><a href="http://wowubuntu.com/markdown/#block" target="_blank" rel="noopener">http://wowubuntu.com/markdown/#block</a></p>
<p></p><p style="text-align:right">2017.9.11 一 am</p><br><a id="more"></a> <p></p>
<p>## 一、概述<br>### 1 宗旨<br>### 2 兼容HTML<br>### 3 特殊字符自动转换</p>
<h2 id="二、区块元素"><a href="#二、区块元素" class="headerlink" title="二、区块元素"></a>二、区块元素</h2><h3 id="1-段落和换行"><a href="#1-段落和换行" class="headerlink" title="1 段落和换行"></a>1 段落和换行</h3><h4 id="1-一个-Markdown-段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。"><a href="#1-一个-Markdown-段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。" class="headerlink" title="1.一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。"></a>1.一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</h4><h4 id="2-「由一个或多个连续的文本行组成」这句话其实暗示了-Markdown-允许段落内的强迫换行（插入换行符），这个特性和其他大部分的-text-to-HTML-格式不一样（包括-Movable-Type-的「Convert-Line-Breaks」选项），其它的格式会把每个换行符都转成-lt-br-gt-标签。"><a href="#2-「由一个或多个连续的文本行组成」这句话其实暗示了-Markdown-允许段落内的强迫换行（插入换行符），这个特性和其他大部分的-text-to-HTML-格式不一样（包括-Movable-Type-的「Convert-Line-Breaks」选项），其它的格式会把每个换行符都转成-lt-br-gt-标签。" class="headerlink" title="2.「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。"></a>2.「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</h4><h4 id="3-如果你确实想要依赖-Markdown-来插入-lt-br-gt-标签的话，在插入处先按入两个以上的空格然后回车。"><a href="#3-如果你确实想要依赖-Markdown-来插入-lt-br-gt-标签的话，在插入处先按入两个以上的空格然后回车。" class="headerlink" title="3.如果你确实想要依赖 Markdown 来插入 &lt;br /&gt;标签的话，在插入处先按入两个以上的空格然后回车。"></a>3.如果你确实想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code>标签的话，在插入处先按入两个以上的空格然后回车。</h4><p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<hr>
<hr>
<h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2 标题"></a>2 标题</h3><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>
<h4 id="1-类-Setext-形式是用底线的形式，利用-（最高阶标题）和-（第二阶标题），例如："><a href="#1-类-Setext-形式是用底线的形式，利用-（最高阶标题）和-（第二阶标题），例如：" class="headerlink" title="1.类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如："></a>1.类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：</h4><h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><p>任何数量的 = 和 - 都可以有效果。</p>
<h4 id="2-类-Atx-形式则是在行首插入-1-到-6-个-，对应到标题-1-到-6-阶，例如："><a href="#2-类-Atx-形式则是在行首插入-1-到-6-个-，对应到标题-1-到-6-阶，例如：" class="headerlink" title="2.类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如："></a>2.类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：</h4><h1 id="这是-H1"><a href="#这是-H1" class="headerlink" title="这是 H1"></a>这是 H1</h1><h2 id="这是-H2"><a href="#这是-H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h6 id="这是-H6"><a href="#这是-H6" class="headerlink" title="这是 H6"></a>这是 H6</h6><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<h1 id="这是-H1-1"><a href="#这是-H1-1" class="headerlink" title="这是 H1"></a>这是 H1</h1><h2 id="这是-H2-1"><a href="#这是-H2-1" class="headerlink" title="这是 H2"></a>这是 H2</h2><h3 id="这是-H3"><a href="#这是-H3" class="headerlink" title="这是 H3"></a>这是 H3</h3><hr>
<hr>
<h3 id="3-区块引用Blockquotes"><a href="#3-区块引用Blockquotes" class="headerlink" title="3 区块引用Blockquotes"></a>3 区块引用Blockquotes</h3><p>打一段字，后面可以加空格接引用 &gt; 这里是行内的引用 ??并不好使</p>
<blockquote>
<p>This is a b,<br>This is a b,.<br>This is a b,</p>
</blockquote>
<h4 id="1-偷懒"><a href="#1-偷懒" class="headerlink" title="1.偷懒"></a>1.偷懒</h4><blockquote>
<p>只在整个段落的第一行加<br>这里是第二行</p>
</blockquote>
<blockquote>
<p>又一个段落了</p>
</blockquote>
<h4 id="2-嵌套引用"><a href="#2-嵌套引用" class="headerlink" title="2.嵌套引用"></a>2.嵌套引用</h4><blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h4 id="3-引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等："><a href="#3-引用的区块内也可以使用其他的-Markdown-语法，包括标题、列表、代码区块等：" class="headerlink" title="3.引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等："></a>3.引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</h4><blockquote>
<h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><p>再加一点，看着上面的代码块，颜色突然结束，怪怪的</p>
</blockquote>
<hr>
<hr>
<h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4 列表"></a>4 列表</h3><p><code>2017.9.14 四 15:30</code><br>无序：星号、加号、减号<br>有序：数字接英文句点</p>
<h4 id="1-也可以html标记"><a href="#1-也可以html标记" class="headerlink" title="1.也可以html标记"></a>1.也可以html标记</h4><ol><br>    <li>无序ol</li><br>    <li>li，</li><br>    <li>这里 数字 排序了</li><br>    <li>一段markdown结束，最好加空行加以区分</li><br></ol>

<h4 id="2-数字不影响排序"><a href="#2-数字不影响排序" class="headerlink" title="2.数字不影响排序"></a>2.数字不影响排序</h4><ol>
<li>bird</li>
<li>数字是几不重要</li>
<li>比如这个的数字是：1，3，5</li>
<li>这个数字是二，但排序仍是4</li>
</ol>
<p>懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<h4 id="3-列表项目标记通常是放在最左边，但是其实也可以缩进，最多-3-个空格，项目标记后面则一定要接着至少一个空格或制表符。"><a href="#3-列表项目标记通常是放在最左边，但是其实也可以缩进，最多-3-个空格，项目标记后面则一定要接着至少一个空格或制表符。" class="headerlink" title="3.列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。"></a>3.列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</h4><ul>
<li>前面三个空格<br>第二行，后面没有空格 ，一个空格不会换行</li>
<li>前面三个空格，后面一个空格<br>第二行了。。有tab的可以换行</li>
<li>都是三个缩进，好看</li>
<li>三个缩进<br>第二行没空格， markdown不好看 </li>
</ul>
<h4 id="4-列表项目间用空行分开，内容用-标签包起来"><a href="#4-列表项目间用空行分开，内容用-标签包起来" class="headerlink" title="4.列表项目间用空行分开，内容用  标签包起来"></a>4.列表项目间用空行分开，内容用 <p> 标签包起来</p></h4><ul>
<li>bird</li>
<li><p>前面没有空行</p>
</li>
<li><p>前面加了一个空行，</p>
</li>
<li>只加了一个，就都有空行了</li>
</ul>
<h4 id="5-列表项目可以包含多个段落，每个项目下的段落都必须缩进-4-个空格或是-1-个制表符："><a href="#5-列表项目可以包含多个段落，每个项目下的段落都必须缩进-4-个空格或是-1-个制表符：" class="headerlink" title="5.列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符："></a>5.列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</h4><ol>
<li><p>第一项，第一段，第一行<br>第一项，第一段，第二行</p>
<p>第一项，第二段，第一行。。段落间前面要有空行<br>第一项，第二段，第二行。。段落间前面要有空行</p>
</li>
<li><p>第二项，第一段，第一行。。前面没有空行–不需要要你过来区分段落  。加不加空行，输出是一致的  </p>
<p>第二项，第二段，第一行。。每行都有缩进，看起来比第一段，没有所经的好看点<br>sdfsfsf算法</p>
</li>
</ol>
<p>你每行都有缩进，看起来会看好很多</p>
<h4 id="6-如果要在列表项目内放进引用，那-gt-就需要缩进："><a href="#6-如果要在列表项目内放进引用，那-gt-就需要缩进：" class="headerlink" title="6.如果要在列表项目内放进引用，那 &gt; 就需要缩进："></a>6.如果要在列表项目内放进引用，那 &gt; 就需要缩进：</h4><ul>
<li><p>项目列表里有引用了</p>
<blockquote>
<p>这里需要缩进<br>这里需要缩进，符号后面的空格好像不重要</p>
</blockquote>
<blockquote>
<p>前面没有换行。所以这一个前面加了空行<br>前面没有换行。所以这一个前面加了空行，或者上一个加了一个制表符</p>
</blockquote>
<blockquote>
<p>tab的是一个引用，空行就换成另一个引用了</p>
</blockquote>
<h4 id="7-如果要放代码区块的话，该区块就需要缩进两次，也就是-8-个-空-格或是-2-个制表符："><a href="#7-如果要放代码区块的话，该区块就需要缩进两次，也就是-8-个-空-格或是-2-个制表符：" class="headerlink" title="7.如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个        空 格或是 2 个制表符："></a>7.如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个        空 格或是 2 个制表符：</h4><p>===============  </p>
<p>  /*</p>
<pre><code>* 这个符号前面也要加空格
&gt;这个引用的符号，前面 竟然 不需要加空格
</code></pre><p>  */</p>
</li>
<li>这个符号前面也要加空格<blockquote>
<p>这个引用的符号，前面 竟然 不需要加空格</p>
</blockquote>
</li>
<li>星号加空格可以知道是一个markdown标签；可以没有回车换行。<blockquote>
<p>这个引用的符号，前面 竟然 不需要加空格</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>这是个数字列表没有表现出来</li>
<li>这是个数字列表没有表现出来<blockquote>
<p>这个引用的符号，前面 竟然 不需要加空格   </p>
</blockquote>
</li>
<li><p>这是个数字列表没有表现出来。加tab换行，只是换了一行，还是一个引用。。</p>
</li>
<li><p>加了一个空行——回车换行就表现出来了</p>
</li>
<li>加了一个空行——回车换行就表现出来了</li>
</ol>
<p>================</p>
<ul>
<li>代码块列表项，2个tab</li>
<li>代码块列表项，2个tab<br>斯蒂芬森斯蒂芬森<br>斯蒂芬</li>
<li>斯蒂芬 斯蒂芬森</li>
</ul>
<h4 id="8-项目列表很可能会不小心产生：1986-What-a-great-season"><a href="#8-项目列表很可能会不小心产生：1986-What-a-great-season" class="headerlink" title="8.项目列表很可能会不小心产生：1986. What a great season."></a>8.项目列表很可能会不小心产生：1986. What a great season.</h4><ol start="1986">
<li>What a great season.</li>
<li>What a great season.<br>1986.符号后面的空格还是很有用的。<br>1986.符号后面的空格还是很有用的。前面那句话加了一个tab</li>
</ol>
<p>============</p>
<pre><code>/*
1986.符号后面的空格还是很有用的。前面那句话加了换行，所以是又一个markdown了。（没有空格，不是列表了）
*/
</code></pre><p>前面说的增量已经有了，（文档有些过时 -<em>-|-</em>-，我的哭脸呢）</p>
<p>1986.   wahts sd s d<br>1986.   wahts sd s d </p>
<pre><code>/* 
1、发现：回车换行，相当与 p  标签，1加了换行，和间距，也就是段落的区分。2区分不同markdown语言   
tab也是换行，只是没有间距，同一个段落的换行

这个是回车换行，有间距，也就是段落的区分
2、markdown也有标签，和文本输出的概念。第一个/*  */，因为是直接在 语法####的下面，所以可以没有回车换行；后面两个必须加回车换行，和前面的文本（输出内容）做区分；和html表现一致
3、可能回车换行，换段落；tab，回车换行稍微有些绕。语法下直接写文本，好像也是markdown语法----html中直接输出文本。md中，要换另一个markdown，需要回车加一个空行，不然还会认为是直接输出文本....
4、tab====&lt;br&gt;  空行=====&lt;p&gt;  回车======html中的回车，并不会产出换行。。所以，tab 空行相当于markdown的标签
从这里面的颜色，也可以看出那些是markdown的语法----标签；
tab，空行，代码块，分隔符等，还有一些看不出来  
*/
</code></pre><p>====================    </p>
<h3 id="5-代码区块"><a href="#5-代码区块" class="headerlink" title="5 代码区块"></a>5 代码区块</h3><p>缩进 4 个空格或是 1 个制表符<br>1.这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除</p>
<pre><code>前面四个缩进
    前面又加了四个缩进，第一个四个缩进被当做markdown语法识别了。代码里缩进一致，显得好看
    回车换了一行

    如果前面加了一个空行，，就变成段落了
前面还是四个缩进 。下面不加换行也是可以的，加换行代码清晰
</code></pre><p>2.一个代码区块会一直持续到没有缩进的那一行。<code>（所以上面的代码快就可以不用加换行来区分了）（后面没有tab换行，下面的代码会接上来，成为一段内容）</code><br>3.在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理<br>&copy;    &amp;   &nbsp; &nbsp; &nbsp; &nbsp;  &gt;<br>&amp;  &lt;             &gt;</p>
<pre><code>&amp;copy; &amp; &gt; &lt;      &gt;   
</code></pre><p>4.代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<pre><code>***
</code></pre><h3 id="6-分隔线"><a href="#6-分隔线" class="headerlink" title="6 分隔线"></a>6 分隔线</h3><p>三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p>
<hr>
<hr>
<hr>
<hr>
<p>前后都有段落时</p>
<hr>
<p>前后都有段落时</p>
<p>## 三、区段元素<br>### 1 链接<br>### 2 强调<br>### 3 代码<br>### 4 图片</p>
<p>## 四、其他<br>### 1 反斜杠<br>### 2 自动链接</p>
<p>## 五、感谢<br>## 六、Markdown免费编辑器</p>
]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法说明(简体中文版) 四 其他</title>
    <url>/w3/md/4_qita/</url>
    <content><![CDATA[<!-- # Markdown 语法说明(简体中文版) -->
<p>其他及剩余部分</p>
<p><a href="http://wowubuntu.com/markdown/#misc" target="_blank" rel="noopener">http://wowubuntu.com/markdown/#misc</a></p>
<p style="text-align:right">2017.9.11 一 am</p><br><a id="more"></a><br><br>## 一、概述<br>### 1 宗旨<br>### 2 兼容HTML<br>### 3 特殊字符自动转换<br><br>## 二、区块元素<br>### 1 段落和换行<br>### 2 标题<br>### 3 区块引用Blockquotes<br>### 4 列表<br>### 5 代码区块<br>### 6 分隔线<br><br>## 三、区段元素<br>### 1 链接<br>### 2 强调<br>### 3 代码<br>### 4 图片<br><br>## 四、其他<br>### 1 自动链接<br>#### 1.Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br><br><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><br><br>#### 2.邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：<br><br><a href="mailto:&#97;&#100;&#x64;&#114;&#101;&#x73;&#x73;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#97;&#100;&#x64;&#114;&#101;&#x73;&#x73;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#x6d;</a><br><br>#### 3.在浏览器里面，这段字串（其实是  <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a</code>）会变成一个可以点击的「<a href="mailto:address@example.com" target="_blank" rel="noopener">address@example.com</a>」链接。<br><br>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）<br>(不知道说的什么)<br><br><a href="mailto:&#x61;&#100;&#x64;&#x72;&#101;&#115;&#115;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x61;&#100;&#x64;&#x72;&#101;&#115;&#115;&#64;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a><br><br>### 2 反斜杠<br>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：<br><br>*literal asterisks*<br><br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><br><br>## 五、感谢<br>（就不谢了）<br><br>## 六、Markdown免费编辑器<br>（感觉不靠谱，文档都不知道什么时候写的。还是copy一下吧）<br>Windows 平台<br><em> MarkdownPad
</em> MarkPad<br><br>Linux 平台<br><em> ReText<br><br>Mac 平台
</em> Mou<br><br>在线编辑器<br><br><em> Markable.in
</em> Dillinger.io<br><br>浏览器插件<br><em> MaDe (Chrome)<br><br>高级应用
</em> Sublime Text 2 + MarkdownEditing / 教程<br><br><br><p style="text-align:right;">2017.9.14 四 20:10</p>   

</em>]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法说明(简体中文版) 三 区段元素</title>
    <url>/w3/md/3_quduan/</url>
    <content><![CDATA[<!-- # Markdown 语法说明(简体中文版) -->
<p>区段语法的介绍/使用</p>
<p><a href="http://wowubuntu.com/markdown/#span" target="_blank" rel="noopener">http://wowubuntu.com/markdown/#span</a></p>
<p></p><p style="text-align:right">2017.9.11 一 am</p><br><a id="more"></a> <p></p>
<p>## 一、概述<br>### 1 宗旨<br>### 2 兼容HTML<br>### 3 特殊字符自动转换<br>\<br>## 二、区块元素<br>### 1 段落和换行<br>### 2 标题<br>### 3 区块引用Blockquotes<br>### 4 列表<br>### 5 代码区块<br>### 6 分隔线</p>
<h2 id="三、区段元素"><a href="#三、区段元素" class="headerlink" title="三、区段元素"></a>三、区段元素</h2><h3 id="1-链接"><a href="#1-链接" class="headerlink" title="1 链接"></a>1 链接</h3><p>行内式  参考式 : 链接文字都是用 [方括号] 来标记。</p>
<h4 id="1-行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接-网址后面，双引号把-title-文字包起来"><a href="#1-行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接-网址后面，双引号把-title-文字包起来" class="headerlink" title="1.行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接;网址后面，双引号把 title 文字包起来"></a>1.行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接;网址后面，双引号把 title 文字包起来</h4><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link</p>
<p>要链接到同样主机的资源，你可以使用相对路径：<br>See my <a href="/about/">About</a> page for details.</p>
<h4 id="2-1参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记："><a href="#2-1参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：" class="headerlink" title="2.1参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记："></a>2.1参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</h4><p>This is <a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">an example</a> reference-style link</p>
<p>也可以选择性地在两个方括号中间加上一个空格：<br>This is <a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">an example</a> reference-style link.</p>
<h4 id="2-2接着，在文件的任意处，你可以把这个标记的链接内容定义出来："><a href="#2-2接着，在文件的任意处，你可以把这个标记的链接内容定义出来：" class="headerlink" title="2.2接着，在文件的任意处，你可以把这个标记的链接内容定义出来："></a>2.2接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</h4><h4 id="2-2-1链接内容定义的形式为："><a href="#2-2-1链接内容定义的形式为：" class="headerlink" title="2.2.1链接内容定义的形式为："></a>2.2.1链接内容定义的形式为：</h4><p>1方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字;<br>2接着一个冒号;<br>3接着一个以上的空格或制表符;<br>4接着链接的网址;<br>5选择性地接着 title 内容，可以用单引号、双引号或是括弧包着<br>请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<h4 id="2-2-3其他说明"><a href="#2-2-3其他说明" class="headerlink" title="2.2.3其他说明"></a>2.2.3其他说明</h4><p>1、链接网址也可以用尖括号包起来：<br><a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">id</a>: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  “Optional Title Here”</p>
<p>2、你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：<br><a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">id</a>: <a href="http://example.com/longish/path/to/resource/here" target="_blank" rel="noopener">http://example.com/longish/path/to/resource/here</a><br>    “Optional Title Here”</p>
<p>3、网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>4、链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的    </p>
<p>5、隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号<br><a href="http://google.com/" target="_blank" rel="noopener">Google</a><br>然后定义链接内容：（要换行-区分markdown，不定义，上面的链接没有变化）</p>
<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：<br>Visit <a href="http://daringfireball.net/" target="_blank" rel="noopener">Daring Fireball</a> for more information.<br>然后接着定义链接：</p>
<p>6、链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<h4 id="3-比较"><a href="#3-比较" class="headerlink" title="3.比较"></a>3.比较</h4><p>下面是一个参考式链接的范例：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<p>如果改成用链接名称的方式写：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a><br>than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or<br><a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p>
<p>考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。   </p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="2-强调"><a href="#2-强调" class="headerlink" title="2 强调"></a>2 强调</h3><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong></strong></em></p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<p>1唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>2但是如果你的 <em> 和 _ 两边都有空白的话，它们就只会被当成普通的符号。<br>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：<br>\</em>this text is surrounded by literal asterisks*</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h3><p>1如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如 :</p>
<p>Use the <code>printf()</code> function.</p>
<p>2如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<p><code>There is a literal backtick (`) here.</code></p>
<p>3代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<p>A single backtick in a code span: <code>`</code> 没有空格是不行的</p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<p>4在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>
<p>你也可以这样写：&gt; </p>
<p><code>&amp;#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.sdf<code>&amp;gt; &lt;&gt;</code></p>
<h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4 图片"></a>4 图片</h3><p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。<br>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 </p>
<h4 id="1-行内式的图片语法看起来像是：-title可选-可以直接接进去"><a href="#1-行内式的图片语法看起来像是：-title可选-可以直接接进去" class="headerlink" title="1.行内式的图片语法看起来像是： title可选 ==可以直接接进去    =="></a>1.行内式的图片语法看起来像是： title可选<img src="http://you img base url//path/to/img.jpg?e=1585218234&token=your qiniu access key:OXySY1KsyTKJ5DUWdHup2-wM1Yk=" alt="Alt text"> ==可以直接接进去    ==</h4><p><img src="http://you img base url//path/to/img.jpg?e=1585218234&token=your qiniu access key:OXySY1KsyTKJ5DUWdHup2-wM1Yk=" alt="Alt text" title="Optional title"></p>
<h4 id="2-参考式的图片语法则长得像这样："><a href="#2-参考式的图片语法则长得像这样：" class="headerlink" title="2.参考式的图片语法则长得像这样："></a>2.参考式的图片语法则长得像这样：</h4><p><img src="http://example.com/?e=1585218234&token=your qiniu access key:iiCIzzuBuMUZTcMbQ7LNR8yIODk=" alt="Alt text" title="Optional Title Here"> </p>
<h4 id="3-到目前为止，-Markdown-还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的-标签。"><a href="#3-到目前为止，-Markdown-还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的-标签。" class="headerlink" title="3.到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的  标签。"></a>3.到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。</h4><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-反斜杠"><a href="#1-反斜杠" class="headerlink" title="1 反斜杠"></a>1 反斜杠</h3><h3 id="2-自动链接"><a href="#2-自动链接" class="headerlink" title="2 自动链接"></a>2 自动链接</h3><h2 id="五、感谢"><a href="#五、感谢" class="headerlink" title="五、感谢"></a>五、感谢</h2><h2 id="六、Markdown免费编辑器"><a href="#六、Markdown免费编辑器" class="headerlink" title="六、Markdown免费编辑器"></a>六、Markdown免费编辑器</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法说明(简体中文版)</title>
    <url>/w3/md/markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%89%88)/</url>
    <content><![CDATA[<p>toc only.</p>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></p>
<p style="text-align:right">2017.9.11 一 am</p>

<a id="more"></a> 
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-宗旨"><a href="#1-宗旨" class="headerlink" title="1 宗旨"></a>1 宗旨</h3><h3 id="2-兼容HTML"><a href="#2-兼容HTML" class="headerlink" title="2 兼容HTML"></a>2 兼容HTML</h3><h3 id="3-特殊字符自动转换"><a href="#3-特殊字符自动转换" class="headerlink" title="3 特殊字符自动转换"></a>3 特殊字符自动转换</h3><h2 id="二、区块元素"><a href="#二、区块元素" class="headerlink" title="二、区块元素"></a>二、区块元素</h2><h3 id="1-段落和换行"><a href="#1-段落和换行" class="headerlink" title="1 段落和换行"></a>1 段落和换行</h3><h3 id="2-标题"><a href="#2-标题" class="headerlink" title="2 标题"></a>2 标题</h3><h3 id="3-区块引用Blockquotes"><a href="#3-区块引用Blockquotes" class="headerlink" title="3 区块引用Blockquotes"></a>3 区块引用Blockquotes</h3><h3 id="4-列表"><a href="#4-列表" class="headerlink" title="4 列表"></a>4 列表</h3><h3 id="5-代码区块"><a href="#5-代码区块" class="headerlink" title="5 代码区块"></a>5 代码区块</h3><h3 id="6-分隔线"><a href="#6-分隔线" class="headerlink" title="6 分隔线"></a>6 分隔线</h3><h2 id="三、区段元素"><a href="#三、区段元素" class="headerlink" title="三、区段元素"></a>三、区段元素</h2><h3 id="1-链接"><a href="#1-链接" class="headerlink" title="1 链接"></a>1 链接</h3><h3 id="2-强调"><a href="#2-强调" class="headerlink" title="2 强调"></a>2 强调</h3><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h3><h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4 图片"></a>4 图片</h3><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-反斜杠"><a href="#1-反斜杠" class="headerlink" title="1 反斜杠"></a>1 反斜杠</h3><h3 id="2-自动链接"><a href="#2-自动链接" class="headerlink" title="2 自动链接"></a>2 自动链接</h3><h2 id="五、感谢"><a href="#五、感谢" class="headerlink" title="五、感谢"></a>五、感谢</h2><h2 id="六、Markdown免费编辑器"><a href="#六、Markdown免费编辑器" class="headerlink" title="六、Markdown免费编辑器"></a>六、Markdown免费编辑器</h2>]]></content>
      <categories>
        <category>w3</category>
        <category>md</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP教程-W3school</title>
    <url>/w3/ser/php%E6%95%99%E7%A8%8B-w3s/</url>
    <content><![CDATA[<p>toc and abstract.   </p>
<p>Server Side: SQL  ASP ADO PHP  VBScript   </p>
<p style="text-align:right">md文件重写   2017.9.26 二  21：54</p><br><p style="text-align:right">2017.8.16 三  21：00</p>

<h2 id="一-PHP-基础教程"><a href="#一-PHP-基础教程" class="headerlink" title="一 PHP 基础教程"></a>一 PHP 基础教程</h2><h3 id="1-教程"><a href="#1-教程" class="headerlink" title="1 教程"></a>1 教程</h3><h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2 简介"></a>2 简介</h3><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3 安装"></a>3 安装</h3><h3 id="4-语法"><a href="#4-语法" class="headerlink" title="4 语法"></a>4 语法</h3><p>PHP 语句以分号结尾（;）。PHP 代码块的关闭标签也会自动表明分号（因此在 PHP 代码块的最后一行不必使用分号）。<br>注释：//  #  /<em>  </em>/</p>
<h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5 变量"></a>5 变量</h3><p>作用域：local  global  static （函数中不能用global变量）<br>关键字：global（$GLOBALS[index] ），static</p>
<h3 id="6-Echo-Print-语言结构，有无括号均可使用：echo-或-echo-。–print也是"><a href="#6-Echo-Print-语言结构，有无括号均可使用：echo-或-echo-。–print也是" class="headerlink" title="6 Echo/Print  语言结构，有无括号均可使用：echo 或 echo()。–print也是"></a>6 Echo/Print  语言结构，有无括号均可使用：echo 或 echo()。–print也是</h3><p>echo - 能够输出一个以上的字符串<br>print - 只能输出一个字符串，并始终返回 1<br>(echo 比 print 稍快，因为它不返回任何值。)  </p>
<h3 id="7-数据类型-PHP-var-dump-会返回变量的数据类型和值："><a href="#7-数据类型-PHP-var-dump-会返回变量的数据类型和值：" class="headerlink" title="7 数据类型  (PHP var_dump() 会返回变量的数据类型和值：)"></a>7 数据类型  (PHP var_dump() 会返回变量的数据类型和值：)</h3><ol>
<li>字符串:</li>
<li>整数:十进制、十六进制（前缀是 0x）或八进制（前缀是 0）</li>
<li>浮点数: 小数点或指数形式的数字。$x=2.4e3  8E-5</li>
<li>逻辑:</li>
<li>数组:</li>
<li><p>对象: 在 PHP 中，必须明确地声明对象。<br> 首先我们必须声明对象的类。对此，我们使用 class 关键词。类是包含属性和方法的结构。  </p>
<p> 然后我们在对象类中定义数据类型，然后在该类的实例中使用此数据类型：</p>
</li>
<li>NULL:<h3 id="8-字符串函数"><a href="#8-字符串函数" class="headerlink" title="8 字符串函数"></a>8 字符串函数</h3>PHP strlen() 函数  strpos() 函数   更多……<h3 id="9-常量-define-函数-它使用三个参数："><a href="#9-常量-define-函数-它使用三个参数：" class="headerlink" title="9 常量 define() 函数 - 它使用三个参数："></a>9 常量 define() 函数 - 它使用三个参数：</h3>可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。<br> 有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。<br>注释：与变量不同，常量贯穿整个脚本是自动全局的。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其他-自己代码发现：1.函数好像不可以重新定义   </span><br><span class="line"></span><br><span class="line">2.函数后面必须有 ; ，无论是不是最后一行。--echo();  </span><br><span class="line"></span><br><span class="line">3. echo &quot;$x&quot;;//5  echo &apos;$x&apos;.&apos;&lt;/br&gt;&apos;;//$x  ;双引号中可以直接写变量，单引号是真的字符串；echo &quot;My car is a &#123;$cars[0]&#125;&quot;; = echo &quot;My car is a $cars[0]&quot;;&#123;&#125;中写表达式</span><br><span class="line"></span><br><span class="line">4.注意—区别其他语言js：1同样大小写敏感，但关键字不敏感；</span><br><span class="line">	2变量随时声明，$开头，作用域区别于js，函数名不可重复声明；</span><br><span class="line">	3常量的定义，define()函数，常量名，作用域;大小写敏感否，是不一样的常量，可以重写；</span><br><span class="line">	4字符串的拼接运算符 .  .= ；</span><br><span class="line">	5函数名大小写不敏感;</span><br><span class="line">	6混合写法—输出：&lt;?=$value?&gt; &lt;?php echo $value?&gt;相同；</span><br><span class="line">	7数组，函数定义方式；数组长度count(),实际长度，不会因为跳过负值长度虚假；</span><br><span class="line">	8 对象，定义，使用，继承：class，-&gt;，extent；</span><br><span class="line">	9 超全局   </span><br><span class="line">	10 强大的函数</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="10-运算符-lt-gt-不相等"><a href="#10-运算符-lt-gt-不相等" class="headerlink" title="10 运算符   &lt;&gt; 不相等"></a>10 运算符   &lt;&gt; 不相等</h3><p>字符串: .  .=<br>数组：联合+</p>
<h3 id="11-If…Else-elseif等价else-if"><a href="#11-If…Else-elseif等价else-if" class="headerlink" title="11 If…Else  elseif等价else if"></a>11 If…Else  elseif等价else if</h3><h3 id="12-Switch"><a href="#12-Switch" class="headerlink" title="12 Switch"></a>12 Switch</h3><h3 id="13-While-循环"><a href="#13-While-循环" class="headerlink" title="13 While 循环"></a>13 While 循环</h3><h3 id="14-For-循环"><a href="#14-For-循环" class="headerlink" title="14 For 循环"></a>14 For 循环</h3><p>Foreach只适用于数组；并且数组指针会逐一地移动，直到到达最后一个数组元素。</p>
<h3 id="15-函数-PHP-的真正力量来自它的函数：它拥有超过-1000-个内建的函数。"><a href="#15-函数-PHP-的真正力量来自它的函数：它拥有超过-1000-个内建的函数。" class="headerlink" title="15 函数  PHP 的真正力量来自它的函数：它拥有超过 1000 个内建的函数。"></a>15 函数  PHP 的真正力量来自它的函数：它拥有超过 1000 个内建的函数。</h3><p>默认参数值（类似es新语法）：function f($arg=50){  };<br>返回值  </p>
<p style="text-align:right">2017.8.17 四  21：00</p>

<h3 id="16-数组"><a href="#16-数组" class="headerlink" title="16 数组"></a>16 数组</h3><p>数组长度count()函数  array(“”=&gt; ,””=&gt; ,)  foreach($arr as $k=&gt;$v){}<br>索引：自动分配，0开始  array(“d”,”s”,”s”)；也可以收到分配<br>关联<br>多维  </p>
<h3 id="17-数组排序"><a href="#17-数组排序" class="headerlink" title="17 数组排序"></a>17 数组排序</h3><p>Sort(),rsort,  asort,ksort,  arsort,krsort</p>
<h3 id="18-超全局-全部作用域中始终可用的内置变量—4-1-0中引入"><a href="#18-超全局-全部作用域中始终可用的内置变量—4-1-0中引入" class="headerlink" title="18 超全局  全部作用域中始终可用的内置变量—4.1.0中引入"></a>18 超全局  全部作用域中始终可用的内置变量—4.1.0中引入</h3><h4 id="GLOBALS-SERVER-REQUEST-POST-GET-FILES-ENV-COOKIE-SESSION"><a href="#GLOBALS-SERVER-REQUEST-POST-GET-FILES-ENV-COOKIE-SESSION" class="headerlink" title="$GLOBALS,$_SERVER, $_REQUEST, $_POST, $_GET, $_FILES, $_ENV,  $_COOKIE, $_SESSION"></a>$GLOBALS,$_SERVER, $_REQUEST, $_POST, $_GET, $_FILES, $_ENV,  $_COOKIE, $_SESSION</h4><p>Server:关于报头、路径和脚本位置的信息<br>Request:HTML表单提交的数据<br>Post:表单method=”post”；传递变量<br>Get: 表单method=”get”；URL中发送的数据  </p>
<h2 id="二-PHP-表单"><a href="#二-PHP-表单" class="headerlink" title="二 PHP 表单"></a>二 PHP 表单</h2><h3 id="1-处理"><a href="#1-处理" class="headerlink" title="1 处理"></a>1 处理</h3><p>安全验证。<br>GET和POST：键值对（键—表单控件名称）</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2 验证"></a>2 验证</h3><h3 id="3-必填"><a href="#3-必填" class="headerlink" title="3 必填"></a>3 必填</h3><h3 id="4-URL-E-mail"><a href="#4-URL-E-mail" class="headerlink" title="4 URL/E-mail"></a>4 URL/E-mail</h3><h3 id="5-完成"><a href="#5-完成" class="headerlink" title="5 完成"></a>5 完成</h3><h2 id="三-PHP-高级教程"><a href="#三-PHP-高级教程" class="headerlink" title="三 PHP 高级教程"></a>三 PHP 高级教程</h2><h3 id="1-多维数组"><a href="#1-多维数组" class="headerlink" title="1 多维数组"></a>1 多维数组</h3><h3 id="2-日期"><a href="#2-日期" class="headerlink" title="2 日期"></a>2 日期</h3><h3 id="3-Include"><a href="#3-Include" class="headerlink" title="3 Include:"></a>3 Include:</h3><p>nclude 和 require 语句是相同的，除了错误处理方面：</p>
<ul>
<li>require 会生成致命错误（E_COMPILE_ERROR）并停止脚本;</li>
<li>include 只生成警告（E_WARNING），并且脚本会继续</li>
</ul>
<h3 id="4-文件-——–"><a href="#4-文件-——–" class="headerlink" title="4 文件:——–"></a>4 文件:——–</h3><h3 id="5-文件打开-读取————–"><a href="#5-文件打开-读取————–" class="headerlink" title="5 文件打开/读取————–"></a>5 文件打开/读取————–</h3><h3 id="6-文件创建-写入————"><a href="#6-文件创建-写入————" class="headerlink" title="6 文件创建/写入————-"></a>6 文件创建/写入————-</h3><h3 id="7-文件上传—————–"><a href="#7-文件上传—————–" class="headerlink" title="7 文件上传—————–"></a>7 文件上传—————–</h3><h3 id="8-Cookies"><a href="#8-Cookies" class="headerlink" title="8 Cookies"></a>8 Cookies</h3><h3 id="9-Sessions"><a href="#9-Sessions" class="headerlink" title="9 Sessions"></a>9 Sessions</h3><h3 id="10-E-mail"><a href="#10-E-mail" class="headerlink" title="10 E-mail"></a>10 E-mail</h3><p>mail(to,subject,message,headers,parameters) 函数用于从脚本中发送电子邮件。</p>
<h3 id="11-安全E-mail————"><a href="#11-安全E-mail————" class="headerlink" title="11 安全E-mail————"></a>11 安全E-mail————</h3><h3 id="12-Error："><a href="#12-Error：" class="headerlink" title="12 Error：++++"></a>12 Error：++++</h3><h3 id="13-Exception"><a href="#13-Exception" class="headerlink" title="13 Exception:+++++"></a>13 Exception:+++++</h3><h3 id="14-Filter"><a href="#14-Filter" class="headerlink" title="14 Filter:+++++"></a>14 Filter:+++++</h3><p>用于验证和过滤来自非安全来源的数据，比如用户的输入。</p>
<ul>
<li><p>什么是 PHP 过滤器  </p>
<ol>
<li>PHP 过滤器用于验证和过滤来自非安全来源的数据。  </li>
<li>验证和过滤用户输入或自定义数据是任何 Web 应用程序的重要组成部分。  </li>
<li>设计 PHP 的过滤器扩展的目的是使数据过滤更轻松快捷。</li>
</ol>
</li>
<li><p>为什么使用过滤器</p>
</li>
<li>什么是外部数据<br>  来自表单的输入数据、Cookies、服务器变量、数据库查询结果</li>
<li>函数和过滤器:如需过滤变量，请使用下面的过滤器函数之一<ol>
<li>filter_var() - 通过一个指定的过滤器来过滤单一的变量</li>
<li>filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量</li>
<li>filter_input - 获取一个输入变量，并对它进行过滤</li>
<li>filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤</li>
</ol>
</li>
<li><p>有两种过滤器：</p>
<ol>
<li><p>Validating 过滤器：<br>用于验证用户输入<br>严格的格式规则（比如 URL 或 E-Mail 验证）<br>如果成功则返回预期的类型，如果失败则返回 FALSE</p>
</li>
<li><p>Sanitizing 过滤器：<br>用于允许或禁止字符串中指定的字符<br>无数据格式规则<br>始终返回字符串    </p>
</li>
</ol>
</li>
<li>选项和标志</li>
<li>验证输入</li>
<li>净化输入</li>
<li>过滤多个输入</li>
<li>使用 Filter Callback<h2 id="四-PHP-数据库"><a href="#四-PHP-数据库" class="headerlink" title="四 PHP 数据库"></a>四 PHP 数据库</h2>MySQL: (和mysali–impoved 不一样)<br>简介,Connect,create,insert,select,where,order by,update,delete,ODBC<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><h3 id="2-Connect"><a href="#2-Connect" class="headerlink" title="2 Connect"></a>2 Connect</h3>  $con = mysql_connect(“localhost”,”peter”,”abc123”);<br>  if (!$con) {<pre><code>die(&apos;Could not connect: &apos; . mysql_error());
</code></pre>  }<br>  mysql_close($con);<h3 id="3-create"><a href="#3-create" class="headerlink" title="3 create"></a>3 create</h3></li>
<li><p>Create database</p>
<pre><code>mysql_query(&quot;CREATE DATABASE my_db&quot;,$con)
</code></pre></li>
<li><p>Create table in my_db database</p>
<pre><code>mysql_select_db(&quot;my_db&quot;, $con);
$sql = &quot;CREATE TABLE Persons (
    FirstName varchar(15),
    LastName varchar(15),
    Age int
)&quot;;
mysql_query($sql,$con);
</code></pre></li>
<li>MySQL 数据类型    <ol>
<li>数值</li>
<li>文本</li>
<li>日期</li>
<li>杂项：enum(value1,value2,ect)、set</li>
</ol>
</li>
<li><p>主键和自动递增字段</p>
<pre><code>//把 personID 字段设置为主键字段。主键字段通常是 ID 号，且通常使用 AUTO_INCREMENT 设置。
$sql = &quot;CREATE TABLE Persons (
    personID int NOT NULL AUTO_INCREMENT, 
    PRIMARY KEY(personID),
    FirstName varchar(15),
    LastName varchar(15),
    Age int
)&quot;;
</code></pre></li>
</ul>
<h3 id="4-insert"><a href="#4-insert" class="headerlink" title="4 insert"></a>4 insert</h3><pre><code>INSERT INTO table_name VALUES (value1, value2,....)
INSERT INTO table_name (column1, column2,...) VALUES (value1, value2,....)
//例子
mysql_query(&quot;INSERT INTO Persons (FirstName, LastName, Age)VALUES (&apos;Peter&apos;, &apos;Griffin&apos;, &apos;35&apos;)&quot;);
</code></pre><h3 id="5-select"><a href="#5-select" class="headerlink" title="5 select"></a>5 select</h3><pre><code>$result = mysql_query(&quot;SELECT * FROM Persons&quot;);
while($row = mysql_fetch_array($result))
{
    echo $row[&apos;FirstName&apos;] . &quot; &quot; . $row[&apos;LastName&apos;];
    echo &quot;&lt;br /&gt;&quot;;
}
</code></pre><ol>
<li>在 $result 变量中存放由 mysql_query() 函数返回的数据。    </li>
<li>接下来，我们使用 mysql_fetch_array() 函数以数组的形式从记录集返回第一行。每个随后对 mysql_fetch_array() 函数的调用都会返回记录集中的下一行。<br>while loop 语句会循环记录集中的所有记录。  </li>
<li>为了输出每行的值，我们使用了 PHP 的 $row 变量 ($row[‘FirstName’] 和 $row[‘LastName’])。    </li>
</ol>
<h3 id="6-where"><a href="#6-where" class="headerlink" title="6 where"></a>6 where</h3><pre><code>$result = mysql_query(&quot;SELECT * FROM Persons WHERE FirstName=&apos;Peter&apos;&quot;);
while($row = mysql_fetch_array($result))
</code></pre><h3 id="7-order-by"><a href="#7-order-by" class="headerlink" title="7 order by"></a>7 order by</h3><pre><code>SELECT column_name(s) FROM table_name ORDER BY column_name
SELECT column_name(s) FROM table_name ORDER BY column_name DESC
SELECT column_name(s) FROM table_name ORDER BY column_name1, column_name2
//例子
$result = mysql_query(&quot;SELECT * FROM Persons ORDER BY age&quot;)
while($row = mysql_fetch_array($result))
</code></pre><h3 id="8-update"><a href="#8-update" class="headerlink" title="8 update"></a>8 update</h3><pre><code>mysql_query(&quot;UPDATE Persons SET Age = &apos;36&apos; WHERE FirstName = &apos;Peter&apos; AND LastName = &apos;Griffin&apos;&quot;);
</code></pre><h3 id="9-delete"><a href="#9-delete" class="headerlink" title="9 delete"></a>9 delete</h3><pre><code>mysql_query(&quot;DELETE FROM Persons WHERE LastName=&apos;Griffin&apos;&quot;);
</code></pre><h3 id="10-ODBC"><a href="#10-ODBC" class="headerlink" title="10 ODBC"></a>10 ODBC</h3><p>ODBC 是一种应用程序编程接口（Application Programming Interface，API），使我们有能力连接到某个数据源（比如一个 MS Access 数据库）。</p>
<ol>
<li><p>创建 ODBC 连接<br> * 通过一个 ODBC 连接，您可以连接到您的网络中的任何计算机上的任何数据库，只要 ODBC 连接是可用的。</p>
<p> * 这是创建到达 MS Access 数据的 ODBC 连接的方法：</p>
<ol>
<li>在控制面板中打开管理工具</li>
<li>双击其中的数据源 (ODBC) 图标</li>
<li>选择系统 DSN 选项卡</li>
<li>点击系统 DSN 选项卡中的“添加”按钮</li>
<li>选择 Microsoft Access Driver。点击完成。</li>
<li>在下一个界面，点击“选择”来定位数据库。</li>
<li>为这个数据库取一个数据源名 (DSN)。</li>
<li><p>点击确定。</p>
<p>* 请注意，必须在您的网站所在的计算机上完成这个配置。如果您的计算机上正在运行 Internet 信息服务器 (IIS)，上面的指令会生效，但是假如您的网站位于远程服务器，您必须拥有对该服务器的物理访问权限，或者请您的主机提供商为您建立 DSN。</p>
</li>
</ol>
</li>
<li><p>连接到 ODBC<br> 1. odbc_connect() 函数用于连接到 ODBC 数据源。该函数有四个参数：数据源名、用户名、密码以及可选的指针类型参数。<br> 2. odbc_exec() 函数用于执行 SQL 语句。</p>
<pre><code>$conn=odbc_connect(&apos;northwind&apos;,&apos;&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM customers&quot;; 
$rs=odbc_exec($conn,$sql);
</code></pre></li>
<li><p>取回记录<br>odbc_fetch_row() 函数用于从结果集中返回记录。如果能够返回行，则返回 true，否则返回 false。<br>该函数有两个参数：ODBC 结果标识符和可选的行号：</p>
<pre><code>odbc_fetch_row($rs)
</code></pre></li>
<li><p>从记录中取回字段<br>odbc_result() 函数用于从记录中读取字段。该函数有两个参数：ODBC 结果标识符和字段编号或名称。</p>
<pre><code>$compname=odbc_result($rs,1); 
$compname=odbc_result($rs,&quot;CompanyName&quot;);
</code></pre></li>
<li><p>关闭 ODBC 连接  </p>
<pre><code>odbc_close($conn);
</code></pre></li>
<li>ODBC 实例  </li>
</ol>
<h2 id="五-PHP-XML"><a href="#五-PHP-XML" class="headerlink" title="五 PHP XML"></a>五 PHP XML</h2><h3 id="1-expat-parser"><a href="#1-expat-parser" class="headerlink" title="1 expat parser"></a>1 expat parser</h3><h3 id="2-dom"><a href="#2-dom" class="headerlink" title="2 dom"></a>2 dom</h3><h3 id="3-simpleXML"><a href="#3-simpleXML" class="headerlink" title="3 simpleXML"></a>3 simpleXML</h3><h2 id="六-PHP-和AJAX"><a href="#六-PHP-和AJAX" class="headerlink" title="六 PHP 和AJAX"></a>六 PHP 和AJAX</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1 简介"></a>1 简介</h3><h3 id="2-XMLHttpRequest"><a href="#2-XMLHttpRequest" class="headerlink" title="2 XMLHttpRequest"></a>2 XMLHttpRequest</h3><h3 id="3-AJAX-Suggest"><a href="#3-AJAX-Suggest" class="headerlink" title="3 AJAX Suggest"></a>3 AJAX Suggest</h3><h3 id="4-AJAX-XML"><a href="#4-AJAX-XML" class="headerlink" title="4 AJAX XML"></a>4 AJAX XML</h3><h3 id="5-AJAX-Database"><a href="#5-AJAX-Database" class="headerlink" title="5 AJAX Database,"></a>5 AJAX Database,</h3><h3 id="6-AJAX-responseXML"><a href="#6-AJAX-responseXML" class="headerlink" title="6 AJAX responseXML,"></a>6 AJAX responseXML,</h3><h3 id="7-AJAX-ive-search"><a href="#7-AJAX-ive-search" class="headerlink" title="7 AJAX ive search,"></a>7 AJAX ive search,</h3><h3 id="8-AJAX-RSS-reader"><a href="#8-AJAX-RSS-reader" class="headerlink" title="8 AJAX RSS reader,"></a>8 AJAX RSS reader,</h3><h3 id="9-AJAX-poll"><a href="#9-AJAX-poll" class="headerlink" title="9 AJAX poll"></a>9 AJAX poll</h3><h2 id="七-PHP-参考手册"><a href="#七-PHP-参考手册" class="headerlink" title="七 PHP 参考手册"></a>七 PHP 参考手册</h2><h3 id="Array-calendar-date-directory-error-filesystem-filter"><a href="#Array-calendar-date-directory-error-filesystem-filter" class="headerlink" title="Array,calendar,date,directory,error,filesystem,filter,"></a>Array,calendar,date,directory,error,filesystem,filter,</h3><h3 id="FTP-HTTP-libXML-mail-math-mySQL-mySQLi-simpleXML-string-XML"><a href="#FTP-HTTP-libXML-mail-math-mySQL-mySQLi-simpleXML-string-XML" class="headerlink" title="FTP,HTTP,libXML,mail,math,mySQL,mySQLi,simpleXML,string,XML,"></a>FTP,HTTP,libXML,mail,math,mySQL,mySQLi,simpleXML,string,XML,</h3><h3 id="zip-杂项-时区"><a href="#zip-杂项-时区" class="headerlink" title="zip,杂项,时区"></a>zip,杂项,时区</h3><h2 id="八-PHP-测验"><a href="#八-PHP-测验" class="headerlink" title="八 PHP 测验"></a>八 PHP 测验</h2><p style="text-align:right">md文件重写   2017.9.26 二  23：54</p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.三、高级 4.文件 之后未完成</span><br><span class="line">2.五、XML 未</span><br><span class="line">3.六、AJAX</span><br><span class="line">4.七、手册</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
  </entry>
  <entry>
    <title>别具光芒：Css属性、浏览器兼容与网页布局</title>
    <url>/pdf/css/%E5%88%AB%E5%85%B7%E5%85%89%E8%8A%92%EF%BC%9Acss%E5%B1%9E%E6%80%A7%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E4%B8%8E%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>李烨编    人民邮电    2008.10<br>2017.6.24 六 am<br>第一部分：web标准  1，2<br>第二部分：css2.1详解<br>第三部分：实例 17</p>
<h2 id="第1章-Web标准概述"><a href="#第1章-Web标准概述" class="headerlink" title="第1章 Web标准概述"></a>第1章 Web标准概述</h2><h3 id="1-1-Web标准概述"><a href="#1-1-Web标准概述" class="headerlink" title="1.1 Web标准概述"></a>1.1 Web标准概述</h3><p>W3c—万维网联盟+其他（ecma）<br>结构：主要包括xhtml,xml，<br>表现:css，<br>行为:</p>
<h3 id="1-2表现与结构的分离"><a href="#1-2表现与结构的分离" class="headerlink" title="1.2表现与结构的分离"></a>1.2表现与结构的分离</h3><h3 id="1-3易用性：避免框架、表单、javascript和cookies"><a href="#1-3易用性：避免框架、表单、javascript和cookies" class="headerlink" title="1.3易用性：避免框架、表单、javascript和cookies"></a>1.3易用性：避免框架、表单、javascript和cookies</h3><h3 id="1-4难点所在："><a href="#1-4难点所在：" class="headerlink" title="1.4难点所在："></a>1.4难点所在：</h3><p>1，div+css不等于web标准<br>2，正确使用xhtml标签<br>3，表格本身并没有被抛弃<br>4，善于利用css<br>5，不要滥用class<br>6，应对浏览器<br>7，“通过验证”并不是最终目的</p>
<h3 id="1-5-SEO简介"><a href="#1-5-SEO简介" class="headerlink" title="1.5 SEO简介"></a>1.5 SEO简介</h3><p>17点：<br>静态页面，页面标题，meta标签优化，针对google制作sitemaps，图片的关键词优化，<br>避免表格的嵌套，采用web标准进行网站重构，网站结构的扁平化规划，页面容量的合理化<br>外部文件策略，外包链接（PR值），网站地图，图像热点，flash应用，js脚本，frame框架，资讯的内部链接</p>
<p>盒模型的七个参数？？<br>（本书html4.0，html5.0 在研发中）</p>
<h2 id="第2章-结构与XHTML"><a href="#第2章-结构与XHTML" class="headerlink" title="第2章 结构与XHTML"></a>第2章 结构与XHTML</h2><h3 id="2-1-理解结构与表现"><a href="#2-1-理解结构与表现" class="headerlink" title="2.1 理解结构与表现"></a>2.1 理解结构与表现</h3><h3 id="2-2-从html到xhtml"><a href="#2-2-从html到xhtml" class="headerlink" title="2.2 从html到xhtml"></a>2.2 从html到xhtml</h3><p>网页是由超文本标记语言（html）构成的<br>2.2.1 Html简史<br>1，Html特点：（设计者（本尼斯李）考虑1989：独立于平台，超文本，精确的结构化文档<br>所以用 SGML（标准通用标记语言）做为html的开发模版     （html 1.0）<br>SGML：具有结构化和独立于平台的优点，标准化—相当长时间内不需要重新构建<br>1独立于平台，因为它对文档的语义结构或含义进行编码描述，而不是对文档的实际外观进行编码描述。<br>    2另一个特征，按语义编码的文本可以由计算机更智能地自动处理<br>    3一大优点—灵活性。（sgml，..本身并不是一种格式，而是定义其他格式的一种规范，。。任何使用sgml的软件都能读懂它。–人们定义了许多文档类型DTD，html只是一种DTD，或者SGML的应用<br>89以来，html及万维网变化巨大，NCSA（美国国家超级计算机应用中心）1993首次构建mosaic浏览器时，把自己需要的特性添加到html中，包括直接插入图形<br>2，1994，html失控发展。IETF主持，1995.11日内瓦 成立了HTML工作小组，把html形式化成一种SGML DTD     （html 2.0）<br>3，万维网联盟html工作组，集中了1996年万维网发展成功， HTML 3.2<br>4，HTML 4.0  继承以往版本的所有特点，并发展<br>2.2.2 html的缺点<br>5，w3c，又制定了XHTML：html向xml过渡的桥梁，一种增强了的html<br>XML是web发展的趋势，XHTML 1.0当前替代html 4.0标记语言的标准。。既适合XML系统，又大部分HTML浏览器页面，这个指导方针可以使web平滑的过渡到XML<br>    另一个优势非常严密，同时xhtml能与其他基于xml的标记语言、应用程序以及协议进行良好的交互工作。Xhtml是web标准家族的一部分。。。</p>
<p>2.2.3从html到xhtml<br>1，选择DTD定义文档的类型&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “<a href="http://www.xhtml1/DTD/xhtml1-transitional.dtd”&gt;" target="_blank" rel="noopener">http://www.xhtml1/DTD/xhtml1-transitional.dtd”&gt;</a><br>XHTML 1.0 三种DTD声明可供选择：Transitional  Strict  Frameset<br>2,设定一个名字空间 <code>&lt;html XMLns=”http://www.w3.org/1999/xhtml”&gt;</code><br>    Xml允许定义自己的标签，制定者定义的标签可能和其他人定义的标签可能相同，但不同的意义。当交互或共享容易错误，..<br>    XHTML,需要符合XML文档的规则，也需要定义名字空间。不能自定义，都是相同的..<br>3,定义语言编码 <code>&lt;meta http-equiv=”Content-Type” content=”text/html;charset=GB2312/&gt;</code><br>4,一定要正确的嵌套使用<br>5，一定要有正确的组织结构<br>6，标签名字一定要用小写字母  XML对大小写敏感<br>7，一定要关闭   <code>&lt;img/&gt;</code><br>8,属性名字必须小写<br>9，属性值必须带 英文双引号<br>10，属性的简写被禁止  html中是可以的   checked   vs   checked=”checked”<br>11,id属性代替name属性  xhtml除了表单form, 链接a  ，name属性不能使用<br>12,内容文字注意转义  &amp; &lt;  &gt;  “  版权&copy;  注册&reg;<br>13,xml:lang和lang属性(html格式，两个同时用)<br>&lt; html xmlns=<a href="http://www.w3.org/1999/xhtml" target="_blank" rel="noopener">http://www.w3.org/1999/xhtml</a> lang=”zh-CN” xml:lang=”zh-CN”&gt;</p>
<h3 id="2-3理解（X）HTML标签的语义"><a href="#2-3理解（X）HTML标签的语义" class="headerlink" title="2.3理解（X）HTML标签的语义"></a>2.3理解（X）HTML标签的语义</h3><p>2.3.1  浏览器默认样式<br>实际3个样式：制作者&gt;用户&gt;浏览器默认<br>2.3.2 常用标签和属性<br>H1~h6  p ul,ol,li dl,dt,dd  em,strong  table,td ,th, caption,summary属性，<br>q,blockquote,cite和cite属性  ins,del  dfn,code,samp,kbd,var,address  abbr,acronym<br>11title属性（为元素提供额外说明信息）（？？如果同时设置，不同浏览器表现）<br>alt属性（为不能显示图像，窗体或applets的用户端指定替换文字，语言由lang指定）<br>12表单form,input,textarea,select,optgroup,option,button,label,fieldset,legend<br>13 div,span</p>
<p>2.3.3 （x）html各个元素对搜索引擎的权重比例<br>10分：内部链接文字，title元素    7分：域名<br>5分：h1,h2 每段首句，     4分：路径或文件名，相似度（关键词堆积）<br>1.5分：每句开头  1分：加粗或斜体，文本用法（内容），title属性<br>0.5分：图片的alt属性，meta描述（description属性）<br>0.05分：meta关键词（keywords属性）<br>（？现在还是这样吗）</p>
<h3 id="2-4网站整体制作基本流程"><a href="#2-4网站整体制作基本流程" class="headerlink" title="2.4网站整体制作基本流程"></a>2.4网站整体制作基本流程</h3><p>第2部分  层叠样式表CSS</p>
<h2 id="第3章-css入门"><a href="#第3章-css入门" class="headerlink" title="第3章 css入门"></a>第3章 css入门</h2><p>3.1 css简介<br>3.1.1起源<br>1990年代初htm被发明开始，样式表就以各种形式出现<br>1994 F提出css 。1996。12 css 1  1998.5 css2  本书完稿时css 3还在开发中<br>3.1.2 神奇的css   css禅意花园—css zen garden<br>3.1.3 css与html<br>3.1.4 css与浏览器  拥有最多用户的windows ie（包括ie7.0）却并没有完全支出css2.1-hack<br>3.1.5 css 2.1与css 2</p>
<p>3.2 css的使用方法<br>3.2.1 行内<br>3.3.2 嵌入<br>3.2.3 外部<br><code>&lt;link rel=”stylesheet” href=”basic.css” type=”text/css” media=”all”&gt;</code><br>Rel：定义了文档与链接的关系，  （stylesheet：样式表）<br>Media：可选属性，值：screen,print,projection(投影)，speech(屏幕阅读器等发生设备)，braille（盲文触摸式反馈设备）,embossed（用于打印的盲人印刷设备）,handheld(手持设备)<br>    Tty,tv,all<br>3.2.4 导入式样式表<br>    @import  好处：一些老的浏览器（netscape 4.X）不接受，进而不接受规则<br>因此，要写在样式表文件的最开始<br>Window ie，使用导入式样式表，有可能会出现文档样式暂时失效的现象（导入样式的style标签前插入一个空的script标签，或者也可以使用link标签引入外部样式表）<br>3.2.5 应用<br>3.2.6 维护和组织样式表</p>
<h3 id="3-3-基本样式规则"><a href="#3-3-基本样式规则" class="headerlink" title="3.3 基本样式规则"></a>3.3 基本样式规则</h3><p>3.3.1 基本语法<br>3.3.2 继承与层叠<br>3.3.3 分组：分组选择器，分组声明，组合应用<br>3.3.4 注释<br>3.3.5 缩写：Css属性缩写，颜色值缩写，利用继承，0px与0<br>3.3.6 注意事项：空格，大小写敏感，容错</p>
<h3 id="3-4-元素类型"><a href="#3-4-元素类型" class="headerlink" title="3.4 元素类型"></a>3.4 元素类型</h3><p>3.4.1 替换和不可替换元素：Img,input,textarea,select,object     p<br>3.4,2 显示元素（另一种分类方式）（display属性）<br>块级:div,p,h1~h6   一般都是不可替换元素  float，block，list-item<br>行内：img,input     inline</p>
<h3 id="3-5-媒体类型"><a href="#3-5-媒体类型" class="headerlink" title="3.5 媒体类型"></a>3.5 媒体类型</h3><p>1.指定媒体相关的样式表<br>1，样式表 @import url(“  “) aural;  或者  @media print{… }<br>2，文档语言中指定 <code>&lt;link rel=”stylesheet” href=” “  type=”text/css” media=”print,screen”/&gt;</code><br>2.媒体组：连续媒体，视觉，栅格，交互，all</p>
<h2 id="第4章-文档结构与选择器"><a href="#第4章-文档结构与选择器" class="headerlink" title="第4章 文档结构与选择器"></a>第4章 文档结构与选择器</h2><p>1 文档结构 css大部分能力是基于元素的“父子”关系，有时候一般化为祖先和后代，兄弟  </p>
<p>2 css选择器 （css 2.1 。。，但是由于一些浏览器只支持其中一部分，大打折扣）<br>通配选择器，类型，ID（虽然重复的id不会报错，但是js操作），类，包含（后代），<br>（—上面的都支持，下面的ie7，ff2.0 o8.5支持，ie6不支持（可针对ie6做处理）—）<br>子元素&gt;，相邻兄弟+，属性（简易，精确值，部分值，特殊–（和现在学的稍微有些不一样））</p>
<p>3 伪类与伪元素<br>3.1伪类：链接：link，visited  动态：hover，active，focus（ie6只支持a的hover）多种<br>子元素：first-child（ie6不支持）语言:lang(en){… }（ie7）<br>3.2 伪元素：<br>first-line：只可以和块级连用，特性和行内元素类似。字体、颜色、背景、word-spacing、letter-spacing、text-decoration、vertiack-align、text-transform、line-height、text-shadow、clear<br>fisrst-letter: 和行内元素类似。字体、颜色、背景、letter-spacing、vertiack-align（仅当不浮动时）、text-transform、line-height、margin、padding、border、float、letter-spacing、word-spacing、text-shadow、clear  （如果出现标点符号也包括在内）<br>before,after: 必须和css的content属性配合使用 （ie7 不支持）<br>3.3 注意：<br>    链接伪类顺序：lvha<br>    位置：伪类选择器任何位置，伪元素选择器主体之后p:first-letter:hover,div:first-line a错的</p>
<p>4 指定值、计算值和实际值<br>制定者不必定义每一个，解释网页的（浏览器）必须为文档树每个元素每个属性一个值<br>一个属性最终值4步计算：指定值—（用以继承的）计算值—（如果需要转为绝对）使用值—（依照局部的环境限定）实际值</p>
<p>5 继承<br>5.1 值的继承：color，font-size<br>5.2 inherit值 只用作后备值，显示地指定inherit   p { font-size: inherit; }<br>5.3 继承的局限性：border,marging,padding,背景不继承，浏览器默认也影响继承的结果（老）</p>
<p>6层叠<br>6.1 层叠的顺序<br>    层叠规则依据下面几个步骤进行<br>1，    查找有冲突的元素<br>2，    样式表的来源：用户的重要性》制定者的重要性》制定者定义》用户定义》浏览器默认。。。<br>制定者定义css文件引入的规则取决于顺序。（样式表中使用@优先级，同样适用）。<br>行内》嵌入》从文件引入<br>3，    选择器的特殊性：声明的第二排序基于选择器的特殊性<br>4，    规则出现的先后次序：相同的权重，相同的来源，相同的特殊性<br>6.2特殊性的计算—-0，0，0，1   1，2，4，4      a,b,c,d    忽略伪元素<br>6.3 继承和特殊性 继承0<br>6.4 重要性 import高于内联式（？？那行内呢）<br>6.5 非css的表现类内容:font标签，align属性</p>
<p>7 css 3新增选择器前瞻<br>7.1 更多的属性选择器 ^ $ *<br>7.2 普通兄弟 ~<br>7.3 结构伪类：root，nth-child(n)（从1开始），nth-last-child(n) nth-of-type(n) nth-last-of-tyoe(n) last-child first-of-type last-of-type only-child only-of-type empty<br>7.4 UI元素伪类和伪元素 :enabled disabled checked  ::selection<br>7.5 其他 否定not(s) 目标 target</p>
<p>8 命名规范<br>注意名称的语义、使用有意义的单词、分段书写（驼峰、帕斯卡、下划线、连字符）</p>
<p>9 选择器综合运用<br>不要过于复杂，只要能生效   如果通过包含选择器，一般没必要添加类或者id</p>
<p>2017.6.24 六 23：00</p>
<h2 id="第5章-单位和值"><a href="#第5章-单位和值" class="headerlink" title="第5章 单位和值"></a>第5章 单位和值</h2><p>1 颜色<br>1.1    颜色关键字：css 2 16个关键字。Orange—css 2.1新增<br>显示设备、操作系统、显示卡、浏览器不同；<br>（8位真彩色：256种颜色；24-1600万中）<br>1.2    RGB颜色：（同显示器原理）百分比，数字，十六进制<br>1.3    关键字transparent：边框也可，默认有color属性指定。<br>好像：Ie6无，ie7但是有<em>px的距离<br>1.4网页安全色：216网页安全色。当r，g，b颜色数字信号值（DAC count）为0，51，102，153，204，255构成的组合，6</em>6*6=216，210中彩色（转15：00，33，66，99，CC,FF）</p>
<p>2整数值和实数值:前缀+，—；很多会有取值范围</p>
<p>3 长度<br>3.1 格式<br>3.2 单位：对计算机的屏幕设备，px是一个最基本单位（都换为px显示）；其他设备可能不是px<br>1，绝对：in=2.54cm，1cm=0.394in；mm；72pt=1in，印刷；12点活字，pica=12pt，6pica=1in<br>    （如果不被支持，用户端近似实际值）<br>2，相对：em，ex ，（和字体尺寸相关）；px<br>Pixel：picture element 用来计算数位影像的一种单位。那么多少个像素等于1英寸呢？<br>    和显示器的PPI相关。（DPI，印刷上的计量单位：每平方英寸上，所印刷的网点数dot per inch），但在与电脑结合。。大多数人将数位影像的解析度用DPI表示，印刷-网点dot和电脑显示的像素pixel并不同，专业人士用ppi表示数位解析度，借以区分二者。<br>    Windows默认96ppi，mac os 71ppi。。css2 规范90ppi。实际应用中，浏览器往往会使用显示器的设置，但在其他设备中结果就不尽相同了。图片尺寸一般px<br>3.3 应用  绝对—打印设备；显示器—建议相对</p>
<p>4百分比<br>参考值：1同一元素的另外一个属性的值font-size:10pt;line-height:120%;==10pt*120=12pt；2 其祖先元素的属性值；3格式化上下文的值。。。子元素通常继承其父元素的计算值</p>
<p>5 关键字：以标识符形式出现，不可以放在引号之间</p>
<p>6 字符串：引号中。（再次出现要转义\”===\22,\’===\27）。不可以直接包含新行，转义\00000a,\A<br>7 URL+URN=URI :统一资源。。web地址的基本形式是URI<br>url：普遍， 。不仅标识资源，而且指出访问资源的方式（比如协议：http,ftp）,urn没有<br>urn：url的更新形式，不依赖于位置，并可能减少失效连接的个数<br>uri，( ) , 空白字符 ‘ “ 六个转义   (===%28  )===%29</p>
<p>8 其他值：大部分应用在其他设备<br>8.1 计数器counter：只可以由content属性引用<br>8.2 角度angle：deg（度） ，grad（梯度），rad（弧度） 90度=100梯度=1.57。。。。。弧度<br>8.3 时间：ms s，不可以为负数<br>8.4 频率：使用在语音样式表中，实数+单位Hz，kHz。不可以负数</p>
<p>9不支持的值的处理  display:run-in     忽略</p>
<h2 id="第6章字体"><a href="#第6章字体" class="headerlink" title="第6章字体"></a>第6章字体</h2><p>字体：font，字面：face；字体集：font family；磅值：weight；样式：style—三种字形roman type，oblique type，utakuc type<br>1 字体集 font-famliy 继承<br>英文字体一般有若干系列字体组成。。每一个字体集又包括黑，粗，斜各种风格的字体成员<br>1.1    语法：多个用逗号隔开，含有空格用引号，中文字体用引号<br>访问者计算机是否安装，最好常见的TrueType字体（applecomputer，microsoft联合），如：New Roman,Courier,Verdana,Century Gothic, 中文操作系统windows自带宋体、黑体、楷体<br>字体名并不是随便输入的，在各个操作平台上的名称可能不一样。Windows—应用软件，mac—打开系统文件夹<br>1.2    常用字体系列：Times字体系列、04字体系列（网页设计中很著名）<br>除了设计者定义，css也定义几个一般的字体系列<br>1，Serif字体：Times New Roman,  宋体，细明体（繁体常用）。成比例有衬线。比较容易阅读<br>2，Sans Serif字体：Arial，  黑体       适合标题字，不适合大面积文字，因为容易造成字母辨认困扰<br>3，    Monospace字体：Courier New，无比例，模拟打印字或者程序代码。等宽，易辨认，美观差<br>4，    Cursive字体：ComicSans，模拟你手写的草体文字 不鼓励使用<br>5，    Fantasy字体：WingDings，Symbol。更多是通过说明他不属于某个范畴（其他4）来定义</p>
<p>2 字体尺寸：font-size 继承<br>很多其他属性设定，可以以字体大小为基础达到弹性设计的目的<br>2.1 语法：与浏览器显示出来的实际大小，取决于字的“全身方框”<br>2.2 绝对尺寸：<br>2.3 相对尺寸<br>2.4 百分比和em<br>2.5 尺寸的继承与浏览器的显示：继承的是计算值，不是百分比；不能是小数，不同计算机不同的处理方式；奇数尺寸的字在横向可能会有变形<br>2.6 分辨率（dpi）与弹性设计：避免单位混用；美观、易控制-px；但是。。。尽量百分比，关键字</p>
<p>3 字体磅值：font-weight 继承<br>3.1 语法<br>3.2 继承<br>3.3 浏览器显示原理<br>1，9个级别的关键字：<br>2，bolder，lighter</p>
<p>4 字体样式：font-style  继承  normal,italic,oblique</p>
<p>5 字体变形：font-variant 继承 normal，small-caps, 有些字体提供小型大写字母 </p>
<p>6 缩写的字体属性：font<br>(style/variant/weight)? size (/line-height)? Family (系统字体)  </p>
<p>7 调整与拉伸：font-size-adjust font-stretch  css 2中，css 2.1 又删除了</p>
<p>8 字体匹配原理：很复杂的过程<br>8.1 匹配步骤<br>8.2 设定字体集注意事项：建议定义多个；最好指定一种常用字体系列；可以只定义一个字体系列，而不指定具体的字体名<br>8.3 字体的选择：一个文档里指定字体选择行为有4中：名字匹配、只能匹配、综合、下载<br>8.4 @font-size规则：css2，css2.1 又删了 （现在不是又有了吗）<br>（00：51）</p>
<p>2017.6.27 二 21：27</p>
<h2 id="第7章-文本"><a href="#第7章-文本" class="headerlink" title="第7章 文本"></a>第7章 文本</h2><p>1 水平对齐：text-align 继承 块级<br>Left，right，center，justify—因浏览器而异<br>继承—不同B有差别：Opera  <th>不继承右对齐<br>1.4    应用：整体居中。IE5.5 后，加wrapper，margin：0 auto；</th></p>
<p>2 文本缩进：text-indent  继承 块级<br>2.2 正值缩进  百分比基数 由父元素的宽度，而不是元素本身的宽度<br>2.3 负值缩进：悬挂缩进和隐藏文字     溢出部分情况根据元素及祖先元素overflow<br>2.4    应用：隐藏单行文字 （‘类似logo’）直接img 违背了“表现与结构分离”</p>
<p>3 行高 line-height  继承<br>行高：文本行的基线（英文字母x）间距离，文本间空白距离不仅仅行高决定，同时也受字号的影响<br>3.2 内容区域：理论上一行中每个元素都有一个内容区域，由字体尺寸决定<br>行内框：行内元素会生成一个，只是一个概念。无其他影响，行内框==内容区域。设定行会对其产生影响<br>行框：任何，故同一行内若干元素，不同行框，行内框。最大值。只同本行内元素行高有关</p>
<p>3.3 行高的计算与继承  基数：元素本身的字体尺寸。。不带单位的缩放因子。。若含图片<br>3.4 浏览器的差别与错误：ie6 对含有图片或表单等可替换行内元素，行高失效<br>3.5 应用：当行文字在垂直方向居中</p>
<p>4 垂直对齐 vertical-align  不继承  行内和单元格table-cell<br>Text-top，super,sub，综合（垂直对齐和行框高度有关，行内框高度由行内元素的行内框有关）<br>4.3 奇怪的ie  6，7<br>4.4 文档类型与纯图片内容的垂直对齐<br>4.5 单元格的垂直对齐    表格是比较特殊的元素</p>
<p>5 单词间隔 字母间隔： 单词间隔以空格来判断<br>Word-spacing：继承  受文字对齐方式影响。浏览器不能判定文字的内容，故以空格为准<br>Letter-spacing：继承 受文字对齐。最后一个字排除<br>5.3 水平对齐的影响和继承</p>
<p>6 文本转换 text-transform  继承   capitalize不同浏览器不同</p>
<p>7 文本装饰 text-decoration 不继承。 Blink  ，可多值，最后的会清除前面</p>
<p>8 空白 white-spac 不继承<br>Pre：所有不压缩。<br>pre-wrap：所有不压缩，同时保持内容自动回行，Css2.1<br>pre-line：空格，制表符被压缩，换行保留，同时自动。Css2.1<br>8.3 应用：显示不回行文本  no-wrap</p>
<p>9 文本阴影：text-shadow  不继承   css2新增，2.1又删<br>    颜色 阴影水平延伸距离 阴影垂直 模糊效果的作用距离   仅仅发光：长度1，2为0.必选</p>
<p>10 文字方向 direction 继承 ltr，rtl，<br>编码方式 Unicode-bidi  继承 n，bidi-override,embed   与direction属性一起使用<br>只设定direction不会影响。必须unicode-bidi：embed 或 bidi-override</p>
<h2 id="第8章框模型"><a href="#第8章框模型" class="headerlink" title="第8章框模型"></a>第8章框模型</h2><p>盒模型：文档树中的元素都产生，。。。<br>视觉格式化模型（浮动、定位）：浏览器根据视觉格式模型，将这些框布局成访问者看到的</p>
<p>1 框模型   ie6，7  怪异的框模型</p>
<p>2 包含块 ：视觉格式化模型中的概念，与框模型类似。为它里面包含的元素提供参考<br>2.1 视口viewport：用户通过它来浏览文档。滚动机制。一个渲染区域最多一个视口<br>2.2 包含块<br>1，初始包含块：根元素，正常为html，不正确body，width属性指定，auto：视口。不呢个定位和浮动<br>2，其他，如果定位为:relative,static  ,由最近的块级、单元格、行内块祖先元素的内容框创建<br>3，fixed，视口<br>5，    absolute，最近非static</p>
<p>3 宽度：width 不继承 除了非替换的行内元素，表格行，行组<br>3.2 行内 ：非替换的不能。。图片，定宽不定高，等比例变化<br>    百分比 基数：元素包含块的宽度。。 css1，ie5 父元素的内容框宽度  。。。溢出<br>4 最大宽度和最小宽度  </p>
<p>5 高度 height 块级和替换元素生成的内容框的高度<br>5.2 行内元素的高度，，非替换行内元素的框高度由行高决定<br>6 最大高度和最小高度<br>7 补白  padding 除了表格的一些  不许负值<br>    比分比基数： 上下左右，都是以包含块的宽度为基数，高度无关<br>8 边框 border  不继承  缩写<br>color，ie6没transparent,width，-style：dotted,dashed,solid,double,groove,ridge,inset,outet,none<br>8.7 应用：文字链接的装饰</p>
<p>9 边距 margin 表格标题，表格，行内表格有效，单元格（border-collapse,border-spacing）、表格行<br>9.2 垂直方向<br>1，行内元素：非替换的无效（水平有效，padding也有效），由行高决定<br>2，边距的重叠：1常规流向的块级—最大值。<em>父元素设padding，border</em><br>    2浮动元素 不重叠 。3overflow属性，不是visible，其后代不重叠<br>    4绝对定位 不重叠，包括该元素和其后代之间<br>    5行内快 不重叠    6根元素和其后代之间不重叠<br>9.3 百分比值边距  基数：包含块宽度      与高度无关<br>9.4 负值边距 （不同与padding）<br>9.5 应用：元素水平居中 margin:0 auto；负值可以使水平居中，但不可使垂直居中？？基数</p>
<p>10 常规流向中的视觉模型<br>常规流向（未定位—本节，相对定位）<br>视觉模型：知道浏览器如何生成元素框及如何显示。display决定框类型，部分影响它在视觉模型表现<br>10.1 块级元素的水平格式化<br>1定义了width  2width:auto,其他为0，尽量充满父元素 3左右auto  4边距负值<br>10.2 应用：宽度自适应的布局<br>10.3  <em>垂直格式化  **</em>有一页是黑的<br>1     overflow：visible ie6自动扩展高度以包含内容  2height和auto值，是否有任何块类子元素：如果值行内；如果包括块类子。。子浮动，绝对定位被忽略  3上下边距的auto-==0   4垂直方向的边距会发生重叠<br>10.4 应用：高度自适应浏览器窗口<br>百分比高度基数：包含块的高度。由于视口不为初始包含块提供高度让其适应文档的内容，故高度为明确定义，auto。。这是高度和宽度最重要的区别   html,body{height:100%</p>
<p>10.5 行内元素的格式化  p182<br>1，行内非替换元素<br>    高度取决于元素行高，height无效，垂直方向的边框，补白不影响。。水平有边距，边框，补白，会随内容的的断裂而断开。<br>2，行内替换元素<br>    1百分比内在尺寸        2表单的替换元素<br>（00：14）<br>2017.6.28 三  21：25</p>
<h2 id="第9章浮动、定位与视觉格式化模型"><a href="#第9章浮动、定位与视觉格式化模型" class="headerlink" title="第9章浮动、定位与视觉格式化模型"></a>第9章浮动、定位与视觉格式化模型</h2><p>1 视觉格式化模型控制框的生成<br>块框的生成（主，匿名，） 行内   插入（run-in）<br>2 显示类型：display  不继承<br>Ie7 不支持 inline-block</p>
<p>3 定位  position 不继承<br>3.2 设定框偏移：top、  定位元素<br>    百分比：包含块的宽度           auto：<br>3.3 相对定位<br>3.4 绝对定位<br>Fixed，也是绝对定位，绝对定位的一个子类  ie6 不支持<br>    P200<br>3.5 堆叠顺序 z-index  定位<br>堆叠容器  （和包含块没有必然联系），还同父元素的堆叠顺序有关<br>Ie 会为定位元素的z-index设为0。。。。。不会出现：子元素 永远由父元素决定<br>3.6 ie中的position<br>Text-align与定位，ie6 的问题，<br>3.7 应用：显示提示内容</p>
<p>4 浮动与清除  不 除了绝对（绝对，和fixed），display：none<br>Ie6扩展父元素的高度以包含子；与相同方向浮动 双倍边距；<br>多浮动，混合组合，，浏览器表现不一<br>4.3 清除浮动：clear 块级<br>清除本元素 前面 的浮动影响        不会对后代影响<br>本元素内的子元素清除，对本元素有影响，而且和本元素是否浮动有关<br>4.4 应用：3行3列布局设计</p>
<p>#footer—clear：both     为content添加下边据，而不是footer添加上边距</p>
<p>5 display、float和position<br>6 溢出和剪切<br>6.1 overflow： 不 块和替换元素 ie6扩展元素框以包含内容<br>6.2 clip 不  绝对定位       允许负值<br>6.3 两者关系</p>
<p>7 可视性 visibility  继承<br>Collapse 表格的行、列（组）上<br>7.2 应用：显示及隐藏元素<br>（22：07）</p>
<h2 id="第10章颜色与背景"><a href="#第10章颜色与背景" class="headerlink" title="第10章颜色与背景"></a>第10章颜色与背景</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub入门与实践</title>
    <url>/pdf/ex/GitHub%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p style="text-align:right">2018.8.15 星期三 9:44</p>

<p>GitHub入门与实践:20170520<br>git指令总结: 20170531</p>
<p>mkdir file<br>cd file<br>git init<br>git status<br>git add<br>git commit -m<br>git commit -am<br>git log (–pretty=short,text,-p) 仓库中提交的日志<br>git diff 查看工作树、暂存区、最新提交之间的差别<br>1查看当前工作树与暂存区的差别。<br>(2HEAD,查看工作树和最新提交的差别,HEAD 是指向当前分支中最新一次提交<br>的指针。)</p>
<p>git branch——显示分支一览表<br>git checkout -b——创建、切换分支<br>git checkout master 切换到 master 分支<br>git checkout - 切换回上一个分支</p>
<p>git merge——合并分支<br>git merge –no-ff feature-A</p>
<p>git log –graph——以图表形式查看分支</p>
<p>git reflog 查看当前仓库执行过的操作的日志。<br>git reset——回溯历史版本<br>git reset –hard fd0cbf0d4a25f747230694d95cac1be72d33441d<br>回溯和推进其实是相同的操作—自己注解</p>
<p>git commit –amend——修改上一条提交信息<br>git rebase -i——压缩历史<br>git rebase -i HEAD~2 更改历史<br>可以选定当前分支中包含<br>HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。<br>（将 6fba227 左侧的 pick 部分删除，改写为 fixup。<br>pick 7a34294 Add feature-C<br>fixup 6fba227 Fix typo）</p>
<p>git remote add——添加远程仓库<br>git push——推送至远程仓库<br>git push -u origin master<br>1像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master分支。<br>-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的 upstream（上游） 。<br>2添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可<br>以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦<br>执行该操作后，当前本地仓库 master 分支的内容将会被推送到<br>GitHub 的远程仓库中。</p>
<p>$ git push -u origin feature-D 推送至 master 以外的分支</p>
<p>git clone——获取远程仓库<br>git checkout -b feature-D origin/feature-D</p>
<p>git pull——获取最新的远程仓库分支<br>git pull origin feature-D 将本地的 feature-D 分支更新到最新状态。</p>
<p>第一部分<br>一、git remote<br>1、git remote -v 查看远程状态<br>2、git remote add upstream 源库的clone地址<br>3、git remote rm vnt5901 删除</p>
<p>（ 到.git/refs/remotes目录下去找这个分支信息，删掉）<br>（ 到.git/refs/heads 目录下是分支，可以删掉或者删除分支操作）</p>
<p>$ git remote show origin</p>
<p>二、git branch<br>$ git branch 查看本地分支<br>$ git branch -a 查看本地和远程分支<br>$ git branch test 创建分支<br>$ git checkout test 切换分支到test<br>$ git branch -d xxxxx 删除本地分支</p>
<p>$ git checkout -b test 创建并切换<br>$ git branch -av</p>
<p>三、git merge<br>git merge upstream/master</p>
<p>四、git push 和commit-id， .git/FETCH_HEAD文件<br>git push origin master</p>
<ol>
<li>git fetch<br>→→ 这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中<br>　　2. git fetch remote_repo<br>→→ 这将更新名称为remote_repo 的远程repo上的所有branch的最新commit-id，将其记录。<br>　　3. git fetch remote_repo remote_branch_name<br>→→ 这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name<br>　　4. git fetch remote_repo remote_branch_name:local_branch_name<br>→→ 这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。</li>
</ol>
<p>git fetch -p</p>
<p>五、git pull 的运行过程：<br>　　git pull : 首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，<br>然后git fetch 获得当前指向的远程分支的后续版本的数据，<br>然后再利用git merge将其与本地的当前分支合并。</p>
<p>第二部分<br>github下fork后如何同步源库的新更新内容?<br>步骤:</p>
<p>1使用 查看远程状态<br>git remote -v</p>
<p>2给 fork 添加源库的clone地址</p>
<p>git remote add upstream 源库的clone地址</p>
<p>3再次查看状态确认是否配置成功</p>
<p>4从上源仓库 fetch 分支和提交点，并会被存储在一个本地分支 upstream<br>/<em> 而不是origin /</em></p>
<p>git fetch upstream</p>
<p>5切换到本地分支<br>把 upstream/分支 分支合并到本地对应的分支上，这样就完成了同步，<br>并且不会丢掉本地修改的内容，比如master分支的。</p>
<p>git merge upstream/master</p>
<p>6 push</p>
<p>git push origin master</p>
<p>第三部分<br>git fetch origin master<br>git log -p master..origin/master<br>git merge origin/master</p>
<p>上述过程其实可以用以下更清晰的方式来进行：</p>
<p>git fetch origin master:tmp<br>git diff tmp<br>git merge tmp</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>ex</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/pdf/ex/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><ol>
<li>在当前目录新建一个Git代码库 $ git init</li>
<li>新建一个目录，将其初始化为Git代码库 $ git init [project-name]</li>
<li>下载一个项目和它的整个代码历史 $ git clone [url]</li>
</ol>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<ol>
<li>显示当前的Git配置 $ git config –list</li>
<li>编辑Git配置文件 $ git config -e [–global]</li>
<li>设置提交代码时的用户信息 $ git config [–global] user.name “[name]” $ git config [–global] user.email “[email address]”</li>
</ol>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><ol>
<li>添加指定文件到暂存区 $ git add [file1] [file2] …</li>
<li>添加指定目录到暂存区，包括子目录 $ git add [dir]</li>
<li>添加当前目录的所有文件到暂存区 $ git add .</li>
<li>添加每个变化前，都会要求确认</li>
<li>对于同一个文件的多处变化，可以实现分次提交 $ git add -p</li>
<li>删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] …</li>
<li>停止追踪指定文件，但该文件会保留在工作区 $ git rm –cached [file]</li>
<li>改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed]</li>
</ol>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><ol>
<li>提交暂存区到仓库区 $ git commit -m [message]</li>
<li>提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] … -m [message]  1. 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a</li>
<li>提交时显示所有diff信息 $ git commit -v</li>
<li>使用一次新的commit，替代上一次提交</li>
<li>如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit –amend -m [message]</li>
<li>重做上一次commit，并包括指定文件的新变化 $ git commit –amend [file1] [file2] …</li>
</ol>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><ol>
<li>列出所有本地分支 $ git branch</li>
<li>列出所有远程分支 $ git branch -r</li>
<li>列出所有本地分支和远程分支 $ git branch -a</li>
<li>新建一个分支，但依然停留在当前分支 $ git branch [branch-name]</li>
<li>新建一个分支，并切换到该分支 $ git checkout -b [branch]</li>
<li>新建一个分支，指向指定commit $ git branch [branch] [commit]</li>
<li>新建一个分支，与指定的远程分支建立追踪关系 $ git branch –track [branch] [remote-branch]</li>
<li>切换到指定分支，并更新工作区 $ git checkout [branch-name]</li>
<li>切换到上一个分支 $ git checkout -</li>
<li>建立追踪关系，在现有分支与指定的远程分支之间 $ git branch –set-upstream [branch] [remote-branch]</li>
<li>合并指定分支到当前分支 $ git merge [branch]</li>
<li>选择一个commit，合并进当前分支 $ git cherry-pick [commit]</li>
<li>删除分支 $ git branch -d [branch-name]</li>
<li>删除远程分支 $ git push origin –delete [branch-name] $ git branch -dr [remote/branch]</li>
</ol>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><ol>
<li>列出所有tag $ git tag</li>
<li>新建一个tag在当前commit $ git tag [tag]</li>
<li>新建一个tag在指定commit $ git tag [tag] [commit]</li>
<li>删除本地tag $ git tag -d [tag]</li>
<li>删除远程tag $ git push origin :refs/tags/[tagName]</li>
<li>查看tag信息 $ git show [tag]</li>
<li>提交指定tag $ git push [remote] [tag]</li>
<li>提交所有tag $ git push [remote] –tags</li>
<li>新建一个分支，指向某个tag $ git checkout -b [branch] [tag]</li>
</ol>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><ol>
<li>显示有变更的文件 $ git status</li>
<li>显示当前分支的版本历史 $ git log</li>
<li>显示commit历史，以及每次commit发生变更的文件 $ git log –stat</li>
<li>搜索提交历史，根据关键词 $ git log -S [keyword]</li>
<li>显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD –pretty=format:%s</li>
<li>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD –grep feature</li>
<li>显示某个文件的版本历史，包括文件改名 $ git log –follow [file] $ git whatchanged [file]</li>
<li>显示指定文件相关的每一次diff $ git log -p [file]</li>
<li>显示过去5次提交 $ git log -5 –pretty –oneline</li>
<li>显示所有提交过的用户，按提交次数排序 $ git shortlog -sn</li>
<li>显示指定文件是什么人在什么时间修改过 $ git blame [file]</li>
<li>显示暂存区和工作区的差异 $ git diff</li>
<li>显示暂存区和上一个commit的差异 $ git diff –cached [file]</li>
<li>显示工作区与当前分支最新commit之间的差异 $ git diff HEAD</li>
<li>显示两次提交之间的差异 $ git diff [first-branch]…[second-branch]</li>
<li>显示今天你写了多少行代码 $ git diff –shortstat “@{0 day ago}”</li>
<li>显示某次提交的元数据和内容变化 $ git show [commit]</li>
<li>显示某次提交发生变化的文件 $ git show –name-only [commit]</li>
<li>显示某次提交时，某个文件的内容 $ git show [commit]:[filename]</li>
<li>显示当前分支的最近几次提交 $ git reflog</li>
</ol>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><ol>
<li>下载远程仓库的所有变动 $ git fetch [remote]</li>
<li>显示所有远程仓库 $ git remote -v</li>
<li>显示某个远程仓库的信息 $ git remote show [remote]</li>
<li>增加一个新的远程仓库，并命名 $ git remote add [shortname] [url]</li>
<li>取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch]</li>
<li>上传本地指定分支到远程仓库 $ git push [remote] [branch]</li>
<li>强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] –force</li>
<li>推送所有分支到远程仓库 $ git push [remote] –all</li>
</ol>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><ol>
<li>恢复暂存区的指定文件到工作区 $ git checkout [file]</li>
<li>恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file]  1. 恢复暂存区的所有文件到工作区 $ git checkout .</li>
<li>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file]</li>
<li>重置暂存区与工作区，与上一次commit保持一致 $ git reset –hard</li>
<li>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit]</li>
<li>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset –hard [commit]</li>
<li>重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset –keep [commit]</li>
<li>新建一个commit，用来撤销指定commit</li>
<li>后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit]  1. 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop</li>
</ol>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><ol>
<li>生成一个可供发布的压缩包 $ git archive</li>
</ol>
<h2 id="1-远程仓库相关命令"><a href="#1-远程仓库相关命令" class="headerlink" title="1) 远程仓库相关命令"></a>1) 远程仓库相关命令</h2><p>检出仓库：$ git clone git://github.com/jquery/jquery.git<br>查看远程仓库：$ git remote -v<br>添加远程仓库：$ git remote add [name] [url]<br>删除远程仓库：$ git remote rm [name]<br>修改远程仓库：$ git remote set-url –push[name][newUrl]<br>拉取远程仓库：$ git pull [remoteName] [localBranchName]<br>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
<h2 id="2）分支-branch-操作相关命令"><a href="#2）分支-branch-操作相关命令" class="headerlink" title="2）分支(branch)操作相关命令"></a>2）分支(branch)操作相关命令</h2><p>查看本地分支：$ git branch<br>查看远程分支：$ git branch -r<br>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支<br>切换分支：$ git checkout [name]<br>创建新分支并立即切换到新分支：$ git checkout -b [name]<br>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项<br>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并<br>创建远程分支(本地分支push到远程)：$ git push origin [name]<br>删除远程分支：$ git push origin :heads/[name]</p>
<p>我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。<br>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。<br>$ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支<br>$ git push origin test:test // 提交本地test分支作为远程的test分支<br>如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。<br>$ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p>
<h2 id="3）版本-tag-操作相关命令"><a href="#3）版本-tag-操作相关命令" class="headerlink" title="3）版本(tag)操作相关命令"></a>3）版本(tag)操作相关命令</h2><p>查看版本：$ git tag<br>创建版本：$ git tag [name]<br>删除版本：$ git tag -d [name]<br>查看远程版本：$ git tag -r<br>创建远程版本(本地版本push到远程)：$ git push origin [name]<br>删除远程版本：$ git push origin :refs/tags/[name]<br>推送所有tag: git push origin –tags<br>tag迁出branch：<br>git checkout tagname<br>git checkout -b new_branch_name</p>
<h2 id="4）git-stash暂存相关命令"><a href="#4）git-stash暂存相关命令" class="headerlink" title="4）git stash暂存相关命令"></a>4）git stash暂存相关命令</h2><p>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>
<h2 id="5）git-rebase-使用"><a href="#5）git-rebase-使用" class="headerlink" title="5）git rebase 使用"></a>5）git rebase 使用</h2><p>当前分支问题develop，从master拉取最新代码<br>git pull –rebase origin master 或者 git rebase develop<br>先将develop分支的代码checkout出来，作为工作目录<br>然后将master分支从develop分支创建起的所有改变的补丁，依次打上。如果打补丁的过程没问题，rebase就搞定了<br>如果打补丁的时候出现了问题，就会提示你处理冲突。处理好了，可以运行git rebase –continue继续直到完成<br>如果你不想处理，你还是有两个选择，一个是放弃rebase过程（运行git rebase –abort），另一个是直接用test分支的取代当前分支的（git rebase –skip）。</p>
<h2 id="6）-工具"><a href="#6）-工具" class="headerlink" title="6） 工具"></a>6） 工具</h2><p>SourceTree &amp; git bash</p>
<p>将云端代码clone到本地，建立自己本地的开发分支：<br>git checkout licheng<br>在本地分支做开发，自测通过之后再提交到云端版本库。</p>
<p>提交代码：<br>提交代码之前，首先要更新本地版本库<br>git pull origin develop<br>代码更新之后如果发现代码有冲突，先解决冲突后再提交。<br>每次提交进来只提交确认修改过的文件，最好不要全目录提交。<br>1、增加新文件到版本库：git add {filename}<br>2、提交已经存在或已经添加到版本库中的文件修改：git commit {filename} -m “message”<br>3、将代码提交云端：git push origin develop</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>ex</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex基础</title>
    <url>/sum/css/flex%E5%9F%BA%E7%A1%80(401)/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">[Flex 布局教程：语法篇]</a>        </p>
<h2 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h2><p>1、Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局.box{display: flex;}。<br>行内元素也可以使用Flex布局。.box{display: inline-flex;}<br>Webkit内核的浏览器，必须加上-webkit前缀。</p>
<p>2、注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>容器默认存在两根轴：<br>水平的主轴（main axis）和垂直的交叉轴（cross axis）。</p>
<p>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；<br>交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。<br>单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。<br>flex-direction 决定主轴的方向（即项目的排列方向）<br>flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>flex-flow flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br>justify-content 定义了项目在主轴上的对齐方式。<br>align-items 定义项目在交叉轴上如何对齐。<br>align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><p>以下6个属性设置在项目上。   </p>
<p>order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>flex-grow:属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>    如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br>flex-shrink:缩小比例，默认为1，即如果空间不足，该项目将缩小<br>    如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>flex-basis:在分配多余空间之前，项目占据的主轴空间（main size）。<br>    浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>    它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<br>flex: flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>    该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>    建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<br>align-self: align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。<br>    默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ];</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>sum</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Css布局实战</title>
    <url>/pdf/css/Css%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p><a href="http://www.w3.org/QA/#validators" target="_blank" rel="noopener">http://www.w3.org/QA/#validators</a><br><a href="http://awards.cssmania.com" target="_blank" rel="noopener">http://awards.cssmania.com</a><br><a href="http://www.emediage.com" target="_blank" rel="noopener">http://www.emediage.com</a></p>
<p>RSS</p>
<p>Http://<a href="http://www.flashempire.com" target="_blank" rel="noopener">www.flashempire.com</a></p>
<h2 id="第四章、网站元素设计"><a href="#第四章、网站元素设计" class="headerlink" title="第四章、网站元素设计"></a>第四章、网站元素设计</h2><p>1、ul，ul中的a在各个浏览器不一致;;下面只会被ie解析<br><em>Html ul li(float:left; height:1%;), </em>html ul li a{ height:1%;}</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>1、？？文字随图片边缘不规则浮动， clear:left;</p>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>1、css代码优化：增加代码重用率，使用样式覆盖进行简化<br>2、a.tip:hover{cursor:hand}, ie对hover伪对象的支持不是很完善</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>DivCSS网页布局揭秘</title>
    <url>/pdf/css/DivCSS%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%8F%AD%E7%A7%98/</url>
    <content><![CDATA[<p>前言：<br>本书特色<br>关键知识点：<br>学习建议：<br>注重基础知识的学习，深刻理解web标准的意义，勤练习多编码善于思考<br>在线交流：<br>    <a href="http://www.52css.com" target="_blank" rel="noopener">http://www.52css.com</a><br>    <a href="http://www.w3cbbs.com" target="_blank" rel="noopener">http://www.w3cbbs.com</a> 专门针对本书的学习交流板块<br>    <a href="http://www.52css.com/book/" target="_blank" rel="noopener">http://www.52css.com/book/</a>    源码<br>联系：<a href="mailto:computerbook@126.com" target="_blank" rel="noopener">computerbook@126.com</a>  </p>
<h2 id="一、-Hello-World"><a href="#一、-Hello-World" class="headerlink" title="一、    Hello World"></a>一、    Hello World</h2><ol>
<li>Clear,IE页面布局的外观表现一致（也有影响），Firefox会错乱</li>
<li>IE6 中对高度的解释是默认行距的高度，设置溢出隐藏可以避免此问题的出现，实现“最小高度”</li>
<li>将图片定位居左，底部，当内容较多是背景图片滑动与底部对齐，在图片高度的有效范围内不会被内容撑破—container<br>H1是居左，顶部，同一张背景图两者结合形成闭合的圆角边框，在这张图片的有效高度内可以进行相对自有滑动</li>
<li>Text-indent:2em; 段落首行缩进两个汉字的空格，相对单位em</li>
<li>布局时，添加背景色</li>
</ol>
<h2 id="二、简洁布局之变换的CSS"><a href="#二、简洁布局之变换的CSS" class="headerlink" title="二、简洁布局之变换的CSS"></a>二、简洁布局之变换的CSS</h2><ol>
<li>Container层在sider层前面（虽然页面上sider在container前面）<br> 反向浮动的益处：1，2，3搜索引擎蜘蛛对页面进行爬行</li>
<li>Id，class命名：以含义，不以表现（大小）、位置</li>
<li>适当的注释，<code>&lt;!—main_End--&gt;</code> 发布时可以去掉</li>
<li>Logo设计、关于表单的id与name(后台name获取值，id方便定义样式)、li设置独立的id、表单输入框美化</li>
<li>定制图像按钮—特殊的表单元素，行距大于高度可以使汉字在容器中更好的垂直居中对齐</li>
<li>文档标题h1,h3,,h2预留，，取决于整站结构与栏目组织情况</li>
<li>A标签内含有图片元素时边框的处理，border:0; //ie6,8，firefox试了好像没有</li>
<li>图片格式，色彩丰富且有色彩渐变过渡—jpg，色彩简单无过渡—gif（或png）</li>
</ol>
<h2 id="三、古色古香的古典风格网站设计"><a href="#三、古色古香的古典风格网站设计" class="headerlink" title="三、古色古香的古典风格网站设计"></a>三、古色古香的古典风格网站设计</h2><p>1．图片属于网站内容图片，并非页面表现图片<br>2．为什么标题用h4，内容终端页两级标题—h1，h2；首页，栏目列表页栏目标题h3<br>3．先主体后细节，先勾勒总体布局框架，再<br>4．网站文件目录与文件情况</p>
<h2 id="四、活力四射的热情风格网站设计"><a href="#四、活力四射的热情风格网站设计" class="headerlink" title="四、活力四射的热情风格网站设计"></a>四、活力四射的热情风格网站设计</h2>]]></content>
      <categories>
        <category>pdf</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript忍者秘籍</title>
    <url>/pdf/js/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D/</url>
    <content><![CDATA[<p>十三<br>311，处理程序的管理</p>
<p>十四</p>
<p>后几章（with之后，包括第四部分）代码没有手动去实现</p>
<h2 id="函数（未考虑匿名函数）"><a href="#函数（未考虑匿名函数）" class="headerlink" title="函数（未考虑匿名函数）"></a>函数（未考虑匿名函数）</h2><p>声明<br>  声明提前：funtion f(){} 相当于变量（内存）声明，<br>      提前到最前面，里面定义的内容也会一起提前（var f=function(){},或者其他的f会覆盖掉function f()）<br>调用<br>  调用前，后调用后不一样<br>    没有调用之前，只是声明，开辟了一个function的空间<br>    调用之后，函数里面定义的内容才会产生作用<br>  函数名后面有()都相当于函数调用了；如果没有返回值（return ），返回undefined<br>function f(){this.a=’aa’}    //what is this<br>1&gt;做为函数调用，this–&gt;window<br>2&gt;方法，   this–&gt;obj<br>3&gt;构造器   new f()区别于f()<br>    创建一个新的空对象<br>    传递给   this参数，从而成为构造器的函数上下文<br>    如果没有显示的返回值，新创建的对象则作为构造器的返回值进行返回</p>
<p>4&gt;自有指定 上下文 apply,call<br>  每个函数都有apply()和call()方法</p>
<p>for-each() 该函数在数组的每个元素上都进行回调调用<br>    在函数式编程中，这种风格更简洁，并优于传统的那些for语句；闭包后，更明显（代码重用）<br>  这种迭代函数，可以很简单的将‘当前’元素作为参数传递给回调函数，<br>    但大多数情况，都是京当前元素作为回调函数的函数上下文</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>事件处理程序，对象方法，回调<br>window.onload=function(){}<br>var ninja={<br>    shout:function(){}<br>}<br>ninja.shout();<br>setTimeou(function(){},500);</p>
<p>4.2递归<br>命名函数中<br>匿名函数中的递归：<br>方法中</p>
<p>4.3将函数视为对象<br>和其他对象一样，可以给函数添加属性</p>
<p>注意：!!的使用</p>
<p>4.4可变长度的参数列表<br>js没有函数重载–参数列表的灵活性是关键<br>4.4.1  apply（）支持可变参数<br>4.4.2  arguments<br>    函数的length，和arguments 的length不一样<br>函数重载方式：参数类型，特定参数是否存在，参数个数（函数的length）</p>
<p>5闭包</p>
<p>5.2使用闭包<br>1、私有变量，<br>2、回调（$.ajax）和定时器（动画，未将变量放到全局作用域）<br>5.3绑定上下文</p>
<p>123—102第五章 闭包</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>1、计算密集型的代码<br>2、动画<br>3、异步测试套件</p>
<p>还需研究<br>第五章：P120之后<br>第六章：最后  类<br>第八章：中央计时器，异步检测</p>
<h2 id="跨浏览器"><a href="#跨浏览器" class="headerlink" title="跨浏览器"></a>跨浏览器</h2><p>可重用代码开发的五大关注点：<br>浏览器的bug、浏览器的bug修复、浏览器缺失的功能、外部代码、浏览器回归<br>公理：记住过去、考虑未来、测试现在</p>
<p>封装代码-jQuery</p>
<p>避免植入属性</p>
<p>11.2.4缺失的功能<br>优雅降级、向后兼容</p>
]]></content>
      <categories>
        <category>pdf</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Node.js教程-Runoob</title>
    <url>/w3/ser/nodejs-runoob/</url>
    <content><![CDATA[<p>toc and abstract.  </p>
<p>菜鸟:<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>
<p style="text-align:right">2017.1.1 星期日 15:10</p>

<a id="more"></a>
<h2 id="一-教程"><a href="#一-教程" class="headerlink" title="一 教程"></a>一 教程</h2><p>简单的说 Node.js 就是运行在服务端的 JavaScript。<br>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。<br>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。  </p>
<ul>
<li>Hello World<ol>
<li>脚本模式</li>
<li>交互模式</li>
</ol>
</li>
</ul>
<h2 id="二-安装配置"><a href="#二-安装配置" class="headerlink" title="二 安装配置"></a>二 安装配置</h2><p>LTS   </p>
<ul>
<li><p>Windows安装</p>
<ol>
<li><p>安装包 .msi  </p>
<blockquote>
<p>检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出如下结果：   </p>
</blockquote>
</li>
<li><p>二进制文件 (.exe)安装</p>
</li>
<li>版本测试</li>
</ol>
</li>
<li>Ubuntu   </li>
<li>CentOS    </li>
</ul>
<h2 id="三-创建第一个应用"><a href="#三-创建第一个应用" class="headerlink" title="三 创建第一个应用"></a>三 创建第一个应用</h2><p>不过对 Node.js 来说，概念完全不一样了。使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。</p>
<pre><code>var http = require(&apos;http&apos;);

http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});

    // 发送响应数据 &quot;Hello World&quot;
    response.end(&apos;Hello World\n&apos;);
}).listen(8888);

// 终端打印如下信息
console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);
</code></pre><p>让我们先了解下 Node.js 应用是由哪几部分组成的：  </p>
<ol>
<li>引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。</li>
<li>创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</li>
<li>接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP <h2 id="四-NPM-使用介绍"><a href="#四-NPM-使用介绍" class="headerlink" title="四 NPM 使用介绍"></a>四 NPM 使用介绍</h2>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</li>
</ol>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。  </li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 <code>npm -v</code> 来测试是否成功安装。</p>
<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：<code>npm install npm -g</code><br>使用淘宝镜像的命令：<code>cnpm install npm -g</code></p>
<h3 id="1-使用-npm-命令安装模块"><a href="#1-使用-npm-命令安装模块" class="headerlink" title="1 使用 npm 命令安装模块"></a>1 使用 npm 命令安装模块</h3><pre><code>$ npm install express
</code></pre><h3 id="2-全局安装与本地安装"><a href="#2-全局安装与本地安装" class="headerlink" title="2 全局安装与本地安装"></a>2 全局安装与本地安装</h3><pre><code>$ npm install express -g
</code></pre><ul>
<li>全局安装：</li>
</ul>
<ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。  </li>
<li>可以直接在命令行里使用。  </li>
</ol>
<ul>
<li><p>查看安装信息  </p>
<pre><code>//查看所有全局安装的模块
$ npm list -g
//某模块的版本号
$ npm list grunt
</code></pre><h3 id="3-使用-package-json"><a href="#3-使用-package-json" class="headerlink" title="3 使用 package.json"></a>3 使用 package.json</h3><h4 id="Package-json-属性说明"><a href="#Package-json-属性说明" class="headerlink" title="Package.json 属性说明"></a>Package.json 属性说明</h4><p>name,version,description,homepage,author,contributors,dependencies,repository,main,keywords</p>
<h3 id="4-卸载模块"><a href="#4-卸载模块" class="headerlink" title="4 卸载模块"></a>4 卸载模块</h3><p>  $ npm uninstall express</p>
<h3 id="5-更新"><a href="#5-更新" class="headerlink" title="5 更新"></a>5 更新</h3><p>  $ npm update express</p>
<h3 id="6-搜索"><a href="#6-搜索" class="headerlink" title="6 搜索"></a>6 搜索</h3><p>  $ npm search express</p>
<h3 id="7-创建"><a href="#7-创建" class="headerlink" title="7 创建"></a>7 创建</h3><p>  //生成package.json<br>  $ npm init<br>  //添加用户<br>  $ npm adduser<br>  //发布<br>  $ npm publish</p>
<h3 id="8-版本号"><a href="#8-版本号" class="headerlink" title="8 版本号"></a>8 版本号</h3><p>X.Y.Z:主版本号，次版本号,补丁版本号   </p>
</li>
</ul>
<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。</p>
<h3 id="9-NPM-常用命令"><a href="#9-NPM-常用命令" class="headerlink" title="9 NPM 常用命令"></a>9 NPM 常用命令</h3><h3 id="10-使用淘宝-NPM-镜像"><a href="#10-使用淘宝-NPM-镜像" class="headerlink" title="10 使用淘宝 NPM 镜像"></a>10 使用淘宝 NPM 镜像</h3><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org
$ cnpm install [name]
</code></pre><h2 id="五-REPL"><a href="#五-REPL" class="headerlink" title="五 REPL"></a>五 REPL</h2><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。  </p>
<p>Node 自带了交互式解释器，可以执行以下任务：<br>读取 、执行 、打印、 循环：循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</p>
<h3 id="1-启动-node"><a href="#1-启动-node" class="headerlink" title="1 启动 $ node"></a>1 启动 <code>$ node</code></h3><ol>
<li>简单表达式运算</li>
<li>使用变量</li>
<li>多行表达式</li>
<li><p>下划线（_）变量</p>
<pre><code>var x=10,y=20;
x+y
var sum=_
console.log(sum)//30
</code></pre></li>
</ol>
<h3 id="2-REPL-命令"><a href="#2-REPL-命令" class="headerlink" title="2 REPL 命令"></a>2 REPL 命令</h3><p>ctrl+c,ctrl+c两次、ctrl+d,向上/下，tab，.help，.break,.clear,.save filename,.load filename   </p>
<h3 id="3-停止-REPL"><a href="#3-停止-REPL" class="headerlink" title="3 停止 REPL"></a>3 停止 REPL</h3><pre><code>两次ctrl+c
</code></pre><h2 id="六-回调函数"><a href="#六-回调函数" class="headerlink" title="六 回调函数"></a>六 回调函数</h2><ol>
<li>Node.js 异步编程的直接体现就是回调。  </li>
<li>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。  </li>
<li>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 </li>
</ol>
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<h3 id="1-阻塞代码实例"><a href="#1-阻塞代码实例" class="headerlink" title="1 阻塞代码实例"></a>1 阻塞代码实例</h3><pre><code>var fs = require(&quot;fs&quot;);
var data = fs.readFileSync(&apos;input.txt&apos;);
console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);
</code></pre><h3 id="2-非阻塞代码实例"><a href="#2-非阻塞代码实例" class="headerlink" title="2 非阻塞代码实例"></a>2 非阻塞代码实例</h3><pre><code>var fs = require(&quot;fs&quot;);
fs.readFile(&apos;input.txt&apos;, function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log(&quot;程序执行结束!&quot;);
</code></pre><p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>
<h2 id="七-事件循环"><a href="#七-事件循环" class="headerlink" title="七 事件循环"></a>七 事件循环</h2><ol>
<li>Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</li>
<li>Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</li>
<li>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</li>
<li>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.<h3 id="1-事件驱动程序"><a href="#1-事件驱动程序" class="headerlink" title="1 事件驱动程序"></a>1 事件驱动程序</h3></li>
<li>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</li>
<li>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</li>
</ol>
<ul>
<li>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）  </li>
<li>在<strong>事件驱动模型</strong>中，会<em>生成一个主循环来监听事件，当检测到事件时触发回调函数</em>。<br>图例：<a href="http://www.runoob.com/nodejs/nodejs-event-loop.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-event-loop.html</a></li>
</ul>
<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
// 绑定事件及事件的处理程序
eventEmitter.on(&apos;eventName&apos;, eventHandler);
// 通过程序触发事件：
eventEmitter.emit(&apos;eventName&apos;);
</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h3 id="2-Node-应用程序是如何工作的？"><a href="#2-Node-应用程序是如何工作的？" class="headerlink" title="2 Node 应用程序是如何工作的？"></a>2 Node 应用程序是如何工作的？</h3><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>
<h2 id="八-EventEmitter"><a href="#八-EventEmitter" class="headerlink" title="八 EventEmitter"></a>八 EventEmitter</h2><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。<br>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h3 id="1-EventEmitter-类"><a href="#1-EventEmitter-类" class="headerlink" title="1 EventEmitter 类"></a>1 EventEmitter 类</h3><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<ol>
<li><p>你可以通过require(“events”);来访问该模块。</p>
<pre><code>// 引入 events 模块  
var events = require(&apos;events&apos;);  
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre></li>
<li><p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p> 下面我们用一个简单的例子说明 EventEmitter 的用法：  </p>
</li>
<li><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。<br>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<pre><code>var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener1&apos;, arg1, arg2); 
}); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener2&apos;, arg1, arg2); 
}); 
emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); 
</code></pre></li>
<li>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。<ul>
<li>方法：addListener(event,listener),on(event,listener),once(v,l),removeListener(e,l),removeAllListener([e]),setMaxListeners(n),listeners(e),emit(e,[arg1],[arg2],[…])  </li>
<li>类方法：listenerCount(emitter,event)</li>
<li>事件：newListener,removeListener,</li>
</ul>
</li>
</ol>
<h3 id="2-error-事件"><a href="#2-error-事件" class="headerlink" title="2 error 事件"></a>2 error 事件</h3><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<h3 id="3-继承-EventEmitter"><a href="#3-继承-EventEmitter" class="headerlink" title="3 继承 EventEmitter"></a>3 继承 EventEmitter</h3><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<ol>
<li>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。</li>
<li>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</li>
</ol>
<h2 id="九-Buffer"><a href="#九-Buffer" class="headerlink" title="九 Buffer"></a>九 Buffer</h2><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。<br>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h3 id="1-创建-Buffer-类"><a href="#1-创建-Buffer-类" class="headerlink" title="1 创建 Buffer 类"></a>1 创建 Buffer 类</h3><pre><code>var buf = new Buffer(10);
var buf = new Buffer([10, 20, 30, 40, 50]);
var buf = new Buffer(&quot;www.runoob.com&quot;, &quot;utf-8&quot;);
</code></pre><h3 id="2-写入缓冲区"><a href="#2-写入缓冲区" class="headerlink" title="2 写入缓冲区"></a>2 写入缓冲区</h3><pre><code>buf.write(string[, offset[, length]][, encoding])
</code></pre><h3 id="3-从缓冲区读取数据"><a href="#3-从缓冲区读取数据" class="headerlink" title="3 从缓冲区读取数据"></a>3 从缓冲区读取数据</h3><pre><code>buf.toString([encoding[, start[, end]]])
</code></pre><h3 id="4-将-Buffer-转换为-JSON-对象"><a href="#4-将-Buffer-转换为-JSON-对象" class="headerlink" title="4 将 Buffer 转换为 JSON 对象"></a>4 将 Buffer 转换为 JSON 对象</h3><pre><code>buf.toJSON()    
</code></pre><h3 id="5-缓冲区合并"><a href="#5-缓冲区合并" class="headerlink" title="5 缓冲区合并"></a>5 缓冲区合并</h3><pre><code>Buffer.concat(list[, totalLength])    
</code></pre><h3 id="6-缓冲区比较"><a href="#6-缓冲区比较" class="headerlink" title="6 缓冲区比较"></a>6 缓冲区比较</h3><pre><code>buf.compare(otherBuffer);
</code></pre><h3 id="7-拷贝缓冲区"><a href="#7-拷贝缓冲区" class="headerlink" title="7 拷贝缓冲区"></a>7 拷贝缓冲区</h3><pre><code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])
</code></pre><h3 id="8-缓冲区裁剪"><a href="#8-缓冲区裁剪" class="headerlink" title="8 缓冲区裁剪"></a>8 缓冲区裁剪</h3><h3 id="9-缓冲区长度"><a href="#9-缓冲区长度" class="headerlink" title="9 缓冲区长度"></a>9 缓冲区长度</h3><h3 id="10-方法参考手册"><a href="#10-方法参考手册" class="headerlink" title="10 方法参考手册"></a>10 方法参考手册</h3><h2 id="十-Stream"><a href="#十-Stream" class="headerlink" title="十 Stream"></a>十 Stream</h2><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。   </li>
<li>Writable - 可写操作。  </li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li><p>finish - 所有数据已被写入到底层系统时触发。</p>
<h3 id="1-从流中读取数据"><a href="#1-从流中读取数据" class="headerlink" title="1 从流中读取数据"></a>1 从流中读取数据</h3><p>  var fs = require(“fs”);<br>  var data = ‘’;<br>  // 创建可读流<br>  var readerStream = fs.createReadStream(‘input.txt’);<br>  // 设置编码为 utf8。<br>  readerStream.setEncoding(‘UTF8’);<br>  // 处理流事件 –&gt; data, end, and error<br>  readerStream.on(‘data’, function(chunk) {<br>  data += chunk;<br>  });<br>  readerStream.on(‘end’,function(){<br>  console.log(data);<br>  });<br>  readerStream.on(‘error’, function(err){<br>  console.log(err.stack);<br>  });<br>  console.log(“程序执行完毕”);</p>
<h3 id="2-写入流"><a href="#2-写入流" class="headerlink" title="2 写入流"></a>2 写入流</h3><p>  var fs = require(“fs”);<br>  var data = ‘菜鸟教程官网地址：<a href="http://www.runoob.com&#39;" target="_blank" rel="noopener">www.runoob.com&#39;</a>;<br>  // 创建一个可以写入的流，写入到文件 output.txt 中<br>  var writerStream = fs.createWriteStream(‘output.txt’);<br>  // 使用 utf8 编码写入数据<br>  writerStream.write(data,’UTF8’);<br>  // 标记文件末尾<br>  writerStream.end();<br>  // 处理流事件 –&gt; data, end, and error<br>  writerStream.on(‘finish’, function() {</p>
<pre><code>console.log(&quot;写入完成。&quot;);
</code></pre><p>  });<br>  writerStream.on(‘error’, function(err){<br>  console.log(err.stack);<br>  });<br>  console.log(“程序执行完毕”);</p>
<h3 id="3-管道流"><a href="#3-管道流" class="headerlink" title="3 管道流"></a>3 管道流</h3><p>  // 管道读写操作<br>  // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中<br>  readerStream.pipe(writerStream);</p>
<h3 id="4-链式流"><a href="#4-链式流" class="headerlink" title="4 链式流"></a>4 链式流</h3><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。<br>接下来我们就是用管道和链式来压缩和解压文件。</p>
<p>  var fs = require(“fs”);<br>  var zlib = require(‘zlib’);</p>
<p>  // 压缩 input.txt 文件为 input.txt.gz<br>  fs.createReadStream(‘input.txt’)<br>  .pipe(zlib.createGzip())<br>  .pipe(fs.createWriteStream(‘input.txt.gz’));<br>  console.log(“文件压缩完成。”);</p>
<p>  // 解压 input.txt.gz 文件为 input.txt<br>  fs.createReadStream(‘input.txt.gz’)<br>  .pipe(zlib.createGunzip())<br>  .pipe(fs.createWriteStream(‘input.txt’));</p>
<p>  console.log(“文件解压完成。”);</p>
</li>
</ul>
<h2 id="十一-模块系统"><a href="#十一-模块系统" class="headerlink" title="十一 模块系统"></a>十一 模块系统</h2><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展</p>
<h3 id="1-创建模块"><a href="#1-创建模块" class="headerlink" title="1 创建模块"></a>1 创建模块</h3><pre><code>//1 
var hello = require(&apos;./hello&apos;);
hello.world();
//接下来我们就来创建 hello.js 文件，代码如下：
exports.world = function() {
    console.log(&apos;Hello World&apos;);
}
</code></pre><p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>
<p>2 有时候我们只是想把一个对象封装到模块中</p>
<pre><code>function Hello() { 
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log(&apos;Hello &apos; + name); 
    }; 
}; 
module.exports = Hello;
//main.js 
var Hello = require(&apos;./hello&apos;); 
hello = new Hello(); 
hello.setName(&apos;BYVoid&apos;); 
hello.sayHello(); 
</code></pre><p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p>
<h3 id="2-服务端的模块放在哪里"><a href="#2-服务端的模块放在哪里" class="headerlink" title="2 服务端的模块放在哪里"></a>2 服务端的模块放在哪里</h3><p>Node.js 的 require 方法中的文件查找策略如下：<br>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<ul>
<li>从文件模块缓存中加载</li>
<li>从原生模块加载</li>
<li>从文件加载<br>  require方法接受以下几种参数的传递：<ul>
<li>http、fs、path等，原生模块。</li>
<li>./mod或../mod，相对路径的文件模块。</li>
<li>/pathtomodule/mod，绝对路径的文件模块。</li>
<li>mod，非原生模块的文件模块。</li>
</ul>
</li>
</ul>
<h2 id="十二-函数"><a href="#十二-函数" class="headerlink" title="十二 函数"></a>十二 函数</h2><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。<br>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>
<h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1 匿名函数"></a>1 匿名函数</h3><h3 id="2-函数传递是如何让HTTP服务器工作的"><a href="#2-函数传递是如何让HTTP服务器工作的" class="headerlink" title="2 函数传递是如何让HTTP服务器工作的"></a>2 函数传递是如何让HTTP服务器工作的</h3><pre><code>var http = require(&quot;http&quot;);
http.createServer(function(request, response) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;Hello World&quot;);
    response.end();
}).listen(8888);
</code></pre><h2 id="十三-路由"><a href="#十三-路由" class="headerlink" title="十三 路由"></a>十三 路由</h2><ol>
<li><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>
</li>
<li><p>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
</li>
</ol>
<p>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。<br>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。 </p>
<ol>
<li><p>现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>
<p> 好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。 </p>
<p> 在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
</li>
<li>现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：</li>
<li><p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 </p>
<p> 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p>
<ol>
<li>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，server.js 文件代码如下</li>
<li>同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：</li>
<li><p>在这里，我们传递的函数依旧什么也没做。</p>
<p> 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
</li>
<li>以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。<br>浏览器访问 <a href="http://127.0.0.1:8888/，输出结果如下：" target="_blank" rel="noopener">http://127.0.0.1:8888/，输出结果如下：</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//server.js </span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">function start(route) &#123;</span><br><span class="line">    function onRequest(request, response) &#123;</span><br><span class="line">        var pathname = url.parse(request.url).pathname;</span><br><span class="line">        console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">        //3.1</span><br><span class="line">        route(pathname);</span><br><span class="line"></span><br><span class="line">        response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">        response.write(&quot;Hello World&quot;);</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;</span><br><span class="line">    http.createServer(onRequest).listen(8888);</span><br><span class="line">    console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br><span class="line">//2 router.js 文件代码：</span><br><span class="line">function route(pathname) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">&#125;</span><br><span class="line">exports.route = route;</span><br><span class="line">//3.2 index.js 文件代码：</span><br><span class="line">var server = require(&quot;./server&quot;);</span><br><span class="line">var router = require(&quot;./router&quot;);</span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="十四-全局对象"><a href="#十四-全局对象" class="headerlink" title="十四 全局对象"></a>十四 全局对象</h2><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。<br>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<h3 id="1-全局对象与全局变量"><a href="#1-全局对象与全局变量" class="headerlink" title="1 全局对象与全局变量"></a>1 全局对象与全局变量</h3><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
<p>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>
<blockquote>
<p>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p>
</blockquote>
<h3 id="1-filename"><a href="#1-filename" class="headerlink" title="1 _filename"></a>1 _filename</h3><h3 id="2-dirname"><a href="#2-dirname" class="headerlink" title="2 _dirname"></a>2 _dirname</h3><h3 id="3-1-setTimeout-cb-ms"><a href="#3-1-setTimeout-cb-ms" class="headerlink" title="3.1 setTimeout(cb, ms)"></a>3.1 setTimeout(cb, ms)</h3><h3 id="3-2-clearTimeout-t"><a href="#3-2-clearTimeout-t" class="headerlink" title="3.2 clearTimeout(t)"></a>3.2 clearTimeout(t)</h3><h3 id="4-setInterval-cb-ms"><a href="#4-setInterval-cb-ms" class="headerlink" title="4 setInterval(cb, ms)"></a>4 setInterval(cb, ms)</h3><h3 id="5-console"><a href="#5-console" class="headerlink" title="5 console"></a>5 console</h3><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。</p>
<p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>
<p>console 方法:log,info,error,warn,dir,time,timeEnd,trace,assert</p>
<h3 id="6-process"><a href="#6-process" class="headerlink" title="6 process"></a>6 process</h3><p>process 是一个全局变量，即 global 对象的属性。<br>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法:exit,before,Exit,uncaughtException,Signal</p>
<ul>
<li><p>实例 </p>
<pre><code>process.on(&apos;exit&apos;, function(code) {
// 以下代码永远不会执行
setTimeout(function() {
    console.log(&quot;该代码不会执行&quot;);
}, 0);

console.log(&apos;退出码为:&apos;, code);
});
console.log(&quot;程序执行结束&quot;);
</code></pre></li>
<li>退出状态码</li>
<li>Process 属性<br>。。</li>
<li>方法参考手册</li>
</ul>
<h2 id="十五-常用工具"><a href="#十五-常用工具" class="headerlink" title="十五 常用工具"></a>十五 常用工具</h2><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<h3 id="1-util-inherits"><a href="#1-util-inherits" class="headerlink" title="1 util.inherits"></a>1 util.inherits</h3><p>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<h3 id="2-util-inspect"><a href="#2-util-inspect" class="headerlink" title="2 util.inspect"></a>2 util.inspect</h3><h3 id="3-util-isArray-object"><a href="#3-util-isArray-object" class="headerlink" title="3 util.isArray(object)"></a>3 util.isArray(object)</h3><h3 id="4-util-isRegExp-object"><a href="#4-util-isRegExp-object" class="headerlink" title="4 util.isRegExp(object)"></a>4 util.isRegExp(object)</h3><h3 id="5-util-isDate-object"><a href="#5-util-isDate-object" class="headerlink" title="5 util.isDate(object)"></a>5 util.isDate(object)</h3><h3 id="6-util-isError-object"><a href="#6-util-isError-object" class="headerlink" title="6 util.isError(object)"></a>6 util.isError(object)</h3><h2 id="十六-文件系统"><a href="#十六-文件系统" class="headerlink" title="十六 文件系统"></a>十六 文件系统</h2><h2 id="十七-GET-POST请求"><a href="#十七-GET-POST请求" class="headerlink" title="十七 GET/POST请求"></a>十七 GET/POST请求</h2><h2 id="十八-工具模块"><a href="#十八-工具模块" class="headerlink" title="十八 工具模块"></a>十八 工具模块</h2><h3 id="1-OS-模块"><a href="#1-OS-模块" class="headerlink" title="1 OS 模块"></a>1 OS 模块</h3><p>提供基本的系统操作函数。</p>
<h3 id="2-Path-模块"><a href="#2-Path-模块" class="headerlink" title="2 Path 模块"></a>2 Path 模块</h3><p>提供了处理和转换文件路的工具。</p>
<h3 id="3-Net-模块"><a href="#3-Net-模块" class="headerlink" title="3 Net 模块"></a>3 Net 模块</h3><p>用于底层的网络通信。提供了服务端和客户端的的操作。</p>
<h3 id="4-DNS-模块"><a href="#4-DNS-模块" class="headerlink" title="4 DNS 模块"></a>4 DNS 模块</h3><p>用于解析域名。</p>
<h3 id="5-Domain-模块"><a href="#5-Domain-模块" class="headerlink" title="5 Domain 模块"></a>5 Domain 模块</h3><p>简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</p>
<h2 id="十九-Web模块"><a href="#十九-Web模块" class="headerlink" title="十九 Web模块"></a>十九 Web模块</h2><h3 id="1-什么是-Web-服务器？"><a href="#1-什么是-Web-服务器？" class="headerlink" title="1 什么是 Web 服务器？"></a>1 什么是 Web 服务器？</h3><p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。</p>
<p>大多数 web 服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。</p>
<p>目前最主流的三个Web服务器是Apache、Nginx、IIS。</p>
<h3 id="2-Web-应用架构"><a href="#2-Web-应用架构" class="headerlink" title="2 Web 应用架构"></a>2 Web 应用架构</h3><ul>
<li>Client - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。</li>
<li>Server - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。</li>
<li>Business - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</li>
<li><p>Data - 数据层，一般由数据库组成。</p>
<h3 id="3-使用-Node-创建-Web-服务器"><a href="#3-使用-Node-创建-Web-服务器" class="headerlink" title="3 使用 Node 创建 Web 服务器"></a>3 使用 Node 创建 Web 服务器</h3><p>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：</p>
<p>  var http = require(‘http’);<br>  var fs = require(‘fs’);<br>  var url = require(‘url’);<br>  // 创建服务器<br>  http.createServer( function (request, response) {<br>  // 解析请求，包括文件名<br>  var pathname = url.parse(request.url).pathname;<br>  // 输出请求的文件名<br>  console.log(“Request for “ + pathname + “ received.”);<br>  // 从文件系统中读取请求的文件内容<br>  fs.readFile(pathname.substr(1), function (err, data) {</p>
<pre><code>if (err) {
    console.log(err);
    // HTTP 状态码: 404 : NOT FOUND
    // Content Type: text/plain
    response.writeHead(404, {&apos;Content-Type&apos;: &apos;text/html&apos;});
}else{             
    // HTTP 状态码: 200 : OK
    // Content Type: text/plain
    response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html&apos;});    

    // 响应文件内容
    response.write(data.toString());        
}
//  发送响应数据
response.end();
</code></pre><p>  });<br>  }).listen(8081);</p>
<p>  // 控制台会输出以下信息<br>  console.log(‘Server running at <a href="http://127.0.0.1:8081/&#39;)" target="_blank" rel="noopener">http://127.0.0.1:8081/&#39;)</a>;</p>
<h3 id="4-使用-Node-创建-Web-客户端"><a href="#4-使用-Node-创建-Web-客户端" class="headerlink" title="4 使用 Node 创建 Web 客户端"></a>4 使用 Node 创建 Web 客户端</h3><p>  var http = require(‘http’);<br>  // 用于请求的选项<br>  var options = {<br>  host: ‘localhost’,<br>  port: ‘8081’,<br>  path: ‘/index.htm’<br>  };<br>  // 处理响应的回调函数<br>  var callback = function(response){<br>  // 不断更新数据<br>  var body = ‘’;<br>  response.on(‘data’, function(data) {</p>
<pre><code>body += data;
</code></pre><p>  });<br>  response.on(‘end’, function() {</p>
<pre><code>// 数据接收完成
console.log(body);
</code></pre><p>  });<br>  }<br>  // 向服务端发送请求<br>  var req = http.request(options, callback);<br>  req.end();</p>
</li>
</ul>
<h2 id="二十-Express框架"><a href="#二十-Express框架" class="headerlink" title="二十 Express框架"></a>二十 Express框架</h2><h3 id="1-Express-简介"><a href="#1-Express-简介" class="headerlink" title="1 Express 简介"></a>1 Express 简介</h3><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>
<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<p>Express 框架核心特性：</p>
<ol>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。<h3 id="2-安装-Express"><a href="#2-安装-Express" class="headerlink" title="2 安装 Express"></a>2 安装 Express</h3>以下几个重要的模块是需要与 express 框架一起安装的：</li>
</ol>
<ul>
<li>body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li>
<li>cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li>
<li>multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。<h3 id="3-第一个-Express-框架实例"><a href="#3-第一个-Express-框架实例" class="headerlink" title="3 第一个 Express 框架实例"></a>3 第一个 Express 框架实例</h3>  //express_demo.js 文件<br>  var express = require(‘express’);<br>  var app = express();<br>  app.get(‘/‘, function (req, res) {<pre><code>res.send(&apos;Hello World&apos;);
</code></pre>  })<br>  var server = app.listen(8081, function () {<pre><code>var host = server.address().address
var port = server.address().port
console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)
</code></pre>  })<h3 id="4-请求和响应"><a href="#4-请求和响应" class="headerlink" title="4 请求和响应"></a>4 请求和响应</h3>Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。<h4 id="1-Request-对象-request-对象表示-HTTP-请求，"><a href="#1-Request-对象-request-对象表示-HTTP-请求，" class="headerlink" title="1.Request 对象 - request 对象表示 HTTP 请求，"></a>1.Request 对象 - request 对象表示 HTTP 请求，</h4>包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：<h4 id="2-Response-对象-response-对象表示-HTTP-响应，"><a href="#2-Response-对象-response-对象表示-HTTP-响应，" class="headerlink" title="2.Response 对象 - response 对象表示 HTTP 响应，"></a>2.Response 对象 - response 对象表示 HTTP 响应，</h4>即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：<h3 id="5-路由"><a href="#5-路由" class="headerlink" title="5 路由"></a>5 路由</h3>我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。  </li>
</ul>
<p>在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。</p>
<h3 id="6-静态文件"><a href="#6-静态文件" class="headerlink" title="6 静态文件"></a>6 静态文件</h3><p>Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。</p>
<p>你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：</p>
<pre><code>app.use(express.static(&apos;public&apos;));
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/images/logo.png" target="_blank" rel="noopener">http://127.0.0.1:8081/images/logo.png</a>    </p>
<h3 id="7-GET-方法"><a href="#7-GET-方法" class="headerlink" title="7 GET 方法"></a>7 GET 方法</h3><p>以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;form action=&quot;http://127.0.0.1:8081/process_get&quot; method=&quot;GET&quot;&gt;
First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt;  &lt;br&gt;

Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
//
var express = require(&apos;express&apos;);
var app = express();
app.use(express.static(&apos;public&apos;));
app.get(&apos;/index.htm&apos;, function (req, res) {
    res.sendFile( __dirname + &quot;/&quot; + &quot;index.htm&quot; );
})
app.get(&apos;/process_get&apos;, function (req, res) {
    // 输出 JSON 格式
    var response = {
        &quot;first_name&quot;:req.query.first_name,
        &quot;last_name&quot;:req.query.last_name
    };
    console.log(response);
    res.end(JSON.stringify(response));
})
var server = app.listen(8081, function () {
    var host = server.address().address
    var port = server.address().port
    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)
})   
</code></pre><h3 id="8-POST-方法"><a href="#8-POST-方法" class="headerlink" title="8 POST 方法"></a>8 POST 方法</h3><p>以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 server.js 文件内的 process_post 路由器来处理输入：</p>
<h3 id="9-文件上传"><a href="#9-文件上传" class="headerlink" title="9 文件上传"></a>9 文件上传</h3><p>以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。</p>
<h3 id="10-Cookie-管理"><a href="#10-Cookie-管理" class="headerlink" title="10 Cookie 管理"></a>10 Cookie 管理</h3><p>我们可以使用中间件向 Node.js 服务器发送 cookie 信息，以下代码输出了客户端发送的 cookie 信息：</p>
<pre><code>// express_cookie.js 文件
var express      = require(&apos;express&apos;)
var cookieParser = require(&apos;cookie-parser&apos;)
var app = express()
app.use(cookieParser())
app.get(&apos;/&apos;, function(req, res) {
console.log(&quot;Cookies: &quot;, req.cookies)
})
app.listen(8081)
</code></pre><h2 id="二一-RESTful-API"><a href="#二一-RESTful-API" class="headerlink" title="二一 RESTful API"></a>二一 RESTful API</h2><ul>
<li><p>什么是 REST？<br>  REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>
<p>  表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
</li>
<li>HTTP 方法<br>以下为 REST 基本架构的四个方法：</li>
</ul>
<ol>
<li>GET - 用于获取数据。</li>
<li>PUT - 用于更新或添加数据。</li>
<li>DELETE - 用于删除数据。</li>
<li>POST - 用于添加数据。<h3 id="1-RESTful-Web-Services"><a href="#1-RESTful-Web-Services" class="headerlink" title="1 RESTful Web Services"></a>1 RESTful Web Services</h3>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</li>
</ol>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<h3 id="2-创建-RESTful"><a href="#2-创建-RESTful" class="headerlink" title="2 创建 RESTful"></a>2 创建 RESTful</h3><ol>
<li>获取用户列表：RESTful API listUsers</li>
<li>添加用户: RESTful API addUser</li>
<li>显示用户详情: RESTful API :id（用户id）</li>
<li>删除用户: RESTful API deleteUser</li>
</ol>
<h2 id="二二-多进程"><a href="#二二-多进程" class="headerlink" title="二二 多进程"></a>二二 多进程</h2><p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p>
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p>
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p>
<ul>
<li>exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li>
<li>spawn - child_process.spawn 使用指定的命令行参数创建新进程。</li>
<li>fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。<h3 id="1-exec-方法"><a href="#1-exec-方法" class="headerlink" title="1 exec() 方法"></a>1 exec() 方法</h3>  child_process.exec(command[, options], callback)<br>child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。<h3 id="2-spawn-方法"><a href="#2-spawn-方法" class="headerlink" title="2 spawn() 方法"></a>2 spawn() 方法</h3>  child_process.spawn(command[, args][, options])<h3 id="3-fork-方法"><a href="#3-fork-方法" class="headerlink" title="3 fork 方法"></a>3 fork 方法</h3>  child_process.fork(modulePath[, args][, options])<br>child_process.fork 是 spawn() 方法的特殊形式，用于创建进程</li>
</ul>
<h2 id="二三-JXcore打包"><a href="#二三-JXcore打包" class="headerlink" title="二三 JXcore打包"></a>二三 JXcore打包</h2><p>Node.js 是一个开放源代码、跨平台的、用于服务器端和网络应用的运行环境。</p>
<p>JXcore 是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。</p>
<h2 id="二四-MySQL"><a href="#二四-MySQL" class="headerlink" title="二四 MySQL"></a>二四 MySQL</h2><ul>
<li><p>安装驱动</p>
<pre><code>$ cnpm install mysql
</code></pre></li>
<li><p>连接数据库</p>
<pre><code>var mysql      = require(&apos;mysql&apos;);
</code></pre><p>  var connection = mysql.createConnection({<br>  host     : ‘localhost’,<br>  user     : ‘root’,<br>  password : ‘123456’,<br>  database : ‘test’<br>  });</p>
<p>  connection.connect();</p>
<p>  connection.query(‘SELECT 1 + 1 AS solution’, function (error, results, fields) {<br>  if (error) throw error;<br>  console.log(‘The solution is: ‘, results[0].solution);<br>  });</p>
<h3 id="数据库操作-CURD"><a href="#数据库操作-CURD" class="headerlink" title="数据库操作( CURD )"></a>数据库操作( CURD )</h3></li>
</ul>
<ol>
<li><p>查询数据<br>将上面我们提供的 SQL 文件导入数据库后，执行以下代码即可查询出数据：</p>
<pre><code>var mysql  = require(&apos;mysql&apos;);  
var connection = mysql.createConnection({     
    host     : &apos;localhost&apos;,       
    user     : &apos;root&apos;,              
    password : &apos;123456&apos;,       
    port: &apos;3306&apos;,                   
    database: &apos;test&apos;, 
}); 
connection.connect();
var  sql = &apos;SELECT * FROM websites&apos;;
//查
connection.query(sql,function (err, result) {
    if(err){
        console.log(&apos;[SELECT ERROR] - &apos;,err.message);
        return;
    }
    console.log(&apos;-----------------SELECT-------------&apos;);
    console.log(result);
    console.log(&apos;-------------------------------\n\n&apos;);  
});
connection.end();    
</code></pre></li>
<li><p>插入数据</p>
<pre><code>var  addSql = &apos;INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)&apos;;
var  addSqlParams = [&apos;菜鸟工具&apos;, &apos;https://c.runoob.com&apos;,&apos;23453&apos;, &apos;CN&apos;];
//增
connection.query(addSql,addSqlParams,function (err, result) {
    ..
}    
</code></pre></li>
<li><p>更新数据</p>
<pre><code>var modSql = &apos;UPDATE websites SET name = ?,url = ? WHERE Id = ?&apos;;
var modSqlParams = [&apos;菜鸟移动站&apos;, &apos;https://m.runoob.com&apos;,6];
//改
connection.query(modSql,modSqlParams,function (err, result) {        
</code></pre></li>
<li><p>删除数据</p>
<pre><code>var delSql = &apos;DELETE FROM websites where id=6&apos;;
//删
connection.query(delSql,function (err, result) {
</code></pre></li>
</ol>
<h2 id="二五-MongoDB"><a href="#二五-MongoDB" class="headerlink" title="二五 MongoDB"></a>二五 MongoDB</h2><p>MongoDB是一种文档导向数据库管理系统，由C++撰写而成。</p>
<ul>
<li><p>安装驱动</p>
<pre><code>$ cnpm install mongodb  
</code></pre><p>接下来我们来实现增删改查功能。</p>
<h3 id="数据库操作-CURD-1"><a href="#数据库操作-CURD-1" class="headerlink" title="数据库操作( CURD )"></a>数据库操作( CURD )</h3></li>
</ul>
<ol>
<li><p>插入数据</p>
<pre><code>var MongoClient = require(&apos;mongodb&apos;).MongoClient;
var DB_CONN_STR = &apos;mongodb://localhost:27017/runoob&apos;; //# 数据库为 runoob

var insertData = function(db, callback) {  
    //连接到表 site
    var collection = db.collection(&apos;site&apos;);
    //插入数据
    var data = [{&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;url&quot;:&quot;www.runoob.com&quot;},{&quot;name&quot;:&quot;菜鸟工具&quot;,&quot;url&quot;:&quot;c.runoob.com&quot;}];
    collection.insert(data, function(err, result) { 
        if(err)
        {
            console.log(&apos;Error:&apos;+ err);
            return;
        }     
        callback(result);
    });
}

MongoClient.connect(DB_CONN_STR, function(err, db) {
    console.log(&quot;连接成功！&quot;);
    insertData(db, function(result) {
        console.log(result);
        db.close();
    });
});
</code></pre></li>
<li><p>查询数据</p>
<pre><code>var selectData = function(db, callback) {  
    //连接到表  
    var collection = db.collection(&apos;site&apos;);
    //查询数据
    var whereStr = {&quot;name&quot;:&apos;菜鸟教程&apos;};
    collection.find(whereStr).toArray(function(err, result) {
        if(err)
        {
            console.log(&apos;Error:&apos;+ err);
            return;
        }     
        callback(result);
    });
}
</code></pre></li>
<li><p>更新数据</p>
<pre><code>var updateData = function(db, callback) {  
    //连接到表  
    var collection = db.collection(&apos;site&apos;);
    //更新数据
    var whereStr = {&quot;name&quot;:&apos;菜鸟教程&apos;};
    var updateStr = {$set: { &quot;url&quot; : &quot;https://www.runoob.com&quot; }};
    collection.update(whereStr,updateStr, function(err, result) {
        if(err)
        {
            console.log(&apos;Error:&apos;+ err);
            return;
        }     
        callback(result);
    });
}
</code></pre></li>
<li><p>删除数据</p>
<pre><code>var delData = function(db, callback) {  
    //连接到表  
    var collection = db.collection(&apos;site&apos;);
    //删除数据
    var whereStr = {&quot;name&quot;:&apos;菜鸟工具&apos;};
    collection.remove(whereStr, function(err, result) {
        if(err)
        {
        console.log(&apos;Error:&apos;+ err);
        return;
        }     
        callback(result);
    });
}
</code></pre></li>
</ol>
<p style="text-align:right">home 2017.1.1 日 22:53</p>

<table>
<thead>
<tr>
<th>目录章节</th>
<th>状态</th>
<th>截止时间</th>
<th>后续安排</th>
</tr>
</thead>
<tbody>
<tr>
<td>note</td>
<td>///</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>code</td>
<td>///</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>14 全局对象 前</td>
<td>概念性知识，重在理解</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>14 全局对象 后</td>
<td>应用性，实践，基本简单过一遍，有的没有过</td>
<td>2017.10.1</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>16 文件系统</td>
<td>没有过</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>17 GET/POST请求</td>
<td>没有过</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>19 Web模块中文件（上传）</td>
<td>没有过</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>18 工具模块 5个</td>
<td>没有过</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>—-</td>
<td>A 比较重要，偏实践</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>15 常用工具util</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>24 MySQL</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>25 MongoDB</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>20 Express框架</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>—-</td>
<td>B 比较重要，偏理论</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>19 Web模块</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>21 RESTful API</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>22 多线程</td>
<td>大概过了一下</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>23 JXcore</td>
<td>大概过了一下，根本不知道什么东西</td>
<td>2017.10.1</td>
<td>neededThenWork</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td></td>
</tr>
</tbody>
</table>
<p>总结：</p>
<ol>
<li>基本上都过了一遍，知道了。</li>
<li>知道了，不等于 掌握、明白；离实际操作还有差别。</li>
<li>还有一些没有过的，比如文件，get/post等；<br>还有一些没看明白的（JXcore），和没有看的部分（工具模块5个）。</li>
</ol>
<ul>
<li>掌握nodejs 基本原理，常见操作，为以后熟练应用（具体某一块）打基础  </li>
</ul>
<p>其他：<a href="http://www.yiibai.com/nodejs/" target="_blank" rel="noopener">http://www.yiibai.com/nodejs/</a> </p>
]]></content>
      <categories>
        <category>w3</category>
        <category>ser</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Template</title>
    <url>/template/</url>
    <content><![CDATA[<p>新建文章的模版，可直接复制目录结构。还包括了需要配置的front matter </p>
<p>需要自己建立目录结构的文档，可以选择性复制。<br>有的文档有目录可以复制，下面的目录结构就不需要了。</p>
<a id="more"></a> 
<p style="text-align:right">2018. 星期 00:00</p>

<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><h3 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h3><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><h3 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h3><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><h3 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h3><h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3><h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3><h3 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h3><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h3><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><h3 id="7-3"><a href="#7-3" class="headerlink" title="7.3"></a>7.3</h3><h3 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h3><h3 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h3><h3 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h3><h3 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h3><h3 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h3><h3 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h3><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><h3 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h3><h3 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h3><h3 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h3><h3 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h3><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><h3 id="0-1"><a href="#0-1" class="headerlink" title="0.1"></a>0.1</h3><h3 id="0-2"><a href="#0-2" class="headerlink" title="0.2"></a>0.2</h3><h3 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h3><h3 id="0-4"><a href="#0-4" class="headerlink" title="0.4"></a>0.4</h3><h3 id="0"><a href="#0" class="headerlink" title="0."></a>0.</h3><p style="text-align:right"> </p>


<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><h4 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h4><p>#### </p>
<h2 id="一-1"><a href="#一-1" class="headerlink" title="一"></a>一</h2><h2 id="二-1"><a href="#二-1" class="headerlink" title="二"></a>二</h2><h2 id="三-1"><a href="#三-1" class="headerlink" title="三"></a>三</h2><h2 id="四-1"><a href="#四-1" class="headerlink" title="四"></a>四</h2><h2 id="五-1"><a href="#五-1" class="headerlink" title="五"></a>五</h2><h2 id="六-1"><a href="#六-1" class="headerlink" title="六"></a>六</h2><h2 id="七-1"><a href="#七-1" class="headerlink" title="七"></a>七</h2><h2 id="八-1"><a href="#八-1" class="headerlink" title="八"></a>八</h2><h2 id="九-1"><a href="#九-1" class="headerlink" title="九"></a>九</h2><h2 id="零-1"><a href="#零-1" class="headerlink" title="零"></a>零</h2>]]></content>
  </entry>
  <entry>
    <title>Gather</title>
    <url>/gather/</url>
    <content><![CDATA[<p>bucket/gather archives, for me it’s yinxiang.<br>And todo lists does not include in schedule. </p>
<a id="more"></a>
<!-- 单独文件记录schedule  -->  
<!-- 不记入schedule.md（收集文章太多，加上分类不好区分） -->
<!-- ## onGoing
1. - [ ]   -->
<h2 id="preparing"><a href="#preparing" class="headerlink" title="preparing"></a>preparing</h2><h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><ol start="3">
<li>019 组件</li>
</ol>
<h2 id="relex"><a href="#relex" class="headerlink" title="relex"></a>relex</h2><ol>
<li>js：020 库函数 </li>
</ol>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>cleared..</p>
<ol>
<li>D 000 HTML5 标签列表/常用unicode编码</li>
<li>D 001 Html - 编码规范</li>
<li>D 002 常用meta整理</li>
<li>D 002 IE=EmulateIE7 标签的作用</li>
<li>D 003 前端面试题-url、href、src</li>
<li>D 004 Flash 终于走向死亡！Flash 的兴衰之路你知多少</li>
<li>D 004 HTML5的视频格式之争</li>
<li>D 005 玩转HTML5 Video视频WebVTT字幕使用样式与制作</li>
<li>D 006 HTML5中37个最重要的技术点</li>
<li>D 007 HTML5全局属性汇总</li>
<li>D 008 frame和iframe的区别</li>
<li>D 009 HTML5 data-* 自定义属性 </li>
<li>D 010 视频播放–踩坑小计</li>
<li>D 011 视频格式/编码</li>
<li>D 012 xgPlayer 无缝清晰度切换</li>
<li>D 071 解决input[type=file]打开时慢、卡顿问题</li>
<li>D 081 HTML 5.2 有哪些新内容  </li>
<li>D 111 如何将PSD文件快速转换成HTML方法  Dgone  </li>
</ol>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>done.. </p>
<ol start="0">
<li>D 000 css 历史,OOP  </li>
<li>D 001 css编码</li>
<li>D 002 css代码组织方法</li>
<li>D 003 单位：px/em/rem,vh; ppi/dpi;视口   </li>
<li>D 004 字体ttf/eot/woff/svg,加载策略（js-fetch）  </li>
<li>D 005 各种字体</li>
<li>D 006 字号与行高</li>
<li>D 007 单/多行 text-overflow省略号   </li>
<li>D 008 文本两端对齐</li>
<li>D 009 压缩css</li>
<li>D 010 chrome源码看浏览器如何计算css </li>
<li>D 011 hack</li>
<li>D 012 响应式/自适应/流式布局，响应式图片/视频；响应式设计原则   </li>
<li>D 013 css 知识</li>
<li>D 014 word-wrap,word-break,white-space</li>
<li>D 015 层叠上下文</li>
<li>D 016 BFC</li>
<li>D 017 莫名空白：inline-block </li>
<li>D 018 inherit/auto/unset</li>
<li>D 019 伪元素</li>
<li>D 020 video自动填充满父元素object-fit</li>
<li>D 021 布局方案</li>
<li>D 022 居中/垂直居中 布局</li>
<li>D 023 圣杯布局</li>
<li>D 024 5种页脚固定 </li>
<li><p>D 025 </p>
</li>
<li><p>D 051 移动端布局方案</p>
</li>
<li>D 052 移动端布局问题/技巧</li>
<li><p>D 055 iPhone X 适配</p>
</li>
<li><p>D 070 web中图标处理 </p>
</li>
<li>D 071 背景透明 </li>
<li>D 075 5种方式隐藏元素 </li>
<li>D 077 任意图片赋色</li>
<li><p>D 079 0.5px边</p>
</li>
<li><p>090 css图形 </p>
</li>
<li>D 091 雪碧图</li>
<li>D 092 如何只用 CSS 完成漂亮的加载</li>
<li><p>D 100 CSS 函数的 8 个妙用</p>
</li>
<li><p>D 110 CSS 动画性能研究</p>
</li>
<li>D 111 css3动画</li>
<li>D 112 WAAPI</li>
<li>D 115 打造高性能剪切动画 </li>
<li><p>G 116 视差滚动</p>
</li>
<li><p>G 121 3D 视角</p>
</li>
<li>S 122 conic-gradient</li>
<li>D 123 filter</li>
<li><p>S 123 Houdini画星空</p>
</li>
<li><p>D 400 flex</p>
</li>
<li><p>401 flex 实际</p>
</li>
<li><p>D 501 css并不安全</p>
</li>
</ol>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><ol>
<li>D 000 js历史，JS是真正的 OOP 语言吗</li>
<li>B 001 js代码规范</li>
<li>D 002 浏览器内核/引擎/渲染   </li>
<li>D 003 js接口设计  </li>
<li>B 004 js错误处理</li>
<li>B 005 js性能技巧</li>
<li>D 006 js反调试</li>
<li>B 007 js复制内容到剪贴板</li>
<li>D 008 加载第三方js/css async/defer, preload/profetch  </li>
<li>B 009 文件操作/上传/下载，断点/分片  </li>
<li>B 010 全屏API</li>
<li>D 011 event loop,执行上下文和调用栈</li>
<li>D 012 模板字符串/引擎</li>
<li>B 013 web内存管理  </li>
<li>B 014 web存储</li>
<li>B 015 跨页面通信</li>
<li>B 016 web路由</li>
<li>D 017 service worker/PWA </li>
<li>D 018 函数式编程</li>
<li>T 019 组件化</li>
<li>D 020 常用函数/库</li>
<li>D 021 js操作iframe</li>
<li>D 022 图片懒加载</li>
<li>D 023 setTimeout/setInterval,Promise/asyn/await  </li>
<li>D 024 函数节流/防抖</li>
<li>B 025 滚动条操作</li>
<li>D 026 js操作伪元素</li>
<li>D 027 动态插入js并执行</li>
<li>B 028 chrome devtools </li>
<li>D 029 js void操作符  </li>
<li>030 数据类型转换</li>
<li>031 null，undefi</li>
<li>032 字符串</li>
<li>033 数字</li>
<li>034 数组</li>
<li>035 dom</li>
<li>036 对象</li>
<li>037 继承</li>
<li>038 克隆</li>
<li>039 js难点 </li>
<li>X 040 函数多种写法，不使用匿名函数，箭头函数，小而清晰的函数</li>
<li>D 051 JS、CSS以及img对DOMContentLoaded事件的影响</li>
<li>B 071 移动端tab事件,摇一摇  </li>
<li>B 072 移动设备软键盘操作</li>
<li>D 073 js获取移动设备型号：非UA；GPU   </li>
<li>D 074 唤起native app</li>
<li>D 075 微信网页长按图片识别/保存 二维码/图片</li>
<li>D 090 Web端即时通讯</li>
<li>D 091 递归和迭代，斐波那契数列，<del>背包问题</del></li>
<li>D 093 前端端分离   </li>
<li>D 112 炫酷H5中序列图片视频化播放的高性能实现</li>
</ol>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>cleared..  </p>
<ol start="0">
<li>B 000 互联网协议、网关   </li>
<li>D 001 http/https,http2.0,tcp/ip,socket</li>
<li>D 002 https, ssl/tls</li>
<li>D 003 cookie,session , SSO</li>
<li>B 004 http缓存</li>
<li>D 005 CROS</li>
<li>B 006 跨域操作</li>
<li>X 007 XXS,http劫持       </li>
<li>D 008 DNS  </li>
<li>D 009 HTTP协议中GET和POST </li>
<li>D 010 直播协议 HLS、RTMP与HTTP FLV</li>
<li>D 011 OpenSSL 安装、介绍</li>
<li>D 012 http长连接和短连接</li>
<li>D 073 主流浏览器图片反防盗链方法总结</li>
<li>D 101 web服务器/应用服务器，web容器，反向代理  </li>
<li>D 111 OAuth 2.0 认证</li>
<li>D 411 PCDN</li>
</ol>
<h2 id="jsrel"><a href="#jsrel" class="headerlink" title="jsrel"></a>jsrel</h2><p>done..<br>008 babel<br>009 regex<br>012 svg<br>016 webgl<br>017 webassembly</p>
<ol>
<li>B 001 字符编码 </li>
<li>D 002 前端国际化 </li>
<li>D 003 图片技术</li>
<li>D 004 uri/url/urn </li>
<li>D 005 MPEG DASH 和 HLS </li>
<li>D 006 深入学习json</li>
<li>D 007 lint</li>
<li>D 010 文本朗读 SpeechSynthesisUtterance/SpeechSynthesis</li>
<li>B 011 文档生成</li>
<li>D 013 websocket  </li>
<li>B 014 js模块规范</li>
<li>B 015 bookmarklet</li>
<li>D 018 TypeScript VS JavaScript 对比</li>
<li>G 019 非对称加密与安全证书</li>
<li>D 020 提高 HTML5 画布性能</li>
<li>B 021 blob,base64 </li>
<li>D 022 restful</li>
<li>B 023 mock 数据</li>
<li>D 024 js过滤html标签    </li>
<li>G 422 二维码的生成细节和原理</li>
</ol>
<h2 id="web优化"><a href="#web优化" class="headerlink" title="web优化"></a>web优化</h2><p>cleared ..   </p>
<ol>
<li>D 001 代码规范</li>
<li>D 002 dom操作</li>
<li>D 003 编程/code review </li>
<li>D 004 网页性能提升指南 </li>
<li>D 005 理解Critical CSS</li>
<li>D 006 html优化</li>
<li>D 007 能用HTML/CSS解决的问题就不要使用JS</li>
<li>D 。。。</li>
<li>D 。。。</li>
<li>D 028 性能测试</li>
<li>S 029 高性能计算</li>
<li>D 030 6款Web性能优化辅助工具</li>
<li>G 百度搜索引擎工作原理</li>
</ol>
<h2 id="jslib"><a href="#jslib" class="headerlink" title="jslib"></a>jslib</h2><ol>
<li>X 基于JSON Schema的表单验证  </li>
<li>D 141 jQuery attr()/prop()</li>
</ol>
<h2 id="git-svn"><a href="#git-svn" class="headerlink" title="git/svn"></a>git/svn</h2><p>cleared ..   </p>
<ol>
<li>D 001 Git fetch和git pull的区别</li>
<li>D 002 Git的4个阶段的撤销更改 </li>
<li>003 Git提交历史的修改删除合并等实践</li>
<li>D 004 git push 参数</li>
<li>D 101 git commit 时使用 Emoji</li>
<li>X 192 16个不错的 git 别名</li>
</ol>
<h2 id="框架-选型"><a href="#框架-选型" class="headerlink" title="框架/选型"></a>框架/选型</h2><ol>
<li>D 01 框架/选型</li>
</ol>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>doned ..</p>
<ol start="0">
<li>给前端工程师讲设计终篇,用户体验设置和 UI 设计的 10 个不同点</li>
<li>D 首页改版方法总结</li>
<li>D 从登录框看前端</li>
<li>D 下划线是否破坏可读性</li>
<li>D 动效/交互</li>
<li>D BANNER设计的七大手法</li>
<li>D 搜索结果的最佳实践分享</li>
<li>D 好的用户界面-界面设计的一些技巧</li>
<li>D 手机QQ里的注册那些事儿</li>
<li>D 表单设计:一页只做一件事</li>
<li>D 大产品小细节」Hick‘s Law 希克法则</li>
<li>D 这3个UI设计细节，可以让你感受到和高手的差距</li>
<li>D 关于加载设计，你要知道的8种策略和4种样式</li>
<li>D 开发出“点赞”功能的那个人，现在却很厌恶这个功能</li>
<li>D 提升网站转化率的Web设计忠告</li>
<li>D 如何发现用户的真实需求</li>
<li>D 如果你的产品停止成长，你该怎么做</li>
<li>D 产品经理的思考</li>
<li>D 一个产品的成功与否，和范围管理有直接的关系</li>
<li>G UX专家如何做设计评审 </li>
<li>G 以开发的视角做设计</li>
<li>G 201 前端之切切切切切图 </li>
<li>G 202 100个PS高效操作技巧 </li>
<li>D 501 3D常识   </li>
<li>G </li>
</ol>
<h2 id="其它技术-语言"><a href="#其它技术-语言" class="headerlink" title="其它技术/语言"></a>其它技术/语言</h2><p>done.</p>
<ol>
<li>B 001 markdown</li>
<li>B 002 hexo+next   </li>
<li>D 003 csv 文件</li>
<li>D 004 curl </li>
<li>B 005 CEF和DebugView入门</li>
<li>D 006 SSH/github (heox发布)，数字签名/CA   (<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">github-with-ssr</a>)</li>
<li>D 007 前端加密</li>
<li>D 008 md5加密</li>
<li>D 009 IOS wkwebview</li>
<li>G 010 webview缓存原理</li>
<li>D 011 情感分析  </li>
<li>D 012 中文分词    </li>
<li>D 013 前端工程师反击爬虫</li>
<li>D 014 如何搭建一个完整的视频直播系统</li>
<li>D 015 webrtc </li>
<li>201 微信/小程序资料收集</li>
<li>202 小程序历史</li>
<li>203 小程序开始</li>
<li>204 小程序开发基础</li>
<li>301 移动端开发真机调试</li>
<li>302 测试前端代码1-4</li>
<li>303 微信跳一跳-测试</li>
<li>D 401 比特币</li>
</ol>
<!-- v0 html: format of table  -->
<!-- 
cat|title|state|blob|note  
--|--|--|--|--
000|HTML5 标签列表|Dtools|x|查阅
001|Html - 编码规范|D|x|-
002|常用meta整理|D|x|-
002|IE=EmulateIE7 标签的作用|D|x|浏览器兼容
003|前端面试题-url、href、src|D|x|-
004|Flash 终于走向死亡！Flash 的兴衰之路你知多少|D|x|-
004|HTML5的视频格式之争|D|x|-
005|玩转HTML5 Video视频WebVTT字幕使用样式与制作|D|x|-
007|HTML5全局属性汇总|D|x|-
008|frame和iframe的区别|D|B0|-
081|HTML 5.2 有哪些新内容？|D|x|-
--|--|--|--|-- -->
<!-- v0 js,http: format of checkbox
1. - [x] 001 js代码规范
1. - [x] 004 js错误处理
1. - [x] 005 js性能技巧
1. - [ ] 006 js反调试
1. - [ ] 008 加载第三方js
1. - [x] 010 全屏API
2. - [ ] 012 模板字符串/引擎
3. - [x] 013 web内存管理
4. - [x] 014 web存储
5. - [x] 015 跨页面通信
6. - [x] 016 web路由
7. - [ ] 017 service worker/PWA
1. - [ ] 021 js操作iframe
2. - [ ] 026 js操作伪元素
3. - [ ] 
4. - [ ] 090 Web端即时通讯
5. - [x]  
6. 

## http 
1. - [ ] 001 http/https,tcp/ip,socket
2. - [ ] 002 https, ssl/tls
3. - [ ] 003 cookie,session , SSO
4. - [x] 004 http缓存
5. - [x] 005 CROS
6. - [x] 006 跨域操作
7. - [ ] 011 url->浏览器加载过程，DNS   
8. - [ ] 012 浏览器渲染过程
9. - [ ] 073 主流浏览器图片反防盗链方法总结
10. - [x] 
-->]]></content>
  </entry>
  <entry>
    <title>Booklist</title>
    <url>/booklist/</url>
    <content><![CDATA[<p>pdf list and schedule。<br><!-- 单独文件记录schedule  --><br><!-- 也可以从中pick out 记入schedule.md --></p>
<a id="more"></a>
<p>## onGoing   </p>
<ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<!-- ## preparing -->
<p>## schedule    </p>
<ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> Web标准之道</li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> Web前端黑客技术揭秘</li>
</ul>
</li>
</ol>
<p>## relax   </p>
<ol start="2">
<li>Web容量规划的艺术</li>
<li>操作系统</li>
<li>JS设计模式</li>
</ol>
<p>## hungry   </p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><ol>
<li>HTML5与CSS3权威指南</li>
<li>HTML高级程序设计</li>
<li>HTML5与CSS3基础教程（中文第8版）</li>
</ol>
<p>h1: skip:5-7：<br>h2：read:1,11:html历史、展望;<br>h3：read:响应式、字体、调试、发布、增强;  </p>
<p>bothered:  </p>
<ol>
<li>精通XHMTL程序设计高级编程 </li>
</ol>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ol>
<li>Div+CSS网页布局揭秘（案例实战篇）</li>
<li>别具光芒：css属性、浏览器兼容与网页布局学习</li>
<li>CSS网站布局实录2nd</li>
<li>响应式Web设计：HTML5和CSS3实战</li>
<li>CSS揭秘</li>
</ol>
<p>h5: 扩展学习</p>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><ol>
<li>JavaScript忍者秘籍</li>
<li>effiectiveJS</li>
<li>函数范式</li>
<li>学习JavaScript数据结构和算法</li>
<li>JavaScript面向对象编程语言</li>
<li>JavaScript模式</li>
<li>正则表达式30分钟入门教程</li>
</ol>
<!-- h2: effiectiveJS.doc -->
<p>### rest<br>正则指引<br>### abandon</p>
<ol>
<li>你不知道的javascirpt   </li>
</ol>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>rest  </p>
<ol>
<li>图解HTTP-上</li>
<li>HTTP权威指南完整版</li>
</ol>
<h2 id="web优化"><a href="#web优化" class="headerlink" title="web优化"></a>web优化</h2><ol>
<li>Web性能权威指南</li>
<li>编写高质量代码-Web前端开发修炼之道</li>
<li>高性能网站建设指南</li>
<li>SEO必知必会51技</li>
<li>代码整洁之道</li>
</ol>
<h2 id="jslib"><a href="#jslib" class="headerlink" title="jslib"></a>jslib</h2><ol>
<li>锋利的jQuery2nd</li>
<li>犀利开发jQuery内核详解与实践</li>
</ol>
<h2 id="js框架"><a href="#js框架" class="headerlink" title="js框架"></a>js框架</h2><ol>
<li>ReactJSAndWhyIt’sAwesome</li>
<li>React 入门实例教程</li>
<li>REACT：引领未来的用户界面开发框架</li>
<li>AngularJS权威教程</li>
</ol>
<p>### rest  </p>
<ol>
<li>AngularJS权威教程—10章后</li>
</ol>
<p>### abolished</p>
<ol>
<li>基于Redux的React Native六天实战<sapn style="float:right;">180622</sapn></li>
<li>vue-seller/elm:beifeng   </li>
<li>vue2.0:muke–basic, elm   </li>
</ol>
<h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><ol>
<li>ECMAScript6入门</li>
<li>深入浅出ES6</li>
</ol>
<p>h2: overview</p>
<h2 id="包管理-grunt-glup-webpack"><a href="#包管理-grunt-glup-webpack" class="headerlink" title="包管理 grunt/glup/webpack"></a>包管理 grunt/glup/webpack</h2><ol>
<li>grunt: 网上教程</li>
<li>webpack教程</li>
<li>Glup入门指南</li>
</ol>
<h2 id="版本管理-git-svn"><a href="#版本管理-git-svn" class="headerlink" title="版本管理 git/svn"></a>版本管理 git/svn</h2><ol>
<li>github入门与实践</li>
<li>git常用命令.doc</li>
</ol>
<!-- ## nodejs -->
<h2 id="ser"><a href="#ser" class="headerlink" title="ser"></a>ser</h2><p>rest  </p>
<ol>
<li>PHP和MySQL WEB开发 </li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>SQL必知必会 第4版</li>
<li>数据库系统概论第5版</li>
</ol>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ol>
<li>大巧不工-Web前端设计修炼之道</li>
<li>WEB界面设计</li>
<li>视频tarena:UID:coded </li>
<li>视频tarena:Axure RP:coded</li>
</ol>
<p>h3: photoshop.doc,图标设计.doc</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li>视频beifeng:设计模式:coded</li>
</ol>
<p>rest    </p>
<ol start="2">
<li>JAVASCRIPT设计模式</li>
</ol>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>rest   </p>
<ol>
<li>大话数据模式</li>
</ol>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ol>
<li>计算机网络基础</li>
<li>计算机导论</li>
</ol>
<p>### rest<br>操作系统   </p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><ol>
<li>数学之美</li>
<li>浅谈前端移动开发</li>
</ol>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li>Sublime Text全程指南</li>
</ol>
<p>h1: discarded   </p>
]]></content>
  </entry>
  <entry>
    <title>Resource</title>
    <url>/resource/</url>
    <content><![CDATA[<p>w3 list and schedule。<br><!-- 单独文件记录schedule  --><br><!-- 也可以从中pick out 记入schedule.md --><br><!-- 本页/文档 很少会出现schedule --></p>
<!--
1. 第一步是初步了解，逐步深入，构建一个良好的了解范围，可以从某一点深入，拓展至全局；也可以全面了解，逐条深入。
1. 第二步是重复，强调的记忆，记住。
1. 第三步是使用，就是践行的过程。
1. 第四步是融会贯通，就是返璞归真、悟道之类的。
1. 第五步是影响他人。

S1:听说  
S2:开始使用(知道/调研)      
S3:深入研究    
S4:熟练/反复使用    
S5:加工/再创造    
-->
<p>Web 技术文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web</a><br>w3school在线教程:<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a><br>W3School Online:<a href="https://www.w3schools.com/" target="_blank" rel="noopener">https://www.w3schools.com/</a><br>菜鸟教程:<a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a><br><!-- 前端文档工具:<http://www.css88.com/nav/>    --></p>
<!-- IBM: https://www.ibm.com/developerworks/cn/topics/ -->
<a id="more"></a>
<h2 id="onGoing"><a href="#onGoing" class="headerlink" title="onGoing"></a>onGoing</h2><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h2 id="preparing"><a href="#preparing" class="headerlink" title="preparing"></a>preparing</h2><ol start="2">
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<!-- ## schedule -->
<h2 id="relex"><a href="#relex" class="headerlink" title="relex"></a>relex</h2><ol start="2">
<li>subtitle, bignumber,drag,pager</li>
</ol>
<h2 id="csslib"><a href="#csslib" class="headerlink" title="csslib"></a>csslib</h2><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bootstrap</td>
<td><a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">https://v3.bootcss.com/css/</a></td>
<td>B3</td>
<td>S4</td>
<td>v3</td>
<td>/twbs/bootstrap</td>
</tr>
<tr>
<td>Layui</td>
<td><a href="http://www.layui.com/doc/" target="_blank" rel="noopener">http://www.layui.com/doc/</a></td>
<td>-</td>
<td>S2</td>
<td>v2.x</td>
<td>/sentsin/layui  </td>
</tr>
<tr>
<td>Layui-Layer</td>
<td><a href="http://layer.layui.com/" target="_blank" rel="noopener">http://layer.layui.com/</a></td>
<td>-</td>
<td>S2</td>
<td>v2</td>
<td>/sentsin/layer </td>
</tr>
<tr>
<td>Layui-layDate</td>
<td><a href="http://www.layui.com/laydate/" target="_blank" rel="noopener">http://www.layui.com/laydate/</a></td>
<td>-</td>
<td>S1</td>
<td>-</td>
<td>/sentsin/laydate </td>
</tr>
<tr>
<td>Element</td>
<td><a href="https://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">https://element.eleme.io/#/zh-CN/component/installation</a></td>
<td>-</td>
<td>S1</td>
<td>-</td>
<td>/ElemeFE/element </td>
</tr>
</tbody>
</table>
<h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hexo</td>
<td><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></td>
<td>B1</td>
<td>S4</td>
<td>-</td>
<td>/hexojs/hexo  </td>
</tr>
<tr>
<td>Next</td>
<td><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></td>
<td>B1</td>
<td>S4</td>
<td>-</td>
<td>/iissnan/hexo-theme-next   </td>
</tr>
</tbody>
</table>
<!-- Hexo英文:<https://hexo.io/docs/index.html>   -->
<!-- Next文档在github中位置:<https://github.com/iissnan/theme-next-docs> -->
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Canvas教程-MDN</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></td>
<td>B2</td>
<td>S3</td>
</tr>
<tr>
<td>Using files from web applications</td>
<td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications</a></td>
<td>-</td>
<td>S3</td>
</tr>
<tr>
<td>ECMAScript 6 入门</td>
<td><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></td>
<td>pdf</td>
<td>S2.5 </td>
</tr>
</tbody>
</table>
<p>其它：  </p>
<ol>
<li><a href="https://www.html5rocks.com/zh/tutorials/canvas/performance/" target="_blank" rel="noopener">提高 HTML5 画布性能</a>| Y| S3 <!-- $_BLOB: [提高 HTML5 画布性能]() -->
</li>
</ol>
<h2 id="jslib"><a href="#jslib" class="headerlink" title="jslib"></a>jslib</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug-npm</td>
<td><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">https://www.npmjs.com/package/debug</a></td>
<td>B4</td>
<td>S4</td>
<td>v3</td>
<td>/visionmedia/debug</td>
</tr>
<tr>
<td>pjax-npm</td>
<td><a href="https://www.npmjs.com/package/pjax" target="_blank" rel="noopener">https://www.npmjs.com/package/pjax</a></td>
<td>-</td>
<td>S4</td>
<td>-</td>
<td>/defunkt/jquery-pjax&gt;</td>
</tr>
<tr>
<td>[x]iScroll</td>
<td><a href="http://iscrolljs.com/" target="_blank" rel="noopener">http://iscrolljs.com/</a></td>
<td>-</td>
<td>S3</td>
<td>-</td>
<td>/cubiq/iscroll      </td>
</tr>
<tr>
<td>[v]iScroll5 API</td>
<td><a href="https://iiunknown.gitbooks.io/iscroll-5-api-cn/" target="_blank" rel="noopener">https://iiunknown.gitbooks.io/iscroll-5-api-cn/</a></td>
<td>Gsf</td>
<td>S3</td>
<td>v5</td>
<td>/iiunknown/iscroll5.doc.cn</td>
</tr>
<tr>
<td>clipboardjs</td>
<td><a href="https://clipboardjs.com/" target="_blank" rel="noopener">https://clipboardjs.com/</a></td>
<td>-</td>
<td>S3</td>
<td>-</td>
<td>/zenorocha/clipboard.js </td>
</tr>
<tr>
<td>json-server</td>
<td>-</td>
<td>-</td>
<td>S3</td>
<td>-</td>
<td>/typicode/json-serve</td>
</tr>
<tr>
<td>faker.js</td>
<td><a href="http://faker.hook.io" target="_blank" rel="noopener">http://faker.hook.io</a></td>
<td>B-</td>
<td>S3</td>
<td>-</td>
<td>/marak/Faker.js</td>
</tr>
<tr>
<td>mock.js</td>
<td><a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a></td>
<td>B-</td>
<td>S2</td>
<td>v0.1</td>
<td>//nuysoft/Mock   </td>
</tr>
<tr>
<td>fetch</td>
<td><a href="https://github.github.io/fetch/" target="_blank" rel="noopener">https://github.github.io/fetch/</a>/-</td>
<td>B-</td>
<td>S3</td>
<td>-</td>
<td>/github/fetch  </td>
</tr>
<tr>
<td>axios</td>
<td>-</td>
<td>B-</td>
<td>S3</td>
<td>-</td>
<td>/axios/axios   </td>
</tr>
<tr>
<td>lodash</td>
<td>-</td>
<td>S2</td>
<td>v4</td>
<td>/lodash/lodash </td>
</tr>
<tr>
<td>moment.js</td>
<td><a href="http://momentjs.com/docs/" target="_blank" rel="noopener">http://momentjs.com/docs/</a></td>
<td>S2</td>
<td>v2</td>
<td>/moment/moment</td>
</tr>
<tr>
<td>rollup</td>
<td><a href="https://rollupjs.org/guide/en" target="_blank" rel="noopener">https://rollupjs.org/guide/en</a></td>
<td>S2</td>
<td>-</td>
<td>/rollup/rollup    </td>
</tr>
<tr>
<td>resumable</td>
<td>&lt;&gt;</td>
<td>S3</td>
<td>-</td>
<td>/23/resumable.js   </td>
</tr>
<tr>
<td>bootstrap-progressbar</td>
<td>&lt;&gt;</td>
<td>S2</td>
<td>/minddust/bootstrap-progressbar</td>
</tr>
<tr>
<td>jQuery-File-Upload</td>
<td>&lt;&gt;</td>
<td>S2</td>
<td>-</td>
<td>/blueimp/jQuery-File-Upload</td>
</tr>
</tbody>
</table>
<p>faker文档：<a href="http://marak.github.io/faker.js/" target="_blank" rel="noopener">http://marak.github.io/faker.js/</a><br>mockjs文档： <a href="http://mockjs.com/0.1/" target="_blank" rel="noopener">http://mockjs.com/0.1/</a><br>lodash文档： <a href="https://lodash.com/docs/4.17.10" target="_blank" rel="noopener">https://lodash.com/docs/4.17.10</a><br><!-- Gsf:  gitbook-stared,github-forked --></p>
<p>jQuery API中文文档:<a href="http://jquery.cuishifeng.cn/" target="_blank" rel="noopener">http://jquery.cuishifeng.cn/</a> v1.11.3<br><!-- **$_PS:** 主要是离线文档   --></p>
<h3 id="video"><a href="#video" class="headerlink" title="video"></a>video</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>videojs</td>
<td><a href="http://docs.videojs.com/" target="_blank" rel="noopener">http://docs.videojs.com/</a></td>
<td>B1</td>
<td>S4</td>
<td>v6-&gt;v7</td>
<td>/videojs/video.js/&gt;  </td>
</tr>
<tr>
<td>videojs-contrib-dash</td>
<td><a href="https://github.com/videojs/videojs-contrib-dash" target="_blank" rel="noopener">https://github.com/videojs/videojs-contrib-dash</a></td>
<td>-</td>
<td>S3</td>
<td>v2.13</td>
<td>/videojs/videojs-contrib-dash</td>
</tr>
<tr>
<td>videojs-contrib-hls</td>
<td><a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">https://github.com/videojs/videojs-contrib-hls</a></td>
<td>-</td>
<td>S3</td>
<td>v5.14</td>
<td>/videojs/videojs-contrib-hls</td>
</tr>
<tr>
<td>dash.js</td>
<td><a href="http://cdn.dashjs.org/latest/jsdoc/module-MediaPlayer.html" target="_blank" rel="noopener">http://cdn.dashjs.org/latest/jsdoc/module-MediaPlayer.html</a></td>
<td>-</td>
<td>S2</td>
<td>-</td>
<td>/Dash-Industry-Forum/dash.js&gt;</td>
</tr>
</tbody>
</table>
<h3 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>[x]jsdoc</td>
<td><a href="http://usejsdoc.org/" target="_blank" rel="noopener">http://usejsdoc.org/</a></td>
<td>-</td>
<td>S3</td>
<td>v3</td>
<td>/jsdoc3/jsdoc</td>
</tr>
<tr>
<td>[v]JSDoc中文文档</td>
<td><a href="http://www.css88.com/doc/jsdoc/index.html" target="_blank" rel="noopener">http://www.css88.com/doc/jsdoc/index.html</a></td>
<td>-</td>
<td>S3</td>
<td>v3</td>
<td>X </td>
</tr>
<tr>
<td>apiDoc</td>
<td><a href="http://apidocjs.com/" target="_blank" rel="noopener">http://apidocjs.com/</a></td>
<td>x</td>
<td>S2</td>
<td>-</td>
<td>/apidoc/apidoc</td>
</tr>
</tbody>
</table>
<!-- jsdoc 中文文档和chrome 开发者指南都是是渔人码头发布在gitbook上的，但是都没有找到   -->
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue</td>
<td><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></td>
<td>-</td>
<td>S3</td>
<td>v2</td>
<td>/vuejs/vue  </td>
</tr>
<tr>
<td>angular.js</td>
<td><a href="https://code.angularjs.org/1.3.15/docs/api" target="_blank" rel="noopener">https://code.angularjs.org/1.3.15/docs/api</a></td>
<td>-</td>
<td>S2.5</td>
<td>v1.3.15</td>
<td>/angular/angular.js)</td>
</tr>
<tr>
<td>angular</td>
<td><a href="https://angular.io/docs" target="_blank" rel="noopener">https://angular.io/docs</a></td>
<td>-</td>
<td>-</td>
<td>v6</td>
<td>/angular/angular  </td>
</tr>
<tr>
<td>[x]reactjs</td>
<td><a href="https://reactjs.org/" target="_blank" rel="noopener">https://reactjs.org/</a></td>
<td>-</td>
<td>-</td>
<td>v16</td>
<td>/facebook/react</td>
</tr>
<tr>
<td>[v]reactjs</td>
<td><a href="http://www.css88.com/react/" target="_blank" rel="noopener">http://www.css88.com/react/</a></td>
<td>-</td>
<td>S4</td>
<td>v16.5</td>
<td>X</td>
</tr>
<tr>
<td>react native</td>
<td><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">https://facebook.github.io/react-native/</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>/facebook/react-native&gt; </td>
</tr>
<tr>
<td>vue</td>
<td><a href="https://vuejs.org/v2/guide/" target="_blank" rel="noopener">https://vuejs.org/v2/guide/</a></td>
<td>-</td>
<td>-</td>
<td>v2</td>
<td>/vuejs/vue</td>
</tr>
</tbody>
</table>
<p>react中文网：<a href="https://reactjs.org.cn/doc/hello-world.html/" target="_blank" rel="noopener">https://reactjs.org.cn/doc/hello-world.html/</a><br>Ant Design: <a href="https://ant.design/docs/react/getting-started-cn" target="_blank" rel="noopener">https://ant.design/docs/react/getting-started-cn</a>  S3<br>Element: <a href="http://element-cn.eleme.io/#/zh-CN/component/custom-theme" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN/component/custom-theme</a> S3   </p>
<h2 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h2><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>webpack</td>
<td><a href="https://webpack.docschina.org/configuration/" target="_blank" rel="noopener">https://webpack.docschina.org/configuration/</a></td>
<td>B2</td>
<td>S3</td>
<td>v3</td>
<td>/webpack/webpack   </td>
</tr>
<tr>
<td>webpack多页应用架构专题系列</td>
<td><a href="https://array_huang.coding.me/webpack-book/" target="_blank" rel="noopener">https://array_huang.coding.me/webpack-book/</a></td>
<td>Gsf</td>
<td>S4</td>
<td>v3</td>
<td>X</td>
</tr>
</tbody>
</table>
<!-- 英文/原文：<https://webpack.js.org/concepts/>     -->
<p>其它:  </p>
<ol>
<li><a href="https://guoyongfeng.github.io/book/08/03-webpack%E6%94%AF%E6%8C%81ES6.html" target="_blank" rel="noopener">现代化前端工程师权威指南#webpack 支持ES6</a></li>
</ol>
<h2 id="ser"><a href="#ser" class="headerlink" title="ser"></a>ser</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version</th>
<th>Github</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node.js文档</td>
<td><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">http://nodejs.cn/api/</a></td>
<td>-</td>
<td>S2.5</td>
<td>v8.11.1</td>
<td>X</td>
</tr>
<tr>
<td>nodejs-runoob</td>
<td><a href="http://www.runoob.com/nodejs" target="_blank" rel="noopener">http://www.runoob.com/nodejs</a></td>
<td>-</td>
<td>S3</td>
<td>-</td>
<td>X </td>
</tr>
<tr>
<td>yarn(中文网)</td>
<td><a href="https://yarn.org.cn/doc/index.html" target="_blank" rel="noopener">https://yarn.org.cn/doc/index.html</a></td>
<td>-</td>
<td>S3</td>
<td>v1.9.4</td>
<td>/yarnpkg/yarn </td>
</tr>
<tr>
<td>express</td>
<td><a href="http://expressjs.jser.us/4x_zh-cn/api.html" target="_blank" rel="noopener">http://expressjs.jser.us/4x_zh-cn/api.html</a></td>
<td>-</td>
<td>S2.5</td>
<td>v4</td>
<td></td>
</tr>
<tr>
<td>express(中文手册)</td>
<td><a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">http://www.expressjs.com.cn/guide/routing.html</a></td>
<td>-</td>
<td>S2.5</td>
<td>v4.x</td>
<td></td>
</tr>
<tr>
<td>[x]pm2</td>
<td><a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/quick-start/</a></td>
<td>-</td>
<td>S2.5</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>[v]PM2实用入门指南</td>
<td><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/pm2-documentation.html</a></td>
<td>-</td>
<td>S2.5</td>
<td>-</td>
<td>X  </td>
</tr>
<tr>
<td>socket.io</td>
<td><a href="https://socket.io/" target="_blank" rel="noopener">https://socket.io/</a></td>
<td>-</td>
<td>S3</td>
<td>v2</td>
<td>/socketio/socket.io/   </td>
</tr>
<tr>
<td>socket.io 中文版</td>
<td><a href="http://javacheng.oschina.io/socket.io/" target="_blank" rel="noopener">http://javacheng.oschina.io/socket.io/</a></td>
<td>-</td>
<td>S3</td>
<td>v2</td>
<td>X</td>
</tr>
<tr>
<td>mediasoup</td>
<td><a href="https://mediasoup.org/documentation/" target="_blank" rel="noopener">https://mediasoup.org/documentation/</a></td>
<td>-</td>
<td>S3</td>
<td>-</td>
<td></td>
</tr>
</tbody>
</table>
<p>其它：  </p>
<ol>
<li>node-debug tutorial:<a href="http://i5ting.github.io/node-debug-tutorial/#1" target="_blank" rel="noopener">http://i5ting.github.io/node-debug-tutorial/#1</a><br> <a href="http://i5ting.github.io/node-debug-tutorial/#160106" target="_blank" rel="noopener">4.1.6 代码覆盖率</a></li>
</ol>
<h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status</th>
<th>Version </th>
</tr>
</thead>
<tbody>
<tr>
<td>PHP 手册</td>
<td><a href="http://php.net/manual/zh/" target="_blank" rel="noopener">http://php.net/manual/zh/</a></td>
<td>-</td>
<td>S2.5</td>
<td>-</td>
</tr>
<tr>
<td>slim(中文文档)</td>
<td><a href="http://slim.lup5.com/docs/" target="_blank" rel="noopener">http://slim.lup5.com/docs/</a></td>
<td>-</td>
<td>v-v-</td>
<td>v2.5</td>
<td></td>
</tr>
<tr>
<td>Swagger从入门到精通</td>
<td><a href="https://legacy.gitbook.com/book/huangwenchao/swagger/details" target="_blank" rel="noopener">https://legacy.gitbook.com/book/huangwenchao/swagger/details</a></td>
<td>Gs</td>
<td>S3</td>
<td>-</td>
</tr>
</tbody>
</table>
<!-- 已废~~文档(slim中文网):<http://www.slimphp.net/>~~   -->
<!-- Swagger从入门到精通gitbook id:huangwenchao 。同gitbhub id没有找到源文件  -->
<!-- aculearn restful api:<http://192.168.1.81/user/rest/explorer/>    -->
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python 3 教程:<a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-tutorial.html</a>   </p>
<h2 id="其它语言"><a href="#其它语言" class="headerlink" title="其它语言"></a>其它语言</h2><h3 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h3><p>S4, v2-&gt;v3,缺升级服务<br>主要是一些插件:MUI2.nsh,LogicLib.nsh,nsDialogs.nsh,nsExec<br>GuiNsis(图形界面),Venis IX(编辑器)   </p>
<h3 id="md"><a href="#md" class="headerlink" title="md"></a>md</h3><p>Mastering Markdown - GitHub Guides:<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">https://guides.github.com/features/mastering-markdown/</a></p>
<table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status  </th>
</tr>
</thead>
<tbody>
<tr>
<td>Markdown 语法说明 (简体中文版)</td>
<td><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">http://wowubuntu.com/markdown/</a></td>
<td>B4</td>
<td>S4 </td>
</tr>
<tr>
<td>Markdown 编辑器语法指南</td>
<td><a href="https://segmentfault.com/markdown" target="_blank" rel="noopener">https://segmentfault.com/markdown</a></td>
<td>B4</td>
<td>S4 </td>
</tr>
<tr>
<td>Markdown 语法介绍</td>
<td><a href="https://coding.net/help/doc/project/markdown.html" target="_blank" rel="noopener">https://coding.net/help/doc/project/markdown.html</a></td>
<td>B4</td>
<td>S4  </td>
</tr>
</tbody>
</table>
<h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p>CSV File Reading and Writing:<a href="https://docs.python.org/2/library/csv.html" target="_blank" rel="noopener">https://docs.python.org/2/library/csv.html</a>   </p>
<ol>
<li><a href="https://baike.baidu.com/item/CSV/10739" target="_blank" rel="noopener">CSV</a>| Y| S3</li>
<li><a href="https://blog.csdn.net/einstellung/article/details/73549262" target="_blank" rel="noopener">CSV文件读取和处理</a>| Y| S3|python</li>
<li><a href="https://www.jianshu.com/p/ddb17fd1b018" target="_blank" rel="noopener">前端生成csv文件并导出到本地教程</a>| -| x|github:/knrz/csv.js</li>
</ol>
<h3 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h3><p>Schema 教程-W3C:<a href="http://www.w3school.com.cn/schema/schema_complex.asp|" target="_blank" rel="noopener">http://www.w3school.com.cn/schema/schema_complex.asp|</a> -| S2.5|- </p>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>辅导教程:<a href="https://www.tslang.cn/docs/" target="_blank" rel="noopener">https://www.tslang.cn/docs/</a>   | -| S3|/Microsoft/TypeScript  </p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="restful-api"><a href="#restful-api" class="headerlink" title="restful api"></a>restful api</h3><p>restful api:<a href="http://www.restapitutorial.com/" target="_blank" rel="noopener">http://www.restapitutorial.com/</a></p>
<ol>
<li><a href="http://www.cnblogs.com/artech/p/restful-web-api-02.html" target="_blank" rel="noopener">我所理解的RESTful Web API [设计篇]</a>| Y| S3| - </li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a>| Y| S3| -</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li>
</ol>
<!-- ### graphy api -->
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="https://mochajs.org/" target="_blank" rel="noopener">https://mochajs.org/</a><br><a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener">https://github.com/mochajs/mocha</a>   </p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">测试框架 Mocha 实例教程</a>| -| S2| -</li>
</ol>
<h3 id="错误监听"><a href="#错误监听" class="headerlink" title="错误监听"></a>错误监听</h3><p>1. sentry Ss<br><a href="https://sentry.io/welcome/" target="_blank" rel="noopener">https://sentry.io/welcome/</a>    <a href="https://docs.sentry.io/quickstart/" target="_blank" rel="noopener">https://docs.sentry.io/quickstart/</a><br><a href="https://docs.sentry.io/" target="_blank" rel="noopener">https://docs.sentry.io/</a>   <a href="https://docs.sentry.io/clients/javascript/" target="_blank" rel="noopener">https://docs.sentry.io/clients/javascript/</a>   </p>
<h3 id="webRTC"><a href="#webRTC" class="headerlink" title="webRTC"></a>webRTC</h3><h3 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h3><table>
<thead>
<tr>
<th>Title</th>
<th>Site</th>
<th>Backup</th>
<th>Status  </th>
</tr>
</thead>
<tbody>
<tr>
<td>[x] Chrome 开发者工具</td>
<td><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/</a></td>
<td>-</td>
<td>S3   </td>
</tr>
<tr>
<td>[v] 中文文档</td>
<td><a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="noopener">http://www.css88.com/doc/chrome-devtools/</a></td>
<td>x</td>
<td>S3</td>
<td></td>
</tr>
</tbody>
</table>
<!-- chrome 开发者工具，左边目录是英文；有的文章也没有翻译 -->
<!-- 中文文档gitbook id:feiwen8772 (没有找到) ==github id -->
<ol>
<li>Chrome DevTools:<a href="https://developer.chrome.com/devtools" target="_blank" rel="noopener">https://developer.chrome.com/devtools</a><br> github：/GoogleChrome/devtools-docs</li>
</ol>
<p>其它：<br><a href="http://shouce.jb51.net/chrome/index.html" target="_blank" rel="noopener">http://shouce.jb51.net/chrome/index.html</a><br>脚本之家手册：<a href="http://shouce.jb51.net/" target="_blank" rel="noopener">http://shouce.jb51.net/</a></p>
<h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><ol>
<li>mui</li>
<li>echart.js  </li>
<li>swiper.js</li>
</ol>
<h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><!-- 1. 现代化前端工程师权威指南:<https://guoyongfeng.github.io/book/>  -->
<!--
《礼记·中庸》
博学之，审问之，慎思之，明辨之，笃行之。有弗学，学之弗能，弗措也；有弗问，问之弗知，弗措也；有弗思，思之弗得，弗措也；有弗辨，辨之弗明，弗措也；有弗行，行之弗笃，弗措也。人一能之，己百之，人十能之，己千之。果能此道矣，虽愚必明，虽柔必强。-->
]]></content>
  </entry>
  <entry>
    <title>Schedule</title>
    <url>/schedule/</url>
    <content><![CDATA[<p>日程/计划表<br>Pick out from priv/todos list and publish it. It also includes items from booklist and resource,exclude rest and others. But does not include prepared.   </p>
<a id="more"></a>
<!-- ~~SSS~~  --> 
<!-- todos, ~~YX~~, booklist, resource -->
<p><span style="float:right;"></span></p>
<h2 id="onGoing"><a href="#onGoing" class="headerlink" title="onGoing"></a>onGoing</h2><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h2 id="preparing"><a href="#preparing" class="headerlink" title="preparing"></a>preparing</h2><ol start="3">
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><ol>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> node安装包/命令行参数   </li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> Web前端黑客技术揭秘</li>
</ul>
</li>
<li><hr>
</li>
<li><ul>
<li style="list-style: none"><input type="checkbox"> </li>
</ul>
</li>
</ol>
<h2 id="relax"><a href="#relax" class="headerlink" title="relax"></a>relax</h2><ol>
<li>ablob:ins</li>
<li>《操作系统》</li>
</ol>
<h2 id="abolished"><a href="#abolished" class="headerlink" title="abolished"></a>abolished</h2><ol start="4">
<li>《Web标准之道》<sapn style="float:right;">6.10</sapn></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Tempordata</title>
    <url>/temporaryData/</url>
    <content><![CDATA[<p>工具:<br>标你妹: <a href="http://www.biaonimeia.com" target="_blank" rel="noopener">www.biaonimeia.com</a><br>蓝湖:lanhuapp.com</p>
<ol>
<li>侧边栏社交链接</li>
<li>样式 -webkit-padding-start: 10px;</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Vue学习</title>
    <url>/sum/jsplus/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>vue组件写法/*.vue文件 ; Vue.component(), props   </p>
<h2 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h2><p style="text-align:right">2018.11.21</p>

<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>webpack3配置,从定义环境/生产 变量使用插件,而非mode选项.<br>也是热更新,但是报错信息会一直累积(开始以为一直在出错,怎么出错这么多),应该可以配置<br>$TODO: 报错信息清空/不缓存  </p>
<p>所以参照webpack,比如路径,模板,输出文件,脚本运行方式(npm run dev/build)等,也可以自己修改/添加(比如less)配置,或者用webpack重新配置   </p>
<p>生成文件在dist下,build中build的相关配置,比如webpack的.(creat-react-app 生成的项目在build文件夹下)    </p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>dev.assetsSubDirectory: 提供资源的目录/文件夹<br>dev.assetsPublicPath: 访问资源的路径,基于webpack server的.所以才有了下面的使用方式<br>build.assetsSubDirectory: 生成(build)资源存放目录/文件夹(dist/static),不能出现路径,编译会出错<br>build.assetsPublicPath:访问资源的路径.如果是<code>/</code>表示绝对路径,如果服务器没有提供当前根目录的服务或者根目录没有资源,会加载失败. 网上许多vue项目打开空白就是这个原因:编译生成的js,css等文件在dist目录,而dist目录并没有在根目录(<code>\</code>路径)中,所以没有加载到资源,页面是空白的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">// Template version: 1.3.1</span></span><br><span class="line"><span class="comment">// see http://vuejs-templates.github.io/webpack for documentation.</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line">    <span class="comment">// Paths</span></span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  build: &#123;</span><br><span class="line">    index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>), <span class="comment">// Template for index.html</span></span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// Paths</span></span><br><span class="line">    assetsSubDirectory:<span class="string">'static'</span>,</span><br><span class="line">    <span class="comment">// assetsPublicPath: '/', // 原始   </span></span><br><span class="line">    assetsPublicPath: <span class="string">'./'</span>, <span class="comment">// 推荐  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>背景图片和img标签引用资源方式<br>background的使用方式是引用的资源路径,并不是经过编译的模块, 所以上面使用资源路径的访问方式是正确的.下面出错,是因为访问的路径(webpack server提供的服务)下没有资源   </p>
<p>img标签使用 相对路径的方式是会编译成模块,路径按当前文件的位置引用.而<code>/static</code>是绝对路径,使用资源路径(webpack server服务提供). dev访问正常, 如果build,网站配置并不会给dist配置<code>/</code>的访问路径,所以绝对路径<code>/static</code>并没有该资源.除非网站配置正确的访问路径,或者自己把资源添加到根目录.<br>所以推荐使用相对路径.配置build.assetsPublicPath的路径为<code>./</code>,非<code>/</code>,上面也可以使用绝对路径了.不过<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// ## background:Carousel.vue</span><br><span class="line"><span class="comment">&lt;!-- &lt;el-carousel-item :style="&#123;background:'url(/static/images/'+img+(img=='banner3'?'.png':'.webp')+') no-repeat',backgroundSize:'cover'&#125;" :key="index"&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-carousel-item</span> <span class="attr">:style</span>=<span class="string">"&#123;background:'url(./static/images/'+img+(img=='banner3'?'.png':'.webp')+') no-repeat',backgroundSize:'cover'&#125;"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- blank --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;el-carousel-item :style="&#123;background:'url(./images/'+img+(img=='banner3'?'.png':'.webp')+') no-repeat',backgroundSize:'cover'&#125;" :key="index"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;el-carousel-item :style="&#123;background:'url(../assets/images/'+img+(img=='banner3'?'.png':'.webp')+') no-repeat',backgroundSize:'cover'&#125;" :key="index"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;el-carousel-item :style="&#123;background:'url(./assets/images/'+img+(img=='banner3'?'.png':'.webp')+') no-repeat',backgroundSize:'cover'&#125;" :key="index"&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">// ## img:Teachers.vue</span><br><span class="line"><span class="comment">&lt;!-- &lt;img src="/static/images/hamburger.png" class="image"&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../assets/images/hamburger.png"</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;img src="./images/hamburger.png" class="image"&gt; --&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element ui"></a>element ui</h2><p>可以按需引入,也可以全部引入   </p>
<p>改变/自定义 element ui 样式:需要在全局中修改(style标签不加 scoped),比如 <code>.el-carousel__button</code>, 或者单独引入css文件,即使是在本模块import; 添加className 提高权重,即使!import 也不会生效(如果样式不是全局的话).<br>$PS:听说可以在style中添加!import, html标签都找不到,往哪个元素上添加.自述比较麻烦<br>$PS:有的样式好像可以在scoped中修改,比如<code>.el-main</code>,<code>.el-col-6</code>,或许因为这些是layout样式?  </p>
<p>$TODO: 样式引入方式/权重 分析.<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span>  &lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;: <span class="selector-tag">worked</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.el-col-6</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-main</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="selector-tag">--</span>  &lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;: <span class="selector-tag">not</span> <span class="selector-tag">work</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.self</span> <span class="selector-class">.el-carousel__button</span>&#123;  <span class="comment">/* not work */</span></span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>:#<span class="number">#ff0</span><span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-carousel__button</span>&#123; <span class="comment">/* not work */</span></span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background</span>:#<span class="number">#f00</span><span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="assets和static文件夹的区别"><a href="#assets和static文件夹的区别" class="headerlink" title="assets和static文件夹的区别"></a>assets和static文件夹的区别</h3><!-- [vue-cli 自定义路径别名 assets和static文件夹的区别 --save-dev和--save的区别](https://juejin.im/post/59be4d325188257e764c8485)   -->
<p>相信有很多人知道vue-cli有两个放置静态资源的地方，分别是src/assets文件夹和static文件夹,这两者的区别很多人可能不太清楚。<br>assets目录中的文件会被webpack处理解析为模块依赖，只支持相对路径形式。例如，在 <img src="http://you img base url/./logo.png?e=1585218234&token=your qiniu access key:2kvzu6cirYa4FhAkck4Go9XepRc=">和 background: url(./logo.png)中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。</p>
<p>static/ 目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist/static）下。必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。<br>任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。</p>
<p>在我们实际的开发中，总的来说：static放不会变动的文件 assets放可能会变动的文件。</p>
<p>因为webpack会将图片当做模块来引用，所以在js中需要使用require将图片引用进来，不能直接以字符串的形式。   </p>
<h3 id="资源路径处理"><a href="#资源路径处理" class="headerlink" title="资源路径处理"></a>资源路径处理</h3><!-- [资源路径处理](https://vue-loader-v14.vuejs.org/zh-cn/configurations/asset-url.html)   -->
<p>默认情况下，vue-loader 使用 css-loader 和 Vue 模版编译器自动处理样式和模版文件。在编译过程中，所有的资源路径例如 <code>&lt;img src=&quot;...&quot;&gt;、background: url(...) 和 @import</code> 会作为模块依赖。   </p>
<p>例如，url(./image.png) 会被转换为 require(‘./image.png’)，而</p>
<p><code>&lt;img src=&quot;../image.png&quot;&gt;</code><br>将会编译为：<code>createElement(&#39;img&#39;, { attrs: { src: require(&#39;../image.png&#39;) }})</code><br>编译规则:<br>1) 如果路径是绝对路径，会原样保留。<br>2) 如果路径以 . 开头，将会被看作相对的模块依赖，并按照你的本地文件系统上的目录结构进行解析。<br>3) 如果路径以 ~ 开头，其后的部分将会被看作模块依赖。这意味着你可以用该特性来引用一个 node 依赖中的资源：<br>4) (13.7.0+) 如果路径以 @ 开头，也会被看作模块依赖。如果你的 webpack 配置中给 @ 配置了 alias，这就很有用了。所有 vue-cli 创建的项目都默认配置了将 @ 指向 /src。  </p>
]]></content>
      <categories>
        <category>sum</category>
        <category>jsplus</category>
      </categories>
  </entry>
</search>
